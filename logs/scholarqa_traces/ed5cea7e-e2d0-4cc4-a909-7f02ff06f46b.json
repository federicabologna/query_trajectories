{
    "query": "Can explain what Visual programming",
    "user_id": "lib_user",
    "task_id": "ed5cea7e-e2d0-4cc4-a909-7f02ff06f46b",
    "timestamp": "2025-06-23T23:37:57.527427",
    "n_retrieval": 256,
    "n_retrieved": 251,
    "n_candidates": 34,
    "n_rerank": 50,
    "opt_in": true,
    "total_cost": 0.376197,
    "decomposed_query": {
        "rewritten_query": "What is visual programming and how does it work.",
        "keyword_query": "visual programming explanation",
        "search_filters": {
            "fieldsOfStudy": "Computer Science"
        },
        "cost": 0.009351,
        "model": "claude-3-7-sonnet-20250219"
    },
    "candidates": [
        {
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "venue": "IEEE Access",
            "year": 2021,
            "reference_count": 107,
            "citation_count": 39,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ieeexplore.ieee.org/ielx7/6287639/9312710/09320477.pdf",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/ACCESS.2021.3051043?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/ACCESS.2021.3051043, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1980707",
                    "name": "M. Kuhail"
                },
                {
                    "authorId": "153238394",
                    "name": "Shahbano Farooq"
                },
                {
                    "authorId": "3083161",
                    "name": "R. Hammad"
                },
                {
                    "authorId": "8357681",
                    "name": "Mohammed Bahja"
                }
            ],
            "abstract": "Recently many researches have explored the potential of visual programming in robotics, the Internet of Things (IoT), and education. However, there is a lack of studies that analyze the recent evidence-based visual programming approaches that are applied in several domains. This study presents a systematic review to understand, compare, and reflect on recent visual programming approaches using twelve dimensions: visual programming classification, interaction style, target users, domain, platform, empirical evaluation type, test participants\u2019 type, number of test participants, test participants\u2019 programming skills, evaluation methods, evaluation measures, and accessibility of visual programming tools. The results show that most of the selected articles discussed tools that target IoT and education, while other fields such as data science, robotics are emerging. Further, most tools use abstractions to hide implementation details and use similar interaction styles. The predominant platforms for the tools are web and mobile, while desktop-based tools are on the decline. Only a few tools were evaluated with a formal experiment, whilst the remaining ones were evaluated with evaluation studies or informal feedback. Most tools were evaluated with students with little to no programming skills. There is a lack of emphasis on usability principles in the design stage of the tools. Additionally, only one of the tools was evaluated for expressiveness. Other areas for exploration include supporting end users throughout the life cycle of applications created with the tools, studying the impact of tutorials on improving learnability, and exploring the potential of machine learning to improve debugging solutions developed with visual programming.",
            "corpus_id": 231725028,
            "sentences": [
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Visual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:",
                    "score": 0.33092007672030155,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 5284,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 71
                        },
                        {
                            "start": 72,
                            "end": 301
                        },
                        {
                            "start": 302,
                            "end": 507
                        },
                        {
                            "start": 510,
                            "end": 698
                        },
                        {
                            "start": 699,
                            "end": 818
                        },
                        {
                            "start": 821,
                            "end": 975
                        },
                        {
                            "start": 976,
                            "end": 1057
                        },
                        {
                            "start": 1058,
                            "end": 1159
                        },
                        {
                            "start": 1160,
                            "end": 1372
                        },
                        {
                            "start": 1373,
                            "end": 1484
                        },
                        {
                            "start": 1487,
                            "end": 1693
                        },
                        {
                            "start": 1694,
                            "end": 1855
                        },
                        {
                            "start": 1856,
                            "end": 2042
                        },
                        {
                            "start": 2043,
                            "end": 2138
                        },
                        {
                            "start": 2141,
                            "end": 2181
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 502,
                            "end": 506,
                            "matchedPaperCorpusId": "15687689"
                        },
                        {
                            "start": 694,
                            "end": 697,
                            "matchedPaperCorpusId": "8272806"
                        },
                        {
                            "start": 813,
                            "end": 817,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 903,
                            "end": 906,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1182,
                            "end": 1185,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1531,
                            "end": 1534,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1557,
                            "end": 1560,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1787,
                            "end": 1790,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1795,
                            "end": 1798,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1926,
                            "end": 1929,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1993,
                            "end": 1996,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 2038,
                            "end": 2041,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 2089,
                            "end": 2092,
                            "matchedPaperCorpusId": "7335020"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9912109375
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Diagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.",
                    "score": 0.3213007535264759,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 9585,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 95
                        },
                        {
                            "start": 96,
                            "end": 307
                        },
                        {
                            "start": 308,
                            "end": 374
                        },
                        {
                            "start": 375,
                            "end": 469
                        },
                        {
                            "start": 470,
                            "end": 642
                        },
                        {
                            "start": 645,
                            "end": 750
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 84,
                            "end": 88,
                            "matchedPaperCorpusId": "74221"
                        },
                        {
                            "start": 90,
                            "end": 94,
                            "matchedPaperCorpusId": "143658620"
                        },
                        {
                            "start": 637,
                            "end": 641,
                            "matchedPaperCorpusId": "19780225"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97998046875
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.",
                    "score": 0.369000986686166,
                    "section_title": "1) FORM-BASED TOOLS",
                    "char_start_offset": 28883,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 216
                        },
                        {
                            "start": 217,
                            "end": 404
                        },
                        {
                            "start": 405,
                            "end": 478
                        },
                        {
                            "start": 481,
                            "end": 576
                        },
                        {
                            "start": 577,
                            "end": 735
                        },
                        {
                            "start": 736,
                            "end": 790
                        },
                        {
                            "start": 791,
                            "end": 901
                        },
                        {
                            "start": 902,
                            "end": 978
                        },
                        {
                            "start": 981,
                            "end": 1046
                        },
                        {
                            "start": 1047,
                            "end": 1144
                        },
                        {
                            "start": 1145,
                            "end": 1179
                        },
                        {
                            "start": 1180,
                            "end": 1238
                        },
                        {
                            "start": 1239,
                            "end": 1434
                        },
                        {
                            "start": 1437,
                            "end": 1551
                        },
                        {
                            "start": 1552,
                            "end": 1676
                        },
                        {
                            "start": 1677,
                            "end": 1817
                        },
                        {
                            "start": 1818,
                            "end": 1927
                        },
                        {
                            "start": 1928,
                            "end": 2071
                        },
                        {
                            "start": 2074,
                            "end": 2242
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 239,
                            "end": 243,
                            "matchedPaperCorpusId": "146808112"
                        },
                        {
                            "start": 338,
                            "end": 342,
                            "matchedPaperCorpusId": "218969033"
                        },
                        {
                            "start": 508,
                            "end": 512,
                            "matchedPaperCorpusId": "146808112"
                        },
                        {
                            "start": 1041,
                            "end": 1045,
                            "matchedPaperCorpusId": "218969033"
                        },
                        {
                            "start": 1452,
                            "end": 1456,
                            "matchedPaperCorpusId": "67453782"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.970703125
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "The works found in [7], [26] and [29] analyzed a limited number of visual programming approaches and techniques since article retrieval mainly focused on EUD approaches in general as opposed to visual programming approaches. For example, the work found in [29] classified the articles based on broad EUD techniques that do not cover all VPL classifications, whilst the authors of [7] primarily investigated EUD with reference to EUD-related conferences and missed relevant visual programming journals. Other review studies such as [8] and [10] surveyed visual programming environments in specific domains such as robotics and IoT, thereby overlooking a broach view of VPL approaches applied in multiple domains beyond IoT and robotics. \n\nFurthermore, as Table 1 shows, the existing review studies have barely touched on the empirical evidence, evaluation methods and measures that back up the validity of the visual programming tools. \n\nTherefore, there is a need for a systematic identification of articles describing and analyzing approaches and visual programming techniques used in multiple domains and backed up by empirical evidence, in order to obtain an in-depth analysis and understanding of the visual programming research. \n\nBy systematically analyzing 30 articles presenting visual programming tools representing various approaches (blockbased, diagram-based, form-based and icon-based), this study contributes: (1) an in-depth analysis of the visual programming approaches currently used to enable the creation of software applications used in several domains beyond the traditional ones (such as computer science education); (2) a characterization of the trends and technologies used for the development of visual programming tools; (3) an in-depth explanation of the empirical evidence used to back up the validity of the study, and (4) the discussion of open challenges and future research directions specific to visual programming tools. \n\nThis study will help the research community in the field of end-user development aiming at designing and evaluating visual programming tools. Such tools might adapt some ideas from the tools surveyed in this study, while addressing the discussed challenges and considering the suggested future research directions. \n\nThe rest of the article is organized as follows. It first gives a background of visual programming as a subset of EUD as well as its categories. Then, the article discusses the review studies in related areas. Thereafter, the study explains the methodology of this systematic literature review including the research questions.",
                    "score": 0.3213007535264759,
                    "section_title": "I. INTRODUCTION",
                    "char_start_offset": 2088,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 224
                        },
                        {
                            "start": 225,
                            "end": 501
                        },
                        {
                            "start": 502,
                            "end": 735
                        },
                        {
                            "start": 738,
                            "end": 934
                        },
                        {
                            "start": 937,
                            "end": 1233
                        },
                        {
                            "start": 1236,
                            "end": 1954
                        },
                        {
                            "start": 1957,
                            "end": 2098
                        },
                        {
                            "start": 2099,
                            "end": 2271
                        },
                        {
                            "start": 2274,
                            "end": 2322
                        },
                        {
                            "start": 2323,
                            "end": 2418
                        },
                        {
                            "start": 2419,
                            "end": 2483
                        },
                        {
                            "start": 2484,
                            "end": 2601
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 19,
                            "end": 22,
                            "matchedPaperCorpusId": "195856963"
                        },
                        {
                            "start": 24,
                            "end": 28,
                            "matchedPaperCorpusId": "14139027"
                        },
                        {
                            "start": 33,
                            "end": 37,
                            "matchedPaperCorpusId": "67770007"
                        },
                        {
                            "start": 256,
                            "end": 260,
                            "matchedPaperCorpusId": "67770007"
                        },
                        {
                            "start": 380,
                            "end": 383,
                            "matchedPaperCorpusId": "195856963"
                        },
                        {
                            "start": 531,
                            "end": 534,
                            "matchedPaperCorpusId": "219455753"
                        },
                        {
                            "start": 539,
                            "end": 543,
                            "matchedPaperCorpusId": "30037917"
                        },
                        {
                            "start": 1424,
                            "end": 1427,
                            "matchedPaperCorpusId": "7335020"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9482421875
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Our study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains. Moreover, the study sheds light on commonalities and differences between tools of the same or different approaches or domains. Finally, the study discusses only the approaches that are backed up by empirical evidence. The details of the empirical evidence are thoroughly discussed in the study.",
                    "score": 0.3721991141151649,
                    "section_title": "B. VISUAL PROGRAMMING REVIEW STUDIES",
                    "char_start_offset": 18048,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 321
                        },
                        {
                            "start": 322,
                            "end": 448
                        },
                        {
                            "start": 449,
                            "end": 539
                        },
                        {
                            "start": 540,
                            "end": 616
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.93896484375
                }
            ],
            "relevance_judgement": 0.9912109375,
            "relevance_judgment_input_expanded": "# Title: Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review\n# Venue: IEEE Access\n# Authors: M. Kuhail, Shahbano Farooq, R. Hammad, Mohammed Bahja\n## Abstract\nRecently many researches have explored the potential of visual programming in robotics, the Internet of Things (IoT), and education. However, there is a lack of studies that analyze the recent evidence-based visual programming approaches that are applied in several domains. This study presents a systematic review to understand, compare, and reflect on recent visual programming approaches using twelve dimensions: visual programming classification, interaction style, target users, domain, platform, empirical evaluation type, test participants\u2019 type, number of test participants, test participants\u2019 programming skills, evaluation methods, evaluation measures, and accessibility of visual programming tools. The results show that most of the selected articles discussed tools that target IoT and education, while other fields such as data science, robotics are emerging. Further, most tools use abstractions to hide implementation details and use similar interaction styles. The predominant platforms for the tools are web and mobile, while desktop-based tools are on the decline. Only a few tools were evaluated with a formal experiment, whilst the remaining ones were evaluated with evaluation studies or informal feedback. Most tools were evaluated with students with little to no programming skills. There is a lack of emphasis on usability principles in the design stage of the tools. Additionally, only one of the tools was evaluated for expressiveness. Other areas for exploration include supporting end users throughout the life cycle of applications created with the tools, studying the impact of tutorials on improving learnability, and exploring the potential of machine learning to improve debugging solutions developed with visual programming.\n## I. INTRODUCTION\nThe works found in [7], [26] and [29] analyzed a limited number of visual programming approaches and techniques since article retrieval mainly focused on EUD approaches in general as opposed to visual programming approaches. For example, the work found in [29] classified the articles based on broad EUD techniques that do not cover all VPL classifications, whilst the authors of [7] primarily investigated EUD with reference to EUD-related conferences and missed relevant visual programming journals. Other review studies such as [8] and [10] surveyed visual programming environments in specific domains such as robotics and IoT, thereby overlooking a broach view of VPL approaches applied in multiple domains beyond IoT and robotics. \n\nFurthermore, as Table 1 shows, the existing review studies have barely touched on the empirical evidence, evaluation methods and measures that back up the validity of the visual programming tools. \n\nTherefore, there is a need for a systematic identification of articles describing and analyzing approaches and visual programming techniques used in multiple domains and backed up by empirical evidence, in order to obtain an in-depth analysis and understanding of the visual programming research. \n\nBy systematically analyzing 30 articles presenting visual programming tools representing various approaches (blockbased, diagram-based, form-based and icon-based), this study contributes: (1) an in-depth analysis of the visual programming approaches currently used to enable the creation of software applications used in several domains beyond the traditional ones (such as computer science education); (2) a characterization of the trends and technologies used for the development of visual programming tools; (3) an in-depth explanation of the empirical evidence used to back up the validity of the study, and (4) the discussion of open challenges and future research directions specific to visual programming tools. \n\nThis study will help the research community in the field of end-user development aiming at designing and evaluating visual programming tools. Such tools might adapt some ideas from the tools surveyed in this study, while addressing the discussed challenges and considering the suggested future research directions. \n\nThe rest of the article is organized as follows. It first gives a background of visual programming as a subset of EUD as well as its categories. Then, the article discusses the review studies in related areas. Thereafter, the study explains the methodology of this systematic literature review including the research questions.\n\n## II. BACKGROUND\nVisual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:\n...\nDiagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.\n\n## B. VISUAL PROGRAMMING REVIEW STUDIES\nOur study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains. Moreover, the study sheds light on commonalities and differences between tools of the same or different approaches or domains. Finally, the study discusses only the approaches that are backed up by empirical evidence. The details of the empirical evidence are thoroughly discussed in the study.\n\n## 1) FORM-BASED TOOLS\n2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.",
            "reference_string": "[231725028 | Kuhail et al. | 2021 | Citations: 39]"
        },
        {
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "venue": "",
            "year": 2014,
            "reference_count": 10,
            "citation_count": 8,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5755/j01.eee.20.1.6169",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5755/J01.EEE.20.1.6169?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5755/J01.EEE.20.1.6169, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3102760",
                    "name": "Ignas Plauska"
                },
                {
                    "authorId": "69972564",
                    "name": "R. Lukas"
                },
                {
                    "authorId": null,
                    "name": "Robertas Dama\u0161evi\u010dius"
                }
            ],
            "abstract": "Visual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169",
            "corpus_id": 60941791,
            "sentences": [
                {
                    "corpus_id": "60941791",
                    "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
                    "text": "Visual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
                    "score": 0.3441653753236377,
                    "section_title": "body",
                    "char_start_offset": 1,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 235
                        },
                        {
                            "start": 236,
                            "end": 403
                        },
                        {
                            "start": 404,
                            "end": 673
                        },
                        {
                            "start": 674,
                            "end": 953
                        },
                        {
                            "start": 956,
                            "end": 1988
                        },
                        {
                            "start": 1991,
                            "end": 2095
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 91,
                            "end": 94,
                            "matchedPaperCorpusId": "12628167"
                        },
                        {
                            "start": 949,
                            "end": 952,
                            "matchedPaperCorpusId": "220866115"
                        },
                        {
                            "start": 1011,
                            "end": 1014,
                            "matchedPaperCorpusId": "11750514"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9892578125
                },
                {
                    "corpus_id": "60941791",
                    "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
                    "text": "Visual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169",
                    "score": 0.3028248728546346,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.958984375
                }
            ],
            "relevance_judgement": 0.9892578125,
            "relevance_judgment_input_expanded": "# Title: Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching\n# Venue: \n# Authors: Ignas Plauska, R. Lukas, Robertas Dama\u0161evi\u010dius\n## Abstract\nVisual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169\n## body\nVisual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
            "reference_string": "[60941791 | Plauska et al. | 2014 | Citations: 8]"
        },
        {
            "title": "Development of application software without programming",
            "venue": "IOP Conference Series: Materials Science and Engineering",
            "year": 2019,
            "reference_count": 18,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1088/1757-899x/477/1/012058",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1088/1757-899X/477/1/012058?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1088/1757-899X/477/1/012058, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "30811658",
                    "name": "J. Hamzabegovi\u0107"
                }
            ],
            "abstract": "End-user programming is an increasingly popular discipline of software engineering. In order to design a development environment that allows programming by non-programmers, it is desirable to understand their mental model. Most languages designed for end-users are based on visual interaction techniques such as programming with graphically presented rules and agents. Visual techniques allow direct manipulation in the environment in such a way that users grasp and pull visual components to match the application, as well as to select specific actions on certain events. Due to its omnipresence in operating systems, desktop and mobile applications, direct manipulation is an interaction technique which non-programmers are familiar with, and therefore highly desirable in application development environments by end-users or non-programmers. In this paper we present a review of the features and the functionality of the development environment that would allow the end-users logopedists to develop their therapeutic software without writing programming code and without any programming knowledge.",
            "corpus_id": 86787308,
            "sentences": [
                {
                    "corpus_id": "86787308",
                    "title": "Development of application software without programming",
                    "text": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.",
                    "score": 0.4483924175418692,
                    "section_title": "Visual programming",
                    "char_start_offset": 13785,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 189
                        },
                        {
                            "start": 190,
                            "end": 345
                        },
                        {
                            "start": 346,
                            "end": 493
                        },
                        {
                            "start": 494,
                            "end": 798
                        },
                        {
                            "start": 801,
                            "end": 918
                        },
                        {
                            "start": 919,
                            "end": 1090
                        },
                        {
                            "start": 1091,
                            "end": 1125
                        },
                        {
                            "start": 1126,
                            "end": 1258
                        },
                        {
                            "start": 1259,
                            "end": 1408
                        },
                        {
                            "start": 1409,
                            "end": 1522
                        },
                        {
                            "start": 1523,
                            "end": 1615
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.98486328125
                },
                {
                    "corpus_id": "86787308",
                    "title": "Development of application software without programming",
                    "text": "Visual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
                    "score": 0.3721991141151649,
                    "section_title": "Visual programming and parametrization",
                    "char_start_offset": 15443,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 218
                        },
                        {
                            "start": 219,
                            "end": 380
                        },
                        {
                            "start": 381,
                            "end": 518
                        },
                        {
                            "start": 519,
                            "end": 748
                        },
                        {
                            "start": 749,
                            "end": 1062
                        },
                        {
                            "start": 1063,
                            "end": 1185
                        },
                        {
                            "start": 1188,
                            "end": 1338
                        },
                        {
                            "start": 1339,
                            "end": 1609
                        },
                        {
                            "start": 1610,
                            "end": 1847
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.984375
                }
            ],
            "relevance_judgement": 0.98486328125,
            "relevance_judgment_input_expanded": "# Title: Development of application software without programming\n# Venue: IOP Conference Series: Materials Science and Engineering\n# Authors: J. Hamzabegovi\u0107\n## Abstract\nEnd-user programming is an increasingly popular discipline of software engineering. In order to design a development environment that allows programming by non-programmers, it is desirable to understand their mental model. Most languages designed for end-users are based on visual interaction techniques such as programming with graphically presented rules and agents. Visual techniques allow direct manipulation in the environment in such a way that users grasp and pull visual components to match the application, as well as to select specific actions on certain events. Due to its omnipresence in operating systems, desktop and mobile applications, direct manipulation is an interaction technique which non-programmers are familiar with, and therefore highly desirable in application development environments by end-users or non-programmers. In this paper we present a review of the features and the functionality of the development environment that would allow the end-users logopedists to develop their therapeutic software without writing programming code and without any programming knowledge.\n## Visual programming\nIn computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.\n\n## Visual programming and parametrization\nVisual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
            "reference_string": "[86787308 | Hamzabegovic | 2019 | Citations: 0]"
        },
        {
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "venue": "Education sciences",
            "year": 2019,
            "reference_count": 50,
            "citation_count": 23,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.mdpi.com/2227-7102/9/3/181/pdf?version=1563177761",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3390/EDUCSCI9030181?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3390/EDUCSCI9030181, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2157028104",
                    "name": "Piedade Jo\u00e3o"
                },
                {
                    "authorId": "72582337",
                    "name": "Dorotea Nuno"
                },
                {
                    "authorId": "2157024771",
                    "name": "Sampaio Ferrentini F\u00e1bio"
                },
                {
                    "authorId": "144370033",
                    "name": "P. ana"
                }
            ],
            "abstract": "In the last few years, it has been pointed out that teaching programming is a strong strategy to develop pupils\u2019 competences in computational thinking (CT). In the Portuguese context, the curriculum changes in 2018 made programming and CT compulsory for every pupil in primary and secondary education. Nowadays, there is an information and communication technology (ICT) subject, taught by a computer science teacher in each school grade. In Portugal, to become a computer science teacher in primary and secondary education, it is compulsory to have a master\u2019s degree in computer science education. This article reports on a pedagogical activity developed with student-teachers of a Master in Teaching Informatics at the University of Lisbon. Within the activities of the master\u2019s program, we developed a cross-analysis of the core characteristics of 26 block-based and visual programming applications (apps) used to teach computational thinking and programming in school classes. In order to organize the analysis, a framework with several dimensions was developed and used by student-teachers to register the characteristics of each app. The product of this work is a comparative matrix mapping the core characteristics of each of the 26 apps that student-teachers used to select the most appropriate one for teaching programming and computational thinking according to each grade, age group and other characteristics.",
            "corpus_id": 199002134,
            "sentences": [
                {
                    "corpus_id": "199002134",
                    "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
                    "text": "The visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
                    "score": 0.41045944639441756,
                    "section_title": "Visual and Block-based Programming Environment",
                    "char_start_offset": 12132,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 218
                        },
                        {
                            "start": 219,
                            "end": 398
                        },
                        {
                            "start": 401,
                            "end": 547
                        },
                        {
                            "start": 548,
                            "end": 674
                        },
                        {
                            "start": 675,
                            "end": 679
                        },
                        {
                            "start": 680,
                            "end": 973
                        },
                        {
                            "start": 974,
                            "end": 1205
                        },
                        {
                            "start": 1208,
                            "end": 1409
                        },
                        {
                            "start": 1410,
                            "end": 1624
                        },
                        {
                            "start": 1625,
                            "end": 1871
                        },
                        {
                            "start": 1874,
                            "end": 2034
                        },
                        {
                            "start": 2035,
                            "end": 2150
                        },
                        {
                            "start": 2153,
                            "end": 2335
                        },
                        {
                            "start": 2336,
                            "end": 2430
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 394,
                            "end": 397,
                            "matchedPaperCorpusId": "17459721"
                        },
                        {
                            "start": 416,
                            "end": 420,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1404,
                            "end": 1408,
                            "matchedPaperCorpusId": "59528289"
                        },
                        {
                            "start": 1619,
                            "end": 1623,
                            "matchedPaperCorpusId": "11994747"
                        },
                        {
                            "start": 1866,
                            "end": 1870,
                            "matchedPaperCorpusId": "51750550"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.98291015625
                }
            ],
            "relevance_judgement": 0.98291015625,
            "relevance_judgment_input_expanded": "# Title: A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers\n# Venue: Education sciences\n# Authors: Piedade Jo\u00e3o, Dorotea Nuno, Sampaio Ferrentini F\u00e1bio, P. ana\n## Abstract\nIn the last few years, it has been pointed out that teaching programming is a strong strategy to develop pupils\u2019 competences in computational thinking (CT). In the Portuguese context, the curriculum changes in 2018 made programming and CT compulsory for every pupil in primary and secondary education. Nowadays, there is an information and communication technology (ICT) subject, taught by a computer science teacher in each school grade. In Portugal, to become a computer science teacher in primary and secondary education, it is compulsory to have a master\u2019s degree in computer science education. This article reports on a pedagogical activity developed with student-teachers of a Master in Teaching Informatics at the University of Lisbon. Within the activities of the master\u2019s program, we developed a cross-analysis of the core characteristics of 26 block-based and visual programming applications (apps) used to teach computational thinking and programming in school classes. In order to organize the analysis, a framework with several dimensions was developed and used by student-teachers to register the characteristics of each app. The product of this work is a comparative matrix mapping the core characteristics of each of the 26 apps that student-teachers used to select the most appropriate one for teaching programming and computational thinking according to each grade, age group and other characteristics.\n## Visual and Block-based Programming Environment\nThe visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
            "reference_string": "[199002134 | Joao et al. | 2019 | Citations: 23]"
        },
        {
            "title": "Microsoft Visual Basic 6.0 Software to Develop Mathematics Teaching Materials",
            "venue": "Journal of Physics: Conference Series",
            "year": 2019,
            "reference_count": 13,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1088/1742-6596/1155/1/012090",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1088/1742-6596/1155/1/012090?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1088/1742-6596/1155/1/012090, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "84008749",
                    "name": "O. Dermawan"
                },
                {
                    "authorId": "108395174",
                    "name": "Defriyanto"
                },
                {
                    "authorId": "2145724414",
                    "name": "Junaidah"
                },
                {
                    "authorId": "2073137966",
                    "name": "S. M. Ayu"
                },
                {
                    "authorId": "146321436",
                    "name": "Busmayaril"
                },
                {
                    "authorId": "2248504509",
                    "name": "Meisuri"
                },
                {
                    "authorId": "2177074572",
                    "name": "M.J Muhtari"
                }
            ],
            "abstract": "The presumption of mathematics lessons difficulty lead to a lack of students\u2019 learning interest, which can contribute to mathematics learning achievement. Identification of the problem in this study was carried out by conducting interviews with mathematics teachers at SMP Negeri (State middle School)12 Bandar Lampung, Mr. I Ketut Pande, S. Pd and also giving questionnaires to the eighth-grade students of middle school about problems in mathematics. Researchers are trying to develop computerized-based teaching materials designed as attractive as possible. In supporting the development of teaching materials, researchers using an application Microsoft Visual Basic 6.0 is one of the software applications in Windows. In developing applications, Visual Basic uses a visual approach to design user interfaces of forms, while coding uses basic languages that tend to be easily understood in accordance with mathematics learning in the two-variable linear equation system material for the eighth-grade students of Middle School. This Teaching materials have validation stage by material experts, media experts and in trials on students at Bandar Lampung 12 Public Middle School. The quality of teaching materials has reached the feasibility standard of teaching materials from the results of the assessment of material experts, media experts, educational practitioners, and students. It can be concluded that mathematics teaching materials using Microsoft Visual Basic media that have been developed in this study are worthy of being used as supporting teaching materials in the teaching and learning process.",
            "corpus_id": 186749406,
            "sentences": [
                {
                    "corpus_id": "186749406",
                    "title": "Microsoft Visual Basic 6.0 Software to Develop Mathematics Teaching Materials",
                    "text": "Visual Basic is a computer programming language, in [12] is commands or instructions that are understood by computers to perform certain tasks. Visual Basic besides being referred to as a programming language, it is also often referred to as a tool (tool) to produce Windows-based application programs. \n\nIn Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach. \n\nVisual Basic allows the creation of Graphical User Interface (GUI) or programming applications that use the graphical display as a communication tool with the user. In Visual Basic to create a user interface display is relatively easy to do because only need to put graphics objects into the source (form) that has been provided by Visual Basic. After that, simply set the properties of these objects. Some of the capabilities or benefits of Visual Basic include: 1. To create a Window-based application program 2. To create program help objects such as ActiveX controls, Help files, internet applications and so on. \n\nVisual basic components are very important. These components will help us in making the program. The first time opening Visual Basic will appear several components, namely, among others, the menu bar, toolbar, form, project window, properties window, and form layout window, as shown below: [5] Figure 1 Example display of Microsoft Visual Basic 6.0 Information: \n\n1. Menu Bar used to select specific tasks such as saving projects, opening projects, etc. \n\n2. The Main Toolbar used to perform certain tasks quickly. \n\n3. Toolbox window, this window contains components that you can use to develop the user interface. \n\n4. Form Designer window, this window is your place to design the user interface of your application. So, this window resembles a canvas for a painter. 5. Project window, this window contains an overview of all modules contained in your application. \n\nYou can use Ctrl + R to display the project window or use the Project Explorer icon. 6. The Properties window is a list of object properties that are currently selected. For example, you can change the foreground color and background color. You can use F4 to display the properties window.",
                    "score": 0.3244780451268607,
                    "section_title": "Visual Basic",
                    "char_start_offset": 6767,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 143
                        },
                        {
                            "start": 144,
                            "end": 302
                        },
                        {
                            "start": 305,
                            "end": 525
                        },
                        {
                            "start": 526,
                            "end": 624
                        },
                        {
                            "start": 627,
                            "end": 791
                        },
                        {
                            "start": 792,
                            "end": 972
                        },
                        {
                            "start": 973,
                            "end": 1028
                        },
                        {
                            "start": 1029,
                            "end": 1093
                        },
                        {
                            "start": 1094,
                            "end": 1243
                        },
                        {
                            "start": 1246,
                            "end": 1289
                        },
                        {
                            "start": 1290,
                            "end": 1342
                        },
                        {
                            "start": 1343,
                            "end": 1608
                        },
                        {
                            "start": 1611,
                            "end": 1700
                        },
                        {
                            "start": 1703,
                            "end": 1761
                        },
                        {
                            "start": 1764,
                            "end": 1862
                        },
                        {
                            "start": 1865,
                            "end": 1965
                        },
                        {
                            "start": 1966,
                            "end": 2113
                        },
                        {
                            "start": 2116,
                            "end": 2200
                        },
                        {
                            "start": 2201,
                            "end": 2203
                        },
                        {
                            "start": 2204,
                            "end": 2285
                        },
                        {
                            "start": 2286,
                            "end": 2356
                        },
                        {
                            "start": 2357,
                            "end": 2405
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.982421875
                }
            ],
            "relevance_judgement": 0.982421875,
            "relevance_judgment_input_expanded": "# Title: Microsoft Visual Basic 6.0 Software to Develop Mathematics Teaching Materials\n# Venue: Journal of Physics: Conference Series\n# Authors: O. Dermawan, Defriyanto, Junaidah, S. M. Ayu, Busmayaril, Meisuri, M.J Muhtari\n## Abstract\nThe presumption of mathematics lessons difficulty lead to a lack of students\u2019 learning interest, which can contribute to mathematics learning achievement. Identification of the problem in this study was carried out by conducting interviews with mathematics teachers at SMP Negeri (State middle School)12 Bandar Lampung, Mr. I Ketut Pande, S. Pd and also giving questionnaires to the eighth-grade students of middle school about problems in mathematics. Researchers are trying to develop computerized-based teaching materials designed as attractive as possible. In supporting the development of teaching materials, researchers using an application Microsoft Visual Basic 6.0 is one of the software applications in Windows. In developing applications, Visual Basic uses a visual approach to design user interfaces of forms, while coding uses basic languages that tend to be easily understood in accordance with mathematics learning in the two-variable linear equation system material for the eighth-grade students of Middle School. This Teaching materials have validation stage by material experts, media experts and in trials on students at Bandar Lampung 12 Public Middle School. The quality of teaching materials has reached the feasibility standard of teaching materials from the results of the assessment of material experts, media experts, educational practitioners, and students. It can be concluded that mathematics teaching materials using Microsoft Visual Basic media that have been developed in this study are worthy of being used as supporting teaching materials in the teaching and learning process.\n## Visual Basic\nVisual Basic is a computer programming language, in [12] is commands or instructions that are understood by computers to perform certain tasks. Visual Basic besides being referred to as a programming language, it is also often referred to as a tool (tool) to produce Windows-based application programs. \n\nIn Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach. \n\nVisual Basic allows the creation of Graphical User Interface (GUI) or programming applications that use the graphical display as a communication tool with the user. In Visual Basic to create a user interface display is relatively easy to do because only need to put graphics objects into the source (form) that has been provided by Visual Basic. After that, simply set the properties of these objects. Some of the capabilities or benefits of Visual Basic include: 1. To create a Window-based application program 2. To create program help objects such as ActiveX controls, Help files, internet applications and so on. \n\nVisual basic components are very important. These components will help us in making the program. The first time opening Visual Basic will appear several components, namely, among others, the menu bar, toolbar, form, project window, properties window, and form layout window, as shown below: [5] Figure 1 Example display of Microsoft Visual Basic 6.0 Information: \n\n1. Menu Bar used to select specific tasks such as saving projects, opening projects, etc. \n\n2. The Main Toolbar used to perform certain tasks quickly. \n\n3. Toolbox window, this window contains components that you can use to develop the user interface. \n\n4. Form Designer window, this window is your place to design the user interface of your application. So, this window resembles a canvas for a painter. 5. Project window, this window contains an overview of all modules contained in your application. \n\nYou can use Ctrl + R to display the project window or use the Project Explorer icon. 6. The Properties window is a list of object properties that are currently selected. For example, you can change the foreground color and background color. You can use F4 to display the properties window.",
            "reference_string": "[186749406 | Dermawan et al. | 2019 | Citations: 2]"
        },
        {
            "title": "Low-Code Programming Models",
            "venue": "Communications of the ACM",
            "year": 2022,
            "reference_count": 46,
            "citation_count": 21,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3587691",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2205.02282, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1728836",
                    "name": "Martin Hirzel"
                }
            ],
            "abstract": "Low-code has the potential to empower more people to automate tasks by creating computer programs.",
            "corpus_id": 248524774,
            "sentences": [
                {
                    "corpus_id": "248524774",
                    "title": "Low-Code Programming Models",
                    "text": "Config. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
                    "score": 0.3579152567309107,
                    "section_title": "Palette Code canvas Stage",
                    "char_start_offset": 13328,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 7
                        },
                        {
                            "start": 8,
                            "end": 25
                        },
                        {
                            "start": 26,
                            "end": 133
                        },
                        {
                            "start": 134,
                            "end": 265
                        },
                        {
                            "start": 266,
                            "end": 412
                        },
                        {
                            "start": 413,
                            "end": 591
                        },
                        {
                            "start": 592,
                            "end": 895
                        },
                        {
                            "start": 896,
                            "end": 1044
                        },
                        {
                            "start": 1045,
                            "end": 1164
                        },
                        {
                            "start": 1165,
                            "end": 1233
                        },
                        {
                            "start": 1234,
                            "end": 1346
                        },
                        {
                            "start": 1347,
                            "end": 1462
                        },
                        {
                            "start": 1465,
                            "end": 1504
                        },
                        {
                            "start": 1505,
                            "end": 1690
                        },
                        {
                            "start": 1691,
                            "end": 1832
                        },
                        {
                            "start": 1833,
                            "end": 1983
                        },
                        {
                            "start": 1986,
                            "end": 2176
                        },
                        {
                            "start": 2177,
                            "end": 2289
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 355,
                            "end": 359,
                            "matchedPaperCorpusId": "2385464"
                        },
                        {
                            "start": 1929,
                            "end": 1933,
                            "matchedPaperCorpusId": "16189588"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.98193359375
                }
            ],
            "relevance_judgement": 0.98193359375,
            "relevance_judgment_input_expanded": "# Title: Low-Code Programming Models\n# Venue: Communications of the ACM\n# Authors: Martin Hirzel\n## Abstract\nLow-code has the potential to empower more people to automate tasks by creating computer programs.\n## Palette Code canvas Stage\nConfig. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
            "reference_string": "[248524774 | Hirzel | 2022 | Citations: 21]"
        },
        {
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "venue": "Indian Journal of Science and Technology",
            "year": 2021,
            "reference_count": 32,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.17485/ijst/v14i17.431",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.17485/IJST/V14I17.431?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.17485/IJST/V14I17.431, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "9207310",
                    "name": "Kawther A. Aldhlan"
                },
                {
                    "authorId": "2836785",
                    "name": "Hamad Alreshidi"
                }
            ],
            "abstract": "Objectives: To employ the Scratch program for designing electronic educational games in raising technological awareness and visual programing skills to deal with electronic fatal games for first-grade secondary students in Hail- Saudi Arabia. Method: To achieve the goal, the researchers utilize the experimental methods by using one of the educational games programs (Scratch) to develop technological awareness of electronic games for first-grade secondary school students in Hail, Saudi Arabia. Whereas, the research problem was explained in the high number of suicides among adolescents due to the use of fatal games. Besides, an observation method was used where a scale of technological awareness values and a visual programming skills card were prepared to be acquired by students through the program. An exploratory sample of (38) students in the first grade of Ha\u2019il secondary school was selected. The experimental group consisted of a random sample of (48) students in the first grade of Al-Mas secondary school. The research tools were applied before and after the experimental group to determine the significance of the differences. Findings: The results clearly show that there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the technological awareness scale in favor of the research group in the post-measurement and there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the scorecard for the skill performance in visual programming for the research group in the post-measurement. Application: The research concludes with the importance of employing electronic educational games and the interaction between the values of technological awareness and visual programming to deal with electronic fatal games for first-grade secondary students in Ha\u2019il- Saudi Arabia. \nKeywords: Educational E-Games; Technological Awareness; Visual Programming; Fatal Games; Scratch program",
            "corpus_id": 236566925,
            "sentences": [
                {
                    "corpus_id": "236566925",
                    "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                    "text": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
                    "score": 0.4853129009429891,
                    "section_title": "Visual programming:",
                    "char_start_offset": 28669,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 149
                        },
                        {
                            "start": 150,
                            "end": 360
                        },
                        {
                            "start": 363,
                            "end": 692
                        },
                        {
                            "start": 695,
                            "end": 896
                        },
                        {
                            "start": 897,
                            "end": 978
                        },
                        {
                            "start": 979,
                            "end": 1158
                        },
                        {
                            "start": 1161,
                            "end": 1286
                        },
                        {
                            "start": 1287,
                            "end": 1305
                        },
                        {
                            "start": 1308,
                            "end": 1490
                        },
                        {
                            "start": 1491,
                            "end": 1701
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9814453125
                }
            ],
            "relevance_judgement": 0.9814453125,
            "relevance_judgment_input_expanded": "# Title: Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games\n# Venue: Indian Journal of Science and Technology\n# Authors: Kawther A. Aldhlan, Hamad Alreshidi\n## Abstract\nObjectives: To employ the Scratch program for designing electronic educational games in raising technological awareness and visual programing skills to deal with electronic fatal games for first-grade secondary students in Hail- Saudi Arabia. Method: To achieve the goal, the researchers utilize the experimental methods by using one of the educational games programs (Scratch) to develop technological awareness of electronic games for first-grade secondary school students in Hail, Saudi Arabia. Whereas, the research problem was explained in the high number of suicides among adolescents due to the use of fatal games. Besides, an observation method was used where a scale of technological awareness values and a visual programming skills card were prepared to be acquired by students through the program. An exploratory sample of (38) students in the first grade of Ha\u2019il secondary school was selected. The experimental group consisted of a random sample of (48) students in the first grade of Al-Mas secondary school. The research tools were applied before and after the experimental group to determine the significance of the differences. Findings: The results clearly show that there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the technological awareness scale in favor of the research group in the post-measurement and there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the scorecard for the skill performance in visual programming for the research group in the post-measurement. Application: The research concludes with the importance of employing electronic educational games and the interaction between the values of technological awareness and visual programming to deal with electronic fatal games for first-grade secondary students in Ha\u2019il- Saudi Arabia. \nKeywords: Educational E-Games; Technological Awareness; Visual Programming; Fatal Games; Scratch program\n## Visual programming:\nVisual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
            "reference_string": "[236566925 | Aldhlan et al. | 2021 | Citations: 2]"
        },
        {
            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
            "venue": "British Computer Society Conference on Human-Computer Interaction",
            "year": 2017,
            "reference_count": 20,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.scienceopen.com/document_file/12bbb28c-64da-4374-bf9d-9fde41f35fd6/ScienceOpen/001_Vithana.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.14236/ewic/HCI2017.26?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.14236/ewic/HCI2017.26, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "9346844",
                    "name": "Yasura Vithana"
                },
                {
                    "authorId": "40894841",
                    "name": "Hashini Senaratne"
                }
            ],
            "abstract": "This paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.",
            "corpus_id": 4793447,
            "sentences": [
                {
                    "corpus_id": "4793447",
                    "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                    "text": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
                    "score": 0.3921970797649854,
                    "section_title": "WORK DEVELOPED",
                    "char_start_offset": 5574,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 155
                        },
                        {
                            "start": 156,
                            "end": 300
                        },
                        {
                            "start": 301,
                            "end": 449
                        },
                        {
                            "start": 450,
                            "end": 617
                        },
                        {
                            "start": 618,
                            "end": 799
                        },
                        {
                            "start": 800,
                            "end": 1104
                        },
                        {
                            "start": 1105,
                            "end": 1213
                        },
                        {
                            "start": 1214,
                            "end": 1426
                        },
                        {
                            "start": 1427,
                            "end": 1477
                        },
                        {
                            "start": 1478,
                            "end": 1540
                        },
                        {
                            "start": 1541,
                            "end": 1650
                        },
                        {
                            "start": 1651,
                            "end": 1810
                        },
                        {
                            "start": 1811,
                            "end": 1850
                        },
                        {
                            "start": 1851,
                            "end": 1936
                        },
                        {
                            "start": 1937,
                            "end": 2045
                        },
                        {
                            "start": 2046,
                            "end": 2161
                        },
                        {
                            "start": 2162,
                            "end": 2230
                        },
                        {
                            "start": 2231,
                            "end": 2370
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97802734375
                },
                {
                    "corpus_id": "4793447",
                    "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                    "text": "This paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.",
                    "score": 0.30887401304497075,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97021484375
                }
            ],
            "relevance_judgement": 0.97802734375,
            "relevance_judgment_input_expanded": "# Title: Extensible Visual Programming Model for Modular Systems Targeting Novices\n# Venue: British Computer Society Conference on Human-Computer Interaction\n# Authors: Yasura Vithana, Hashini Senaratne\n## Abstract\nThis paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.\n## WORK DEVELOPED\nThe visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
            "reference_string": "[4793447 | Vithana et al. | 2017 | Citations: 0]"
        },
        {
            "title": "A Visual Language for Composable Inductive Programming",
            "venue": "arXiv.org",
            "year": 2020,
            "reference_count": 21,
            "citation_count": 4,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2009.08700, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1420120235",
                    "name": "Edward McDaid"
                },
                {
                    "authorId": "4697495",
                    "name": "S. McDaid"
                }
            ],
            "abstract": "We present Zoea Visual which is a visual programming language based on the Zoea composable inductive programming language. Zoea Visual allows users to create software directly from a specification that resembles a set of functional test cases. Programming with Zoea Visual involves the definition of a data flow model of test case inputs, optional intermediate values, and outputs. Data elements are represented visually and can be combined to create structures of any complexity. Data flows between elements provide additional information that allows the Zoea compiler to generate larger programs in less time. This paper includes an overview of the language. The benefits of the approach and some possible future enhancements are also discussed.",
            "corpus_id": 221802417,
            "sentences": [
                {
                    "corpus_id": "221802417",
                    "title": "A Visual Language for Composable Inductive Programming",
                    "text": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
                    "score": 0.3028248728546346,
                    "section_title": "Visual Programming",
                    "char_start_offset": 2695,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 89
                        },
                        {
                            "start": 90,
                            "end": 230
                        },
                        {
                            "start": 231,
                            "end": 412
                        },
                        {
                            "start": 415,
                            "end": 555
                        },
                        {
                            "start": 556,
                            "end": 615
                        },
                        {
                            "start": 616,
                            "end": 687
                        },
                        {
                            "start": 690,
                            "end": 798
                        },
                        {
                            "start": 799,
                            "end": 887
                        },
                        {
                            "start": 890,
                            "end": 927
                        },
                        {
                            "start": 930,
                            "end": 973
                        },
                        {
                            "start": 976,
                            "end": 1015
                        },
                        {
                            "start": 1018,
                            "end": 1160
                        },
                        {
                            "start": 1161,
                            "end": 1305
                        },
                        {
                            "start": 1308,
                            "end": 1523
                        },
                        {
                            "start": 1524,
                            "end": 1590
                        },
                        {
                            "start": 1591,
                            "end": 1734
                        },
                        {
                            "start": 1735,
                            "end": 1837
                        },
                        {
                            "start": 1838,
                            "end": 1959
                        },
                        {
                            "start": 1962,
                            "end": 2039
                        },
                        {
                            "start": 2040,
                            "end": 2257
                        },
                        {
                            "start": 2258,
                            "end": 2322
                        },
                        {
                            "start": 2325,
                            "end": 2433
                        },
                        {
                            "start": 2434,
                            "end": 2625
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 551,
                            "end": 554,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 604,
                            "end": 608,
                            "matchedPaperCorpusId": "5257722"
                        },
                        {
                            "start": 611,
                            "end": 614,
                            "matchedPaperCorpusId": "9744698"
                        },
                        {
                            "start": 670,
                            "end": 674,
                            "matchedPaperCorpusId": "44279097"
                        },
                        {
                            "start": 674,
                            "end": 677,
                            "matchedPaperCorpusId": "30037917"
                        },
                        {
                            "start": 677,
                            "end": 680,
                            "matchedPaperCorpusId": "158715"
                        },
                        {
                            "start": 683,
                            "end": 686,
                            "matchedPaperCorpusId": "425881"
                        },
                        {
                            "start": 793,
                            "end": 797,
                            "matchedPaperCorpusId": "561505"
                        },
                        {
                            "start": 2105,
                            "end": 2109,
                            "matchedPaperCorpusId": "30404857"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9736328125
                }
            ],
            "relevance_judgement": 0.9736328125,
            "relevance_judgment_input_expanded": "# Title: A Visual Language for Composable Inductive Programming\n# Venue: arXiv.org\n# Authors: Edward McDaid, S. McDaid\n## Abstract\nWe present Zoea Visual which is a visual programming language based on the Zoea composable inductive programming language. Zoea Visual allows users to create software directly from a specification that resembles a set of functional test cases. Programming with Zoea Visual involves the definition of a data flow model of test case inputs, optional intermediate values, and outputs. Data elements are represented visually and can be combined to create structures of any complexity. Data flows between elements provide additional information that allows the Zoea compiler to generate larger programs in less time. This paper includes an overview of the language. The benefits of the approach and some possible future enhancements are also discussed.\n## Visual Programming\nVisual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
            "reference_string": "[221802417 | McDaid et al. | 2020 | Citations: 4]"
        },
        {
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "venue": "International Conference on Computer Supported Education",
            "year": 2022,
            "reference_count": 23,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5220/0011082500003182",
                "status": "HYBRID",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5220/0011082500003182?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5220/0011082500003182, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1685511",
                    "name": "Anthony Savidis"
                }
            ],
            "abstract": ": Visual programming is widely adopted for teaching purposes, considered as an appropriate starting base before introducing learners to typical programming languages. However, the progress in such tools is very slow and limited compared to standard programming environments. Moreover, there is no systematic classification regarding the most important requirements to improve the support of visual programming tasks. In this context, we introduce programming experience as the context-specific notion of user-experience for the programming domain. Then, we identify three groups of requirements relating to language, interaction and tools, and elaborate with specific requirements per group. In this analysis, we study related examples from current tools in various domains, while we propose scenarios inspired from source-based programming environments.",
            "corpus_id": 248510289,
            "sentences": [
                {
                    "corpus_id": "248510289",
                    "title": "Programming Experience Requirements for Future Visual Development Environments",
                    "text": "The notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming. \n\nWhile visual programming adoption ranges from rapid application development, interactive software configurations, and system administration, it became popular for educational purposes, in particular for teaching programming skills. In this framework, Scratch (Maloney et al., 2010), a block-based tool and Lego Mindstorms\u2122 (Vallance et al., 2009) are amongst the most well-known visual tools in learning contexts. Historically, visual programing systems have been deployed to introduce students in the programming universe before being enabled to manage and master professional source-based programming languages. In this context, their scope is generally considered to be restricted in the early stages of acquiring programming skills. But today, there are visual tools for professional development purposes, ranging from business process, Internet of Things, 3d graphics and robotics, meaning their scope is not merely restricted to learning activities. Also, such tools support an important activity in the development lifecycle that is not always substituted by text-based counterparts, thus retaining a distinct and critical role. In this sense, for certain development skills, professional programmers may still have to learn using visual tools before switching (if they ever do) to the most powerful programminglanguage basis. This interplay between visual tools for leaning, with typical professional programming environments, is depicted under Figure 1. \n\nIn an educational context, emphasis is put on blending user experience (Law et al., 2009) with learning experience (Tawfik et al., 2021) to optimally support programming tasks. We define this combination as programming experience (see Figure 2) to better highlight and contextualise the importance of the programming task. In this context, we carried out a systematic analysis briefed in this paper, resulting in key design requirements linking to programming experience, with a summary provided under Figure 3.",
                    "score": 0.3244780451268607,
                    "section_title": "INTRODUCTION",
                    "char_start_offset": 15,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 114
                        },
                        {
                            "start": 115,
                            "end": 280
                        },
                        {
                            "start": 281,
                            "end": 393
                        },
                        {
                            "start": 396,
                            "end": 627
                        },
                        {
                            "start": 628,
                            "end": 809
                        },
                        {
                            "start": 810,
                            "end": 1009
                        },
                        {
                            "start": 1010,
                            "end": 1132
                        },
                        {
                            "start": 1133,
                            "end": 1351
                        },
                        {
                            "start": 1352,
                            "end": 1531
                        },
                        {
                            "start": 1532,
                            "end": 1729
                        },
                        {
                            "start": 1730,
                            "end": 1858
                        },
                        {
                            "start": 1861,
                            "end": 2037
                        },
                        {
                            "start": 2038,
                            "end": 2183
                        },
                        {
                            "start": 2184,
                            "end": 2372
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 100,
                            "end": 112,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 655,
                            "end": 677,
                            "matchedPaperCorpusId": "9744698"
                        },
                        {
                            "start": 719,
                            "end": 742,
                            "matchedPaperCorpusId": "208013563"
                        },
                        {
                            "start": 1932,
                            "end": 1950,
                            "matchedPaperCorpusId": "10465690"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97265625
                },
                {
                    "corpus_id": "248510289",
                    "title": "Programming Experience Requirements for Future Visual Development Environments",
                    "text": "Being learning tools, visual programming systems strike for a balance between programming facilities and ease-of-use. Thus, more advanced programming techniques may be left out, restricting deployment to small-scale projects. In this context, optional programming features may be provided targeted to more advanced learners as listed below: \n\n\u2022 Scopes may be defined by visual grouping, with local variables being geometrically contained. \u2022 Modules allow split programs into multiple units and reuse them in one or more projects. \u2022 Hybrid code enables contrast the visual code and its respective textual form altogether, enabling mixed editing, while keeping both views fully-synced and well-formed. \u2022 Source code that complements visual code, helpful for implementing complex modules, and also for supporting the cooperation of learners with experienced programmers.",
                    "score": 0.3509754580961078,
                    "section_title": "Extra Optional Elements",
                    "char_start_offset": 11413,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 117
                        },
                        {
                            "start": 118,
                            "end": 225
                        },
                        {
                            "start": 226,
                            "end": 340
                        },
                        {
                            "start": 343,
                            "end": 438
                        },
                        {
                            "start": 439,
                            "end": 529
                        },
                        {
                            "start": 530,
                            "end": 699
                        },
                        {
                            "start": 700,
                            "end": 867
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94580078125
                }
            ],
            "relevance_judgement": 0.97265625,
            "relevance_judgment_input_expanded": "# Title: Programming Experience Requirements for Future Visual Development Environments\n# Venue: International Conference on Computer Supported Education\n# Authors: Anthony Savidis\n## Abstract\n: Visual programming is widely adopted for teaching purposes, considered as an appropriate starting base before introducing learners to typical programming languages. However, the progress in such tools is very slow and limited compared to standard programming environments. Moreover, there is no systematic classification regarding the most important requirements to improve the support of visual programming tasks. In this context, we introduce programming experience as the context-specific notion of user-experience for the programming domain. Then, we identify three groups of requirements relating to language, interaction and tools, and elaborate with specific requirements per group. In this analysis, we study related examples from current tools in various domains, while we propose scenarios inspired from source-based programming environments.\n## INTRODUCTION\nThe notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming. \n\nWhile visual programming adoption ranges from rapid application development, interactive software configurations, and system administration, it became popular for educational purposes, in particular for teaching programming skills. In this framework, Scratch (Maloney et al., 2010), a block-based tool and Lego Mindstorms\u2122 (Vallance et al., 2009) are amongst the most well-known visual tools in learning contexts. Historically, visual programing systems have been deployed to introduce students in the programming universe before being enabled to manage and master professional source-based programming languages. In this context, their scope is generally considered to be restricted in the early stages of acquiring programming skills. But today, there are visual tools for professional development purposes, ranging from business process, Internet of Things, 3d graphics and robotics, meaning their scope is not merely restricted to learning activities. Also, such tools support an important activity in the development lifecycle that is not always substituted by text-based counterparts, thus retaining a distinct and critical role. In this sense, for certain development skills, professional programmers may still have to learn using visual tools before switching (if they ever do) to the most powerful programminglanguage basis. This interplay between visual tools for leaning, with typical professional programming environments, is depicted under Figure 1. \n\nIn an educational context, emphasis is put on blending user experience (Law et al., 2009) with learning experience (Tawfik et al., 2021) to optimally support programming tasks. We define this combination as programming experience (see Figure 2) to better highlight and contextualise the importance of the programming task. In this context, we carried out a systematic analysis briefed in this paper, resulting in key design requirements linking to programming experience, with a summary provided under Figure 3.\n\n## Extra Optional Elements\nBeing learning tools, visual programming systems strike for a balance between programming facilities and ease-of-use. Thus, more advanced programming techniques may be left out, restricting deployment to small-scale projects. In this context, optional programming features may be provided targeted to more advanced learners as listed below: \n\n\u2022 Scopes may be defined by visual grouping, with local variables being geometrically contained. \u2022 Modules allow split programs into multiple units and reuse them in one or more projects. \u2022 Hybrid code enables contrast the visual code and its respective textual form altogether, enabling mixed editing, while keeping both views fully-synced and well-formed. \u2022 Source code that complements visual code, helpful for implementing complex modules, and also for supporting the cooperation of learners with experienced programmers.",
            "reference_string": "[248510289 | Savidis | 2022 | Citations: 1]"
        },
        {
            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
            "venue": "European-Japanese Conference on Information Modelling and Knowledge Bases",
            "year": 2022,
            "reference_count": 15,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ebooks.iospress.nl/pdf/doi/10.3233/FAIA210477",
                "status": "HYBRID",
                "license": "CCBYNC",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3233/faia210477?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3233/faia210477, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2001006030",
                    "name": "Goragod Pongthanisorn"
                },
                {
                    "authorId": "19305117",
                    "name": "W. Viriyavit"
                },
                {
                    "authorId": "2844764",
                    "name": "Thatsanee Charoenporn"
                },
                {
                    "authorId": "1779078",
                    "name": "Virach Sornlertlamvanich"
                }
            ],
            "abstract": "Computer programming is popularized in 21st century education in terms of allowing intensive logical thinking for students. Artificial Intelligent and robotic field is considered to be the most attractive for programming today. However, for the first-time learners and novice programmers, they may encounter a difficulty in understanding the text-based style programming language with its special syntax, sematic, libraries, and the structure of the program itself. In this work, we proposed a visual programming environment for artificial intelligent and robotic application using Google Blockly. The development framework is a web application which is capable of using Google Blockly to create a program and translate the result of visual programming style to conventional text-based programming. This allows almost instant programming capability for learners of programming in such a complex system.",
            "corpus_id": 246022597,
            "sentences": [
                {
                    "corpus_id": "246022597",
                    "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
                    "text": "Not only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
                    "score": 0.3213007535264759,
                    "section_title": "Introduction",
                    "char_start_offset": 4515,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 108
                        },
                        {
                            "start": 109,
                            "end": 366
                        },
                        {
                            "start": 367,
                            "end": 542
                        },
                        {
                            "start": 543,
                            "end": 603
                        },
                        {
                            "start": 606,
                            "end": 692
                        },
                        {
                            "start": 693,
                            "end": 801
                        },
                        {
                            "start": 802,
                            "end": 852
                        },
                        {
                            "start": 853,
                            "end": 907
                        },
                        {
                            "start": 908,
                            "end": 1069
                        },
                        {
                            "start": 1070,
                            "end": 1273
                        },
                        {
                            "start": 1274,
                            "end": 1566
                        },
                        {
                            "start": 1567,
                            "end": 1688
                        },
                        {
                            "start": 1689,
                            "end": 1823
                        },
                        {
                            "start": 1824,
                            "end": 1900
                        },
                        {
                            "start": 1901,
                            "end": 2156
                        },
                        {
                            "start": 2157,
                            "end": 2205
                        },
                        {
                            "start": 2206,
                            "end": 2277
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 1065,
                            "end": 1068,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1901,
                            "end": 1905,
                            "matchedPaperCorpusId": "15999236"
                        },
                        {
                            "start": 1908,
                            "end": 1911,
                            "matchedPaperCorpusId": "35216497"
                        },
                        {
                            "start": 1911,
                            "end": 1914,
                            "matchedPaperCorpusId": "221243933"
                        },
                        {
                            "start": 1914,
                            "end": 1917,
                            "matchedPaperCorpusId": "31119847"
                        },
                        {
                            "start": 2166,
                            "end": 2170,
                            "matchedPaperCorpusId": "15999236"
                        },
                        {
                            "start": 2173,
                            "end": 2176,
                            "matchedPaperCorpusId": "35216497"
                        },
                        {
                            "start": 2176,
                            "end": 2179,
                            "matchedPaperCorpusId": "221243933"
                        },
                        {
                            "start": 2179,
                            "end": 2182,
                            "matchedPaperCorpusId": "31119847"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97216796875
                }
            ],
            "relevance_judgement": 0.97216796875,
            "relevance_judgment_input_expanded": "# Title: Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework\n# Venue: European-Japanese Conference on Information Modelling and Knowledge Bases\n# Authors: Goragod Pongthanisorn, W. Viriyavit, Thatsanee Charoenporn, Virach Sornlertlamvanich\n## Abstract\nComputer programming is popularized in 21st century education in terms of allowing intensive logical thinking for students. Artificial Intelligent and robotic field is considered to be the most attractive for programming today. However, for the first-time learners and novice programmers, they may encounter a difficulty in understanding the text-based style programming language with its special syntax, sematic, libraries, and the structure of the program itself. In this work, we proposed a visual programming environment for artificial intelligent and robotic application using Google Blockly. The development framework is a web application which is capable of using Google Blockly to create a program and translate the result of visual programming style to conventional text-based programming. This allows almost instant programming capability for learners of programming in such a complex system.\n## Introduction\nNot only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
            "reference_string": "[246022597 | Pongthanisorn et al. | 2022 | Citations: 0]"
        },
        {
            "title": "Application of Visual Programming in Program Design Course",
            "venue": "DEStech Transactions on Social Science Education and Human Science",
            "year": 2019,
            "reference_count": 2,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.12783/dtssehs/eiem2018/26901",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.12783/DTSSEHS/EIEM2018/26901?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.12783/DTSSEHS/EIEM2018/26901, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2114140303",
                    "name": "Xiaojun Bai"
                },
                {
                    "authorId": "2801842",
                    "name": "Baili Liu"
                }
            ],
            "abstract": "According to the problems in teaching of computer programming course, brought visual programming tools to assist teaching, introduced the advantages of visual programming, and made use of it in algorithm design, coding and modular design. Practice shows that by introducing of visual programming, it helps the students to improve their interesting, and develop the ability of logic thinking as well as programming. Introduction Computer programming is a basic course for college students of science and engineering majors, it aims to guide students to understand the ideas and methods of programming, and to master a language to solve problems by programming [1] . In recent years, with the propose and development of computational thinking [2] , it is becoming a trend to solve problems in various fields by means of computational methods and tools, thus it becomes more and more important of this course. But in teaching practice, it is quite difficult to reach the objects of this course. Firstly, it needs great efforts on coding and debugging of programs, but Students are often afraid of tedious syntax of the language, and finally lost confidence for programming when meet program errors again and again. Secondly, the procedure of programming is indeed a procedure of logical thinking, but for many fresh students, the ability of logical thinking is still weak, there is some difficulty for them to understand the logic of programs, so we need a gradual training method for logical thinking. Thirdly, the flow diagram that been used for expressing the algorithm, but for it cannot be executed, there has no way to verify the result of the algorithm, we need stronger tools to express algorithms and verify them. In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm. The Usage of Visual Programming in Teaching Practice The author have practiced visual programming in three stage. First for algorithm design, made use of visual program to take place of flow diagram, intuitively introduce the logic of algorithms and verify them immediately. Second for coding, combined with the syntax and control flow of a programming language, transform the visual program into codes of the corresponding language. Third for modular design, create program modules by means of customized block, thus understand the ideas of decomposition and modular design for complex system. Next we will illustrate on the three topics. Make Use of Visual Programming in Algorithm Design Algorithm is the soul of program, and also be the key for developing computational Thinking and logical thinking. For American students, they usually begun visual programming in primary and secondary school, so that the logical thinking had been developed, but for Chinese students, they always lacking this ability. At the beginning of the course, we propose to use the simplest and most",
            "corpus_id": 68068900,
            "sentences": [
                {
                    "corpus_id": "68068900",
                    "title": "Application of Visual Programming in Program Design Course",
                    "text": "it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm. The Usage of Visual Programming in Teaching Practice The author have practiced visual programming in three stage. First for algorithm design, made use of visual program to take place of flow diagram, intuitively introduce the logic of algorithms and verify them immediately. Second for coding, combined with the syntax and control flow of a programming language, transform the visual program into codes of the corresponding language. Third for modular design, create program modules by means of customized block, thus understand the ideas of decomposition and modular design for complex system. Next we will illustrate on the three topics. Make Use of Visual Programming in Algorithm Design Algorithm is the soul of program, and also be the key for developing computational Thinking and logical thinking. For American students, they usually begun visual programming in primary and secondary school, so that the logical thinking had been developed, but for Chinese students, they always lacking this ability. At the beginning of the course, we propose to use the simplest and most",
                    "score": 0.3685763966626367,
                    "section_title": "abstract",
                    "char_start_offset": 2208,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96826171875
                },
                {
                    "corpus_id": "68068900",
                    "title": "Application of Visual Programming in Program Design Course",
                    "text": "According to the problems in teaching of computer programming course, brought visual programming tools to assist teaching, introduced the advantages of visual programming, and made use of it in algorithm design, coding and modular design. Practice shows that by introducing of visual programming, it helps the students to improve their interesting, and develop the ability of logic thinking as well as programming. Introduction Computer programming is a basic course for college students of science and engineering majors, it aims to guide students to understand the ideas and methods of programming, and to master a language to solve problems by programming [1] . In recent years, with the propose and development of computational thinking [2] , it is becoming a trend to solve problems in various fields by means of computational methods and tools, thus it becomes more and more important of this course. But in teaching practice, it is quite difficult to reach the objects of this course. Firstly, it needs great efforts on coding and debugging of programs, but Students are often afraid of tedious syntax of the language, and finally lost confidence for programming when meet program errors again and again. Secondly, the procedure of programming is indeed a procedure of logical thinking, but for many fresh students, the ability of logical thinking is still weak, there is some difficulty for them to understand the logic of programs, so we need a gradual training method for logical thinking. Thirdly, the flow diagram that been used for expressing the algorithm, but for it cannot be executed, there has no way to verify the result of the algorithm, we need stronger tools to express algorithms and verify them. In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm.",
                    "score": 0.3721991141151649,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96533203125
                }
            ],
            "relevance_judgement": 0.96826171875,
            "relevance_judgment_input_expanded": "# Title: Application of Visual Programming in Program Design Course\n# Venue: DEStech Transactions on Social Science Education and Human Science\n# Authors: Xiaojun Bai, Baili Liu\n## Abstract\nAccording to the problems in teaching of computer programming course, brought visual programming tools to assist teaching, introduced the advantages of visual programming, and made use of it in algorithm design, coding and modular design. Practice shows that by introducing of visual programming, it helps the students to improve their interesting, and develop the ability of logic thinking as well as programming. Introduction Computer programming is a basic course for college students of science and engineering majors, it aims to guide students to understand the ideas and methods of programming, and to master a language to solve problems by programming [1] . In recent years, with the propose and development of computational thinking [2] , it is becoming a trend to solve problems in various fields by means of computational methods and tools, thus it becomes more and more important of this course. But in teaching practice, it is quite difficult to reach the objects of this course. Firstly, it needs great efforts on coding and debugging of programs, but Students are often afraid of tedious syntax of the language, and finally lost confidence for programming when meet program errors again and again. Secondly, the procedure of programming is indeed a procedure of logical thinking, but for many fresh students, the ability of logical thinking is still weak, there is some difficulty for them to understand the logic of programs, so we need a gradual training method for logical thinking. Thirdly, the flow diagram that been used for expressing the algorithm, but for it cannot be executed, there has no way to verify the result of the algorithm, we need stronger tools to express algorithms and verify them. In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm. The Usage of Visual Programming in Teaching Practice The author have practiced visual programming in three stage. First for algorithm design, made use of visual program to take place of flow diagram, intuitively introduce the logic of algorithms and verify them immediately. Second for coding, combined with the syntax and control flow of a programming language, transform the visual program into codes of the corresponding language. Third for modular design, create program modules by means of customized block, thus understand the ideas of decomposition and modular design for complex system. Next we will illustrate on the three topics. Make Use of Visual Programming in Algorithm Design Algorithm is the soul of program, and also be the key for developing computational Thinking and logical thinking. For American students, they usually begun visual programming in primary and secondary school, so that the logical thinking had been developed, but for Chinese students, they always lacking this ability. At the beginning of the course, we propose to use the simplest and most\n",
            "reference_string": "[68068900 | Bai et al. | 2019 | Citations: 1]"
        },
        {
            "title": "A visual programming language for drawing and executing flowcharts",
            "venue": "2011 Proceedings of the 34th International Convention MIPRO",
            "year": 2011,
            "reference_count": 24,
            "citation_count": 10,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1202.2284, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3352207",
                    "name": "Dra\u017een Lu\u010danin"
                },
                {
                    "authorId": "2754593",
                    "name": "Ivan Fabek"
                }
            ],
            "abstract": "With recent advances in graphical user interfaces, more and more tasks on computers have become easier to perform. Out of the belief that creating computer programs can also be one of them, visual programming languages (VPLs) have emerged. The goal of VPLs is to shift a part of work from the programmer to the IDE so that the programmer can focus more on algorithm logic than the syntax of the implementation programming language. In this article, the methods required to build a VPL are presented, with an emphasis on a novel method of code generation in a WHILE language. Also, the methods for achieving basic principles of VPLs will be shown \u2014 suitable visual presentation of information and guiding the programmer in the right direction using constraints. These methods are demonstrated on an example of vIDE, a VPL based on the Eclipse integrated development environment (IDE). The design of vIDE with respect to the Eclipse Graphical Modeling Framework (GMF) is described. The concept of a flowchart graphical notation is examined in contrast with the algorithm model it maps to. Finally, the disambiguity of the model representation of an algorithm is discussed and the methods for transforming it to an actual implementation in a programming language.",
            "corpus_id": 7271567,
            "sentences": [
                {
                    "corpus_id": "7271567",
                    "title": "A visual programming language for drawing and executing flowcharts",
                    "text": "With recent advances in graphical user interfaces, more and more tasks on computers have become easier to perform. Out of the belief that creating computer programs can also be one of them, visual programming languages (VPLs) have emerged. The goal of VPLs is to shift a part of work from the programmer to the IDE so that the programmer can focus more on algorithm logic than the syntax of the implementation programming language. In this article, the methods required to build a VPL are presented, with an emphasis on a novel method of code generation in a WHILE language. Also, the methods for achieving basic principles of VPLs will be shown \u2014 suitable visual presentation of information and guiding the programmer in the right direction using constraints. These methods are demonstrated on an example of vIDE, a VPL based on the Eclipse integrated development environment (IDE). The design of vIDE with respect to the Eclipse Graphical Modeling Framework (GMF) is described. The concept of a flowchart graphical notation is examined in contrast with the algorithm model it maps to. Finally, the disambiguity of the model representation of an algorithm is discussed and the methods for transforming it to an actual implementation in a programming language.",
                    "score": 0.3544289123930477,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.966796875
                },
                {
                    "corpus_id": "7271567",
                    "title": "A visual programming language for drawing and executing flowcharts",
                    "text": "In [4] a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time LabView and Simulink can be mentioned as the representatives of a big group -the data flow VPLs, described in [5], which are based around a functional programming style. A similar VPL, but presented as an online web service is Yahoo Pipes [6]. \n\nKTechlab [7] is a flowchart VPL used to describe hardware components. Scratch [8] is a good example of a WHILE language flowchart VPL that has taken the role of education through fun and interactive app programming. One drawback in Scratch is that it doesn't present the user with the source code generated from his flowchart, thus not encouraging gradual transition to classical programming as the user gets more experienced.",
                    "score": 0.3441653753236377,
                    "section_title": "B. Related work",
                    "char_start_offset": 4177,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 182
                        },
                        {
                            "start": 183,
                            "end": 223
                        },
                        {
                            "start": 226,
                            "end": 619
                        },
                        {
                            "start": 620,
                            "end": 693
                        },
                        {
                            "start": 696,
                            "end": 765
                        },
                        {
                            "start": 766,
                            "end": 911
                        },
                        {
                            "start": 912,
                            "end": 1122
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 3,
                            "end": 6,
                            "matchedPaperCorpusId": "13484911"
                        },
                        {
                            "start": 560,
                            "end": 563,
                            "matchedPaperCorpusId": "5257722"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.93798828125
                }
            ],
            "relevance_judgement": 0.966796875,
            "relevance_judgment_input_expanded": "# Title: A visual programming language for drawing and executing flowcharts\n# Venue: 2011 Proceedings of the 34th International Convention MIPRO\n# Authors: Dra\u017een Lu\u010danin, Ivan Fabek\n## Abstract\nWith recent advances in graphical user interfaces, more and more tasks on computers have become easier to perform. Out of the belief that creating computer programs can also be one of them, visual programming languages (VPLs) have emerged. The goal of VPLs is to shift a part of work from the programmer to the IDE so that the programmer can focus more on algorithm logic than the syntax of the implementation programming language. In this article, the methods required to build a VPL are presented, with an emphasis on a novel method of code generation in a WHILE language. Also, the methods for achieving basic principles of VPLs will be shown \u2014 suitable visual presentation of information and guiding the programmer in the right direction using constraints. These methods are demonstrated on an example of vIDE, a VPL based on the Eclipse integrated development environment (IDE). The design of vIDE with respect to the Eclipse Graphical Modeling Framework (GMF) is described. The concept of a flowchart graphical notation is examined in contrast with the algorithm model it maps to. Finally, the disambiguity of the model representation of an algorithm is discussed and the methods for transforming it to an actual implementation in a programming language.\n## B. Related work\nIn [4] a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time LabView and Simulink can be mentioned as the representatives of a big group -the data flow VPLs, described in [5], which are based around a functional programming style. A similar VPL, but presented as an online web service is Yahoo Pipes [6]. \n\nKTechlab [7] is a flowchart VPL used to describe hardware components. Scratch [8] is a good example of a WHILE language flowchart VPL that has taken the role of education through fun and interactive app programming. One drawback in Scratch is that it doesn't present the user with the source code generated from his flowchart, thus not encouraging gradual transition to classical programming as the user gets more experienced.",
            "reference_string": "[7271567 | Lucanin et al. | 2011 | Citations: 10]"
        },
        {
            "title": "Formation of an information retrieval system of visual programming scenarios for information modeling software complexes",
            "venue": "E3S Web of Conferences",
            "year": 2024,
            "reference_count": 18,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1051/e3sconf/202453505002",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1051/e3sconf/202453505002?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1051/e3sconf/202453505002, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2306009129",
                    "name": "Angelina Rybakova"
                },
                {
                    "authorId": "2306027372",
                    "name": "Daniil Piatkov"
                }
            ],
            "abstract": "This article discusses the process of creating an application based on a specialized database for working with a variety of scripts \u2013 visual programming scenarios. The SQL query Language (Structured Query Language) was used as a key tool for implementing the application, data for systematization was presented from the file system for storing scripts of the organization in question. In view of the popularization of the use of visual programming tools in information modeling software complexes, there is a problem of systematization of a regularly increasing number of scripts both in a specific organization and in the market as a whole. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation to filter the necessary scripts. Automation of the implementation of all the above tasks is performed on the basis of the high-level programming language C++ with the integration of SQL queries in the cross-platform development environment Qt Creator. As a result, an information search engine is presented in the form of an application \"Script Manager\".",
            "corpus_id": 270427107,
            "sentences": [
                {
                    "corpus_id": "270427107",
                    "title": "Formation of an information retrieval system of visual programming scenarios for information modeling software complexes",
                    "text": "In recent years, visual programming tools in the information modeling environment have become increasingly popular. Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2] The main purpose of using visual programming, including in the information modeling environment, is to expand the functionality of the software package by developing its own functions. As a result, designers can automate routine tasks and go beyond the basic functionality of the program. [3] Visual programming includes a library of previously prepared program code blocks in the form of a graphical node element. Formed in a certain way by a set of nodes is a scriptscript, as a result of which one or another task is performed automatically. Simultaneously with the basic node library, additional packages created by users can be added to the program. [4][5] The spread and development of visual programming in the information modeling environment has led to a sharp increase in the number of scripts both in a particular company and in the industry as a whole. And already today, large project companies are faced with the difficulties of interacting with a large number of scripts that perform various functions. There are problems with storing, searching, processing and updating scripts, which leads to an increase in the duration of the design and additional labor costs of specialists. [6][7] Thus, it is advisable to create a tool that will eliminate the problems of working with a large number of different types of scripts. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation (Structured Query Language) to filter the necessary scripts.",
                    "score": 0.37955109953353117,
                    "section_title": "Introdution",
                    "char_start_offset": 14,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 115
                        },
                        {
                            "start": 116,
                            "end": 256
                        },
                        {
                            "start": 257,
                            "end": 367
                        },
                        {
                            "start": 368,
                            "end": 559
                        },
                        {
                            "start": 560,
                            "end": 663
                        },
                        {
                            "start": 664,
                            "end": 789
                        },
                        {
                            "start": 790,
                            "end": 919
                        },
                        {
                            "start": 920,
                            "end": 1029
                        },
                        {
                            "start": 1030,
                            "end": 1239
                        },
                        {
                            "start": 1240,
                            "end": 1392
                        },
                        {
                            "start": 1393,
                            "end": 1569
                        },
                        {
                            "start": 1570,
                            "end": 1710
                        },
                        {
                            "start": 1711,
                            "end": 2052
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96630859375
                }
            ],
            "relevance_judgement": 0.96630859375,
            "relevance_judgment_input_expanded": "# Title: Formation of an information retrieval system of visual programming scenarios for information modeling software complexes\n# Venue: E3S Web of Conferences\n# Authors: Angelina Rybakova, Daniil Piatkov\n## Abstract\nThis article discusses the process of creating an application based on a specialized database for working with a variety of scripts \u2013 visual programming scenarios. The SQL query Language (Structured Query Language) was used as a key tool for implementing the application, data for systematization was presented from the file system for storing scripts of the organization in question. In view of the popularization of the use of visual programming tools in information modeling software complexes, there is a problem of systematization of a regularly increasing number of scripts both in a specific organization and in the market as a whole. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation to filter the necessary scripts. Automation of the implementation of all the above tasks is performed on the basis of the high-level programming language C++ with the integration of SQL queries in the cross-platform development environment Qt Creator. As a result, an information search engine is presented in the form of an application \"Script Manager\".\n## Introdution\nIn recent years, visual programming tools in the information modeling environment have become increasingly popular. Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2] The main purpose of using visual programming, including in the information modeling environment, is to expand the functionality of the software package by developing its own functions. As a result, designers can automate routine tasks and go beyond the basic functionality of the program. [3] Visual programming includes a library of previously prepared program code blocks in the form of a graphical node element. Formed in a certain way by a set of nodes is a scriptscript, as a result of which one or another task is performed automatically. Simultaneously with the basic node library, additional packages created by users can be added to the program. [4][5] The spread and development of visual programming in the information modeling environment has led to a sharp increase in the number of scripts both in a particular company and in the industry as a whole. And already today, large project companies are faced with the difficulties of interacting with a large number of scripts that perform various functions. There are problems with storing, searching, processing and updating scripts, which leads to an increase in the duration of the design and additional labor costs of specialists. [6][7] Thus, it is advisable to create a tool that will eliminate the problems of working with a large number of different types of scripts. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation (Structured Query Language) to filter the necessary scripts.",
            "reference_string": "[270427107 | Rybakova et al. | 2024 | Citations: 1]"
        },
        {
            "title": "Studi Komparatif Program Visual Dinamis untuk Pembelajaran Algoritma dan Pemograman Berorientasi Objek",
            "venue": "",
            "year": 2020,
            "reference_count": 0,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.52158/jacost.v1i1.53",
                "status": "GOLD",
                "license": "CCBYSA",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.52158/JACOST.V1I1.53?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.52158/JACOST.V1I1.53, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "9178885",
                    "name": "Kursehi Falgenti"
                }
            ],
            "abstract": "As beginners, many first-year students have difficulty understanding object-oriented programming material. To help students learn algorithmic and object-oriented programming material researchers have developed visual programming (PV). Visual programming is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming. This research aims to compare three dynamic PV tools for object-oriented learning programming that are the most studied. To determine the PV to be compared, a survey was conducted in an online journal database, such as IEEE explore, ACM, and several well-known online publishers. From the survey results, three dynamic PVs were chosen, most widely discussed, namely Jeliot 3, Ville and Jive. All three tools are installed and studied. Comparison results show that each dynamic PV has advantages on certain characteristics. The instructor can choose visual programming by considering the advantages of each PV.",
            "corpus_id": 225541919,
            "sentences": [
                {
                    "corpus_id": "225541919",
                    "title": "Studi Komparatif Program Visual Dinamis untuk Pembelajaran Algoritma dan Pemograman Berorientasi Objek",
                    "text": "As beginners, many first-year students have difficulty understanding object-oriented programming material. To help students learn algorithmic and object-oriented programming material researchers have developed visual programming (PV). Visual programming is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming. This research aims to compare three dynamic PV tools for object-oriented learning programming that are the most studied. To determine the PV to be compared, a survey was conducted in an online journal database, such as IEEE explore, ACM, and several well-known online publishers. From the survey results, three dynamic PVs were chosen, most widely discussed, namely Jeliot 3, Ville and Jive. All three tools are installed and studied. Comparison results show that each dynamic PV has advantages on certain characteristics. The instructor can choose visual programming by considering the advantages of each PV.",
                    "score": 0.3028248728546346,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9658203125
                }
            ],
            "relevance_judgement": 0.9658203125,
            "relevance_judgment_input_expanded": "# Title: Studi Komparatif Program Visual Dinamis untuk Pembelajaran Algoritma dan Pemograman Berorientasi Objek\n# Venue: \n# Authors: Kursehi Falgenti\n## Abstract\nAs beginners, many first-year students have difficulty understanding object-oriented programming material. To help students learn algorithmic and object-oriented programming material researchers have developed visual programming (PV). Visual programming is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming. This research aims to compare three dynamic PV tools for object-oriented learning programming that are the most studied. To determine the PV to be compared, a survey was conducted in an online journal database, such as IEEE explore, ACM, and several well-known online publishers. From the survey results, three dynamic PVs were chosen, most widely discussed, namely Jeliot 3, Ville and Jive. All three tools are installed and studied. Comparison results show that each dynamic PV has advantages on certain characteristics. The instructor can choose visual programming by considering the advantages of each PV.\n",
            "reference_string": "[225541919 | Falgenti | 2020 | Citations: 2]"
        },
        {
            "title": "Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning",
            "venue": "International Journal of Emerging Technologies in Learning (iJET)",
            "year": 2020,
            "reference_count": 45,
            "citation_count": 40,
            "influential_citation_count": 3,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://online-journals.org/index.php/i-jet/article/download/11013/6333",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3991/ijet.v15i01.11013?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3991/ijet.v15i01.11013, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2111748",
                    "name": "Chiung-Fang Chiu"
                }
            ],
            "abstract": "The use of apps in education has become popular in recent years with the development of technology. How to prepare K-12 teachers in creating apps for students learning is worth our attention. This paper presents how to ap-ply visual programming and project-based learning to facilitate K-12 teachers in creating apps. Seven K-12 teachers with less computer background partic-ipated in this study. Data source including (1) K-12 teachers\u2019 project codes, (2) K-12 teachers\u2019 questionnaire, (3) K-12 teachers\u2019 interviews, and (4) ques-tionnaire giving to K-12 students were collected and analyzed. The results reveal that K-12 teachers applied many programming concepts in the coding implementation in these projects. Most students gave positive feedback to these K-12 teachers\u2019 app projects. Furthermore, K-12 teachers were also very positive toward the creation of apps by visual programming and project implementation, which was reflected through K-12 teachers\u2019 questionnaire surveys and interview results. The above findings provide a practicable ap-proach for future teaching to K-12 teachers or novice programmers on app programming.",
            "corpus_id": 212726996,
            "sentences": [
                {
                    "corpus_id": "212726996",
                    "title": "Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning",
                    "text": "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming [9]- [10]. Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions. Study by [15] indicated that students who used the visual interface for programming spent less time off track and completed more of the activity's goals in less time when compared to those who used the textual interface for programming. Saito, Washizaki, and Fukazawa also compared the learning effects of text-based and visual-based programming and found that visual-based programming induces a larger change in attitude toward programming [16]. Therefore, research results suggest that visual-based programming is advantageous in a programming implementation environment for novice programmers. \n\nNumerous studies have shown the benefits and feasibility of visual programming environments such as Scratch (scratch. mit.edu), Alice (www.alice.org), and Kodu (www.kodugamelab.com). Since they are easy to use and understand, visual programming environments have been used as lead-in courses for more advanced computer science courses. For example, research [17]- [18] taught Scratch in a CS0 course to improve the retention rate of at-risk majors and to stimulate interest and positive attitudes toward computer science. Scratch and Kodu were also used to teach important concepts of computer science for students [19]- [21]. Furthermore, research by Werner, Denner, Campe, and Kawamoto also pointed out that visual programming environment is helpful in the development of learners' computational thinking skills [22].",
                    "score": 0.41450130713776434,
                    "section_title": "Visual programming environment",
                    "char_start_offset": 5363,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 157
                        },
                        {
                            "start": 158,
                            "end": 329
                        },
                        {
                            "start": 330,
                            "end": 417
                        },
                        {
                            "start": 418,
                            "end": 627
                        },
                        {
                            "start": 628,
                            "end": 766
                        },
                        {
                            "start": 767,
                            "end": 953
                        },
                        {
                            "start": 954,
                            "end": 1190
                        },
                        {
                            "start": 1191,
                            "end": 1400
                        },
                        {
                            "start": 1401,
                            "end": 1550
                        },
                        {
                            "start": 1553,
                            "end": 1670
                        },
                        {
                            "start": 1671,
                            "end": 1680
                        },
                        {
                            "start": 1681,
                            "end": 1703
                        },
                        {
                            "start": 1704,
                            "end": 1735
                        },
                        {
                            "start": 1736,
                            "end": 1888
                        },
                        {
                            "start": 1889,
                            "end": 2074
                        },
                        {
                            "start": 2075,
                            "end": 2179
                        },
                        {
                            "start": 2180,
                            "end": 2372
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 319,
                            "end": 322,
                            "matchedPaperCorpusId": "33572463"
                        },
                        {
                            "start": 324,
                            "end": 328,
                            "matchedPaperCorpusId": "2965215"
                        },
                        {
                            "start": 963,
                            "end": 967,
                            "matchedPaperCorpusId": "16554511"
                        },
                        {
                            "start": 1395,
                            "end": 1399,
                            "matchedPaperCorpusId": "38535646"
                        },
                        {
                            "start": 1911,
                            "end": 1915,
                            "matchedPaperCorpusId": "59837822"
                        },
                        {
                            "start": 1917,
                            "end": 1921,
                            "matchedPaperCorpusId": "22652302"
                        },
                        {
                            "start": 2168,
                            "end": 2172,
                            "matchedPaperCorpusId": "16831477"
                        },
                        {
                            "start": 2174,
                            "end": 2178,
                            "matchedPaperCorpusId": "3344110"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96484375
                }
            ],
            "relevance_judgement": 0.96484375,
            "relevance_judgment_input_expanded": "# Title: Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning\n# Venue: International Journal of Emerging Technologies in Learning (iJET)\n# Authors: Chiung-Fang Chiu\n## Abstract\nThe use of apps in education has become popular in recent years with the development of technology. How to prepare K-12 teachers in creating apps for students learning is worth our attention. This paper presents how to ap-ply visual programming and project-based learning to facilitate K-12 teachers in creating apps. Seven K-12 teachers with less computer background partic-ipated in this study. Data source including (1) K-12 teachers\u2019 project codes, (2) K-12 teachers\u2019 questionnaire, (3) K-12 teachers\u2019 interviews, and (4) ques-tionnaire giving to K-12 students were collected and analyzed. The results reveal that K-12 teachers applied many programming concepts in the coding implementation in these projects. Most students gave positive feedback to these K-12 teachers\u2019 app projects. Furthermore, K-12 teachers were also very positive toward the creation of apps by visual programming and project implementation, which was reflected through K-12 teachers\u2019 questionnaire surveys and interview results. The above findings provide a practicable ap-proach for future teaching to K-12 teachers or novice programmers on app programming.\n## Visual programming environment\nTraditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming [9]- [10]. Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions. Study by [15] indicated that students who used the visual interface for programming spent less time off track and completed more of the activity's goals in less time when compared to those who used the textual interface for programming. Saito, Washizaki, and Fukazawa also compared the learning effects of text-based and visual-based programming and found that visual-based programming induces a larger change in attitude toward programming [16]. Therefore, research results suggest that visual-based programming is advantageous in a programming implementation environment for novice programmers. \n\nNumerous studies have shown the benefits and feasibility of visual programming environments such as Scratch (scratch. mit.edu), Alice (www.alice.org), and Kodu (www.kodugamelab.com). Since they are easy to use and understand, visual programming environments have been used as lead-in courses for more advanced computer science courses. For example, research [17]- [18] taught Scratch in a CS0 course to improve the retention rate of at-risk majors and to stimulate interest and positive attitudes toward computer science. Scratch and Kodu were also used to teach important concepts of computer science for students [19]- [21]. Furthermore, research by Werner, Denner, Campe, and Kawamoto also pointed out that visual programming environment is helpful in the development of learners' computational thinking skills [22].",
            "reference_string": "[212726996 | Chiu | 2020 | Citations: 40]"
        },
        {
            "title": "ELEA - Build your own Evolutionary Algorithm in your Browser",
            "venue": "GECCO Companion",
            "year": 2023,
            "reference_count": 7,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "http://arxiv.org/pdf/2302.06277",
                "status": "GREEN",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2302.06277, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2194782585",
                    "name": "Markus Wagner"
                },
                {
                    "authorId": "2205544441",
                    "name": "Erik Kohlros"
                },
                {
                    "authorId": "2205539993",
                    "name": "Gerome Quantmeyer"
                },
                {
                    "authorId": "1751539",
                    "name": "Timo K\u00f6tzing"
                }
            ],
            "abstract": "We provide an open source framework to experiment with evolutionary algorithms which we call Experimenting and Learning toolkit for Evolutionary Algorithms (ELEA). ELEA is browser-based and allows to assemble evolutionary algorithms using drag-and-drop, starting from a number of simple pre-designed examples, making the startup costs for employing the toolkit minimal. The designed examples can be executed and collected data can be displayed graphically. Further features include export of algorithm designs and experimental results as well as multi-threading. With the very intuitive user interface and the short time to get initial experiments going, this tool is especially suitable for explorative analyses of algorithms as well as for the use in classrooms.",
            "corpus_id": 256827582,
            "sentences": [
                {
                    "corpus_id": "256827582",
                    "title": "ELEA - Build your own Evolutionary Algorithm in your Browser",
                    "text": "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations. \n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour. \n\nBlockly [2,5] is an example of such a VPS. It is an open-source, client-side library for the programming language JavaScript, providing an editor representing coding concepts as interlocking blocks. Blockly typically runs in a web browser, but it can also generate correct stand-alone code in JavaScript, Python, PHP, Lua, Dart, etc. Figure 1 shows an example of Blockly running in a browser. The default graphical user interface of the Blockly editor consists of (1) a toolbox, which holds available blocks, and where a user can select blocks; and (2) a workspace, where a user can drag, drop and rearrange blocks. The workspace also includes, by default, zoom icons, and a trash can to delete blocks. Assembly of code consists in drag and drop of functional blocks, giving a final visual impression much like pseudo-code. For ELEA, we leverage that Blockly is open-source and that custom blocks can be created. Each block consists of a definition, which defines the visual appearance, and a generator, which describes the block's translation to executable code. Blocks can be written in JavaScript, but they can also be defined using blocks.",
                    "score": 0.3276843530888929,
                    "section_title": "BACKGROUND ON VISUAL PROGRAMMING",
                    "char_start_offset": 6291,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 153
                        },
                        {
                            "start": 154,
                            "end": 284
                        },
                        {
                            "start": 287,
                            "end": 359
                        },
                        {
                            "start": 362,
                            "end": 443
                        },
                        {
                            "start": 444,
                            "end": 522
                        },
                        {
                            "start": 523,
                            "end": 613
                        },
                        {
                            "start": 616,
                            "end": 658
                        },
                        {
                            "start": 659,
                            "end": 814
                        },
                        {
                            "start": 815,
                            "end": 1008
                        },
                        {
                            "start": 1009,
                            "end": 1231
                        },
                        {
                            "start": 1232,
                            "end": 1318
                        },
                        {
                            "start": 1319,
                            "end": 1439
                        },
                        {
                            "start": 1440,
                            "end": 1528
                        },
                        {
                            "start": 1529,
                            "end": 1679
                        },
                        {
                            "start": 1680,
                            "end": 1759
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 34,
                            "end": 37,
                            "matchedPaperCorpusId": "14591095"
                        },
                        {
                            "start": 355,
                            "end": 358,
                            "matchedPaperCorpusId": "41867280"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96435546875
                }
            ],
            "relevance_judgement": 0.96435546875,
            "relevance_judgment_input_expanded": "# Title: ELEA - Build your own Evolutionary Algorithm in your Browser\n# Venue: GECCO Companion\n# Authors: Markus Wagner, Erik Kohlros, Gerome Quantmeyer, Timo K\u00f6tzing\n## Abstract\nWe provide an open source framework to experiment with evolutionary algorithms which we call Experimenting and Learning toolkit for Evolutionary Algorithms (ELEA). ELEA is browser-based and allows to assemble evolutionary algorithms using drag-and-drop, starting from a number of simple pre-designed examples, making the startup costs for employing the toolkit minimal. The designed examples can be executed and collected data can be displayed graphically. Further features include export of algorithm designs and experimental results as well as multi-threading. With the very intuitive user interface and the short time to get initial experiments going, this tool is especially suitable for explorative analyses of algorithms as well as for the use in classrooms.\n## BACKGROUND ON VISUAL PROGRAMMING\nA visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations. \n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour. \n\nBlockly [2,5] is an example of such a VPS. It is an open-source, client-side library for the programming language JavaScript, providing an editor representing coding concepts as interlocking blocks. Blockly typically runs in a web browser, but it can also generate correct stand-alone code in JavaScript, Python, PHP, Lua, Dart, etc. Figure 1 shows an example of Blockly running in a browser. The default graphical user interface of the Blockly editor consists of (1) a toolbox, which holds available blocks, and where a user can select blocks; and (2) a workspace, where a user can drag, drop and rearrange blocks. The workspace also includes, by default, zoom icons, and a trash can to delete blocks. Assembly of code consists in drag and drop of functional blocks, giving a final visual impression much like pseudo-code. For ELEA, we leverage that Blockly is open-source and that custom blocks can be created. Each block consists of a definition, which defines the visual appearance, and a generator, which describes the block's translation to executable code. Blocks can be written in JavaScript, but they can also be defined using blocks.",
            "reference_string": "[256827582 | Wagner et al. | 2023 | Citations: 1]"
        },
        {
            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
            "venue": "arXiv.org",
            "year": 2019,
            "reference_count": 32,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1909.05719, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3419237",
                    "name": "Paul Zikas"
                },
                {
                    "authorId": "1388001839",
                    "name": "Nick Lydatakis"
                },
                {
                    "authorId": "19309698",
                    "name": "Steve Kateros"
                },
                {
                    "authorId": "2896538",
                    "name": "G. Papagiannakis"
                }
            ],
            "abstract": "Virtual reality (VR) has re-emerged as a low-cost, highly accessible consumer product, and training on simulators is rapidly becoming standard in many industrial sectors. Combined with the continued advancements in VR technology, the interest in platforms that generate immersive experiences has increased. However, the available systems are either focusing on gaming context, featuring limited capabilities (embedded editors in game engines) or they support only content creation of virtual environments without any rapid prototyping and modification. In this project we propose Scenior, an innovative coding-free, visual scripting platform to replicate gamified training scenarios through Rapid Prototyping via newly defined VR software design patterns. We implemented and compared three authoring tools: a) Prototyped scripting, b) Visual Scripting and c) VR Editor for rapid reconstruction of VR training scenarios. Our Visual Scripting module is capable generating training applications utilizing a node-based scripting system whereas the VR Editor gives the user/developer the ability to customize and populate new VR training scenarios directly from within the virtual environment. We also introduce Action Prototypes, a new software design pattern suitable to replicate behavioural tasks for VR experiences. In a addition, we present the scenegraph architecture as the main model to represent training scenarios on a modular, dynamic and highly adaptive acyclic graph based on a structured educational curriculum.",
            "corpus_id": 202566030,
            "sentences": [
                {
                    "corpus_id": "202566030",
                    "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
                    "text": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
                    "score": 0.36498851303176744,
                    "section_title": "Visual Programming as an authoring tool",
                    "char_start_offset": 7334,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 111
                        },
                        {
                            "start": 112,
                            "end": 476
                        },
                        {
                            "start": 477,
                            "end": 649
                        },
                        {
                            "start": 650,
                            "end": 932
                        },
                        {
                            "start": 933,
                            "end": 1110
                        },
                        {
                            "start": 1111,
                            "end": 1240
                        },
                        {
                            "start": 1241,
                            "end": 1489
                        },
                        {
                            "start": 1492,
                            "end": 1642
                        },
                        {
                            "start": 1643,
                            "end": 1773
                        },
                        {
                            "start": 1774,
                            "end": 1930
                        },
                        {
                            "start": 1931,
                            "end": 2110
                        },
                        {
                            "start": 2111,
                            "end": 2297
                        },
                        {
                            "start": 2298,
                            "end": 2387
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 699,
                            "end": 703,
                            "matchedPaperCorpusId": "2701916"
                        },
                        {
                            "start": 971,
                            "end": 975,
                            "matchedPaperCorpusId": "54120970"
                        },
                        {
                            "start": 1294,
                            "end": 1298,
                            "matchedPaperCorpusId": "9744698"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9638671875
                }
            ],
            "relevance_judgement": 0.9638671875,
            "relevance_judgment_input_expanded": "# Title: Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns\n# Venue: arXiv.org\n# Authors: Paul Zikas, Nick Lydatakis, Steve Kateros, G. Papagiannakis\n## Abstract\nVirtual reality (VR) has re-emerged as a low-cost, highly accessible consumer product, and training on simulators is rapidly becoming standard in many industrial sectors. Combined with the continued advancements in VR technology, the interest in platforms that generate immersive experiences has increased. However, the available systems are either focusing on gaming context, featuring limited capabilities (embedded editors in game engines) or they support only content creation of virtual environments without any rapid prototyping and modification. In this project we propose Scenior, an innovative coding-free, visual scripting platform to replicate gamified training scenarios through Rapid Prototyping via newly defined VR software design patterns. We implemented and compared three authoring tools: a) Prototyped scripting, b) Visual Scripting and c) VR Editor for rapid reconstruction of VR training scenarios. Our Visual Scripting module is capable generating training applications utilizing a node-based scripting system whereas the VR Editor gives the user/developer the ability to customize and populate new VR training scenarios directly from within the virtual environment. We also introduce Action Prototypes, a new software design pattern suitable to replicate behavioural tasks for VR experiences. In a addition, we present the scenegraph architecture as the main model to represent training scenarios on a modular, dynamic and highly adaptive acyclic graph based on a structured educational curriculum.\n## Visual Programming as an authoring tool\nVisual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
            "reference_string": "[202566030 | Zikas et al. | 2019 | Citations: 1]"
        },
        {
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "venue": "International Conference on Human Factors in Computing Systems",
            "year": 2023,
            "reference_count": 103,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2312.09672, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2261898099",
                    "name": "Zhongyi Zhou"
                },
                {
                    "authorId": "2214751677",
                    "name": "Jing Jin"
                },
                {
                    "authorId": "95798184",
                    "name": "Vrushank Phadnis"
                },
                {
                    "authorId": "29436685",
                    "name": "Xiuxiu Yuan"
                },
                {
                    "authorId": "2261902264",
                    "name": "Jun Jiang"
                },
                {
                    "authorId": "2274943688",
                    "name": "Xun Qian"
                },
                {
                    "authorId": "2261902483",
                    "name": "Kristen Wright"
                },
                {
                    "authorId": "2261902982",
                    "name": "Mark Sherwood"
                },
                {
                    "authorId": "2261904117",
                    "name": "Jason Mayes"
                },
                {
                    "authorId": "2261943879",
                    "name": "Jingtao Zhou"
                },
                {
                    "authorId": "2275032507",
                    "name": "Yiyi Huang"
                },
                {
                    "authorId": "2275017028",
                    "name": "Zheng Xu"
                },
                {
                    "authorId": "2274975067",
                    "name": "Yinda Zhang"
                },
                {
                    "authorId": "2274929798",
                    "name": "Johnny Lee"
                },
                {
                    "authorId": "2292510931",
                    "name": "Alex Olwal"
                },
                {
                    "authorId": "2274972576",
                    "name": "David Kim"
                },
                {
                    "authorId": "2214753154",
                    "name": "Ram Iyengar"
                },
                {
                    "authorId": "2262397661",
                    "name": "Na Li"
                },
                {
                    "authorId": "2350823722",
                    "name": "Ruofei Du"
                }
            ],
            "abstract": "Visual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace. In this paper, we introduce InstructPipe, an AI assistant for prototyping machine learning (ML) pipelines with text instructions. We contribute two large language model (LLM) modules and a code interpreter as part of our framework. The LLM modules generate pseudocode for a target pipeline, and the interpreter renders the pipeline in the node-graph editor for further human-AI collaboration. Both technical and user evaluation (N=16) shows that InstructPipe empowers users to streamline their ML pipeline workflow, reduce their learning curve, and leverage open-ended commands to spark innovative ideas.",
            "corpus_id": 276961580,
            "sentences": [
                {
                    "corpus_id": "276961580",
                    "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
                    "text": "A visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners. Advances in machine learning (ML) further stimulate growing interest in visual programming. Open-source ML hubs (e.g., TF-Hub [1], PyTorch-Hub [57], and Hugging Face [83]) contribute large numbers of encapsulated modules that accelerate AI project development and experimentation, and such libraries provide important resources for an ML-based visual programming platform. Recent advancements in large language models (LLMs) [3,8,77] and findings on Chain-of-Thought [81] have further stimulated community-wide interest in visual programming [4,19,84,86], suggesting further potential in the interactive exploration of AI chains. \n\nDespite the development of visual programming platforms in various domains, we observed that existing systems share one similar characteristic: users usually initiate a creative process in the workspace \"from scratch\". This implies that users need to 1) select nodes, 2) ideate the pipeline structure, and finally, 3) connect nodes within a completely empty workspace. As was also highlighted in existing literature in programming tools [92,95], such processes can easily overwhelm users, especially those who are unfamiliar with a particular visual programming platform. Providing pipeline templates may reduce on-boarding efforts [9,21], but the templates inherently lack flexibility and are not easily adaptable to users' specific needs. Similar issues also arise when users write programs using text-based editors (there exist many built-in functions in a particular programming language and multiple variables in a program), but advances in LLM assistants show that such challenges can be effectively reduced. For example, GitHub Copilot [23] enables users to generate code by simply describing users' requirements in natural language.",
                    "score": 0.3058360598962842,
                    "section_title": "Introduction",
                    "char_start_offset": 1548,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 123
                        },
                        {
                            "start": 124,
                            "end": 291
                        },
                        {
                            "start": 292,
                            "end": 497
                        },
                        {
                            "start": 498,
                            "end": 589
                        },
                        {
                            "start": 590,
                            "end": 870
                        },
                        {
                            "start": 871,
                            "end": 1127
                        },
                        {
                            "start": 1130,
                            "end": 1348
                        },
                        {
                            "start": 1349,
                            "end": 1498
                        },
                        {
                            "start": 1499,
                            "end": 1701
                        },
                        {
                            "start": 1702,
                            "end": 1870
                        },
                        {
                            "start": 1871,
                            "end": 2144
                        },
                        {
                            "start": 2145,
                            "end": 2270
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 641,
                            "end": 645,
                            "matchedPaperCorpusId": "202786778"
                        },
                        {
                            "start": 926,
                            "end": 928,
                            "matchedPaperCorpusId": "218971783"
                        },
                        {
                            "start": 928,
                            "end": 931,
                            "matchedPaperCorpusId": "13756489"
                        },
                        {
                            "start": 1040,
                            "end": 1043,
                            "matchedPaperCorpusId": "262044762"
                        },
                        {
                            "start": 1043,
                            "end": 1046,
                            "matchedPaperCorpusId": "264514979"
                        },
                        {
                            "start": 1046,
                            "end": 1049,
                            "matchedPaperCorpusId": "247447133"
                        },
                        {
                            "start": 1049,
                            "end": 1052,
                            "matchedPaperCorpusId": "238353829"
                        },
                        {
                            "start": 1567,
                            "end": 1571,
                            "matchedPaperCorpusId": "271903516"
                        },
                        {
                            "start": 1762,
                            "end": 1765,
                            "matchedPaperCorpusId": "267523023"
                        },
                        {
                            "start": 1765,
                            "end": 1768,
                            "matchedPaperCorpusId": "2452365"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9638671875
                },
                {
                    "corpus_id": "276961580",
                    "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
                    "text": "A computer program defines the operation of computer systems. However, \"the program given to a computer for solving a problem need not be in a written format\" [73]. This future-looking statement, dating back to the 1960s, inspired several generations of researchers to design and build visual programming systems. Today, visual programming systems (e.g., LabView [39], Unity Graph Editor [76], PromptChainer [84], ComfyUI [13] and Visual Blocks [18]) typically feature a node graph editor, providing users with a visual workspace to \"write\" their program using \"building blocks\" [28,68,89]. Recent work further explored the application of visual programming in education [9,35,40], XR creativity support [88,91,93], and robotics [14,30,31]. For example, Zhang et al. [93] connected the visual programming tool to the concept of teaching by demonstration [44,49,99], allowing users to rapidly customize AR effects in video creation. FlowMatic [91] extended traditional visual programming interfaces into 3D virtual environments, providing users with immersive authoring experiences. \n\nAdvancements in AI have introduced many repositories of advanced ML models [33,66], and an increasing number of researchers are exploring AI chains [41,86]. This progress has motivated HCI researchers to design and build a range of visual programming interfaces to support the AI development process [13,43,84]. For example, ChainForge is a web-based platform for developers to explore various LLM-related configuration and designs in a wide range of applications [4]. Visual Blocks enables creation and interaction of advanced ML pipelines that can leverage state-of-the-art computer vision and computer graphics models in the browser [18]. \n\nThis work contributes the technical system, implementation and evaluation of a novel AI assistant that enables the use of text-based instructions in visual programming of ML pipelines. Compared to typical workflows in which people manually build their pipelines, InstructPipe has the potential to accelerate ML pipeline prototyping in visual programming.",
                    "score": 0.3544289123930477,
                    "section_title": "Related Work 2.1 Visual Programming",
                    "char_start_offset": 6886,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 61
                        },
                        {
                            "start": 62,
                            "end": 164
                        },
                        {
                            "start": 165,
                            "end": 313
                        },
                        {
                            "start": 314,
                            "end": 590
                        },
                        {
                            "start": 591,
                            "end": 740
                        },
                        {
                            "start": 741,
                            "end": 931
                        },
                        {
                            "start": 932,
                            "end": 1081
                        },
                        {
                            "start": 1084,
                            "end": 1240
                        },
                        {
                            "start": 1241,
                            "end": 1395
                        },
                        {
                            "start": 1396,
                            "end": 1552
                        },
                        {
                            "start": 1553,
                            "end": 1725
                        },
                        {
                            "start": 1728,
                            "end": 1912
                        },
                        {
                            "start": 1913,
                            "end": 2082
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 408,
                            "end": 412,
                            "matchedPaperCorpusId": "247447133"
                        },
                        {
                            "start": 445,
                            "end": 449,
                            "matchedPaperCorpusId": "258216977"
                        },
                        {
                            "start": 579,
                            "end": 583,
                            "matchedPaperCorpusId": "1529669"
                        },
                        {
                            "start": 583,
                            "end": 586,
                            "matchedPaperCorpusId": "259376453"
                        },
                        {
                            "start": 586,
                            "end": 589,
                            "matchedPaperCorpusId": "269753286"
                        },
                        {
                            "start": 671,
                            "end": 674,
                            "matchedPaperCorpusId": "267523023"
                        },
                        {
                            "start": 674,
                            "end": 677,
                            "matchedPaperCorpusId": "258217657"
                        },
                        {
                            "start": 677,
                            "end": 680,
                            "matchedPaperCorpusId": "220885043"
                        },
                        {
                            "start": 704,
                            "end": 708,
                            "matchedPaperCorpusId": "269717820"
                        },
                        {
                            "start": 708,
                            "end": 711,
                            "matchedPaperCorpusId": "222799772"
                        },
                        {
                            "start": 711,
                            "end": 714,
                            "matchedPaperCorpusId": "264350354"
                        },
                        {
                            "start": 729,
                            "end": 733,
                            "matchedPaperCorpusId": "16198810"
                        },
                        {
                            "start": 733,
                            "end": 736,
                            "matchedPaperCorpusId": "207237260"
                        },
                        {
                            "start": 736,
                            "end": 739,
                            "matchedPaperCorpusId": "23415794"
                        },
                        {
                            "start": 767,
                            "end": 771,
                            "matchedPaperCorpusId": "264350354"
                        },
                        {
                            "start": 854,
                            "end": 858,
                            "matchedPaperCorpusId": "1504689"
                        },
                        {
                            "start": 858,
                            "end": 861,
                            "matchedPaperCorpusId": "12628167"
                        },
                        {
                            "start": 861,
                            "end": 864,
                            "matchedPaperCorpusId": "251252905"
                        },
                        {
                            "start": 942,
                            "end": 946,
                            "matchedPaperCorpusId": "222799772"
                        },
                        {
                            "start": 1163,
                            "end": 1166,
                            "matchedPaperCorpusId": "257833781"
                        },
                        {
                            "start": 1236,
                            "end": 1239,
                            "matchedPaperCorpusId": "238353829"
                        },
                        {
                            "start": 1391,
                            "end": 1394,
                            "matchedPaperCorpusId": "247447133"
                        },
                        {
                            "start": 1548,
                            "end": 1551,
                            "matchedPaperCorpusId": "262044762"
                        },
                        {
                            "start": 1720,
                            "end": 1724,
                            "matchedPaperCorpusId": "258216977"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96044921875
                }
            ],
            "relevance_judgement": 0.9638671875,
            "relevance_judgment_input_expanded": "# Title: InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs\n# Venue: International Conference on Human Factors in Computing Systems\n# Authors: Zhongyi Zhou, Jing Jin, Vrushank Phadnis, Xiuxiu Yuan, Jun Jiang, Xun Qian, Kristen Wright, Mark Sherwood, Jason Mayes, Jingtao Zhou, Yiyi Huang, Zheng Xu, Yinda Zhang, Johnny Lee, Alex Olwal, David Kim, Ram Iyengar, Na Li, Ruofei Du\n## Abstract\nVisual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace. In this paper, we introduce InstructPipe, an AI assistant for prototyping machine learning (ML) pipelines with text instructions. We contribute two large language model (LLM) modules and a code interpreter as part of our framework. The LLM modules generate pseudocode for a target pipeline, and the interpreter renders the pipeline in the node-graph editor for further human-AI collaboration. Both technical and user evaluation (N=16) shows that InstructPipe empowers users to streamline their ML pipeline workflow, reduce their learning curve, and leverage open-ended commands to spark innovative ideas.\n## Introduction\nA visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners. Advances in machine learning (ML) further stimulate growing interest in visual programming. Open-source ML hubs (e.g., TF-Hub [1], PyTorch-Hub [57], and Hugging Face [83]) contribute large numbers of encapsulated modules that accelerate AI project development and experimentation, and such libraries provide important resources for an ML-based visual programming platform. Recent advancements in large language models (LLMs) [3,8,77] and findings on Chain-of-Thought [81] have further stimulated community-wide interest in visual programming [4,19,84,86], suggesting further potential in the interactive exploration of AI chains. \n\nDespite the development of visual programming platforms in various domains, we observed that existing systems share one similar characteristic: users usually initiate a creative process in the workspace \"from scratch\". This implies that users need to 1) select nodes, 2) ideate the pipeline structure, and finally, 3) connect nodes within a completely empty workspace. As was also highlighted in existing literature in programming tools [92,95], such processes can easily overwhelm users, especially those who are unfamiliar with a particular visual programming platform. Providing pipeline templates may reduce on-boarding efforts [9,21], but the templates inherently lack flexibility and are not easily adaptable to users' specific needs. Similar issues also arise when users write programs using text-based editors (there exist many built-in functions in a particular programming language and multiple variables in a program), but advances in LLM assistants show that such challenges can be effectively reduced. For example, GitHub Copilot [23] enables users to generate code by simply describing users' requirements in natural language.\n\n## Related Work 2.1 Visual Programming\nA computer program defines the operation of computer systems. However, \"the program given to a computer for solving a problem need not be in a written format\" [73]. This future-looking statement, dating back to the 1960s, inspired several generations of researchers to design and build visual programming systems. Today, visual programming systems (e.g., LabView [39], Unity Graph Editor [76], PromptChainer [84], ComfyUI [13] and Visual Blocks [18]) typically feature a node graph editor, providing users with a visual workspace to \"write\" their program using \"building blocks\" [28,68,89]. Recent work further explored the application of visual programming in education [9,35,40], XR creativity support [88,91,93], and robotics [14,30,31]. For example, Zhang et al. [93] connected the visual programming tool to the concept of teaching by demonstration [44,49,99], allowing users to rapidly customize AR effects in video creation. FlowMatic [91] extended traditional visual programming interfaces into 3D virtual environments, providing users with immersive authoring experiences. \n\nAdvancements in AI have introduced many repositories of advanced ML models [33,66], and an increasing number of researchers are exploring AI chains [41,86]. This progress has motivated HCI researchers to design and build a range of visual programming interfaces to support the AI development process [13,43,84]. For example, ChainForge is a web-based platform for developers to explore various LLM-related configuration and designs in a wide range of applications [4]. Visual Blocks enables creation and interaction of advanced ML pipelines that can leverage state-of-the-art computer vision and computer graphics models in the browser [18]. \n\nThis work contributes the technical system, implementation and evaluation of a novel AI assistant that enables the use of text-based instructions in visual programming of ML pipelines. Compared to typical workflows in which people manually build their pipelines, InstructPipe has the potential to accelerate ML pipeline prototyping in visual programming.",
            "reference_string": "[276961580 | Zhou et al. | 2023 | Citations: 1]"
        },
        {
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "venue": "arXiv.org",
            "year": 2018,
            "reference_count": 105,
            "citation_count": 14,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1811.04159, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "145745979",
                    "name": "Jo\u00e3o Pedro Dias"
                },
                {
                    "authorId": "144027277",
                    "name": "H. Ferreira"
                }
            ],
            "abstract": "Software has a longstanding association with a state of crisis considering its success rate. The explosion of Internet-connected devices, Internet-of-Things, adds to the complexity of software systems. The particular characteristics of these systems, such as being large-scale and its heterogeneity, pose increasingly new challenges. In this paper, we first briefly introduce the IoT paradigm and the current state of art of software development. Then, we delve into the particularities of developing software for IoT systems and systems of systems, given an overview of what are the current methodologies and tools for design, develop and test such systems. The findings are discussed, revealing open issues and research directions, and reveal that the nowadays IoT software development practices are still lagging behind of what are the current best practices.",
            "corpus_id": 53282492,
            "sentences": [
                {
                    "corpus_id": "53282492",
                    "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                    "text": "Diagrams and other graphical logic and/or model representations have been playing a role in software development since the appearance of the modern digital computers in the 1940s. In the beginning, the diagrams were paper-based aids, used to design and understand the software structure, but then, interest appeared in the direct use of diagrams as a solution to improve software development tools. This led to the appearing of visual software project management tools, visual editors for graphical interface creation, visual tools for software modeling and engineering, and visual programming languages [Cox 2007]. \n\nA Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as: \n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device. \n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]. \n\nVPLs have been explored and used in several domains, including, but not limited to, educational activities (e.g. learning to program), multimedia, video game development, system design and development, simulations, automation, data warehousing and business analytics [ Ray 2017]. \n\nAlthough several domains of applications already take advantage of the use of VPLs, the emerging field of Internetof-Things (IoT) is still lingering far behind other sectors. \n\nVisual Programming Languages are commonly used with the intent of abstracting low-level concepts and details into a more high-level logic, through the use of visual metaphors [Barricelli and Valtolina 2015;Thomas and Barry 2003]. The application of domain-specific visual programming languages to solve the need of abstraction from the low-level and heterogeneous devices that usually make a part in the IoT connected world can already be observed. We can consider, as an example, how graphical-based programming languages are already widely used for programming low-level devices such as Programmed Logic Controllers (PLCs) in high-production manufacturing systems [Younis and Frey 2003]. \n\nThe goal of this section is to review the landscape of visual programming environments (viz.",
                    "score": 0.3509754580961078,
                    "section_title": "Visual Programming for IoT",
                    "char_start_offset": 44329,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 179
                        },
                        {
                            "start": 180,
                            "end": 398
                        },
                        {
                            "start": 399,
                            "end": 615
                        },
                        {
                            "start": 618,
                            "end": 748
                        },
                        {
                            "start": 749,
                            "end": 768
                        },
                        {
                            "start": 771,
                            "end": 1013
                        },
                        {
                            "start": 1016,
                            "end": 1205
                        },
                        {
                            "start": 1206,
                            "end": 1221
                        },
                        {
                            "start": 1224,
                            "end": 1336
                        },
                        {
                            "start": 1337,
                            "end": 1503
                        },
                        {
                            "start": 1506,
                            "end": 1680
                        },
                        {
                            "start": 1683,
                            "end": 1912
                        },
                        {
                            "start": 1913,
                            "end": 2131
                        },
                        {
                            "start": 2132,
                            "end": 2372
                        },
                        {
                            "start": 2375,
                            "end": 2467
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 752,
                            "end": 763,
                            "matchedPaperCorpusId": "48762803"
                        },
                        {
                            "start": 1209,
                            "end": 1220,
                            "matchedPaperCorpusId": "48762803"
                        },
                        {
                            "start": 1493,
                            "end": 1502,
                            "matchedPaperCorpusId": "30037917"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96337890625
                }
            ],
            "relevance_judgement": 0.96337890625,
            "relevance_judgment_input_expanded": "# Title: State of the Software Development Life-Cycle for the Internet-of-Things\n# Venue: arXiv.org\n# Authors: Jo\u00e3o Pedro Dias, H. Ferreira\n## Abstract\nSoftware has a longstanding association with a state of crisis considering its success rate. The explosion of Internet-connected devices, Internet-of-Things, adds to the complexity of software systems. The particular characteristics of these systems, such as being large-scale and its heterogeneity, pose increasingly new challenges. In this paper, we first briefly introduce the IoT paradigm and the current state of art of software development. Then, we delve into the particularities of developing software for IoT systems and systems of systems, given an overview of what are the current methodologies and tools for design, develop and test such systems. The findings are discussed, revealing open issues and research directions, and reveal that the nowadays IoT software development practices are still lagging behind of what are the current best practices.\n## Visual Programming for IoT\nDiagrams and other graphical logic and/or model representations have been playing a role in software development since the appearance of the modern digital computers in the 1940s. In the beginning, the diagrams were paper-based aids, used to design and understand the software structure, but then, interest appeared in the direct use of diagrams as a solution to improve software development tools. This led to the appearing of visual software project management tools, visual editors for graphical interface creation, visual tools for software modeling and engineering, and visual programming languages [Cox 2007]. \n\nA Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as: \n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device. \n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]. \n\nVPLs have been explored and used in several domains, including, but not limited to, educational activities (e.g. learning to program), multimedia, video game development, system design and development, simulations, automation, data warehousing and business analytics [ Ray 2017]. \n\nAlthough several domains of applications already take advantage of the use of VPLs, the emerging field of Internetof-Things (IoT) is still lingering far behind other sectors. \n\nVisual Programming Languages are commonly used with the intent of abstracting low-level concepts and details into a more high-level logic, through the use of visual metaphors [Barricelli and Valtolina 2015;Thomas and Barry 2003]. The application of domain-specific visual programming languages to solve the need of abstraction from the low-level and heterogeneous devices that usually make a part in the IoT connected world can already be observed. We can consider, as an example, how graphical-based programming languages are already widely used for programming low-level devices such as Programmed Logic Controllers (PLCs) in high-production manufacturing systems [Younis and Frey 2003]. \n\nThe goal of this section is to review the landscape of visual programming environments (viz.",
            "reference_string": "[53282492 | Dias et al. | 2018 | Citations: 14]"
        },
        {
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "venue": "Int. J. Serious Games",
            "year": 2023,
            "reference_count": 42,
            "citation_count": 6,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://journal.seriousgamessociety.org/index.php/IJSG/article/download/577/498",
                "status": "GOLD",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.17083/ijsg.v10i2.577?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.17083/ijsg.v10i2.577, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "39722092",
                    "name": "Christian DeLozier"
                },
                {
                    "authorId": "38203562",
                    "name": "James Shey"
                }
            ],
            "abstract": "Enabling programmers to write correct and efficient parallel code remains an important challenge, and the prevalence of on-chip accelerators exacerbates this challenge. Novice programmers, especially those in disciplines outside of Computer Science and Computer Engineering, need to be able to write code that exploits parallelism and heterogeneity, but the frameworks for writing parallel and heterogeneous programs expect expert knowledge and experience. More effort must be put into understanding how novice programmers solve parallel problems. Unfortunately, novice programmers are difficult to study because they are, by definition, novices. We have designed a visual programming language and game-based framework for studying how novice programmers solve parallel problems. This tool was used to conduct an initial study on 95 undergraduate students with little to no prior programming experience. 71% of all volunteer participants completed the study in 48 minutes on average. This study demonstrated that novice programmers could solve parallel problems, and this framework can be used to conduct more thorough studies of how novice programmers approach parallel code.",
            "corpus_id": 259335765,
            "sentences": [
                {
                    "corpus_id": "259335765",
                    "title": "Using Visual Programming Games to Study Novice Programmers",
                    "text": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
                    "score": 0.311939090775342,
                    "section_title": "Visual Programming",
                    "char_start_offset": 4631,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 76
                        },
                        {
                            "start": 77,
                            "end": 187
                        },
                        {
                            "start": 188,
                            "end": 278
                        },
                        {
                            "start": 279,
                            "end": 425
                        },
                        {
                            "start": 426,
                            "end": 548
                        },
                        {
                            "start": 549,
                            "end": 696
                        },
                        {
                            "start": 697,
                            "end": 788
                        },
                        {
                            "start": 789,
                            "end": 1016
                        },
                        {
                            "start": 1019,
                            "end": 1094
                        },
                        {
                            "start": 1095,
                            "end": 1231
                        },
                        {
                            "start": 1232,
                            "end": 1323
                        },
                        {
                            "start": 1324,
                            "end": 1441
                        },
                        {
                            "start": 1442,
                            "end": 1583
                        },
                        {
                            "start": 1584,
                            "end": 1737
                        },
                        {
                            "start": 1738,
                            "end": 1796
                        },
                        {
                            "start": 1797,
                            "end": 1816
                        },
                        {
                            "start": 1817,
                            "end": 1926
                        },
                        {
                            "start": 1927,
                            "end": 2022
                        },
                        {
                            "start": 2023,
                            "end": 2189
                        },
                        {
                            "start": 2190,
                            "end": 2356
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 145,
                            "end": 148,
                            "matchedPaperCorpusId": "253196672"
                        },
                        {
                            "start": 148,
                            "end": 150,
                            "matchedPaperCorpusId": "235383033"
                        },
                        {
                            "start": 167,
                            "end": 170,
                            "matchedPaperCorpusId": "10976181"
                        },
                        {
                            "start": 183,
                            "end": 186,
                            "matchedPaperCorpusId": "35735491"
                        },
                        {
                            "start": 783,
                            "end": 787,
                            "matchedPaperCorpusId": "51750550"
                        },
                        {
                            "start": 1089,
                            "end": 1093,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1226,
                            "end": 1230,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1436,
                            "end": 1440,
                            "matchedPaperCorpusId": "198986538"
                        },
                        {
                            "start": 1578,
                            "end": 1582,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1820,
                            "end": 1823,
                            "matchedPaperCorpusId": "253196672"
                        },
                        {
                            "start": 2045,
                            "end": 2049,
                            "matchedPaperCorpusId": "239681487"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96240234375
                }
            ],
            "relevance_judgement": 0.96240234375,
            "relevance_judgment_input_expanded": "# Title: Using Visual Programming Games to Study Novice Programmers\n# Venue: Int. J. Serious Games\n# Authors: Christian DeLozier, James Shey\n## Abstract\nEnabling programmers to write correct and efficient parallel code remains an important challenge, and the prevalence of on-chip accelerators exacerbates this challenge. Novice programmers, especially those in disciplines outside of Computer Science and Computer Engineering, need to be able to write code that exploits parallelism and heterogeneity, but the frameworks for writing parallel and heterogeneous programs expect expert knowledge and experience. More effort must be put into understanding how novice programmers solve parallel problems. Unfortunately, novice programmers are difficult to study because they are, by definition, novices. We have designed a visual programming language and game-based framework for studying how novice programmers solve parallel problems. This tool was used to conduct an initial study on 95 undergraduate students with little to no prior programming experience. 71% of all volunteer participants completed the study in 48 minutes on average. This study demonstrated that novice programmers could solve parallel problems, and this framework can be used to conduct more thorough studies of how novice programmers approach parallel code.\n## Visual Programming\nVisual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
            "reference_string": "[259335765 | DeLozier et al. | 2023 | Citations: 6]"
        },
        {
            "title": "Computational Thinking Training and Deep Learning Evaluation Model Construction Based on Scratch Modular Programming Course",
            "venue": "Computational Intelligence and Neuroscience",
            "year": 2023,
            "reference_count": 32,
            "citation_count": 5,
            "influential_citation_count": 1,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://downloads.hindawi.com/journals/cin/2023/3760957.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://pmc.ncbi.nlm.nih.gov/articles/PMC9977527, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2157262938",
                    "name": "Xiaoli Chen"
                },
                {
                    "authorId": "2209867633",
                    "name": "XiaoMing Wang"
                }
            ],
            "abstract": "To improve the algorithmic dimension, critical thinking, and problem-solving ability of computational thinking (CT) in students' programming courses, first, a programming teaching model is constructed based on the scratch modular programming course. Secondly, the design process of the teaching model and the problem-solving model of visual programming are studied. Finally, a deep learning (DL) evaluation model is constructed, and the effectiveness of the designed teaching model is analyzed and evaluated. The T-test result of paired samples of CT is t\u2009=\u2009\u22122.08, P\u2009<\u20090.05. There are significant differences in the results of the two tests, and the designed teaching model can cause changes in students' CT abilities. The results reveal that the effectiveness of the teaching model based on scratch modular programming has been verified on the basis of experiments. The post-test values of the dimensions of algorithmic thinking, critical thinking, collaborative thinking, and problem-solving thinking are all higher than the pretest values, and there are individual differences. The P values are all less than 0.05, which testifies that the CT training of the designed teaching model has the algorithm dimension, critical thinking, collaborative thinking, and problem-solving ability of students' CT. The post-test values of cognitive load are all lower than the pretest values, indicating that the model has a certain positive effect on reducing cognitive load, and there is a significant difference between the pretest and post-test. In the dimension of creative thinking, the P value is 0.218, and there is no obvious difference in the dimensions of creativity and self-efficacy. It can be found from the DL evaluation that the average value of the DL knowledge and skills dimensions is greater than 3.5, and college students can reach a certain standard level in terms of knowledge and skills. The mean value of the process and method dimensions is about 3.1, and the mean value of the emotional attitudes and values is 2.77. The process and method, as well as emotional attitude and values, need to be strengthened. The DL level of college students is relatively low, and it is necessary to improve their DL level from the perspective of knowledge and skills, processes and methods, emotional attitudes and values. This research makes up for the shortcomings of traditional programming and design software to a certain extent. It has a certain reference value for researchers and teachers to carry out programming teaching practice.",
            "corpus_id": 257145390,
            "sentences": [
                {
                    "corpus_id": "257145390",
                    "title": "Computational Thinking Training and Deep Learning Evaluation Model Construction Based on Scratch Modular Programming Course",
                    "text": "Visual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation [23]. Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan [24]. Figure 4 reveals the visual programming problem-solving model. \n\nAs shown in Figure 4, a plan is formed through CT and methods, and a visual programming platform program is built according to the plan. After the platform is debugged, the solution to the problem is obtained and mapped to the real situation. Trough the real situation, questions can be raised and fed back to the CTmethods. Te real situation can further extract the elements in the real situation, such as people, things, things and rules. Finally, the problem is solved.",
                    "score": 0.39857759446045876,
                    "section_title": "Visual Programming Problem-Solving Model.",
                    "char_start_offset": 9036,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 167
                        },
                        {
                            "start": 168,
                            "end": 338
                        },
                        {
                            "start": 339,
                            "end": 493
                        },
                        {
                            "start": 494,
                            "end": 556
                        },
                        {
                            "start": 559,
                            "end": 695
                        },
                        {
                            "start": 696,
                            "end": 801
                        },
                        {
                            "start": 802,
                            "end": 883
                        },
                        {
                            "start": 884,
                            "end": 999
                        },
                        {
                            "start": 1000,
                            "end": 1031
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 333,
                            "end": 337,
                            "matchedPaperCorpusId": "235749050"
                        },
                        {
                            "start": 488,
                            "end": 492,
                            "matchedPaperCorpusId": "237732833"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.96044921875
                }
            ],
            "relevance_judgement": 0.96044921875,
            "relevance_judgment_input_expanded": "# Title: Computational Thinking Training and Deep Learning Evaluation Model Construction Based on Scratch Modular Programming Course\n# Venue: Computational Intelligence and Neuroscience\n# Authors: Xiaoli Chen, XiaoMing Wang\n## Abstract\nTo improve the algorithmic dimension, critical thinking, and problem-solving ability of computational thinking (CT) in students' programming courses, first, a programming teaching model is constructed based on the scratch modular programming course. Secondly, the design process of the teaching model and the problem-solving model of visual programming are studied. Finally, a deep learning (DL) evaluation model is constructed, and the effectiveness of the designed teaching model is analyzed and evaluated. The T-test result of paired samples of CT is t\u2009=\u2009\u22122.08, P\u2009<\u20090.05. There are significant differences in the results of the two tests, and the designed teaching model can cause changes in students' CT abilities. The results reveal that the effectiveness of the teaching model based on scratch modular programming has been verified on the basis of experiments. The post-test values of the dimensions of algorithmic thinking, critical thinking, collaborative thinking, and problem-solving thinking are all higher than the pretest values, and there are individual differences. The P values are all less than 0.05, which testifies that the CT training of the designed teaching model has the algorithm dimension, critical thinking, collaborative thinking, and problem-solving ability of students' CT. The post-test values of cognitive load are all lower than the pretest values, indicating that the model has a certain positive effect on reducing cognitive load, and there is a significant difference between the pretest and post-test. In the dimension of creative thinking, the P value is 0.218, and there is no obvious difference in the dimensions of creativity and self-efficacy. It can be found from the DL evaluation that the average value of the DL knowledge and skills dimensions is greater than 3.5, and college students can reach a certain standard level in terms of knowledge and skills. The mean value of the process and method dimensions is about 3.1, and the mean value of the emotional attitudes and values is 2.77. The process and method, as well as emotional attitude and values, need to be strengthened. The DL level of college students is relatively low, and it is necessary to improve their DL level from the perspective of knowledge and skills, processes and methods, emotional attitudes and values. This research makes up for the shortcomings of traditional programming and design software to a certain extent. It has a certain reference value for researchers and teachers to carry out programming teaching practice.\n## Visual Programming Problem-Solving Model.\nVisual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation [23]. Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan [24]. Figure 4 reveals the visual programming problem-solving model. \n\nAs shown in Figure 4, a plan is formed through CT and methods, and a visual programming platform program is built according to the plan. After the platform is debugged, the solution to the problem is obtained and mapped to the real situation. Trough the real situation, questions can be raised and fed back to the CTmethods. Te real situation can further extract the elements in the real situation, such as people, things, things and rules. Finally, the problem is solved.",
            "reference_string": "[257145390 | Chen et al. | 2023 | Citations: 5]"
        },
        {
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "venue": "Journal of Computers in Education",
            "year": 2022,
            "reference_count": 117,
            "citation_count": 5,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://link.springer.com/content/pdf/10.1007/s40692-022-00236-w.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1007/s40692-022-00236-w?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1007/s40692-022-00236-w, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2103048484",
                    "name": "Nardie Fanchamps"
                },
                {
                    "authorId": "101239469",
                    "name": "L.A.M.P. Slangen"
                },
                {
                    "authorId": "143989442",
                    "name": "M. Specht"
                },
                {
                    "authorId": "102715196",
                    "name": "P. Hennissen"
                }
            ],
            "abstract": "The application of sense-reason-act (SRA) programming in contemporary education can ensure the development of computational thinking (CT) at a more advanced level. SRA-programming has been identified as an instrumental way of thinking for learning to program robots and encourages the development of the more complex concepts of programming. Visual programming environments are diverse in appearance and prove to be an excellent way to teach pupils the basic ideas of programming. It is important to investigate whether the type of output has a characteristic influence on the level of development of CT in visual programming environments. In this research, we therefore explore whether characteristic differences in the development of CT can be measured when SRA-programming is applied in a visual programming environment with an on-screen output or a tangible output. It was expected that the observed effect of pupils' programming actions through the application of SRA would show that the type of output influences the understanding of complex programming concepts at a higher level. Our results indicate that SRA-programming with visual, on-screen output yields a significant increase in the development of CT, as opposed to SRA-programming with a tangible output. The development of complex programming concepts can also be demonstrated.",
            "corpus_id": 250414169,
            "sentences": [
                {
                    "corpus_id": "250414169",
                    "title": "Effect of SRA-programming on computational thinking through different output modalities",
                    "text": "In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011;Tsai, 2019). Through simulation, visual programming environments can provide more complex and richer functionality than the physical boundaries of artefacts in the material world allow. Direct feedback obtained from visual output may be experienced as more powerful than feedback obtained via tangible output (Caci et al., 2013a(Caci et al., , 2013b;;Sefidgar et al., 2017). Visual programming environments also often include integrated, directional incentives which provide the user with instant information on whether the programming solution is the optimal one, or whether it could be constructed more efficiently. These incentives provide guidance, and the user may decide to use them when support is needed (Karalekas et al., 2020). Seen from these perspectives, visual programming environments offer excellent opportunities for solving challenging programming problems and acquiring CT (Papadakis et al., 2016;Rose et al., 2017). \n\nIn programming with a visual output, the application and execution of each programming operation is displayed purely on a screen (Sapounidis et al., 2015). The information obtained from the programmed operation can be characterised as two-dimensional percipient (Mladenovi\u0107 et al., 2020;Price et al., 2003). The elaboration of programming actions appeals to the more abstract imagine ability and reasoning capacity of the user (Price & Barnes, 2015), but it is not possible to fall back on the tangible and physically perceptible (Horn & Bers, 2019; 2023) 10(2):433-462 O' Malley & Fraser, 2004;Sefidgar et al., 2017;Skulmowski et al., 2016). Nothing can be grasped in a hands-on way, and the execution of the programming action cannot be seen from more than one point of view (Sapounidis et al., 2015).",
                    "score": 0.4064586197702927,
                    "section_title": "Theoretical framework",
                    "char_start_offset": 15527,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 234
                        },
                        {
                            "start": 235,
                            "end": 481
                        },
                        {
                            "start": 482,
                            "end": 654
                        },
                        {
                            "start": 655,
                            "end": 843
                        },
                        {
                            "start": 844,
                            "end": 1086
                        },
                        {
                            "start": 1087,
                            "end": 1206
                        },
                        {
                            "start": 1207,
                            "end": 1404
                        },
                        {
                            "start": 1407,
                            "end": 1562
                        },
                        {
                            "start": 1563,
                            "end": 1714
                        },
                        {
                            "start": 1715,
                            "end": 2049
                        },
                        {
                            "start": 2050,
                            "end": 2210
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 214,
                            "end": 233,
                            "matchedPaperCorpusId": "27633066"
                        },
                        {
                            "start": 448,
                            "end": 469,
                            "matchedPaperCorpusId": "8626769"
                        },
                        {
                            "start": 469,
                            "end": 480,
                            "matchedPaperCorpusId": "92996231"
                        },
                        {
                            "start": 778,
                            "end": 797,
                            "matchedPaperCorpusId": "62642207"
                        },
                        {
                            "start": 820,
                            "end": 842,
                            "matchedPaperCorpusId": "18844251"
                        },
                        {
                            "start": 1181,
                            "end": 1205,
                            "matchedPaperCorpusId": "217547495"
                        },
                        {
                            "start": 1361,
                            "end": 1385,
                            "matchedPaperCorpusId": "29749744"
                        },
                        {
                            "start": 1385,
                            "end": 1403,
                            "matchedPaperCorpusId": "54650229"
                        },
                        {
                            "start": 1669,
                            "end": 1694,
                            "matchedPaperCorpusId": "225393741"
                        },
                        {
                            "start": 1694,
                            "end": 1713,
                            "matchedPaperCorpusId": "3523310"
                        },
                        {
                            "start": 1834,
                            "end": 1856,
                            "matchedPaperCorpusId": "16554511"
                        },
                        {
                            "start": 2002,
                            "end": 2024,
                            "matchedPaperCorpusId": "18844251"
                        },
                        {
                            "start": 2024,
                            "end": 2048,
                            "matchedPaperCorpusId": "10493691"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9580078125
                }
            ],
            "relevance_judgement": 0.9580078125,
            "relevance_judgment_input_expanded": "# Title: Effect of SRA-programming on computational thinking through different output modalities\n# Venue: Journal of Computers in Education\n# Authors: Nardie Fanchamps, L.A.M.P. Slangen, M. Specht, P. Hennissen\n## Abstract\nThe application of sense-reason-act (SRA) programming in contemporary education can ensure the development of computational thinking (CT) at a more advanced level. SRA-programming has been identified as an instrumental way of thinking for learning to program robots and encourages the development of the more complex concepts of programming. Visual programming environments are diverse in appearance and prove to be an excellent way to teach pupils the basic ideas of programming. It is important to investigate whether the type of output has a characteristic influence on the level of development of CT in visual programming environments. In this research, we therefore explore whether characteristic differences in the development of CT can be measured when SRA-programming is applied in a visual programming environment with an on-screen output or a tangible output. It was expected that the observed effect of pupils' programming actions through the application of SRA would show that the type of output influences the understanding of complex programming concepts at a higher level. Our results indicate that SRA-programming with visual, on-screen output yields a significant increase in the development of CT, as opposed to SRA-programming with a tangible output. The development of complex programming concepts can also be demonstrated.\n## Theoretical framework\nIn a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011;Tsai, 2019). Through simulation, visual programming environments can provide more complex and richer functionality than the physical boundaries of artefacts in the material world allow. Direct feedback obtained from visual output may be experienced as more powerful than feedback obtained via tangible output (Caci et al., 2013a(Caci et al., , 2013b;;Sefidgar et al., 2017). Visual programming environments also often include integrated, directional incentives which provide the user with instant information on whether the programming solution is the optimal one, or whether it could be constructed more efficiently. These incentives provide guidance, and the user may decide to use them when support is needed (Karalekas et al., 2020). Seen from these perspectives, visual programming environments offer excellent opportunities for solving challenging programming problems and acquiring CT (Papadakis et al., 2016;Rose et al., 2017). \n\nIn programming with a visual output, the application and execution of each programming operation is displayed purely on a screen (Sapounidis et al., 2015). The information obtained from the programmed operation can be characterised as two-dimensional percipient (Mladenovi\u0107 et al., 2020;Price et al., 2003). The elaboration of programming actions appeals to the more abstract imagine ability and reasoning capacity of the user (Price & Barnes, 2015), but it is not possible to fall back on the tangible and physically perceptible (Horn & Bers, 2019; 2023) 10(2):433-462 O' Malley & Fraser, 2004;Sefidgar et al., 2017;Skulmowski et al., 2016). Nothing can be grasped in a hands-on way, and the execution of the programming action cannot be seen from more than one point of view (Sapounidis et al., 2015).",
            "reference_string": "[250414169 | Fanchamps et al. | 2022 | Citations: 5]"
        },
        {
            "title": "Design Space of Programming Tools on Mobile Touchscreen Devices",
            "venue": "arXiv.org",
            "year": 2017,
            "reference_count": 61,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1708.05805, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2207677",
                    "name": "P. Sukumar"
                },
                {
                    "authorId": "1809549",
                    "name": "Ronald A. Metoyer"
                }
            ],
            "abstract": "While mobile touchscreen devices are ubiquitous and present opportunities for novel applications, they have seen little adoption as tools for computer programming. In this literature survey, we bring together the diverse research work on programming-related tasks supported by mobile touchscreen devices to explore the design space for applying them to programming situations. We used the Grounded theory approach to identify themes and classify previous work. We present these themes and how each paper contributes to the theme, and we outline the remaining challenges in and opportunities for using mobile touchscreen devices in programming applications.",
            "corpus_id": 19038821,
            "sentences": [
                {
                    "corpus_id": "19038821",
                    "title": "Design Space of Programming Tools on Mobile Touchscreen Devices",
                    "text": "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax [40,53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains [40,41]. \n\nVP languages are a somewhat natural fit for use on touchscreen devices because they inherently leverage their interaction style and make minimal or no use of the keyboard [21,29]. Aspects of VP can be observed even in the syntaxenforcing implementations of TouchDevelop [58] and the syntax-directed keyboard extension [1]. Therefore, incorporating VP concepts in the implementations of even conventional programming languages on touchscreen devices can be useful in advancing their usability.",
                    "score": 0.3614349632155474,
                    "section_title": "VP concepts",
                    "char_start_offset": 21548,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 156
                        },
                        {
                            "start": 157,
                            "end": 371
                        },
                        {
                            "start": 372,
                            "end": 514
                        },
                        {
                            "start": 517,
                            "end": 696
                        },
                        {
                            "start": 697,
                            "end": 839
                        },
                        {
                            "start": 840,
                            "end": 1009
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 363,
                            "end": 367,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 506,
                            "end": 510,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 688,
                            "end": 692,
                            "matchedPaperCorpusId": "64789544"
                        },
                        {
                            "start": 787,
                            "end": 791,
                            "matchedPaperCorpusId": "14819227"
                        },
                        {
                            "start": 835,
                            "end": 838,
                            "matchedPaperCorpusId": "14326365"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.953125
                }
            ],
            "relevance_judgement": 0.953125,
            "relevance_judgment_input_expanded": "# Title: Design Space of Programming Tools on Mobile Touchscreen Devices\n# Venue: arXiv.org\n# Authors: P. Sukumar, Ronald A. Metoyer\n## Abstract\nWhile mobile touchscreen devices are ubiquitous and present opportunities for novel applications, they have seen little adoption as tools for computer programming. In this literature survey, we bring together the diverse research work on programming-related tasks supported by mobile touchscreen devices to explore the design space for applying them to programming situations. We used the Grounded theory approach to identify themes and classify previous work. We present these themes and how each paper contributes to the theme, and we outline the remaining challenges in and opportunities for using mobile touchscreen devices in programming applications.\n## VP concepts\nVisual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax [40,53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains [40,41]. \n\nVP languages are a somewhat natural fit for use on touchscreen devices because they inherently leverage their interaction style and make minimal or no use of the keyboard [21,29]. Aspects of VP can be observed even in the syntaxenforcing implementations of TouchDevelop [58] and the syntax-directed keyboard extension [1]. Therefore, incorporating VP concepts in the implementations of even conventional programming languages on touchscreen devices can be useful in advancing their usability.",
            "reference_string": "[19038821 | Sukumar et al. | 2017 | Citations: 0]"
        },
        {
            "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
            "venue": "arXiv.org",
            "year": 2025,
            "reference_count": 36,
            "citation_count": 5,
            "influential_citation_count": 1,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2504.06606, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2211467299",
                    "name": "Minghe Gao"
                },
                {
                    "authorId": "2354514403",
                    "name": "Xuqi Liu"
                },
                {
                    "authorId": "2334476426",
                    "name": "Zhongqi Yue"
                },
                {
                    "authorId": "2331539012",
                    "name": "Yang Wu"
                },
                {
                    "authorId": "2297146759",
                    "name": "Shuang Chen"
                },
                {
                    "authorId": "2261788275",
                    "name": "Juncheng Li"
                },
                {
                    "authorId": "2276402838",
                    "name": "Siliang Tang"
                },
                {
                    "authorId": "2289700887",
                    "name": "Fei Wu"
                },
                {
                    "authorId": "2351809900",
                    "name": "Tat-Seng Chua"
                },
                {
                    "authorId": "2253660817",
                    "name": "Yueting Zhuang"
                }
            ],
            "abstract": "Recent advancements in reward signal usage for Large Language Models (LLMs) are remarkable. However, significant challenges exist when transitioning reward signal to the multimodal domain, including labor-intensive annotations, over-reliance on one-step rewards, and inadequate evaluation. To address these issues, we propose SVIP, a novel approach to train a step-level multi-dimensional Chain-of-Thought~(CoT) reward model automatically. It generates code for solving visual tasks and transforms the analysis of code blocks into the evaluation of CoT step as training samples. Then, we train SVIP-Reward model using a multi-head attention mechanism called TriAtt-CoT. The advantages of SVIP-Reward are evident throughout the entire process of MLLM. We also introduce a benchmark for CoT reward model training and testing. Experimental results demonstrate that SVIP-Reward improves MLLM performance across training and inference-time scaling, yielding better results on benchmarks while reducing hallucinations and enhancing reasoning ability.",
            "corpus_id": 277634411,
            "sentences": [
                {
                    "corpus_id": "277634411",
                    "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
                    "text": "Visual Programming [10,27] is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code [20]. Recently, several works have attempted to leverage the interpretability of visual programming, such as VPD [12], which simplifies multimodal learning by distilling tool use and programmatic reasoning into smaller models and Define [9] reimagines visual programming as a task of modular programming and optimization through feedback. \n\nInspired by these works, we further considered treating the execution process of code and its intermediate variables as a CoT decision sequence. The advantage of using programs as CoT in SVIP is evident: code is inherently verifiable and evaluable. Fact [8] eliminates redundant elements through static analysis of Python code's AST and converts them into natural language CoT, while PropTest [13] generates test code to validate the answers. These works provide a solid backbone for us-we can transform the evaluation of CoT steps into the evaluation of code, thereby addressing the challenge of evaluating CoT steps in natural language.",
                    "score": 0.31815208617474316,
                    "section_title": "Visual Programming as Decision Sequence",
                    "char_start_offset": 9524,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 129
                        },
                        {
                            "start": 130,
                            "end": 287
                        },
                        {
                            "start": 288,
                            "end": 620
                        },
                        {
                            "start": 623,
                            "end": 767
                        },
                        {
                            "start": 768,
                            "end": 871
                        },
                        {
                            "start": 872,
                            "end": 1065
                        },
                        {
                            "start": 1066,
                            "end": 1261
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 19,
                            "end": 23,
                            "matchedPaperCorpusId": "253734854"
                        },
                        {
                            "start": 23,
                            "end": 26,
                            "matchedPaperCorpusId": "257505358"
                        },
                        {
                            "start": 282,
                            "end": 286,
                            "matchedPaperCorpusId": "258212542"
                        },
                        {
                            "start": 395,
                            "end": 399,
                            "matchedPaperCorpusId": "265693898"
                        },
                        {
                            "start": 519,
                            "end": 522,
                            "matchedPaperCorpusId": "265351923"
                        },
                        {
                            "start": 877,
                            "end": 880,
                            "matchedPaperCorpusId": "269188197"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.953125
                },
                {
                    "corpus_id": "277634411",
                    "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
                    "text": "Step-level task decomposition: Visual Programming inherently organizes logical steps into a program flow symbolically, closely mirroring the CoT approach where complex tasks are decomposed into sequential segments. This alignment with CoT step-by-step nature ensures each code block in Visual Programming correlates with a CoT reasoning step, facilitating a seamless transition from code to CoT. \n\n3) Multi-dimensional statement evaluation: Furthermore, the modular design of Visual Programming supports multidimensional evaluation. Each module can be independently assessed through intermediate variables, code logic, and compilation data, reflecting key aspects such as data integrity and logical flow. This provides a more comprehensive assessment of the reasoning process. \n\nInspired by Visual Programming, we introduce SVIP, a method that generates executable code to solve visual tasks and seamlessly translates the creation of code and its ana-lytical evaluation into corresponding steps and assessments within the CoT framework. As shown in Figure 2, this is a two-phase code-to-CoT process. In the code generation ( 1 ) and assessment ( 2 ) phase, we begin by generating Python programs for each task, using least-to-most prompting. Subsequently, we conduct a multi-dimensional analysis of these blocks by evaluating their compilability, logic, and function calls. In the CoT conversion ( 3 ) and alignment ( 4 ) phase, we convert the generated code into sequential CoT statements and then map the detailed analysis of each code block into step-level multi-dimensional annotations within these statements. Finally, to capitalize on the evaluations derived from SVIP, we train our reward model SVIP-Reward using a multi-head attention mechanism called TriAtt-CoT. This mechanism is specifically designed to attentively weigh and integrate the varied dimensions of relevance, logic, and attributes assessed in each CoT step. \n\nThe advantages of SVIP-Reward are apparent throughout the entire MLLM pipeline. During the data cleaning phase, SVIP-Reward enhances the selection process by identifying high-quality multimodal reasoning samples based on critical dimensions. During the training phase, it automatically provides multi-dimensional supervisory signals at each step for reinforcement learning. During the inference phase, it leverages reward signals to select the best candidate step for test-time scaling, thereby enhancing the model's reasoning ability at a relatively low computational cost [6,38].",
                    "score": 0.3276843530888929,
                    "section_title": "2)",
                    "char_start_offset": 3572,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 214
                        },
                        {
                            "start": 215,
                            "end": 395
                        },
                        {
                            "start": 398,
                            "end": 532
                        },
                        {
                            "start": 533,
                            "end": 704
                        },
                        {
                            "start": 705,
                            "end": 776
                        },
                        {
                            "start": 779,
                            "end": 1036
                        },
                        {
                            "start": 1037,
                            "end": 1099
                        },
                        {
                            "start": 1100,
                            "end": 1241
                        },
                        {
                            "start": 1242,
                            "end": 1373
                        },
                        {
                            "start": 1374,
                            "end": 1614
                        },
                        {
                            "start": 1615,
                            "end": 1771
                        },
                        {
                            "start": 1772,
                            "end": 1931
                        },
                        {
                            "start": 1934,
                            "end": 2013
                        },
                        {
                            "start": 2014,
                            "end": 2175
                        },
                        {
                            "start": 2176,
                            "end": 2307
                        },
                        {
                            "start": 2308,
                            "end": 2515
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.95263671875
                }
            ],
            "relevance_judgement": 0.953125,
            "relevance_judgment_input_expanded": "# Title: Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program\n# Venue: arXiv.org\n# Authors: Minghe Gao, Xuqi Liu, Zhongqi Yue, Yang Wu, Shuang Chen, Juncheng Li, Siliang Tang, Fei Wu, Tat-Seng Chua, Yueting Zhuang\n## Abstract\nRecent advancements in reward signal usage for Large Language Models (LLMs) are remarkable. However, significant challenges exist when transitioning reward signal to the multimodal domain, including labor-intensive annotations, over-reliance on one-step rewards, and inadequate evaluation. To address these issues, we propose SVIP, a novel approach to train a step-level multi-dimensional Chain-of-Thought~(CoT) reward model automatically. It generates code for solving visual tasks and transforms the analysis of code blocks into the evaluation of CoT step as training samples. Then, we train SVIP-Reward model using a multi-head attention mechanism called TriAtt-CoT. The advantages of SVIP-Reward are evident throughout the entire process of MLLM. We also introduce a benchmark for CoT reward model training and testing. Experimental results demonstrate that SVIP-Reward improves MLLM performance across training and inference-time scaling, yielding better results on benchmarks while reducing hallucinations and enhancing reasoning ability.\n## 2)\nStep-level task decomposition: Visual Programming inherently organizes logical steps into a program flow symbolically, closely mirroring the CoT approach where complex tasks are decomposed into sequential segments. This alignment with CoT step-by-step nature ensures each code block in Visual Programming correlates with a CoT reasoning step, facilitating a seamless transition from code to CoT. \n\n3) Multi-dimensional statement evaluation: Furthermore, the modular design of Visual Programming supports multidimensional evaluation. Each module can be independently assessed through intermediate variables, code logic, and compilation data, reflecting key aspects such as data integrity and logical flow. This provides a more comprehensive assessment of the reasoning process. \n\nInspired by Visual Programming, we introduce SVIP, a method that generates executable code to solve visual tasks and seamlessly translates the creation of code and its ana-lytical evaluation into corresponding steps and assessments within the CoT framework. As shown in Figure 2, this is a two-phase code-to-CoT process. In the code generation ( 1 ) and assessment ( 2 ) phase, we begin by generating Python programs for each task, using least-to-most prompting. Subsequently, we conduct a multi-dimensional analysis of these blocks by evaluating their compilability, logic, and function calls. In the CoT conversion ( 3 ) and alignment ( 4 ) phase, we convert the generated code into sequential CoT statements and then map the detailed analysis of each code block into step-level multi-dimensional annotations within these statements. Finally, to capitalize on the evaluations derived from SVIP, we train our reward model SVIP-Reward using a multi-head attention mechanism called TriAtt-CoT. This mechanism is specifically designed to attentively weigh and integrate the varied dimensions of relevance, logic, and attributes assessed in each CoT step. \n\nThe advantages of SVIP-Reward are apparent throughout the entire MLLM pipeline. During the data cleaning phase, SVIP-Reward enhances the selection process by identifying high-quality multimodal reasoning samples based on critical dimensions. During the training phase, it automatically provides multi-dimensional supervisory signals at each step for reinforcement learning. During the inference phase, it leverages reward signals to select the best candidate step for test-time scaling, thereby enhancing the model's reasoning ability at a relatively low computational cost [6,38].\n\n## Visual Programming as Decision Sequence\nVisual Programming [10,27] is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code [20]. Recently, several works have attempted to leverage the interpretability of visual programming, such as VPD [12], which simplifies multimodal learning by distilling tool use and programmatic reasoning into smaller models and Define [9] reimagines visual programming as a task of modular programming and optimization through feedback. \n\nInspired by these works, we further considered treating the execution process of code and its intermediate variables as a CoT decision sequence. The advantage of using programs as CoT in SVIP is evident: code is inherently verifiable and evaluable. Fact [8] eliminates redundant elements through static analysis of Python code's AST and converts them into natural language CoT, while PropTest [13] generates test code to validate the answers. These works provide a solid backbone for us-we can transform the evaluation of CoT steps into the evaluation of code, thereby addressing the challenge of evaluating CoT steps in natural language.",
            "reference_string": "[277634411 | Gao et al. | 2025 | Citations: 5]"
        },
        {
            "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
            "venue": "Journal of Innovative Technology Convergence",
            "year": 2019,
            "reference_count": 0,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://jitc.innotcs.org/index.php/jitc/article/download/8/7",
                "status": "HYBRID",
                "license": "CCBYNC",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.69478/jitc2019v1n1a06?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.69478/jitc2019v1n1a06, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2300620753",
                    "name": "Jason Sermeno"
                }
            ],
            "abstract": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
            "corpus_id": 269622739,
            "sentences": [
                {
                    "corpus_id": "269622739",
                    "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
                    "text": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
                    "score": 0.3244780451268607,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.95263671875
                }
            ],
            "relevance_judgement": 0.95263671875,
            "relevance_judgment_input_expanded": "# Title: Graphical Block Structured Programming: A Visual Programming Paradigm\n# Venue: Journal of Innovative Technology Convergence\n# Authors: Jason Sermeno\n## Abstract\nThis paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.\n",
            "reference_string": "[269622739 | Sermeno | 2019 | Citations: 0]"
        },
        {
            "title": "PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI",
            "venue": "",
            "year": 2016,
            "reference_count": 19,
            "citation_count": 5,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.23917/warta.v19i1.1984",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.23917/WARTA.V19I1.1984?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.23917/WARTA.V19I1.1984, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1885335036",
                    "name": "Dedi Gunawan"
                },
                {
                    "authorId": "70024582",
                    "name": "Fatah Yasin Al Irsyadi"
                }
            ],
            "abstract": "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education. This research was conducted to the teachers who teach Al-Quran for children learning in order to know the benefit of using visual programming in terms of creating an animation and game education.Several approach has been applied in this research. The first is surveying the knowledge in computer programming by using questioners. Following that, we provide a training of using visual programming and the last is conduction survey in order to know the progress of learning accuisiton.Based on the questioner\u2019s data,it can be found that visual programming is very useful to introduce computer programming for people who have limited computer background. The data shows that 60% respondent believe that the visual programming is easy to follow, while the rest says it is hard to do. Furthermore, some of the participants are able to create simple education game",
            "corpus_id": 63194770,
            "sentences": [
                {
                    "corpus_id": "63194770",
                    "title": "PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI",
                    "text": "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education. This research was conducted to the teachers who teach Al-Quran for children learning in order to know the benefit of using visual programming in terms of creating an animation and game education.Several approach has been applied in this research. The first is surveying the knowledge in computer programming by using questioners. Following that, we provide a training of using visual programming and the last is conduction survey in order to know the progress of learning accuisiton.Based on the questioner\u2019s data,it can be found that visual programming is very useful to introduce computer programming for people who have limited computer background. The data shows that 60% respondent believe that the visual programming is easy to follow, while the rest says it is hard to do. Furthermore, some of the participants are able to create simple education game",
                    "score": 0.33092007672030155,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.95068359375
                }
            ],
            "relevance_judgement": 0.95068359375,
            "relevance_judgment_input_expanded": "# Title: PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI\n# Venue: \n# Authors: Dedi Gunawan, Fatah Yasin Al Irsyadi\n## Abstract\nVisual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education. This research was conducted to the teachers who teach Al-Quran for children learning in order to know the benefit of using visual programming in terms of creating an animation and game education.Several approach has been applied in this research. The first is surveying the knowledge in computer programming by using questioners. Following that, we provide a training of using visual programming and the last is conduction survey in order to know the progress of learning accuisiton.Based on the questioner\u2019s data,it can be found that visual programming is very useful to introduce computer programming for people who have limited computer background. The data shows that 60% respondent believe that the visual programming is easy to follow, while the rest says it is hard to do. Furthermore, some of the participants are able to create simple education game\n",
            "reference_string": "[63194770 | Gunawan et al. | 2016 | Citations: 5]"
        },
        {
            "title": "The Design of Parameter Modeling Software Applicable for Turbine Control Systems of Power Units Operated at Deep Shaving States",
            "venue": "Journal of Physics: Conference Series",
            "year": 2021,
            "reference_count": 13,
            "citation_count": 6,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://iopscience.iop.org/article/10.1088/1742-6596/2076/1/012106/pdf",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1088/1742-6596/2076/1/012106?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1088/1742-6596/2076/1/012106, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "46813111",
                    "name": "L. Zhu"
                },
                {
                    "authorId": "2000943401",
                    "name": "Paiyou Si"
                },
                {
                    "authorId": "2121296025",
                    "name": "S. Liu"
                },
                {
                    "authorId": "48927417",
                    "name": "Chang Xie"
                },
                {
                    "authorId": "2110105326",
                    "name": "Teng Zhang"
                },
                {
                    "authorId": "3864387",
                    "name": "Yuou Hu"
                },
                {
                    "authorId": "152424545",
                    "name": "Xiaozhi Qiu"
                }
            ],
            "abstract": "Against the backdrop of achieving the \u201cdual carbon\u201d reduction goals, the proportion of renewable energy consumption in China is gradually increasing, and more and more thermal power units are gradually being operated at the deep peak shaving states, which puts forward higher requirements for stable operation of the power grid system. In view of the current situation, this paper designs a new type of Python-based parameter modeling software for turbine control systems, including the load selection module, data pre-processing module, parameter identification module, and result output module. To solve the problem that the primary frequency regulation parameters of the units operated at the deep peak shaving states change with the load, the software is designed to set key model parameters of different load segments of the units. The actual measurement results of a unit operated at the deep peak shaving state show that this developed software is convenient and friendly to operate, creates accurate parameter identification results, and has a wider range of applicability.",
            "corpus_id": 243857547,
            "sentences": [
                {
                    "corpus_id": "243857547",
                    "title": "The Design of Parameter Modeling Software Applicable for Turbine Control Systems of Power Units Operated at Deep Shaving States",
                    "text": "Visualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result. The visualized programming environment for Python is designed using the wxPython graphics library. wxPython is a GUI toolkit for Python. It makes it easy for Python programmers to create programs with robust and powerful GUIs.",
                    "score": 0.30887401304497075,
                    "section_title": "Overview of Python-based Visualized Design",
                    "char_start_offset": 7795,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 259
                        },
                        {
                            "start": 260,
                            "end": 358
                        },
                        {
                            "start": 359,
                            "end": 396
                        },
                        {
                            "start": 397,
                            "end": 486
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9501953125
                }
            ],
            "relevance_judgement": 0.9501953125,
            "relevance_judgment_input_expanded": "# Title: The Design of Parameter Modeling Software Applicable for Turbine Control Systems of Power Units Operated at Deep Shaving States\n# Venue: Journal of Physics: Conference Series\n# Authors: L. Zhu, Paiyou Si, S. Liu, Chang Xie, Teng Zhang, Yuou Hu, Xiaozhi Qiu\n## Abstract\nAgainst the backdrop of achieving the \u201cdual carbon\u201d reduction goals, the proportion of renewable energy consumption in China is gradually increasing, and more and more thermal power units are gradually being operated at the deep peak shaving states, which puts forward higher requirements for stable operation of the power grid system. In view of the current situation, this paper designs a new type of Python-based parameter modeling software for turbine control systems, including the load selection module, data pre-processing module, parameter identification module, and result output module. To solve the problem that the primary frequency regulation parameters of the units operated at the deep peak shaving states change with the load, the software is designed to set key model parameters of different load segments of the units. The actual measurement results of a unit operated at the deep peak shaving state show that this developed software is convenient and friendly to operate, creates accurate parameter identification results, and has a wider range of applicability.\n## Overview of Python-based Visualized Design\nVisualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result. The visualized programming environment for Python is designed using the wxPython graphics library. wxPython is a GUI toolkit for Python. It makes it easy for Python programmers to create programs with robust and powerful GUIs.",
            "reference_string": "[243857547 | Zhu et al. | 2021 | Citations: 6]"
        },
        {
            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
            "venue": "International Journal of Advanced Computer Science and Applications",
            "year": 2020,
            "reference_count": 17,
            "citation_count": 19,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "http://thesai.org/Downloads/Volume11No7/Paper_77-DeepScratch_Scratch_Programming_Language.pdf",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.14569/ijacsa.2020.0110777?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.14569/ijacsa.2020.0110777, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2315312012",
                    "name": "Nora S. Alturayeif"
                },
                {
                    "authorId": "2023398349",
                    "name": "Nouf Alturaief"
                },
                {
                    "authorId": "2023401654",
                    "name": "Zainab Alhathloul"
                }
            ],
            "abstract": "Visual programming languages make programming more accessible for novices, which open more opportunities to innovate and develop problem-solving skills. Besides, deep learning is one of the trending computer science fields that has a profound impact on our daily life, and it is important that young people are aware of how our world works. In this study, we partially attribute the difficulties novices face in building deep learning models to the used programming language. This paper presents DeepScratch, a new programming language extension to Scratch that provides powerful language elements to facilitate building and learning about deep learning models. We present the implementation process of DeepScratch, and explain the syntactical definition and the lexical definition of the extended vocabulary. DeepScratch provides two options to implement deep learning models: training a neural network based on built-in datasets and using pre-trained deep learning models. The two options are provided to serve different age groups and educational levels. The preliminary evaluation shows the usability and the effectiveness of this extension as a tool for kids to learn about deep learning.",
            "corpus_id": 221340525,
            "sentences": [
                {
                    "corpus_id": "221340525",
                    "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                    "text": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
                    "score": 0.44188500623303695,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 3910,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 137
                        },
                        {
                            "start": 138,
                            "end": 339
                        },
                        {
                            "start": 340,
                            "end": 560
                        },
                        {
                            "start": 563,
                            "end": 678
                        },
                        {
                            "start": 679,
                            "end": 808
                        },
                        {
                            "start": 809,
                            "end": 894
                        },
                        {
                            "start": 895,
                            "end": 1013
                        },
                        {
                            "start": 1016,
                            "end": 1138
                        },
                        {
                            "start": 1139,
                            "end": 1256
                        },
                        {
                            "start": 1257,
                            "end": 1350
                        },
                        {
                            "start": 1351,
                            "end": 1424
                        },
                        {
                            "start": 1425,
                            "end": 1532
                        },
                        {
                            "start": 1533,
                            "end": 1662
                        },
                        {
                            "start": 1663,
                            "end": 1789
                        },
                        {
                            "start": 1790,
                            "end": 1925
                        },
                        {
                            "start": 1926,
                            "end": 2013
                        },
                        {
                            "start": 2014,
                            "end": 2152
                        },
                        {
                            "start": 2153,
                            "end": 2370
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 674,
                            "end": 677,
                            "matchedPaperCorpusId": "11994747"
                        },
                        {
                            "start": 890,
                            "end": 893,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1009,
                            "end": 1012,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1785,
                            "end": 1788,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1803,
                            "end": 1806,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 2148,
                            "end": 2151,
                            "matchedPaperCorpusId": "17452915"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94873046875
                }
            ],
            "relevance_judgement": 0.94873046875,
            "relevance_judgment_input_expanded": "# Title: DeepScratch: Scratch Programming Language Extension for Deep Learning Education\n# Venue: International Journal of Advanced Computer Science and Applications\n# Authors: Nora S. Alturayeif, Nouf Alturaief, Zainab Alhathloul\n## Abstract\nVisual programming languages make programming more accessible for novices, which open more opportunities to innovate and develop problem-solving skills. Besides, deep learning is one of the trending computer science fields that has a profound impact on our daily life, and it is important that young people are aware of how our world works. In this study, we partially attribute the difficulties novices face in building deep learning models to the used programming language. This paper presents DeepScratch, a new programming language extension to Scratch that provides powerful language elements to facilitate building and learning about deep learning models. We present the implementation process of DeepScratch, and explain the syntactical definition and the lexical definition of the extended vocabulary. DeepScratch provides two options to implement deep learning models: training a neural network based on built-in datasets and using pre-trained deep learning models. The two options are provided to serve different age groups and educational levels. The preliminary evaluation shows the usability and the effectiveness of this extension as a tool for kids to learn about deep learning.\n## II. BACKGROUND\nVisual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
            "reference_string": "[221340525 | Alturayeif et al. | 2020 | Citations: 19]"
        },
        {
            "title": "Program Synthesis Benchmark for Visual Programming in XLogoOnline Environment",
            "venue": "arXiv.org",
            "year": 2024,
            "reference_count": 37,
            "citation_count": 3,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2406.11334, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2299943665",
                    "name": "Chao Wen"
                },
                {
                    "authorId": "2299942951",
                    "name": "Jacqueline Staub"
                },
                {
                    "authorId": "1703727",
                    "name": "A. Singla"
                }
            ],
            "abstract": "Large language and multimodal models have shown remarkable successes on various benchmarks focused on specific skills such as general-purpose programming, natural language understanding, math word problem-solving, and visual question answering. However, it is unclear how well these models perform on tasks that require a combination of these skills. In this paper, we curate a novel program synthesis benchmark based on the XLogoOnline visual programming environment. The benchmark comprises 85 real-world tasks from the Mini-level of the XLogoOnline environment, each requiring a combination of different skills such as spatial planning, basic programming, and logical reasoning. Our evaluation shows that current state-of-the-art models like GPT-4V and Llama3-70B struggle to solve these tasks, achieving only 20% and 2.35% success rates. Next, we develop a fine-tuning pipeline to boost the performance of models by leveraging a large-scale synthetic training dataset with over 80000 tasks. Moreover, we showcase how emulator-driven feedback can be used to design a curriculum over training data distribution. We showcase that a fine-tuned Llama3-8B drastically outperforms GPT-4V and Llama3-70B models, and provide an in-depth analysis of the models' expertise across different skill dimensions. We will publicly release the benchmark for future research on program synthesis in visual programming.",
            "corpus_id": 270559828,
            "sentences": [
                {
                    "corpus_id": "270559828",
                    "title": "Program Synthesis Benchmark for Visual Programming in XLogoOnline Environment",
                    "text": "XLogoOnline [14] is a visual programming platform based on Logo programming language [37] and is widely used by tens of thousands of students every year [38,39].In this work, we focus on the Mini-level (XLogoOnline-Mini).In XLogoOnline-Mini, each task includes a text description of the goal and code constraints, along with a two-dimensional visual grid.The visual grid features a turtle and various elements such as fruits, shapes, colors, lines, walls, and forbidden areas.To solve the task, one needs to write a program to direct the turtle's movement in the visual grid to achieve the specified goal.Figure 1 shows illustrative examples of tasks, the required skills, and solution codes.\n\nRequired skills for XLogoOnline-Mini.We examine the skills required for solving visual programming tasks in XLogoOnline-Mini.Specifically, the visual programming tasks in our domain cover the following skills:",
                    "score": 0.30887401304497075,
                    "section_title": "Background on XLogoOnline-Mini Programming",
                    "char_start_offset": 6242,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 161
                        },
                        {
                            "start": 161,
                            "end": 221
                        },
                        {
                            "start": 221,
                            "end": 355
                        },
                        {
                            "start": 355,
                            "end": 476
                        },
                        {
                            "start": 476,
                            "end": 605
                        },
                        {
                            "start": 605,
                            "end": 692
                        },
                        {
                            "start": 694,
                            "end": 731
                        },
                        {
                            "start": 731,
                            "end": 819
                        },
                        {
                            "start": 819,
                            "end": 903
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 157,
                            "end": 160,
                            "matchedPaperCorpusId": "232172217"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94873046875
                }
            ],
            "relevance_judgement": 0.94873046875,
            "relevance_judgment_input_expanded": "# Title: Program Synthesis Benchmark for Visual Programming in XLogoOnline Environment\n# Venue: arXiv.org\n# Authors: Chao Wen, Jacqueline Staub, A. Singla\n## Abstract\nLarge language and multimodal models have shown remarkable successes on various benchmarks focused on specific skills such as general-purpose programming, natural language understanding, math word problem-solving, and visual question answering. However, it is unclear how well these models perform on tasks that require a combination of these skills. In this paper, we curate a novel program synthesis benchmark based on the XLogoOnline visual programming environment. The benchmark comprises 85 real-world tasks from the Mini-level of the XLogoOnline environment, each requiring a combination of different skills such as spatial planning, basic programming, and logical reasoning. Our evaluation shows that current state-of-the-art models like GPT-4V and Llama3-70B struggle to solve these tasks, achieving only 20% and 2.35% success rates. Next, we develop a fine-tuning pipeline to boost the performance of models by leveraging a large-scale synthetic training dataset with over 80000 tasks. Moreover, we showcase how emulator-driven feedback can be used to design a curriculum over training data distribution. We showcase that a fine-tuned Llama3-8B drastically outperforms GPT-4V and Llama3-70B models, and provide an in-depth analysis of the models' expertise across different skill dimensions. We will publicly release the benchmark for future research on program synthesis in visual programming.\n## Background on XLogoOnline-Mini Programming\nXLogoOnline [14] is a visual programming platform based on Logo programming language [37] and is widely used by tens of thousands of students every year [38,39].In this work, we focus on the Mini-level (XLogoOnline-Mini).In XLogoOnline-Mini, each task includes a text description of the goal and code constraints, along with a two-dimensional visual grid.The visual grid features a turtle and various elements such as fruits, shapes, colors, lines, walls, and forbidden areas.To solve the task, one needs to write a program to direct the turtle's movement in the visual grid to achieve the specified goal.Figure 1 shows illustrative examples of tasks, the required skills, and solution codes.\n\nRequired skills for XLogoOnline-Mini.We examine the skills required for solving visual programming tasks in XLogoOnline-Mini.Specifically, the visual programming tasks in our domain cover the following skills:",
            "reference_string": "[270559828 | Wen et al. | 2024 | Citations: 3]"
        },
        {
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "venue": "arXiv.org",
            "year": 2017,
            "reference_count": 72,
            "citation_count": 3,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1712.10281, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "35131544",
                    "name": "M. S. Fayed"
                }
            ],
            "abstract": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
            "corpus_id": 3949077,
            "sentences": [
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "NOTE: that the words \"step\", \"control\", and \"component\" are used interchangeably and they all mean a graphical control also the words \"goal\" and \"module\" are used interchangeably to mean a programming module.\n\nThe basic idea behind the Graphical Code Replacement (GCR) was to find a way to make the visual programming language fully equivalent to a traditional textual programming language and to overcome all the limitations and weaknesses of VPLs. Looking at the structure of code written in textual programming languages, it can be easily seen that the code contains a set of instructions and commands written as statements in a specific syntax. The statements are arranged in nested structures similar to a computer tree with one or more nodes/leaves. A complex statement such as \"For Loop\" can be represented with a node that can be expanded, while a simple statement such as a \"printf()\" can be represented with a leaf. For example, the code shown in Figure 10 is written in C. This code can be seen as a tree of statements or steps (a step here is defined as a visual component) arranged in a way to print numbers from 1 to 3, print a message, and then continue Printing 4 to 10. Keep in mind that each instruction in any programming language consists of two parts: the operation, and the required data for the specification of that operation. To better describe the concept, the following equivalences can be used:\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of Instructions (Steps Tree) \u2022 Instruction IS EQUIVALENT TO a function F(X), where F is the operation or the function and X is the required data.\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of F(X). Notice that F can be any function and X can be any input data.\n\nWhen the above equivalences are applied to the C code shown in Figure 10 Step's Description/Label Print Text \"This message between number 3 and number 4\" Table 5. Shows the replacement process for one line of code.\n\nAt this point many questions need to be answered. How the steps will be generated automatically? How will they determine what the program will do? How can the developer/programmer control and manage the program as she does with traditional languages? GCR uses the Nested Tree (Steps Tree) to represent the structure of the program. Instead of",
                    "score": 0.3138523027044761,
                    "section_title": "Graphical Code Replacement Method",
                    "char_start_offset": 55501,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9482421875
                },
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "The questions that we aim to answer during this thesis are:\n\n1. What are the problems that prevent mainstream programmers from using the current visual programming languages?\n\n2. What is the design of a general-purpose visual programming language that can solve mainstream programmers problems and encourage them to use the proposed visual programming language in developing practical software?",
                    "score": 0.3832814172581209,
                    "section_title": "Research Questions",
                    "char_start_offset": 10626,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9423828125
                },
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "The objectives of this research subject are:\n\n1. Creating a Framework for creating visual programming languages to help us in creating the visual programming language components faster. The framework must contains the designers and domain-specific language to quickly create the visual programming language components. The implementation of each component should be done in little minutes to ensure the high-level of productivity. 2. Designing a General-Purpose visual programming language to make programming easier to understand for audiences other than programmers and to help expert programmers to quickly create programs and applications in less time. 3. Implementing the General-Purpose visual programming language through an information system that support programs and applications creation and manipulation, to reduce errors and to help users program faster. 4. Evaluating the system in developing business applications and comparing this to using other traditional programming languages that are text based.",
                    "score": 0.4064586197702927,
                    "section_title": "Research Objectives",
                    "char_start_offset": 11043,
                    "sentence_offsets": [],
                    "ref_mentions": [
                        {
                            "start": 657,
                            "end": 658,
                            "matchedPaperCorpusId": "62213603"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94140625
                },
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "languages. According to our study we see a gap in attracting mainstream programmers to using visual programming languages in each new programming task. The current VPLs are not equivalent to the current textual programming languages at the practical side. Yes, some limitations are a result of missing features that can be added but this doesn't count only for \"what we can do?\" but for \"how we can do things with respect to the productivity of the programmer during software development and the quality of the final software\".\n\nWe provided the requirements of a general purpose visual programming tool that can be used as replacement for the usage of popular programming languages like ( C,C++, C# and Java) + (visual programming environments like Visual Studio and Netbeans). We expect that after the implementation and marketing of this new tool, many new software projects can be developed using Visual Programming Language in less time with high quality. Also we expect attracting more users to real programming industry after the existence of this tool.\n\nAlso in this thesis, PWCT was presented. PWCT is a novel general purpose VPL that was designed to compete with textual programming languages such as C++ and Java. The novelty of this work comes from the invention of a technique called GCR. GCR uses graphical components to replace textual code in an easy and seamless process. PWCT's architecture, design, and implementation were covered in this thesis.\n\nThree types of evaluations were used to make sure that PWCT is a competitive VPL.\n\nUsability and capability evaluation shows that PWCT is extremely easy to use and requires a very short time for learning. Moreover, Efficiency evaluations show that PWCT requires",
                    "score": 0.39557691271095835,
                    "section_title": "Reputation Evaluation",
                    "char_start_offset": 76357,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9404296875
                },
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
                    "score": 0.33748140519510234,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.93896484375
                }
            ],
            "relevance_judgement": 0.9482421875,
            "relevance_judgment_input_expanded": "# Title: General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications\n# Venue: arXiv.org\n# Authors: M. S. Fayed\n## Abstract\nLearning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.\n## Research Questions\nThe questions that we aim to answer during this thesis are:\n\n1. What are the problems that prevent mainstream programmers from using the current visual programming languages?\n\n2. What is the design of a general-purpose visual programming language that can solve mainstream programmers problems and encourage them to use the proposed visual programming language in developing practical software?\n\n## Research Objectives\nThe objectives of this research subject are:\n\n1. Creating a Framework for creating visual programming languages to help us in creating the visual programming language components faster. The framework must contains the designers and domain-specific language to quickly create the visual programming language components. The implementation of each component should be done in little minutes to ensure the high-level of productivity. 2. Designing a General-Purpose visual programming language to make programming easier to understand for audiences other than programmers and to help expert programmers to quickly create programs and applications in less time. 3. Implementing the General-Purpose visual programming language through an information system that support programs and applications creation and manipulation, to reduce errors and to help users program faster. 4. Evaluating the system in developing business applications and comparing this to using other traditional programming languages that are text based.\n\n## Graphical Code Replacement Method\nNOTE: that the words \"step\", \"control\", and \"component\" are used interchangeably and they all mean a graphical control also the words \"goal\" and \"module\" are used interchangeably to mean a programming module.\n\nThe basic idea behind the Graphical Code Replacement (GCR) was to find a way to make the visual programming language fully equivalent to a traditional textual programming language and to overcome all the limitations and weaknesses of VPLs. Looking at the structure of code written in textual programming languages, it can be easily seen that the code contains a set of instructions and commands written as statements in a specific syntax. The statements are arranged in nested structures similar to a computer tree with one or more nodes/leaves. A complex statement such as \"For Loop\" can be represented with a node that can be expanded, while a simple statement such as a \"printf()\" can be represented with a leaf. For example, the code shown in Figure 10 is written in C. This code can be seen as a tree of statements or steps (a step here is defined as a visual component) arranged in a way to print numbers from 1 to 3, print a message, and then continue Printing 4 to 10. Keep in mind that each instruction in any programming language consists of two parts: the operation, and the required data for the specification of that operation. To better describe the concept, the following equivalences can be used:\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of Instructions (Steps Tree) \u2022 Instruction IS EQUIVALENT TO a function F(X), where F is the operation or the function and X is the required data.\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of F(X). Notice that F can be any function and X can be any input data.\n\nWhen the above equivalences are applied to the C code shown in Figure 10 Step's Description/Label Print Text \"This message between number 3 and number 4\" Table 5. Shows the replacement process for one line of code.\n\nAt this point many questions need to be answered. How the steps will be generated automatically? How will they determine what the program will do? How can the developer/programmer control and manage the program as she does with traditional languages? GCR uses the Nested Tree (Steps Tree) to represent the structure of the program. Instead of\n\n## Reputation Evaluation\nlanguages. According to our study we see a gap in attracting mainstream programmers to using visual programming languages in each new programming task. The current VPLs are not equivalent to the current textual programming languages at the practical side. Yes, some limitations are a result of missing features that can be added but this doesn't count only for \"what we can do?\" but for \"how we can do things with respect to the productivity of the programmer during software development and the quality of the final software\".\n\nWe provided the requirements of a general purpose visual programming tool that can be used as replacement for the usage of popular programming languages like ( C,C++, C# and Java) + (visual programming environments like Visual Studio and Netbeans). We expect that after the implementation and marketing of this new tool, many new software projects can be developed using Visual Programming Language in less time with high quality. Also we expect attracting more users to real programming industry after the existence of this tool.\n\nAlso in this thesis, PWCT was presented. PWCT is a novel general purpose VPL that was designed to compete with textual programming languages such as C++ and Java. The novelty of this work comes from the invention of a technique called GCR. GCR uses graphical components to replace textual code in an easy and seamless process. PWCT's architecture, design, and implementation were covered in this thesis.\n\nThree types of evaluations were used to make sure that PWCT is a competitive VPL.\n\nUsability and capability evaluation shows that PWCT is extremely easy to use and requires a very short time for learning. Moreover, Efficiency evaluations show that PWCT requires",
            "reference_string": "[3949077 | Fayed | 2017 | Citations: 3]"
        },
        {
            "title": "Visual programming for next-generation sequencing data analytics",
            "venue": "BioData Mining",
            "year": 2016,
            "reference_count": 93,
            "citation_count": 21,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://biodatamining.biomedcentral.com/track/pdf/10.1186/s13040-016-0095-3",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://pmc.ncbi.nlm.nih.gov/articles/PMC4848821, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2667295",
                    "name": "F. Milicchio"
                },
                {
                    "authorId": "3381593",
                    "name": "R. Rose"
                },
                {
                    "authorId": "152441499",
                    "name": "J. Bian"
                },
                {
                    "authorId": "145545650",
                    "name": "Jae Min"
                },
                {
                    "authorId": "144270737",
                    "name": "M. Prosperi"
                }
            ],
            "abstract": "High-throughput or next-generation sequencing (NGS) technologies have become an established and affordable experimental framework in biological and medical sciences for all basic and translational research. Processing and analyzing NGS data is challenging. NGS data are big, heterogeneous, sparse, and error prone. Although a plethora of tools for NGS data analysis has emerged in the past decade, (i) software development is still lagging behind data generation capabilities, and (ii) there is a \u2018cultural\u2019 gap between the end user and the developer. Generic software template libraries specifically developed for NGS can help in dealing with the former problem, whilst coupling template libraries with visual programming may help with the latter. Here we scrutinize the state-of-the-art low-level software libraries implemented specifically for NGS and graphical tools for NGS analytics. An ideal developing environment for NGS should be modular (with a native library interface), scalable in computational methods (i.e. serial, multithread, distributed), transparent (platform-independent), interoperable (with external software interface), and usable (via an intuitive graphical user interface). These characteristics should facilitate both the run of standardized NGS pipelines and the development of new workflows based on technological advancements or users\u2019 needs. We discuss in detail the potential of a computational framework blending generic template programming and visual programming that addresses all of the current limitations. In the long term, a proper, well-developed (although not necessarily unique) software framework will bridge the current gap between data generation and hypothesis testing. This will eventually facilitate the development of novel diagnostic tools embedded in routine healthcare.",
            "corpus_id": 3874016,
            "sentences": [
                {
                    "corpus_id": "3874016",
                    "title": "Visual programming for next-generation sequencing data analytics",
                    "text": "We have highlighted the importance of creating a solid low-level base for NGS programming and a high-level base to scale up analytics, especially with the usage of visual tools. \n\nIn computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71][72][73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates [75,76]. VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design [77,78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required. \n\nHow can visual programming benefit NGS software development? \n\nCurrently, there are no 'pure' VP approaches being developed for NGS applications. \n\nGalaxy or UGENE workflow builders can be considered rudimental VP environments, but as discussed previously, they do not offer the same set of functions as the command-line and have limited interoperability (i.e. they work only within their parent environment and cannot build independent programs). However, there is potential for improving the workflow builders using the VP approach.",
                    "score": 0.3384670555078445,
                    "section_title": "Visual programming",
                    "char_start_offset": 16563,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 177
                        },
                        {
                            "start": 180,
                            "end": 360
                        },
                        {
                            "start": 361,
                            "end": 529
                        },
                        {
                            "start": 530,
                            "end": 555
                        },
                        {
                            "start": 556,
                            "end": 647
                        },
                        {
                            "start": 648,
                            "end": 673
                        },
                        {
                            "start": 674,
                            "end": 786
                        },
                        {
                            "start": 787,
                            "end": 929
                        },
                        {
                            "start": 930,
                            "end": 1083
                        },
                        {
                            "start": 1084,
                            "end": 1371
                        },
                        {
                            "start": 1372,
                            "end": 1439
                        },
                        {
                            "start": 1440,
                            "end": 1637
                        },
                        {
                            "start": 1638,
                            "end": 1737
                        },
                        {
                            "start": 1740,
                            "end": 1800
                        },
                        {
                            "start": 1803,
                            "end": 1885
                        },
                        {
                            "start": 1888,
                            "end": 2187
                        },
                        {
                            "start": 2188,
                            "end": 2274
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 389,
                            "end": 393,
                            "matchedPaperCorpusId": "60451974"
                        },
                        {
                            "start": 521,
                            "end": 525,
                            "matchedPaperCorpusId": "106672214"
                        },
                        {
                            "start": 525,
                            "end": 528,
                            "matchedPaperCorpusId": "11750514"
                        },
                        {
                            "start": 1431,
                            "end": 1435,
                            "matchedPaperCorpusId": "16049286"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94580078125
                }
            ],
            "relevance_judgement": 0.94580078125,
            "relevance_judgment_input_expanded": "# Title: Visual programming for next-generation sequencing data analytics\n# Venue: BioData Mining\n# Authors: F. Milicchio, R. Rose, J. Bian, Jae Min, M. Prosperi\n## Abstract\nHigh-throughput or next-generation sequencing (NGS) technologies have become an established and affordable experimental framework in biological and medical sciences for all basic and translational research. Processing and analyzing NGS data is challenging. NGS data are big, heterogeneous, sparse, and error prone. Although a plethora of tools for NGS data analysis has emerged in the past decade, (i) software development is still lagging behind data generation capabilities, and (ii) there is a \u2018cultural\u2019 gap between the end user and the developer. Generic software template libraries specifically developed for NGS can help in dealing with the former problem, whilst coupling template libraries with visual programming may help with the latter. Here we scrutinize the state-of-the-art low-level software libraries implemented specifically for NGS and graphical tools for NGS analytics. An ideal developing environment for NGS should be modular (with a native library interface), scalable in computational methods (i.e. serial, multithread, distributed), transparent (platform-independent), interoperable (with external software interface), and usable (via an intuitive graphical user interface). These characteristics should facilitate both the run of standardized NGS pipelines and the development of new workflows based on technological advancements or users\u2019 needs. We discuss in detail the potential of a computational framework blending generic template programming and visual programming that addresses all of the current limitations. In the long term, a proper, well-developed (although not necessarily unique) software framework will bridge the current gap between data generation and hypothesis testing. This will eventually facilitate the development of novel diagnostic tools embedded in routine healthcare.\n## Visual programming\nWe have highlighted the importance of creating a solid low-level base for NGS programming and a high-level base to scale up analytics, especially with the usage of visual tools. \n\nIn computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71][72][73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates [75,76]. VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design [77,78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required. \n\nHow can visual programming benefit NGS software development? \n\nCurrently, there are no 'pure' VP approaches being developed for NGS applications. \n\nGalaxy or UGENE workflow builders can be considered rudimental VP environments, but as discussed previously, they do not offer the same set of functions as the command-line and have limited interoperability (i.e. they work only within their parent environment and cannot build independent programs). However, there is potential for improving the workflow builders using the VP approach.",
            "reference_string": "[3874016 | Milicchio et al. | 2016 | Citations: 21]"
        },
        {
            "title": "Towards rule-based visual programming of generic visual systems",
            "venue": "arXiv.org",
            "year": 2000,
            "reference_count": 33,
            "citation_count": 9,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/cs/0010016, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "38400881",
                    "name": "Berthold Hoffmann"
                },
                {
                    "authorId": "1731543",
                    "name": "M. Minas"
                }
            ],
            "abstract": "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation. The language supports object-oriented programming since its graphs are hierarchically structured. Typing allows the shape of these graphs to be specified recursively in order to increase program security. Thanks to its genericity, DiaPlan allows to implement systems that represent and manipulate data in arbitrary diagram notations. The environment for the language exploits the diagram editor generator DiaGen for providing genericity, and for implementing its user interface and type checker.",
            "corpus_id": 58394,
            "sentences": [
                {
                    "corpus_id": "58394",
                    "title": "Towards rule-based visual programming of generic visual systems",
                    "text": "As this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
                    "score": 0.3028248728546346,
                    "section_title": "Genericity",
                    "char_start_offset": 20066,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 129
                        },
                        {
                            "start": 130,
                            "end": 290
                        },
                        {
                            "start": 291,
                            "end": 447
                        },
                        {
                            "start": 448,
                            "end": 580
                        },
                        {
                            "start": 581,
                            "end": 731
                        },
                        {
                            "start": 732,
                            "end": 912
                        },
                        {
                            "start": 913,
                            "end": 1045
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 950,
                            "end": 954,
                            "matchedPaperCorpusId": "43464074"
                        },
                        {
                            "start": 1040,
                            "end": 1044,
                            "matchedPaperCorpusId": "8161155"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94287109375
                }
            ],
            "relevance_judgement": 0.94287109375,
            "relevance_judgment_input_expanded": "# Title: Towards rule-based visual programming of generic visual systems\n# Venue: arXiv.org\n# Authors: Berthold Hoffmann, M. Minas\n## Abstract\nThis paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation. The language supports object-oriented programming since its graphs are hierarchically structured. Typing allows the shape of these graphs to be specified recursively in order to increase program security. Thanks to its genericity, DiaPlan allows to implement systems that represent and manipulate data in arbitrary diagram notations. The environment for the language exploits the diagram editor generator DiaGen for providing genericity, and for implementing its user interface and type checker.\n## Genericity\nAs this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
            "reference_string": "[58394 | Hoffmann et al. | 2000 | Citations: 9]"
        },
        {
            "title": "Advanced Game Engine Wizardry for Visual Programming Environments",
            "venue": "PAINT@SPLASH",
            "year": 2024,
            "reference_count": 30,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3689488.3689992",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3689488.3689992?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3689488.3689992, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2326538317",
                    "name": "Elisabeth Kletsko"
                },
                {
                    "authorId": "2047732442",
                    "name": "Riemer van Rozen"
                }
            ],
            "abstract": "Visual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming. For creating these environments, language engineers require enabling technology. Language workbenches and meta-programming languages support rapid construction of interpreter back-ends. Game engines are specifically created for rich interactive user experiences and have the potential to augment this technology even further with maintainable front-ends. However, these technologies presently live in separate technological spaces. We aim to automate the creation of visual programming environments by integrating the two. We propose Raven, a meta-framework for rapidly prototyping visual editors that exposes key 2D features of Godot in a programmable user interface. Using Raven's declarative notation, language engineers can concisely express the structure and styling of tree-based editors. We demonstrate our approach by: 1) integrating Raven into the Rascal language workbench; and 2) creating two editors for the live state machine language.",
            "corpus_id": 273147365,
            "sentences": [
                {
                    "corpus_id": "273147365",
                    "title": "Advanced Game Engine Wizardry for Visual Programming Environments",
                    "text": "Visual programming environments have the potential to make programming more accessible to programmers of all backgrounds and skill levels. Domain-Specific Languages (DSLs) empower non-programmers with notations and abstractions aimed at particular problem domains [25]. DSLs have been shown to help non-programmers raise their productivity and improve the code quality, e.g., in robotics [10], banking [20], and digital forensics [23]. We aim to support the development of visual programming environments for DSLs. Specifically, we study how to create interactive input and feedback mechanisms that bring the code to life. \n\nLanguage workbenches and meta-programming languages provide techniques and approaches that support prototyping DSLs, e.g., compilers and interpreters [5]. However, generic language technology often has limited support for creating advanced visual programming environments. As a result, creating user-friendly and aesthetically pleasing prototypes is costly and time-consuming. Language engineers need tools and techniques that accelerate the development of prototypes that are easy to deploy, maintain, and extend. \n\nGame engines have been specifically designed to create rich interactive user experiences, e.g., games, apps, and other visualizations. Using powerful tool sets, developers can easily maintain and deploy user-friendly, feature-rich visual applications across platforms. Unfortunately, language workbenches and game engines are currently separate technological spaces. Until now, the combination of this technology in generic solutions for language engineering has not yet been explored. As a result, the potential of game engines for prototyping visual editors for DSLs is still largely unknown. \n\nWe aim to bridge the gap between these technologies by automating the creation of visual programming environments using game engines. A pilot study on this topic shows that Godot in particular offers a solid foundation [2,27]. Godot comes with out-of-the-box support for C, C++, and C#, and recently JVM-based languages such as Kotlin or Java [3]. We investigate how Godot can be leveraged in generic language technology for prototyping of visual editors for DSLs. \n\nWe propose Raven, a novel meta-framework that exposes key 2D functionalities of Godot in a reusable, programmable user interface. We illustrate its potential in two ways.",
                    "score": 0.3213007535264759,
                    "section_title": "Introduction",
                    "char_start_offset": 15,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 138
                        },
                        {
                            "start": 139,
                            "end": 269
                        },
                        {
                            "start": 270,
                            "end": 435
                        },
                        {
                            "start": 436,
                            "end": 514
                        },
                        {
                            "start": 515,
                            "end": 622
                        },
                        {
                            "start": 625,
                            "end": 779
                        },
                        {
                            "start": 780,
                            "end": 897
                        },
                        {
                            "start": 898,
                            "end": 1001
                        },
                        {
                            "start": 1002,
                            "end": 1139
                        },
                        {
                            "start": 1142,
                            "end": 1276
                        },
                        {
                            "start": 1277,
                            "end": 1410
                        },
                        {
                            "start": 1411,
                            "end": 1508
                        },
                        {
                            "start": 1509,
                            "end": 1627
                        },
                        {
                            "start": 1628,
                            "end": 1736
                        },
                        {
                            "start": 1739,
                            "end": 1872
                        },
                        {
                            "start": 1873,
                            "end": 1965
                        },
                        {
                            "start": 1966,
                            "end": 2086
                        },
                        {
                            "start": 2087,
                            "end": 2203
                        },
                        {
                            "start": 2206,
                            "end": 2335
                        },
                        {
                            "start": 2336,
                            "end": 2376
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 264,
                            "end": 268,
                            "matchedPaperCorpusId": "264769167"
                        },
                        {
                            "start": 402,
                            "end": 406,
                            "matchedPaperCorpusId": "14922174"
                        },
                        {
                            "start": 430,
                            "end": 434,
                            "matchedPaperCorpusId": "7011074"
                        },
                        {
                            "start": 1961,
                            "end": 1964,
                            "matchedPaperCorpusId": "264307073"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.93359375
                }
            ],
            "relevance_judgement": 0.93359375,
            "relevance_judgment_input_expanded": "# Title: Advanced Game Engine Wizardry for Visual Programming Environments\n# Venue: PAINT@SPLASH\n# Authors: Elisabeth Kletsko, Riemer van Rozen\n## Abstract\nVisual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming. For creating these environments, language engineers require enabling technology. Language workbenches and meta-programming languages support rapid construction of interpreter back-ends. Game engines are specifically created for rich interactive user experiences and have the potential to augment this technology even further with maintainable front-ends. However, these technologies presently live in separate technological spaces. We aim to automate the creation of visual programming environments by integrating the two. We propose Raven, a meta-framework for rapidly prototyping visual editors that exposes key 2D features of Godot in a programmable user interface. Using Raven's declarative notation, language engineers can concisely express the structure and styling of tree-based editors. We demonstrate our approach by: 1) integrating Raven into the Rascal language workbench; and 2) creating two editors for the live state machine language.\n## Introduction\nVisual programming environments have the potential to make programming more accessible to programmers of all backgrounds and skill levels. Domain-Specific Languages (DSLs) empower non-programmers with notations and abstractions aimed at particular problem domains [25]. DSLs have been shown to help non-programmers raise their productivity and improve the code quality, e.g., in robotics [10], banking [20], and digital forensics [23]. We aim to support the development of visual programming environments for DSLs. Specifically, we study how to create interactive input and feedback mechanisms that bring the code to life. \n\nLanguage workbenches and meta-programming languages provide techniques and approaches that support prototyping DSLs, e.g., compilers and interpreters [5]. However, generic language technology often has limited support for creating advanced visual programming environments. As a result, creating user-friendly and aesthetically pleasing prototypes is costly and time-consuming. Language engineers need tools and techniques that accelerate the development of prototypes that are easy to deploy, maintain, and extend. \n\nGame engines have been specifically designed to create rich interactive user experiences, e.g., games, apps, and other visualizations. Using powerful tool sets, developers can easily maintain and deploy user-friendly, feature-rich visual applications across platforms. Unfortunately, language workbenches and game engines are currently separate technological spaces. Until now, the combination of this technology in generic solutions for language engineering has not yet been explored. As a result, the potential of game engines for prototyping visual editors for DSLs is still largely unknown. \n\nWe aim to bridge the gap between these technologies by automating the creation of visual programming environments using game engines. A pilot study on this topic shows that Godot in particular offers a solid foundation [2,27]. Godot comes with out-of-the-box support for C, C++, and C#, and recently JVM-based languages such as Kotlin or Java [3]. We investigate how Godot can be leveraged in generic language technology for prototyping of visual editors for DSLs. \n\nWe propose Raven, a novel meta-framework that exposes key 2D functionalities of Godot in a reusable, programmable user interface. We illustrate its potential in two ways.",
            "reference_string": "[273147365 | Kletsko et al. | 2024 | Citations: 0]"
        }
    ],
    "retrieved": [
        {
            "corpus_id": "236566925",
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "text": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
            "score": 0.4853129009429891,
            "section_title": "Visual programming:",
            "char_start_offset": 28669,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 149
                },
                {
                    "start": 150,
                    "end": 360
                },
                {
                    "start": 363,
                    "end": 692
                },
                {
                    "start": 695,
                    "end": 896
                },
                {
                    "start": 897,
                    "end": 978
                },
                {
                    "start": 979,
                    "end": 1158
                },
                {
                    "start": 1161,
                    "end": 1286
                },
                {
                    "start": 1287,
                    "end": 1305
                },
                {
                    "start": 1308,
                    "end": 1490
                },
                {
                    "start": 1491,
                    "end": 1701
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9814453125
        },
        {
            "corpus_id": "251936144",
            "title": "VMetaFlow: A Meta-Framework for Integrating Visualizations in Coordinated View Applications",
            "text": "Traditionally, a program is generated from a structured 244 sequence of words with a syntactical meaning. Alternatively, 245 visual programs use graphics and two-dimensional layouts as 246 part of the program specification [24]. This approach is easier 247 to understand and work with, as it resembles the human men-248 tal representation of problems. Unlike the one-dimensional 249 textual way, visual programming uses higher-level descrip-250 tions of the program functionality. Users without program-251 ming skills find this approach more accessible [25].",
            "score": 0.4757768092357937,
            "section_title": "C. VISUAL PROGRAMMING 243",
            "char_start_offset": 7940,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 105
                },
                {
                    "start": 106,
                    "end": 228
                },
                {
                    "start": 229,
                    "end": 351
                },
                {
                    "start": 352,
                    "end": 480
                },
                {
                    "start": 481,
                    "end": 559
                }
            ],
            "ref_mentions": [
                {
                    "start": 223,
                    "end": 227,
                    "matchedPaperCorpusId": "1351280"
                },
                {
                    "start": 554,
                    "end": 558,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9111328125
        },
        {
            "corpus_id": "214242759",
            "title": "Decision Support System of Employee Performance Evaluation",
            "text": "The word \"visual\" refers to the method used to create a graphical user interface (GUI). The word \"Basic\" refers to the BASIC (Beginners All-Purpose Symbolic Instruction Code) language, a language used by many programmers compared to other languages in computer history. Microsoft Visual Basic (often abbreviated as VB) is a programming language that offers an Integrated Development Environment (IDE) that contains commands that can be understood by computers to carry out tasks. The task can be run if there is a response from the user. The response is in the form of certain events. For example selecting a button, menu and so on. Visual Basic has become the most popular Visual programming language and is easy for the beginners to learn. Although it is often underestimated by programmers who are familiar with other high-level languages,Visual Basic is able to dominate the Visual programming. Microsoft Visual Basic is a visual programming application that has a quite popular and easy to learn.",
            "score": 0.46186137106523967,
            "section_title": "Definition of Visual Basic 6.0",
            "char_start_offset": 6482,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 87
                },
                {
                    "start": 88,
                    "end": 269
                },
                {
                    "start": 270,
                    "end": 479
                },
                {
                    "start": 480,
                    "end": 537
                },
                {
                    "start": 538,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 632
                },
                {
                    "start": 633,
                    "end": 741
                },
                {
                    "start": 742,
                    "end": 898
                },
                {
                    "start": 899,
                    "end": 1001
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88818359375
        },
        {
            "corpus_id": "86787308",
            "title": "Development of application software without programming",
            "text": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.",
            "score": 0.4483924175418692,
            "section_title": "Visual programming",
            "char_start_offset": 13785,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 345
                },
                {
                    "start": 346,
                    "end": 493
                },
                {
                    "start": 494,
                    "end": 798
                },
                {
                    "start": 801,
                    "end": 918
                },
                {
                    "start": 919,
                    "end": 1090
                },
                {
                    "start": 1091,
                    "end": 1125
                },
                {
                    "start": 1126,
                    "end": 1258
                },
                {
                    "start": 1259,
                    "end": 1408
                },
                {
                    "start": 1409,
                    "end": 1522
                },
                {
                    "start": 1523,
                    "end": 1615
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.98486328125
        },
        {
            "corpus_id": "221340525",
            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
            "text": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
            "score": 0.44188500623303695,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 3910,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 137
                },
                {
                    "start": 138,
                    "end": 339
                },
                {
                    "start": 340,
                    "end": 560
                },
                {
                    "start": 563,
                    "end": 678
                },
                {
                    "start": 679,
                    "end": 808
                },
                {
                    "start": 809,
                    "end": 894
                },
                {
                    "start": 895,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1138
                },
                {
                    "start": 1139,
                    "end": 1256
                },
                {
                    "start": 1257,
                    "end": 1350
                },
                {
                    "start": 1351,
                    "end": 1424
                },
                {
                    "start": 1425,
                    "end": 1532
                },
                {
                    "start": 1533,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1789
                },
                {
                    "start": 1790,
                    "end": 1925
                },
                {
                    "start": 1926,
                    "end": 2013
                },
                {
                    "start": 2014,
                    "end": 2152
                },
                {
                    "start": 2153,
                    "end": 2370
                }
            ],
            "ref_mentions": [
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 890,
                    "end": 893,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1009,
                    "end": 1012,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1785,
                    "end": 1788,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1803,
                    "end": 1806,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 2148,
                    "end": 2151,
                    "matchedPaperCorpusId": "17452915"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94873046875
        },
        {
            "corpus_id": "14340047",
            "title": "Programmatic and direct manipulation, together at last",
            "text": "In a recent position paper [12], we provided a broad overview of relevant program synthesis (e.g. [23,24,31]), programming by example (e.g. [1,18,26]), and bidirectional programming techniques (e.g. [22]). Here, we focus our discussion on projects related to vector graphics. \n\nSeveral projects use programming languages, direct manipulation interfaces [29], or some combination to provide expressive means for manipulating visual output. We classify them using the following interaction modes identified by Bret Victor in a talk on drawing tools [7]: \"Use\" for using built-in functionality through menus and buttons; \"Draw\" for directly manipulating domain objects; and \"Code\" for writing programs that manipulate domain objects. \n\nDynamic Drawing (Use + Draw). Victor's prototype interactive drawing editor [7], Apparatus [34], and Programming by Manipulation [21] provide expressive direct manipulation capabilities that serve as a way to build programs in restricted, domain-specific languages. By design, these tools tend to prohibit or discourage the user from manipulating content via the \"indirect\" mechanism of code. \n\nAlthough this choice may be desirable for many application domains and end users, we believe there are limits to what can be accomplished using features and transformations provided by any tool. Therefore, our work targets users who wish to work both via direct and programmatic manipulation (i.e. Draw + Code). \n\nPrograms that Generate Graphics (Code). Processing [3] is a language and environment for generating visual output that has been popular both in classroom and commercial settings. Follow-on projects, such as Processing.js [28], provide similar development environments for Web programming. These systems provide immediate and interactive output, but they do not provide ways to directly manipulate output in order to modify the program that generated it. \n\nGUIs that Generate Programs (Draw + Code). Graphical user interfaces (GUIs) for creating visual output in many domains often generate \"code behind\" what the user directly manipulates. Such tools include PaintCode [27], DrawScript [15], SVG-edit [33], and Adobe Fireworks for graphic design.",
            "score": 0.43351848955770794,
            "section_title": "Related Work",
            "char_start_offset": 48154,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 98,
                    "end": 139
                },
                {
                    "start": 140,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 205
                },
                {
                    "start": 206,
                    "end": 275
                },
                {
                    "start": 278,
                    "end": 438
                },
                {
                    "start": 439,
                    "end": 730
                },
                {
                    "start": 733,
                    "end": 762
                },
                {
                    "start": 763,
                    "end": 998
                },
                {
                    "start": 999,
                    "end": 1125
                },
                {
                    "start": 1128,
                    "end": 1322
                },
                {
                    "start": 1323,
                    "end": 1425
                },
                {
                    "start": 1426,
                    "end": 1439
                },
                {
                    "start": 1442,
                    "end": 1481
                },
                {
                    "start": 1482,
                    "end": 1620
                },
                {
                    "start": 1621,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1730
                },
                {
                    "start": 1731,
                    "end": 1895
                },
                {
                    "start": 1898,
                    "end": 1940
                },
                {
                    "start": 1941,
                    "end": 2081
                },
                {
                    "start": 2082,
                    "end": 2188
                }
            ],
            "ref_mentions": [
                {
                    "start": 27,
                    "end": 31,
                    "matchedPaperCorpusId": "9391753"
                },
                {
                    "start": 98,
                    "end": 102,
                    "matchedPaperCorpusId": "5893736"
                },
                {
                    "start": 102,
                    "end": 105,
                    "matchedPaperCorpusId": "8795162"
                },
                {
                    "start": 105,
                    "end": 108,
                    "matchedPaperCorpusId": "12707986"
                },
                {
                    "start": 140,
                    "end": 143,
                    "matchedPaperCorpusId": "16414501"
                },
                {
                    "start": 146,
                    "end": 149,
                    "matchedPaperCorpusId": "6544598"
                },
                {
                    "start": 353,
                    "end": 357,
                    "matchedPaperCorpusId": "14942172"
                },
                {
                    "start": 862,
                    "end": 866,
                    "matchedPaperCorpusId": "14162941"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.72119140625
        },
        {
            "corpus_id": "4039308",
            "title": "Visual and textual programming languages: a systematic review of the literature",
            "text": "This study is focused on the relationship between language choice and learning to program. In particular, we want to discover what effects visual programming languages have on the learning process as well as how they compared to the performance of students using traditional text-based languages. To that end, the following research questions were defined: 1. Are there any benefits of learning a visual programming language over a traditional textbased language? 2. Does the choice of First Programming Language make a difference? What languages are the best ones to teach? \n\n3 Method",
            "score": 0.4326909977268336,
            "section_title": "Research Questions",
            "char_start_offset": 2693,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 90
                },
                {
                    "start": 91,
                    "end": 296
                },
                {
                    "start": 297,
                    "end": 463
                },
                {
                    "start": 464,
                    "end": 531
                },
                {
                    "start": 532,
                    "end": 574
                },
                {
                    "start": 577,
                    "end": 585
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.71923828125
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "The paper presents an approach to learning and an environment for working with a hybrid visual - text programming language with a special emphasis on the training for future programmers at an early stage. An overview of other visual programming environments and languages is made and the advantages of the hybrid visual - text approach offered in this article are highlighted. Emphasis is placed on the practical implementation of a proprietary environment for the development of sample programs in the author's hybrid visual programming language. An example of the use of the environment is presented and perspectives for its development are formulated.",
            "score": 0.4185848365485682,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9228515625
        },
        {
            "corpus_id": "212726996",
            "title": "Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning",
            "text": "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming [9]- [10]. Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions. Study by [15] indicated that students who used the visual interface for programming spent less time off track and completed more of the activity's goals in less time when compared to those who used the textual interface for programming. Saito, Washizaki, and Fukazawa also compared the learning effects of text-based and visual-based programming and found that visual-based programming induces a larger change in attitude toward programming [16]. Therefore, research results suggest that visual-based programming is advantageous in a programming implementation environment for novice programmers. \n\nNumerous studies have shown the benefits and feasibility of visual programming environments such as Scratch (scratch. mit.edu), Alice (www.alice.org), and Kodu (www.kodugamelab.com). Since they are easy to use and understand, visual programming environments have been used as lead-in courses for more advanced computer science courses. For example, research [17]- [18] taught Scratch in a CS0 course to improve the retention rate of at-risk majors and to stimulate interest and positive attitudes toward computer science. Scratch and Kodu were also used to teach important concepts of computer science for students [19]- [21]. Furthermore, research by Werner, Denner, Campe, and Kawamoto also pointed out that visual programming environment is helpful in the development of learners' computational thinking skills [22].",
            "score": 0.41450130713776434,
            "section_title": "Visual programming environment",
            "char_start_offset": 5363,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 329
                },
                {
                    "start": 330,
                    "end": 417
                },
                {
                    "start": 418,
                    "end": 627
                },
                {
                    "start": 628,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 953
                },
                {
                    "start": 954,
                    "end": 1190
                },
                {
                    "start": 1191,
                    "end": 1400
                },
                {
                    "start": 1401,
                    "end": 1550
                },
                {
                    "start": 1553,
                    "end": 1670
                },
                {
                    "start": 1671,
                    "end": 1680
                },
                {
                    "start": 1681,
                    "end": 1703
                },
                {
                    "start": 1704,
                    "end": 1735
                },
                {
                    "start": 1736,
                    "end": 1888
                },
                {
                    "start": 1889,
                    "end": 2074
                },
                {
                    "start": 2075,
                    "end": 2179
                },
                {
                    "start": 2180,
                    "end": 2372
                }
            ],
            "ref_mentions": [
                {
                    "start": 319,
                    "end": 322,
                    "matchedPaperCorpusId": "33572463"
                },
                {
                    "start": 324,
                    "end": 328,
                    "matchedPaperCorpusId": "2965215"
                },
                {
                    "start": 963,
                    "end": 967,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 1395,
                    "end": 1399,
                    "matchedPaperCorpusId": "38535646"
                },
                {
                    "start": 1911,
                    "end": 1915,
                    "matchedPaperCorpusId": "59837822"
                },
                {
                    "start": 1917,
                    "end": 1921,
                    "matchedPaperCorpusId": "22652302"
                },
                {
                    "start": 2168,
                    "end": 2172,
                    "matchedPaperCorpusId": "16831477"
                },
                {
                    "start": 2174,
                    "end": 2178,
                    "matchedPaperCorpusId": "3344110"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96484375
        },
        {
            "corpus_id": "199002134",
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "text": "The visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
            "score": 0.41045944639441756,
            "section_title": "Visual and Block-based Programming Environment",
            "char_start_offset": 12132,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 218
                },
                {
                    "start": 219,
                    "end": 398
                },
                {
                    "start": 401,
                    "end": 547
                },
                {
                    "start": 548,
                    "end": 674
                },
                {
                    "start": 675,
                    "end": 679
                },
                {
                    "start": 680,
                    "end": 973
                },
                {
                    "start": 974,
                    "end": 1205
                },
                {
                    "start": 1208,
                    "end": 1409
                },
                {
                    "start": 1410,
                    "end": 1624
                },
                {
                    "start": 1625,
                    "end": 1871
                },
                {
                    "start": 1874,
                    "end": 2034
                },
                {
                    "start": 2035,
                    "end": 2150
                },
                {
                    "start": 2153,
                    "end": 2335
                },
                {
                    "start": 2336,
                    "end": 2430
                }
            ],
            "ref_mentions": [
                {
                    "start": 394,
                    "end": 397,
                    "matchedPaperCorpusId": "17459721"
                },
                {
                    "start": 416,
                    "end": 420,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1404,
                    "end": 1408,
                    "matchedPaperCorpusId": "59528289"
                },
                {
                    "start": 1619,
                    "end": 1623,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 1866,
                    "end": 1870,
                    "matchedPaperCorpusId": "51750550"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.98291015625
        },
        {
            "corpus_id": "250414169",
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "text": "In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011;Tsai, 2019). Through simulation, visual programming environments can provide more complex and richer functionality than the physical boundaries of artefacts in the material world allow. Direct feedback obtained from visual output may be experienced as more powerful than feedback obtained via tangible output (Caci et al., 2013a(Caci et al., , 2013b;;Sefidgar et al., 2017). Visual programming environments also often include integrated, directional incentives which provide the user with instant information on whether the programming solution is the optimal one, or whether it could be constructed more efficiently. These incentives provide guidance, and the user may decide to use them when support is needed (Karalekas et al., 2020). Seen from these perspectives, visual programming environments offer excellent opportunities for solving challenging programming problems and acquiring CT (Papadakis et al., 2016;Rose et al., 2017). \n\nIn programming with a visual output, the application and execution of each programming operation is displayed purely on a screen (Sapounidis et al., 2015). The information obtained from the programmed operation can be characterised as two-dimensional percipient (Mladenovi\u0107 et al., 2020;Price et al., 2003). The elaboration of programming actions appeals to the more abstract imagine ability and reasoning capacity of the user (Price & Barnes, 2015), but it is not possible to fall back on the tangible and physically perceptible (Horn & Bers, 2019; 2023) 10(2):433-462 O' Malley & Fraser, 2004;Sefidgar et al., 2017;Skulmowski et al., 2016). Nothing can be grasped in a hands-on way, and the execution of the programming action cannot be seen from more than one point of view (Sapounidis et al., 2015).",
            "score": 0.4064586197702927,
            "section_title": "Theoretical framework",
            "char_start_offset": 15527,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 234
                },
                {
                    "start": 235,
                    "end": 481
                },
                {
                    "start": 482,
                    "end": 654
                },
                {
                    "start": 655,
                    "end": 843
                },
                {
                    "start": 844,
                    "end": 1086
                },
                {
                    "start": 1087,
                    "end": 1206
                },
                {
                    "start": 1207,
                    "end": 1404
                },
                {
                    "start": 1407,
                    "end": 1562
                },
                {
                    "start": 1563,
                    "end": 1714
                },
                {
                    "start": 1715,
                    "end": 2049
                },
                {
                    "start": 2050,
                    "end": 2210
                }
            ],
            "ref_mentions": [
                {
                    "start": 214,
                    "end": 233,
                    "matchedPaperCorpusId": "27633066"
                },
                {
                    "start": 448,
                    "end": 469,
                    "matchedPaperCorpusId": "8626769"
                },
                {
                    "start": 469,
                    "end": 480,
                    "matchedPaperCorpusId": "92996231"
                },
                {
                    "start": 778,
                    "end": 797,
                    "matchedPaperCorpusId": "62642207"
                },
                {
                    "start": 820,
                    "end": 842,
                    "matchedPaperCorpusId": "18844251"
                },
                {
                    "start": 1181,
                    "end": 1205,
                    "matchedPaperCorpusId": "217547495"
                },
                {
                    "start": 1361,
                    "end": 1385,
                    "matchedPaperCorpusId": "29749744"
                },
                {
                    "start": 1385,
                    "end": 1403,
                    "matchedPaperCorpusId": "54650229"
                },
                {
                    "start": 1669,
                    "end": 1694,
                    "matchedPaperCorpusId": "225393741"
                },
                {
                    "start": 1694,
                    "end": 1713,
                    "matchedPaperCorpusId": "3523310"
                },
                {
                    "start": 1834,
                    "end": 1856,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 2002,
                    "end": 2024,
                    "matchedPaperCorpusId": "18844251"
                },
                {
                    "start": 2024,
                    "end": 2048,
                    "matchedPaperCorpusId": "10493691"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9580078125
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "The objectives of this research subject are:\n\n1. Creating a Framework for creating visual programming languages to help us in creating the visual programming language components faster. The framework must contains the designers and domain-specific language to quickly create the visual programming language components. The implementation of each component should be done in little minutes to ensure the high-level of productivity. 2. Designing a General-Purpose visual programming language to make programming easier to understand for audiences other than programmers and to help expert programmers to quickly create programs and applications in less time. 3. Implementing the General-Purpose visual programming language through an information system that support programs and applications creation and manipulation, to reduce errors and to help users program faster. 4. Evaluating the system in developing business applications and comparing this to using other traditional programming languages that are text based.",
            "score": 0.4064586197702927,
            "section_title": "Research Objectives",
            "char_start_offset": 11043,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 657,
                    "end": 658,
                    "matchedPaperCorpusId": "62213603"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94140625
        },
        {
            "corpus_id": "244060650",
            "title": "Programming by Blocks",
            "text": "To start learning to program it is necessary to make an analysis of the development environment as well as the programming language, to know which would be the most viable for students to interact within this process and learn in the best way. For example, for Revell \"A typical text-based programming language makes the programmer think like a computer, a visual programming language allows the programmer to describe it as a collection of graphics intended to solve an event\" [Revell, 2018]. \n\nVisual programming languages allow people using this methodology to have a more graphical way to solve problems, using programming elements that can be displayed as images or words in a development environment as Boshernitsan and Downes (2004), point out \"such languages are characterized by their reliance on visual techniques throughout the programming process. The programmer manipulates icons or other graphical representations to create a program, which is then debugged and executed in the same visual environment\". This workshop introduces the main programming concepts using a graphical language such as Scratch, which is explained in Section 1.3, and to achieve this, the computational thinking explained in Section 1.2 is applied 1.5. Wing (2006) indicates that the \"Computational thinking involves problem solving, system design and understanding of human behavior using the fundamental concepts of computer science\". To implement its resolution, computer science resorts to the area of programming, which is the necessary set of instructions given to a machine to be able to perform a specific task. Unlike digital literacy, which involves acquiring a series of basic skills in the use of hardware and software, languages and new forms of communication, digital literacy is not a new skill [UNESCO, 2021].",
            "score": 0.39857759446045876,
            "section_title": "Introduction to programming",
            "char_start_offset": 30,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 243
                },
                {
                    "start": 244,
                    "end": 493
                },
                {
                    "start": 496,
                    "end": 859
                },
                {
                    "start": 860,
                    "end": 1017
                },
                {
                    "start": 1018,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1424
                },
                {
                    "start": 1425,
                    "end": 1607
                },
                {
                    "start": 1608,
                    "end": 1813
                }
            ],
            "ref_mentions": [
                {
                    "start": 478,
                    "end": 492,
                    "matchedPaperCorpusId": "59670739"
                },
                {
                    "start": 1241,
                    "end": 1252,
                    "matchedPaperCorpusId": "41391768"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89453125
        },
        {
            "corpus_id": "257145390",
            "title": "Computational Thinking Training and Deep Learning Evaluation Model Construction Based on Scratch Modular Programming Course",
            "text": "Visual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation [23]. Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan [24]. Figure 4 reveals the visual programming problem-solving model. \n\nAs shown in Figure 4, a plan is formed through CT and methods, and a visual programming platform program is built according to the plan. After the platform is debugged, the solution to the problem is obtained and mapped to the real situation. Trough the real situation, questions can be raised and fed back to the CTmethods. Te real situation can further extract the elements in the real situation, such as people, things, things and rules. Finally, the problem is solved.",
            "score": 0.39857759446045876,
            "section_title": "Visual Programming Problem-Solving Model.",
            "char_start_offset": 9036,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 167
                },
                {
                    "start": 168,
                    "end": 338
                },
                {
                    "start": 339,
                    "end": 493
                },
                {
                    "start": 494,
                    "end": 556
                },
                {
                    "start": 559,
                    "end": 695
                },
                {
                    "start": 696,
                    "end": 801
                },
                {
                    "start": 802,
                    "end": 883
                },
                {
                    "start": 884,
                    "end": 999
                },
                {
                    "start": 1000,
                    "end": 1031
                }
            ],
            "ref_mentions": [
                {
                    "start": 333,
                    "end": 337,
                    "matchedPaperCorpusId": "235749050"
                },
                {
                    "start": 488,
                    "end": 492,
                    "matchedPaperCorpusId": "237732833"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96044921875
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "[ Introduction ] ( Start timing! 60 min max. ) Hello, my name is X. First, I would like to thank you for your participation and completing the consent form. Today, you will be a participant in a user study regarding machine learning and visual programming. Your data will be kept anonymous. Additionally, as a researcher I have no position on this topic and ask that you be as open, honest, and detailed in your answers as possible. Do you have any questions before we begin? \n\nBasically, visual programming borrows the metaphor of block building and allows novice users to develop digital functionalities without writing codes. \n\n[Show Visual Blocks] Here, each block is called a node, and each node takes in specific inputs, then returns the desired outputs. What you can do is to connect a series of nodes together as a pipeline to achieve a highlevel goal. \n\nWe are going to walk you through our Visual Blocks system and ask you to actually use Visual Blocks in two conditions to create a few applications. \n\n[ Tutorial ]( Start timing! 10 min max. ) Before we get started, let us do a tutorial of our system. \n\n[ That's all for our user study. Thank you for your participation and we will compensate for your time.",
            "score": 0.39857759446045876,
            "section_title": "D User Evaluation D.1 Semi-structured Interview Script",
            "char_start_offset": 61142,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 32
                },
                {
                    "start": 33,
                    "end": 67
                },
                {
                    "start": 68,
                    "end": 156
                },
                {
                    "start": 157,
                    "end": 256
                },
                {
                    "start": 257,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 432
                },
                {
                    "start": 433,
                    "end": 475
                },
                {
                    "start": 478,
                    "end": 628
                },
                {
                    "start": 631,
                    "end": 760
                },
                {
                    "start": 761,
                    "end": 860
                },
                {
                    "start": 863,
                    "end": 1010
                },
                {
                    "start": 1013,
                    "end": 1113
                },
                {
                    "start": 1116,
                    "end": 1148
                },
                {
                    "start": 1149,
                    "end": 1219
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92578125
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "languages. According to our study we see a gap in attracting mainstream programmers to using visual programming languages in each new programming task. The current VPLs are not equivalent to the current textual programming languages at the practical side. Yes, some limitations are a result of missing features that can be added but this doesn't count only for \"what we can do?\" but for \"how we can do things with respect to the productivity of the programmer during software development and the quality of the final software\".\n\nWe provided the requirements of a general purpose visual programming tool that can be used as replacement for the usage of popular programming languages like ( C,C++, C# and Java) + (visual programming environments like Visual Studio and Netbeans). We expect that after the implementation and marketing of this new tool, many new software projects can be developed using Visual Programming Language in less time with high quality. Also we expect attracting more users to real programming industry after the existence of this tool.\n\nAlso in this thesis, PWCT was presented. PWCT is a novel general purpose VPL that was designed to compete with textual programming languages such as C++ and Java. The novelty of this work comes from the invention of a technique called GCR. GCR uses graphical components to replace textual code in an easy and seamless process. PWCT's architecture, design, and implementation were covered in this thesis.\n\nThree types of evaluations were used to make sure that PWCT is a competitive VPL.\n\nUsability and capability evaluation shows that PWCT is extremely easy to use and requires a very short time for learning. Moreover, Efficiency evaluations show that PWCT requires",
            "score": 0.39557691271095835,
            "section_title": "Reputation Evaluation",
            "char_start_offset": 76357,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9404296875
        },
        {
            "corpus_id": "259335765",
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "text": "For example, the block that starts a program will only allow blocks to be attached after it instead of before it considering that it does not make sense to have blocks before the start of a program. \n\nAlongside the graphical programming language, we co-developed a game that introduces basic parallel programming concepts and assesses how the player solves parallel programming problems. Our framework is based on prior work on teaching programming to beginners such as in the \"hour of code\" challenge [10]. In the \"hour of code\" challenge, grade -school students learn basic programming concepts and skills using visual programming languages to perform tasks in a game environment. Using this framework, we conducted a preliminary study of how novice programmers solve parallel programming problems. This study was conducted on volunteer participants who were recruited from an introductory core course on cyber security and sought to validate the framework. \n\nThe contributions of the paper are as follows: \n\n\u2022 Proposes a novel use of visual programming languages and serious games for studying novice programmers' ability to understand and use complex language features \u2022 Demonstrates, with a user study, the use of this framework to evaluate novice programmers' ability to solve parallel programming problems involving synchronization \u2022 Provides a framework for future researchers to use to evaluate the usability of programming language features \n\nThe remainder of this paper is organized as follows. Section 2 introduces relevant background material on visual programming languages and parallel programming. Section 3 first describes the programming frameworks that we used to develop the graphical programming language and corresponding game and then describes how the parallel programming problems included in the game relate to real-world parallel programming tasks. Section 4 discusses the implementation of this framework and technical challenges. Section 5 presents the results of the study that we conducted using this framework. Section 6 suggests future improvements that can be made to this framework and concludes the paper.",
            "score": 0.39506927811656245,
            "section_title": "Introduction",
            "char_start_offset": 2455,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 198
                },
                {
                    "start": 201,
                    "end": 387
                },
                {
                    "start": 388,
                    "end": 507
                },
                {
                    "start": 508,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 800
                },
                {
                    "start": 801,
                    "end": 959
                },
                {
                    "start": 962,
                    "end": 1008
                },
                {
                    "start": 1011,
                    "end": 1450
                },
                {
                    "start": 1453,
                    "end": 1505
                },
                {
                    "start": 1506,
                    "end": 1613
                },
                {
                    "start": 1614,
                    "end": 1875
                },
                {
                    "start": 1876,
                    "end": 1958
                },
                {
                    "start": 1959,
                    "end": 2042
                },
                {
                    "start": 2043,
                    "end": 2141
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83544921875
        },
        {
            "corpus_id": "4793447",
            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
            "text": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
            "score": 0.3921970797649854,
            "section_title": "WORK DEVELOPED",
            "char_start_offset": 5574,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 155
                },
                {
                    "start": 156,
                    "end": 300
                },
                {
                    "start": 301,
                    "end": 449
                },
                {
                    "start": 450,
                    "end": 617
                },
                {
                    "start": 618,
                    "end": 799
                },
                {
                    "start": 800,
                    "end": 1104
                },
                {
                    "start": 1105,
                    "end": 1213
                },
                {
                    "start": 1214,
                    "end": 1426
                },
                {
                    "start": 1427,
                    "end": 1477
                },
                {
                    "start": 1478,
                    "end": 1540
                },
                {
                    "start": 1541,
                    "end": 1650
                },
                {
                    "start": 1651,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1850
                },
                {
                    "start": 1851,
                    "end": 1936
                },
                {
                    "start": 1937,
                    "end": 2045
                },
                {
                    "start": 2046,
                    "end": 2161
                },
                {
                    "start": 2162,
                    "end": 2230
                },
                {
                    "start": 2231,
                    "end": 2370
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97802734375
        },
        {
            "corpus_id": "276684953",
            "title": "Two Approaches for Programming Education in the Domain of Graphics: An Experiment",
            "text": "There are multiple senses in which programming education can be related to graphics. This section clarifies the scope of this work. \n\nA fundamental separation exists between graphical and text-based programming. Doing 'graphical programming' commonly means using a visual programming language to create programs graphically, instead of textually. Scratch [33] is an example of a visual programming language popular in educational contexts at the school level. Scratch programs are composed of 'blocks' connected visually. The success of blockbased visual programming languages led to the creation of Blockly [44], a library that facilitates the creation of other block-based languages. Scratch also inspired the creation of Snap! [26], a block-based language in which users can define their own blocks. Our work instead concerns text-based programming languages, which university-level educational contexts use more frequently. \n\nEven when written using text-based programming languages, programs can involve 'the domain of graphics' to different extents. For instance, a program can produce 'static' graphics (2D or 3D), 'animated' graphics, or 'interactive' graphics (known as Graphical User Interfaces). \n\nWhile creating interactive graphical programs has also been explored as a possibility to learn programming (e.g., [17,34]), our work focuses on approaches to create static 2D graphics, among which there is already considerable variety.",
            "score": 0.3908534054751986,
            "section_title": "Graphics and Programming Education",
            "char_start_offset": 3499,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 84
                },
                {
                    "start": 85,
                    "end": 131
                },
                {
                    "start": 134,
                    "end": 211
                },
                {
                    "start": 212,
                    "end": 346
                },
                {
                    "start": 347,
                    "end": 459
                },
                {
                    "start": 460,
                    "end": 521
                },
                {
                    "start": 522,
                    "end": 685
                },
                {
                    "start": 686,
                    "end": 802
                },
                {
                    "start": 803,
                    "end": 927
                },
                {
                    "start": 930,
                    "end": 1055
                },
                {
                    "start": 1056,
                    "end": 1206
                },
                {
                    "start": 1209,
                    "end": 1444
                }
            ],
            "ref_mentions": [
                {
                    "start": 355,
                    "end": 359,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 608,
                    "end": 612,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 730,
                    "end": 734,
                    "matchedPaperCorpusId": "220755838"
                },
                {
                    "start": 1323,
                    "end": 1327,
                    "matchedPaperCorpusId": "3102760"
                },
                {
                    "start": 1327,
                    "end": 1330,
                    "matchedPaperCorpusId": "14479674"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.72314453125
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "The questions that we aim to answer during this thesis are:\n\n1. What are the problems that prevent mainstream programmers from using the current visual programming languages?\n\n2. What is the design of a general-purpose visual programming language that can solve mainstream programmers problems and encourage them to use the proposed visual programming language in developing practical software?",
            "score": 0.3832814172581209,
            "section_title": "Research Questions",
            "char_start_offset": 10626,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9423828125
        },
        {
            "corpus_id": "111507400",
            "title": "VISUAL PROGRAMMING FOR BUILDING INFORMATION MODELING: ENERGY AND SHADING ANALYSIS CASE STUDIES",
            "text": "INTRODUCTION Although visual programming is being broadly implemented in other disciplines, it has only relatively recently become an important supplement to three-dimensional modeling programs in ...",
            "score": 0.37955109953353117,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91796875
        },
        {
            "corpus_id": "233252446",
            "title": "Evolution of Human Computer Interaction",
            "text": "In the eighties, a large number of scientific journals devoted to computer topics were published. The materials of these journals were available to domestic researchers either through scientific libraries or through abstract journals, in which reports of almost all scientific articles were published. The full texts of these articles were available on paper or microfilm. The analysis of publications related to computer graphics allowed to identify the emergence of two new directions the visual programming and the program visualization. It is interesting that at first it was difficult to separate these concepts due to the similarity of the names. \n\nVisual programming implied the use of graphics, in particular schemes, diagrams, iconic images (icons) in the process of developing programs. Visualization of programming assumed that already developed programs were presented in the form of the same graphic elements. Within the framework of programming visualization, one could single out such sections as animation of algorithms, visual debugging etc. The ideas of visual programming languages appeared in the seventies when computer graphics systems began to work quite steadily. Visual languages of the seventies were built on the basis of flowcharts or diagrams of Nassi-Shneiderman, which served to describe structured programming. This direction had developed sufficiently by the end of the eighties. Diagrammatic and iconic programming languages were developed, compilers of visual languages were created, [24]. The first animation system for algorithms was developed back in the mid-sixties. Individual frames were shot on film, and the result was a movie describing the operation of the algorithm. In the eighties, animation systems of algorithms were implemented onthe basis of modern computer graphics at that time [25]. An interesting idea of algorithmic operations was proposed which served as the basis for the animation \"script\" [26]. \n\nIn general,visual debuggers were based on ideas for interactive debugging. The user had the opportunity to view, for example, the program trace to see a graphical displaying the data that the user was interested in. The development of visual debugging systems for parallel computing began. For this purpose both natural graphics for the application were being debugged and traditional schemes and diagrams could be used. The idea of creating software visual complexes was put forward, which consisted in the fact that both the development of programs, their debugging and their maintenance had to be carried out within a single system with the same graphical representation of software entities.",
            "score": 0.37955109953353117,
            "section_title": "Visualization software",
            "char_start_offset": 32910,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 98,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 372
                },
                {
                    "start": 373,
                    "end": 540
                },
                {
                    "start": 541,
                    "end": 652
                },
                {
                    "start": 655,
                    "end": 796
                },
                {
                    "start": 797,
                    "end": 922
                },
                {
                    "start": 923,
                    "end": 1058
                },
                {
                    "start": 1059,
                    "end": 1187
                },
                {
                    "start": 1188,
                    "end": 1342
                },
                {
                    "start": 1343,
                    "end": 1412
                },
                {
                    "start": 1413,
                    "end": 1524
                },
                {
                    "start": 1525,
                    "end": 1605
                },
                {
                    "start": 1606,
                    "end": 1712
                },
                {
                    "start": 1713,
                    "end": 1837
                },
                {
                    "start": 1838,
                    "end": 1955
                },
                {
                    "start": 1958,
                    "end": 2032
                },
                {
                    "start": 2033,
                    "end": 2173
                },
                {
                    "start": 2174,
                    "end": 2247
                },
                {
                    "start": 2248,
                    "end": 2378
                },
                {
                    "start": 2379,
                    "end": 2653
                }
            ],
            "ref_mentions": [
                {
                    "start": 1519,
                    "end": 1523,
                    "matchedPaperCorpusId": "47545019"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87646484375
        },
        {
            "corpus_id": "270427107",
            "title": "Formation of an information retrieval system of visual programming scenarios for information modeling software complexes",
            "text": "In recent years, visual programming tools in the information modeling environment have become increasingly popular. Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2] The main purpose of using visual programming, including in the information modeling environment, is to expand the functionality of the software package by developing its own functions. As a result, designers can automate routine tasks and go beyond the basic functionality of the program. [3] Visual programming includes a library of previously prepared program code blocks in the form of a graphical node element. Formed in a certain way by a set of nodes is a scriptscript, as a result of which one or another task is performed automatically. Simultaneously with the basic node library, additional packages created by users can be added to the program. [4][5] The spread and development of visual programming in the information modeling environment has led to a sharp increase in the number of scripts both in a particular company and in the industry as a whole. And already today, large project companies are faced with the difficulties of interacting with a large number of scripts that perform various functions. There are problems with storing, searching, processing and updating scripts, which leads to an increase in the duration of the design and additional labor costs of specialists. [6][7] Thus, it is advisable to create a tool that will eliminate the problems of working with a large number of different types of scripts. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation (Structured Query Language) to filter the necessary scripts.",
            "score": 0.37955109953353117,
            "section_title": "Introdution",
            "char_start_offset": 14,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 256
                },
                {
                    "start": 257,
                    "end": 367
                },
                {
                    "start": 368,
                    "end": 559
                },
                {
                    "start": 560,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 789
                },
                {
                    "start": 790,
                    "end": 919
                },
                {
                    "start": 920,
                    "end": 1029
                },
                {
                    "start": 1030,
                    "end": 1239
                },
                {
                    "start": 1240,
                    "end": 1392
                },
                {
                    "start": 1393,
                    "end": 1569
                },
                {
                    "start": 1570,
                    "end": 1710
                },
                {
                    "start": 1711,
                    "end": 2052
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96630859375
        },
        {
            "corpus_id": "257496495",
            "title": "Live, Rich, and Composable: Qualities for Programming Beyond Static Text",
            "text": "To this day, though, programmers articulate their thoughts as linear text.\" Similarly, Omar et al. [34] write: \"Diagrams have played a pivotal role in mathematical thought since antiquity, indeed predating symbolic mathematics. Popular computing and creative tooling, too, has embraced visual representation and direct manipulation interfaces for decades. Programming, however, has remained stubbornly mired in textual user interfaces.\" \n\nBefore digging into examples of rich programming systems, we should clarify what we do not mean by \"rich\": A programming system being \"visual\" does not, in and of itself, make it rich in our sense. Many visual programming systems use visual structures to represent the general-purpose, generic structures of textual programming, such as dataflow or control structures. This is not heterogeneous, domain-specific richness. 5 Programming systems that are visual without being rich include block-based programming languages like Scratch [35], node-and-wire editors like Natto [24] and Unreal Engine's \"Blueprints\" [36], visual structure editors like the \"frame-based\" editor in Greenfoot [37], and classic \"visual programming languages\" including VIPR [38], Prograph [39], Forms/3 [40], and Cube [41]. \n\nWe have picked a particularly narrow scope when drawing the boundaries of \"richness\", in order to focus on alternatives to static text that capture the rich, heterogeneous interactivity we have come to expect from applications. This definition is still a work in progress. We welcome continued conversation as part of the shared process of sense-making in our community.",
            "score": 0.3787726998093364,
            "section_title": "Richness",
            "char_start_offset": 9962,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 75
                },
                {
                    "start": 76,
                    "end": 227
                },
                {
                    "start": 228,
                    "end": 355
                },
                {
                    "start": 356,
                    "end": 436
                },
                {
                    "start": 439,
                    "end": 636
                },
                {
                    "start": 637,
                    "end": 807
                },
                {
                    "start": 808,
                    "end": 862
                },
                {
                    "start": 863,
                    "end": 1237
                },
                {
                    "start": 1240,
                    "end": 1467
                },
                {
                    "start": 1468,
                    "end": 1512
                },
                {
                    "start": 1513,
                    "end": 1610
                }
            ],
            "ref_mentions": [
                {
                    "start": 99,
                    "end": 103,
                    "matchedPaperCorpusId": "235474027"
                },
                {
                    "start": 973,
                    "end": 977,
                    "matchedPaperCorpusId": "229934947"
                },
                {
                    "start": 1124,
                    "end": 1128,
                    "matchedPaperCorpusId": "62831677"
                },
                {
                    "start": 1217,
                    "end": 1221,
                    "matchedPaperCorpusId": "206575759"
                },
                {
                    "start": 1232,
                    "end": 1236,
                    "matchedPaperCorpusId": "42620134"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8154296875
        },
        {
            "corpus_id": "246448099",
            "title": "The Effects on Secondary School Students of Applying Experiential Learning to the Conversational AI Learning Curriculum",
            "text": "in teaching programming than is conventional command-line programming with complex syntax (Cetin, 2016). In this study, visual programming tools referred to block-based programming tools such as MIT App Inventor or Scratch. In comparison with conventional text-based programming, such visual programming tools have been helpful for novices to fully focus on learning to solve problems as well as understand the logic and framework of the overall program, rather than attend to specific semantics or syntax (Grover & Pea, 2013;Hsu et al., 2018;Lye & Koh, 2014).",
            "score": 0.375857175152596,
            "section_title": "Introduction",
            "char_start_offset": 2183,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 526,
                    "end": 543,
                    "matchedPaperCorpusId": "52813623"
                },
                {
                    "start": 543,
                    "end": 559,
                    "matchedPaperCorpusId": "11994747"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7001953125
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Thereafter, the study explains the methodology of this systematic literature review including the research questions. Subsequently, the study presents the results of answering the research questions by examining the visual programming tools presented in the selected articles against 12 dimensions: classification of visual programming, interaction style, target users, domain, platform, empirical evidence, types of test participants, number of test participants, programming skills of test participants, evaluation methods, evaluation measures, and accessibility. Thereafter, challenges and future research directions are discussed. Finally, the key findings are presented in the conclusion.",
            "score": 0.375857175152596,
            "section_title": "I. INTRODUCTION",
            "char_start_offset": 4572,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 117
                },
                {
                    "start": 118,
                    "end": 565
                },
                {
                    "start": 566,
                    "end": 634
                },
                {
                    "start": 635,
                    "end": 693
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91650390625
        },
        {
            "corpus_id": "68068900",
            "title": "Application of Visual Programming in Program Design Course",
            "text": "According to the problems in teaching of computer programming course, brought visual programming tools to assist teaching, introduced the advantages of visual programming, and made use of it in algorithm design, coding and modular design. Practice shows that by introducing of visual programming, it helps the students to improve their interesting, and develop the ability of logic thinking as well as programming. Introduction Computer programming is a basic course for college students of science and engineering majors, it aims to guide students to understand the ideas and methods of programming, and to master a language to solve problems by programming [1] . In recent years, with the propose and development of computational thinking [2] , it is becoming a trend to solve problems in various fields by means of computational methods and tools, thus it becomes more and more important of this course. But in teaching practice, it is quite difficult to reach the objects of this course. Firstly, it needs great efforts on coding and debugging of programs, but Students are often afraid of tedious syntax of the language, and finally lost confidence for programming when meet program errors again and again. Secondly, the procedure of programming is indeed a procedure of logical thinking, but for many fresh students, the ability of logical thinking is still weak, there is some difficulty for them to understand the logic of programs, so we need a gradual training method for logical thinking. Thirdly, the flow diagram that been used for expressing the algorithm, but for it cannot be executed, there has no way to verify the result of the algorithm, we need stronger tools to express algorithms and verify them. In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm.",
            "score": 0.3721991141151649,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96533203125
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Our study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains. Moreover, the study sheds light on commonalities and differences between tools of the same or different approaches or domains. Finally, the study discusses only the approaches that are backed up by empirical evidence. The details of the empirical evidence are thoroughly discussed in the study.",
            "score": 0.3721991141151649,
            "section_title": "B. VISUAL PROGRAMMING REVIEW STUDIES",
            "char_start_offset": 18048,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 321
                },
                {
                    "start": 322,
                    "end": 448
                },
                {
                    "start": 449,
                    "end": 539
                },
                {
                    "start": 540,
                    "end": 616
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93896484375
        },
        {
            "corpus_id": "86787308",
            "title": "Development of application software without programming",
            "text": "Visual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
            "score": 0.3721991141151649,
            "section_title": "Visual programming and parametrization",
            "char_start_offset": 15443,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 218
                },
                {
                    "start": 219,
                    "end": 380
                },
                {
                    "start": 381,
                    "end": 518
                },
                {
                    "start": 519,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 1062
                },
                {
                    "start": 1063,
                    "end": 1185
                },
                {
                    "start": 1188,
                    "end": 1338
                },
                {
                    "start": 1339,
                    "end": 1609
                },
                {
                    "start": 1610,
                    "end": 1847
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.984375
        },
        {
            "corpus_id": "257496495",
            "title": "Live, Rich, and Composable: Qualities for Programming Beyond Static Text",
            "text": "Alternatives to static textual code have been explored since the advent of interactive computing. The earliest user interfaces included systems for programmatic CAD [1] and flow-chart programming [2], [3]. These were soon followed by the spreadsheet, which remains an exemplar of end-user programming [4]. \n\nThere are many reasons to depart from static text. The most prominent is the desire to make programming more accessible. Students of programming and potential end-user programmers face serious obstacles approaching conventional programming languages. Perhaps new interfaces could unlock programmatic power for more people. Others have focused instead on how static text forces all programmers (even experts) to interact with artifacts as diverse as data visualizations and interactive games through abstract, indirect representations. Perhaps new interfaces could bridge this gap, giving \"creators\u2026 an immediate connection to what they create\" [5]. \n\nDriven by these motives, researchers and tool-builders have built an enormous diversity of programming systems beyond static text, ranging from spreadsheets to block-based editors to exotic visual programming languages. It is clear that static text is a single point in vast space of possible programming environments. To make sense of what might otherwise be an overwhelming cloud of point examples, we will identify fundamental qualities that these designs advance. \n\nWe focus on two core qualities that have emerged in efforts beyond static text. The first quality is liveness: providing programmers with in-depth feedback about a program's dynamic behavior as the program is edited. This quality is well-established in the computer-science literature. 1 The second quality is as yet unnamed, though its pursuit is implicit in many projects: allowing programmers to work with domain-specific visualizations and interactions. We offer richness as a new term of art to better pin down this quality for analysis. \n\nWe look at these two qualities, surveying systems that exemplify them in different combinations. In the course of this analysis, we run into a third quality called composability: the ability to freely combine smaller programmed artifacts into larger ones, to accomplish larger goals. Unlike liveness and richness, this is not a quality static text lacks, which interactive programming systems strive to add to it. Rather, it is a familiar quality of static text which new programming systems must work hard to maintain.",
            "score": 0.370094466442481,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 98,
                    "end": 205
                },
                {
                    "start": 206,
                    "end": 305
                },
                {
                    "start": 308,
                    "end": 358
                },
                {
                    "start": 359,
                    "end": 428
                },
                {
                    "start": 429,
                    "end": 558
                },
                {
                    "start": 559,
                    "end": 630
                },
                {
                    "start": 631,
                    "end": 842
                },
                {
                    "start": 843,
                    "end": 956
                },
                {
                    "start": 959,
                    "end": 1178
                },
                {
                    "start": 1179,
                    "end": 1277
                },
                {
                    "start": 1278,
                    "end": 1426
                },
                {
                    "start": 1429,
                    "end": 1508
                },
                {
                    "start": 1509,
                    "end": 1645
                },
                {
                    "start": 1646,
                    "end": 1886
                },
                {
                    "start": 1887,
                    "end": 1971
                },
                {
                    "start": 1974,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2387
                },
                {
                    "start": 2388,
                    "end": 2493
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6923828125
        },
        {
            "corpus_id": "246448099",
            "title": "The Effects on Secondary School Students of Applying Experiential Learning to the Conversational AI Learning Curriculum",
            "text": "In conventional programming, programs are written with strict syntax, which can be difficult for general populations to learn, especially non-native English speakers, since a program cannot run successfully it has even minor spelling errors. On the other hand, if students use block-based programming to build the program, these errors will not occur. Block-based programming emphasizes recognition over recall; code-blocks are readily available in the visual interface. Furthermore, the blocks are categorized according to their function or logic. Students only need to concentrate on using appropriate blocks to complete the work they want to do or to create the effect they desire, rather than memorize syntax or particular keywords of the programming language. Moreover, the shape and color of the blocks provide the students with scaffolding to emphasize which blocks can be linked together and how code can (or cannot) be developed. During this process of visual code development, students learn the concepts of programming, students usually need only drag and connect the blocks, reducing the cognitive load and allowing students to focus on the logic and structures involved in programming rather than the syntax of writing programs (Kelleher & Pausch, 2005). Block-based programming provides students with media-rich learning environments, allowing them to connect with various personal interests (Brennan & Resnick, 2012). Chiu (2020) discovered that learners were very positive about the creation of applications (apps) by visual programming and project development, and recommended that novice programmers create apps with block-based programming. Finally, when students used a visual programming tool to write a program, they tended to focus on solving problems. Researchers have indicated that visual programming tools have a positive impact on programming self-efficacy and decrease student frustration (Yukselturk & Altiok, 2017).\n\nIt is especially important to reduce learning frustration for those who are underrepresented in computer science, as they face additional challenges when they first enter the field. Furthermore, it is important to increase their participation in computer science, as underrepresented groups provide unique perspectives and diverse, innovative solutions. In this paper, we investigated the effectiveness of different learning techniques by gender, since historically, females have been underrepresented in computer science, and the relative number of females entering the field has significantly decreased over the past 30 years (Weston et al., 2019). By determining and using the most effective",
            "score": 0.3700067708681244,
            "section_title": "Literature Review",
            "char_start_offset": 2764,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1241,
                    "end": 1266,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 1433,
                    "end": 1444,
                    "matchedPaperCorpusId": "212726996"
                },
                {
                    "start": 1918,
                    "end": 1945,
                    "matchedPaperCorpusId": "7007858"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.72265625
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.",
            "score": 0.369000986686166,
            "section_title": "1) FORM-BASED TOOLS",
            "char_start_offset": 28883,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 216
                },
                {
                    "start": 217,
                    "end": 404
                },
                {
                    "start": 405,
                    "end": 478
                },
                {
                    "start": 481,
                    "end": 576
                },
                {
                    "start": 577,
                    "end": 735
                },
                {
                    "start": 736,
                    "end": 790
                },
                {
                    "start": 791,
                    "end": 901
                },
                {
                    "start": 902,
                    "end": 978
                },
                {
                    "start": 981,
                    "end": 1046
                },
                {
                    "start": 1047,
                    "end": 1144
                },
                {
                    "start": 1145,
                    "end": 1179
                },
                {
                    "start": 1180,
                    "end": 1238
                },
                {
                    "start": 1239,
                    "end": 1434
                },
                {
                    "start": 1437,
                    "end": 1551
                },
                {
                    "start": 1552,
                    "end": 1676
                },
                {
                    "start": 1677,
                    "end": 1817
                },
                {
                    "start": 1818,
                    "end": 1927
                },
                {
                    "start": 1928,
                    "end": 2071
                },
                {
                    "start": 2074,
                    "end": 2242
                }
            ],
            "ref_mentions": [
                {
                    "start": 239,
                    "end": 243,
                    "matchedPaperCorpusId": "146808112"
                },
                {
                    "start": 338,
                    "end": 342,
                    "matchedPaperCorpusId": "218969033"
                },
                {
                    "start": 508,
                    "end": 512,
                    "matchedPaperCorpusId": "146808112"
                },
                {
                    "start": 1041,
                    "end": 1045,
                    "matchedPaperCorpusId": "218969033"
                },
                {
                    "start": 1452,
                    "end": 1456,
                    "matchedPaperCorpusId": "67453782"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.970703125
        },
        {
            "corpus_id": "68068900",
            "title": "Application of Visual Programming in Program Design Course",
            "text": "it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm. The Usage of Visual Programming in Teaching Practice The author have practiced visual programming in three stage. First for algorithm design, made use of visual program to take place of flow diagram, intuitively introduce the logic of algorithms and verify them immediately. Second for coding, combined with the syntax and control flow of a programming language, transform the visual program into codes of the corresponding language. Third for modular design, create program modules by means of customized block, thus understand the ideas of decomposition and modular design for complex system. Next we will illustrate on the three topics. Make Use of Visual Programming in Algorithm Design Algorithm is the soul of program, and also be the key for developing computational Thinking and logical thinking. For American students, they usually begun visual programming in primary and secondary school, so that the logical thinking had been developed, but for Chinese students, they always lacking this ability. At the beginning of the course, we propose to use the simplest and most",
            "score": 0.3685763966626367,
            "section_title": "abstract",
            "char_start_offset": 2208,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96826171875
        },
        {
            "corpus_id": "265658981",
            "title": "Recursive Visual Programming",
            "text": "In this section, we introduce our method, Recursive Visual Programming (RVP). We first review the problem setup and ingredients of visual programming as established by prior work (see Section 3.1). We then introduce our recursive coding framework (see Section 3.2), which involves a multi-step prompting scheme, as well as a system for dynamic type assignment (see Section 3.3).",
            "score": 0.3685763966626367,
            "section_title": "Recursive Visual Programming",
            "char_start_offset": 9366,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 77
                },
                {
                    "start": 78,
                    "end": 197
                },
                {
                    "start": 198,
                    "end": 378
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.90185546875
        },
        {
            "corpus_id": "275145068",
            "title": "Design and Build an Electronic Archiving System Using Visual Basic Language",
            "text": "NET 2005, which narrowed the gap further between Visual Basic and #C by adding some missing capabilities such as redefining operators (Operator Overloading) [1]. The Visual Basic (VB) is a programming environment developed by Microsoft. The components of the Visual Basic language include a graphical user interface (GUI) that allows programmers to modify codes by adding codes to them, directing them, and determining their behavior and appearance to perform various programming instructions. The Basic language is easy to use and can be relied upon to design a prototype for programs that will later be designed using advanced and more difficult programming languages. Therefore, the Basic language was named the Rapid Application Development system. The most prominent uses of Visual Basic are the following: Designing executable files by programmers with the extension (exe). Creating database programs. Programming Microsoft applications and programs; such as PowerPoint and Excel. \n\nUsing macros; which is combining several typical and repeated commands into one simple command; to facilitate repetitive routine tasks and tasks by creating and filling data tables and charts quickly. Conducting certain statistics for some companies using tables programmed using the BASIC language [3]. Visual Basic Language Visual Basic (abbreviated as VB) can be defined as a programming language created and developed by Microsoft, and it is the visual form of the BASIC language. It was developed by Professor John G. Kemeny and Professor Thomas Curtis. This language is characterized by its simplicity and ease of understanding. Many programmers consider it the starting point for learning programming, and it provides users with a set of tools that can be used to create applications with a graphical user interface (GUI). Visual Basic can be considered more than just a programming language; it includes a variety of libraries that are useful in creating entity-oriented programs. From all this development and for the benefit of the Visual Basic program for the subject of our research, which is electronic archiving, the need arose to touch on the program and electronic archiving, each separately. From this point of view, this will be what we will work on according to the plan followed to learn how to build and design an electronic archiving system based on the Visual Basic program [4]. In the literature there are several studies that research electronic archiving, including: the Visual Basic .NET was used, which is one of the Visual Basic versions.",
            "score": 0.3683799275695806,
            "section_title": "INTRODUCTION",
            "char_start_offset": 2038,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 161
                },
                {
                    "start": 162,
                    "end": 236
                },
                {
                    "start": 237,
                    "end": 493
                },
                {
                    "start": 494,
                    "end": 670
                },
                {
                    "start": 671,
                    "end": 752
                },
                {
                    "start": 753,
                    "end": 879
                },
                {
                    "start": 880,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 986
                },
                {
                    "start": 989,
                    "end": 1189
                },
                {
                    "start": 1190,
                    "end": 1292
                },
                {
                    "start": 1293,
                    "end": 1473
                },
                {
                    "start": 1474,
                    "end": 1547
                },
                {
                    "start": 1548,
                    "end": 1623
                },
                {
                    "start": 1624,
                    "end": 1818
                },
                {
                    "start": 1819,
                    "end": 1977
                },
                {
                    "start": 1978,
                    "end": 2197
                },
                {
                    "start": 2198,
                    "end": 2390
                },
                {
                    "start": 2391,
                    "end": 2556
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87158203125
        },
        {
            "corpus_id": "233911153",
            "title": "Elementary Students\u2019 First Approach to Computational Thinking and Programming",
            "text": "On the other hand, programming does not have to be visual or physical to be used by younger pupils. A conference paper called \"Teaching Programming to Young Learners Using Scala and Kojo\" [13] presented how pupils in Sweden and India program. The results indicate that students experience text-based programming as something positive, since it teaches pupils what it really is like to program. The article also suggests that pupils learn abstract thinking by programming. To sum up, research suggests that younger children find it easier to learn programming by using visual or physical resources [14,15].",
            "score": 0.36700438089319387,
            "section_title": "Physical and Visual Aspects of Programming-And How It Relates to Learning",
            "char_start_offset": 6666,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 99
                },
                {
                    "start": 100,
                    "end": 242
                },
                {
                    "start": 243,
                    "end": 393
                },
                {
                    "start": 394,
                    "end": 471
                },
                {
                    "start": 472,
                    "end": 605
                }
            ],
            "ref_mentions": [
                {
                    "start": 597,
                    "end": 601,
                    "matchedPaperCorpusId": "35343202"
                },
                {
                    "start": 601,
                    "end": 604,
                    "matchedPaperCorpusId": "17105523"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.142333984375
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "We talked about the progress in the visual programming languages, the success in different programming domain, and the features of the most popular visual programming languages. According to our literature review and comparative analysis we see a gap in attracting mainstream programmers to using visual programming languages in each new programming task. The current VPLs are not equivalent to the current textual programming languages at the practical side. Yes, some limitations are a result of missing features that can be added but this doesn't count only for \"what we can do?\" but for \"how we can do things with respect to the productivity of the programmer during software development and the quality of the final software\".\n\nWe will provide the requirements of a general purpose visual programming tool that can be used as replacement for the usage of popular programming languages like ( C,C++, C# and Java) + visual programming environments like Visual Studio and Netbeans). We expect that after the implementation and marketing of this new tool, many new software projects can be developed using Visual Programming Language in less time with high quality. Also we expect attracting more users to real programming industry after the existence of this tool.\n\nThe next table provides the requirements for the new general purpose VPL. These requirements are the result of our comparative study where our research team selected the best features that we need to have together in one visual programming language.  15 Support Forums Table 4. Requirements for General-Purpose VPL",
            "score": 0.3667692248926522,
            "section_title": "The requirements for the new General Purpose Visual Programming Language",
            "char_start_offset": 48014,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1519,
                    "end": 1521,
                    "matchedPaperCorpusId": "61050952"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92041015625
        },
        {
            "corpus_id": "202566030",
            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
            "text": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
            "score": 0.36498851303176744,
            "section_title": "Visual Programming as an authoring tool",
            "char_start_offset": 7334,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 111
                },
                {
                    "start": 112,
                    "end": 476
                },
                {
                    "start": 477,
                    "end": 649
                },
                {
                    "start": 650,
                    "end": 932
                },
                {
                    "start": 933,
                    "end": 1110
                },
                {
                    "start": 1111,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1489
                },
                {
                    "start": 1492,
                    "end": 1642
                },
                {
                    "start": 1643,
                    "end": 1773
                },
                {
                    "start": 1774,
                    "end": 1930
                },
                {
                    "start": 1931,
                    "end": 2110
                },
                {
                    "start": 2111,
                    "end": 2297
                },
                {
                    "start": 2298,
                    "end": 2387
                }
            ],
            "ref_mentions": [
                {
                    "start": 699,
                    "end": 703,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 971,
                    "end": 975,
                    "matchedPaperCorpusId": "54120970"
                },
                {
                    "start": 1294,
                    "end": 1298,
                    "matchedPaperCorpusId": "9744698"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9638671875
        },
        {
            "corpus_id": "257038388",
            "title": "Technical Dimensions of Programming Systems",
            "text": "There is a renewed interest in developing new programming systems. Such systems go beyond the simple model of code written in a programming language using a more or less sophisticated text editor. They combine textual and visual notations, create programs through rich graphical interactions, and challenge accepted assumptions paper. Here, we merely wish to demonstrate that such a thing is possible and show what one can do with the results.",
            "score": 0.36498851303176744,
            "section_title": "Conclusions",
            "char_start_offset": 115645,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.61279296875
        },
        {
            "corpus_id": "235641449",
            "title": "Matters of Neural Network Repository Designing for Analyzing and Predicting of Spatial Processes",
            "text": "When developing visual programming languages, drawing of graphs is used as the main approach, that is, in the form of a set of vertices (nodes) connected by arcs (edges). Unlike the textual form of notation, in which objects (symbols and words) form a sequence, and each object is associated only with the left and right \"neighbors\", the graph form allows you to visually depict more complex relationships, since in it each object can be connected to several others objects. In this sense, the text form is one-dimensional, while the graph form is twodimensional. The ability to vary the geometric dimensions, shape and color of vertices, the appearance and thickness of arcs, change the relative position of the vertices without changing the topology of the graph significantly increases the expressive capabilities of the graph form of the program algorithm. \n\nThe creation of a visual (figurative) style of software development is the main motive for the development of graphsymbolic programming (GSP) technology. GSP technology is a technology for designing and coding algorithms and models based on a graphical way of representing programs, with the goal of fully or partially automating the design, coding and testing of software. This programming technology adheres to two fundamental principles: a) visual, graphical form of presentation of program algorithms and other components of their specifications; b) the principle of structured procedural programming. The implementation of this concept is excellent for solving the problem of visual programming of neural networks. Visual programming increases the clarity of the presented codes, significantly reduces the number of errors made at the design and coding stage of programs, and thereby speeds up the development process and increases the reliability of codes of developed programs. Together with the use of the block approach, visual programming methods will not only speed up development due to simple graphical interchangeability of logical blocks, but also provide simple portability of such programs. An application programming interface (API) based on the REST architectural pattern provides a unified interaction with the system for programmatic data exchange, including deep model export, editing, structured data retrieval, and other use cases. \n\nThe main directions for the further use of the expected results: \n\n1) Implementation of intelligent systems for forecasting the development of natural and man-made emergency processes based on new technologies of integration, intellectual analysis and dissemination of large geospatial data into the activities of industrial enterprises and executive authorities of the region.",
            "score": 0.36498851303176744,
            "section_title": "C. Development of Interfaces for Interacting with the Repository",
            "char_start_offset": 17906,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 170
                },
                {
                    "start": 171,
                    "end": 474
                },
                {
                    "start": 475,
                    "end": 563
                },
                {
                    "start": 564,
                    "end": 860
                },
                {
                    "start": 863,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1236
                },
                {
                    "start": 1237,
                    "end": 1468
                },
                {
                    "start": 1469,
                    "end": 1582
                },
                {
                    "start": 1583,
                    "end": 1847
                },
                {
                    "start": 1848,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2318
                },
                {
                    "start": 2321,
                    "end": 2385
                },
                {
                    "start": 2388,
                    "end": 2698
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91796875
        },
        {
            "corpus_id": "19038821",
            "title": "Design Space of Programming Tools on Mobile Touchscreen Devices",
            "text": "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax [40,53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains [40,41]. \n\nVP languages are a somewhat natural fit for use on touchscreen devices because they inherently leverage their interaction style and make minimal or no use of the keyboard [21,29]. Aspects of VP can be observed even in the syntaxenforcing implementations of TouchDevelop [58] and the syntax-directed keyboard extension [1]. Therefore, incorporating VP concepts in the implementations of even conventional programming languages on touchscreen devices can be useful in advancing their usability.",
            "score": 0.3614349632155474,
            "section_title": "VP concepts",
            "char_start_offset": 21548,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 156
                },
                {
                    "start": 157,
                    "end": 371
                },
                {
                    "start": 372,
                    "end": 514
                },
                {
                    "start": 517,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 1009
                }
            ],
            "ref_mentions": [
                {
                    "start": 363,
                    "end": 367,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 506,
                    "end": 510,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 688,
                    "end": 692,
                    "matchedPaperCorpusId": "64789544"
                },
                {
                    "start": 787,
                    "end": 791,
                    "matchedPaperCorpusId": "14819227"
                },
                {
                    "start": 835,
                    "end": 838,
                    "matchedPaperCorpusId": "14326365"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.953125
        },
        {
            "corpus_id": "259423992",
            "title": "A Comparative Study on Programming Education\u2014\u2014Based on China and America",
            "text": "For example, the most famous visual programming tool-Scratch is popular in many commercialized Chinese education institutions. Scratch has a relatively simple visual programming environment that encourages users to create interactive, media-rich projects, including animated stories, games, online news shows, book reports, greeting cards, music videos, science projects, tutorials, simulations, and sensor-driven arts [8].",
            "score": 0.3614349632155474,
            "section_title": "K-12 Programming Education in China",
            "char_start_offset": 5742,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 126
                },
                {
                    "start": 127,
                    "end": 423
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7734375
        },
        {
            "corpus_id": "14902110",
            "title": "Conceptual Understanding of Computer Program Execution: Application to C++",
            "text": "This paper aims at proposing a diagrammatic methodology that produces a conceptual representation of instructions for programming source codes. Without loss of generality, this methodology is applied to the programming language C++. The advantages of this application include source code understanding, maintenance, verification, testing, and identification of parallelism, in addition to other purposes such as reuse and reverse engineering. The proposed methodology enhances understanding of program code in terms of its corresponding computer operations, not as registers, fetch/store/execute cycle, addresses; rather, in terms of conceptual operations such as create, release, transfer, receive, and process, thus completing the cycle of understanding, where it is always claimed that, as a first step, a programmer must understand the application domain (e.g., inventory). This work can be considered a type of visualization of computer programs. Program visualization is a well-known paradigm. A visual programming language, not to be confused with a visual programming environment, is a language that uses graphic tools to represent structural units and control streams in programs. This type of language facilitates creating and specifying of program elements graphically rather than by writing them textually [1]. Some visualization of programs is based on the notion of dataflow programming that represents a program as a directed graph of the data flowing among operations [2] [3]. \n\nProgram understanding is one of the most important aspects influencing the maintainability of programs for programmers [4]. \"Mechanisms for improving program comprehensibility can reduce maintenance cost and maximize return on investments in legacy code by promoting reuse\" [5]. According to Kiper et al. [5], \n\nThe entire software engineering philosophy is built on the premise that high level language code is created for human consumption rather than driven by machine requirements. The first step in repairing or modifying existing code is to understand what that code does.",
            "score": 0.3605538994466623,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 143
                },
                {
                    "start": 144,
                    "end": 232
                },
                {
                    "start": 233,
                    "end": 442
                },
                {
                    "start": 443,
                    "end": 877
                },
                {
                    "start": 878,
                    "end": 951
                },
                {
                    "start": 952,
                    "end": 999
                },
                {
                    "start": 1000,
                    "end": 1189
                },
                {
                    "start": 1190,
                    "end": 1322
                },
                {
                    "start": 1323,
                    "end": 1492
                },
                {
                    "start": 1495,
                    "end": 1618
                },
                {
                    "start": 1619,
                    "end": 1773
                },
                {
                    "start": 1774,
                    "end": 1804
                },
                {
                    "start": 1807,
                    "end": 1980
                },
                {
                    "start": 1981,
                    "end": 2073
                }
            ],
            "ref_mentions": [
                {
                    "start": 1318,
                    "end": 1321,
                    "matchedPaperCorpusId": "62509261"
                },
                {
                    "start": 1484,
                    "end": 1487,
                    "matchedPaperCorpusId": "5257722"
                },
                {
                    "start": 1488,
                    "end": 1491,
                    "matchedPaperCorpusId": "15622049"
                },
                {
                    "start": 1614,
                    "end": 1617,
                    "matchedPaperCorpusId": "16589935"
                },
                {
                    "start": 1769,
                    "end": 1772,
                    "matchedPaperCorpusId": "62616925"
                },
                {
                    "start": 1800,
                    "end": 1803,
                    "matchedPaperCorpusId": "62616925"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8857421875
        },
        {
            "corpus_id": "247731455",
            "title": "Computational Thinking and User Interfaces: A Systematic Review",
            "text": "Recent years have seen a great wave of research on computational thinking and its effect in the field of education. However, there are no mapping studies that consider the implications of the impact caused by the various tools that have been developed to promote computational thinking skills. This article presents a systematic review that relies on PRISMA as the analytical methodology. Twenty-two documents out of a total of 1069 were identified and filtered for further study. The result is an analysis of the state of the art involving the intersection between the areas of Computer Science, Human-Computer Interaction, and Education, the goal of which is to identify the scope of the research, trends and any existing gaps. \n\nThe results showed that despite the relative dearth of literature on the relationship between user interfaces and the development of computational thinking skills, it is safe to say that user interfaces do affect the development of these skills. There is also the need to conduct research that further analyzes the effect caused by the technologies employed in the development of these interfaces. This is thus a worthy area of endeavor for future research. \n\nOver the course of this study, a series of more specific questions emerged as follows. \n\n1) How do the interfaces of visual programming languages affect the development of computational thinking skills? 2) How does the design of a user interface influence the development of computational thinking skills? 3) How does the user experience involving visual programming tools affect the development of computational thinking? 4) What are the differences between the interfaces of visual programming languages? 5) What improvements can be applied to visual programming tools or platforms to make their designs more inclusive and accessible? 6) Is it possible to improve the design of a user interface by applying other thought models? The answer to these questions will provide a starting point for future research.",
            "score": 0.35873906670322675,
            "section_title": "VI. CONCLUSION",
            "char_start_offset": 40615,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 480
                },
                {
                    "start": 481,
                    "end": 729
                },
                {
                    "start": 732,
                    "end": 977
                },
                {
                    "start": 978,
                    "end": 1129
                },
                {
                    "start": 1130,
                    "end": 1189
                },
                {
                    "start": 1192,
                    "end": 1278
                },
                {
                    "start": 1281,
                    "end": 1394
                },
                {
                    "start": 1395,
                    "end": 1497
                },
                {
                    "start": 1498,
                    "end": 1614
                },
                {
                    "start": 1615,
                    "end": 1698
                },
                {
                    "start": 1699,
                    "end": 1922
                },
                {
                    "start": 1923,
                    "end": 2003
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51220703125
        },
        {
            "corpus_id": "73725113",
            "title": "Analysis of an Intelligent Graphical Tutoring System using the Internet of Things (IoT) to Develop the Competency of Embedded Systems",
            "text": "Graphical programming is defined as a graphical approach to programming using diagrams and symbols instead of lines of code or a series of functions. It allows users to interact with a program and see the immediate results. It uses simple methods and features in a positive developmental setting and is divided into two parts: Open source platforms and proprietary platforms [26]. This allows developers to create a program without writing a single line of code and fix programming errors to improve the pro-gram. However, beginners can find it difficult and tire of learning [27] so online graphic programming is developed by replacing text with block diagrams or symbols as well as converting commands back into a programming language. \n\nDuring this research, a graphic programming tool is used to assist teaching in collaboration with an intelligent tutoring system to support learners according to their needs when creating programs connected to embedded systems [28]. This is suitable for beginners because the programming process includes the execution of a command block to create a script, which is a bit like a Lego programming block that cannot be redistributed without prior written permission from its author and to avoid data entry mistakes in its programming. According to the process, it makes a programming language easier for beginners to learn and design projects with creativity and imagination. Whereas course content involves graphical programming by employing a range of tools. These can include a microcontroller, sensor and other electronic devices such as motion controls, sensors, result displays and electric ray robot sound programming [29] using a miniblog, and an open source graphic program for Arduino, Multiplo, physical computing etc. [30].",
            "score": 0.3579152567309107,
            "section_title": "Graphical programming",
            "char_start_offset": 7471,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 149
                },
                {
                    "start": 150,
                    "end": 223
                },
                {
                    "start": 224,
                    "end": 380
                },
                {
                    "start": 381,
                    "end": 513
                },
                {
                    "start": 514,
                    "end": 737
                },
                {
                    "start": 740,
                    "end": 972
                },
                {
                    "start": 973,
                    "end": 1273
                },
                {
                    "start": 1274,
                    "end": 1414
                },
                {
                    "start": 1415,
                    "end": 1499
                },
                {
                    "start": 1500,
                    "end": 1774
                }
            ],
            "ref_mentions": [
                {
                    "start": 375,
                    "end": 379,
                    "matchedPaperCorpusId": "25475069"
                },
                {
                    "start": 576,
                    "end": 580,
                    "matchedPaperCorpusId": "14148501"
                },
                {
                    "start": 967,
                    "end": 971,
                    "matchedPaperCorpusId": "7202300"
                },
                {
                    "start": 1769,
                    "end": 1773,
                    "matchedPaperCorpusId": "12204973"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.919921875
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "The objective of this systematic literature review was to characterize and analyze the current evidence-based visual programming approaches, trends, interaction styles, and techniques. To achieve this objective, we examined 30 articles against 12 relevant dimensions. However, future researchers may develop an evaluation framework that can be used to compare visual programming tools. The research community has contributed such frameworks to be used to compare regular programming languages [84]. While the existing framework of cognitive dimensions of notations [66] can be used to compare tools in terms of their usability, a potentially new evaluation framework is needed to evaluate other quality attributes such as extensibility, security, testability, and portability.",
            "score": 0.3579152567309107,
            "section_title": "D. EVALUATION FRAMEWORK",
            "char_start_offset": 64878,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 184
                },
                {
                    "start": 185,
                    "end": 267
                },
                {
                    "start": 268,
                    "end": 385
                },
                {
                    "start": 386,
                    "end": 498
                },
                {
                    "start": 499,
                    "end": 776
                }
            ],
            "ref_mentions": [
                {
                    "start": 493,
                    "end": 497,
                    "matchedPaperCorpusId": "18678580"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92236328125
        },
        {
            "corpus_id": "248524774",
            "title": "Low-Code Programming Models",
            "text": "Config. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
            "score": 0.3579152567309107,
            "section_title": "Palette Code canvas Stage",
            "char_start_offset": 13328,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 7
                },
                {
                    "start": 8,
                    "end": 25
                },
                {
                    "start": 26,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 265
                },
                {
                    "start": 266,
                    "end": 412
                },
                {
                    "start": 413,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 895
                },
                {
                    "start": 896,
                    "end": 1044
                },
                {
                    "start": 1045,
                    "end": 1164
                },
                {
                    "start": 1165,
                    "end": 1233
                },
                {
                    "start": 1234,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1462
                },
                {
                    "start": 1465,
                    "end": 1504
                },
                {
                    "start": 1505,
                    "end": 1690
                },
                {
                    "start": 1691,
                    "end": 1832
                },
                {
                    "start": 1833,
                    "end": 1983
                },
                {
                    "start": 1986,
                    "end": 2176
                },
                {
                    "start": 2177,
                    "end": 2289
                }
            ],
            "ref_mentions": [
                {
                    "start": 355,
                    "end": 359,
                    "matchedPaperCorpusId": "2385464"
                },
                {
                    "start": 1929,
                    "end": 1933,
                    "matchedPaperCorpusId": "16189588"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.98193359375
        },
        {
            "corpus_id": "62105198",
            "title": "Graphic and Functional Algorithms of Sequence of Tenses in English Grammar for the Effective Education And Automated Systems of Text Synthesis and Editing",
            "text": "In addition to the visual (graphic) languages of communication, there are visual programming languages, in which the relationships between objects, actions, and their sequences are involved in the description processes, together with the objects on an equal footing (Johnston, 2004, p. 7). Visual programming languages appeared in the 20th century as an adjunct to the visualization of conventional programming languages. In 1984, Jaron Lanier published an article about a visual programming language (Jaron Lanier, http://www.well.com/user/jaron), which was followed by the birth of several visual programming languages, such as: \u2022 \u00abDragon (Friendly Russian algorithmic language that provides visibility)\u00bb used in the rocket and space technology, which can be attributed to the language of diagrams or flowcharts (Zenkin, 1991, pp. 96-113); \u2022 The basic elements of the language are states (shown by rectangles), which perform certain actions and transitions from state to state (lines). \n\nFor each transition, a logical condition for the transition to the next step is assigned; \u2022 \u00abLD (Ladder Diagram)\u00bb -a graphic language for programming ladder diagrams (Parr, 2007, p. 34); \u2022 \u00abFBD (Function Block Diagram)\u00bb -graphic language to describe the functional block diagrams (Petrov, 2004, pp. 19-21, 48-64); \u2022 \u00abCFC (Continuous Flow Chart)\u00bb -graphic language created for the design of control systems with continuous technological processes; \u2022 \u00abLabVIEW\u00bb -a graphic language for programming working with non-PC devices (http://www.labview. ru/, 2015); \u2022 \u00abVisSim\u00bb -a graphic language for modeling dynamic systems and designing systems based on models with built-in microprocessors (Darnell, 1996, p. 14); \u2022 \u00abScratch\u00bb -a visual object-oriented educational environment for students (Super Scratch Programming Adventure! Learn to Program, 2012, pp. 5-160);",
            "score": 0.3579152567309107,
            "section_title": "Visual Programming Languages",
            "char_start_offset": 3904,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 289
                },
                {
                    "start": 290,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 548
                },
                {
                    "start": 549,
                    "end": 987
                },
                {
                    "start": 990,
                    "end": 1533
                },
                {
                    "start": 1534,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1838
                },
                {
                    "start": 1839,
                    "end": 1846
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.86083984375
        },
        {
            "corpus_id": "229358825",
            "title": "Enhancing Confidence in Using Computational Thinking Skills via Playing a Serious Game: A Case Study to Increase Motivation in Learning Computer Programming",
            "text": "This cleverly separates the programming logic from programming grammar and syntax, allowing students to focus on developing programming strategies with little or no programming background. Despite all these positive traits, research in this field points out that visual programming environments are merely tools and without well-organized teaching methods and learning materials to support them, all they can provide is a ''short burst of enthusiasm'' [65]. An extensive study identified that visual programming environments influence not only the learning of introductory programming but also the habits of programing that students develop during their learning process [66]. According to this research, when students are asked to perform a programming task they do not approach it by thinking at the algorithmic level but instead, they attempt to solve the problem by using all the blocks that seemed to be relevant for solving the task and randomly combine these blocks into a script in order to try to solve the problem. Additionally, it has been observed that students tend to produce unstructured programming solutions through using various blocks (such as with a repeat-until loop) where the body of blocks are logically coherent and easy to understand, but the outcomes produced by students are no longer coherent and well-organized. One could argue that this is not related to the characteristics of visual programming environments but might be the poor software development skills and weak programming abilities of students. However, scripts and graphical objects are often executed concurrently in visual programming environments. As the scripts are written in the graphical objects, it is difficult for students to develop the skills necessary for building logically coherent solutions as the execution of objects always happen simultaneously. Studies argue that concurrent programming exists as an integral part of the visual programming environments and although debugging concurrent programs can be seen as a viable concept to support learning, students' tendency to develop unstructured programming solutions (such as an incorrect use of a loop construct), leads to outcomes that contain lots of repetitions in different scripts which is not a good programming practice [10], [66]. At this point, it is important to highlight that the intention here is not to alienate visual programming environments from learning introductory programming or to criticise these environments in any way, but rather to emphasize that these environments are simply design tools which do not necessarily consider good programming practices as this is not their purpose.",
            "score": 0.3579152567309107,
            "section_title": "II. RESEARCH BACKGROUND",
            "char_start_offset": 13230,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 188
                },
                {
                    "start": 189,
                    "end": 457
                },
                {
                    "start": 458,
                    "end": 676
                },
                {
                    "start": 677,
                    "end": 1024
                },
                {
                    "start": 1025,
                    "end": 1341
                },
                {
                    "start": 1342,
                    "end": 1534
                },
                {
                    "start": 1535,
                    "end": 1641
                },
                {
                    "start": 1642,
                    "end": 1855
                },
                {
                    "start": 1856,
                    "end": 2297
                },
                {
                    "start": 2298,
                    "end": 2665
                }
            ],
            "ref_mentions": [
                {
                    "start": 671,
                    "end": 675,
                    "matchedPaperCorpusId": "207188650"
                },
                {
                    "start": 2286,
                    "end": 2290,
                    "matchedPaperCorpusId": "207220407"
                },
                {
                    "start": 2292,
                    "end": 2296,
                    "matchedPaperCorpusId": "207188650"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.869140625
        },
        {
            "corpus_id": "32610688",
            "title": "Identifying middle school students\u2019 challenges in computational thinking-based science learning",
            "text": "In a visual programming (VP) environment, students construct programs using graphical objects and a drag-and-drop interface, thus making the programming more intuitive and accessible to the novice programmer (Kelleher and Pausch 2005). Visual constructs significantly reduce issues with program syntax and understanding textual structures making it easier for students to focus on the semantic meaning of the constructs (Soloway 1993). For example, visual interfaces make it easier to interpret and use flow of control constructs, such as loops and conditionals (Parsons and Haden 2007a, b). \n\nCTSiM provides a library of visual constructs that students can choose from and arrange spatially to generate their computational models. If students try to drag and drop a programming construct incorrectly, the system disallows the action and indicates the error by explicitly displaying an \"x\" sign. Therefore, CTSiM eliminates the possibility of generating programs (that is, models) with syntax errors. Examples of other agent-based VP environments include AgentSheets (Repenning 1993), StarLogo TNG (Klopfer et al. 2005), Scratch (Maloney et al. 2004), ViMAP (Sengupta et al., 2015), and Alice (Conway 1997). They have been used successfully in teaching children CT through game design, storytelling, and modeling activities.",
            "score": 0.3579152567309107,
            "section_title": "The advantages of visual programming",
            "char_start_offset": 11363,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 235
                },
                {
                    "start": 236,
                    "end": 435
                },
                {
                    "start": 436,
                    "end": 591
                },
                {
                    "start": 594,
                    "end": 731
                },
                {
                    "start": 732,
                    "end": 895
                },
                {
                    "start": 896,
                    "end": 1000
                },
                {
                    "start": 1001,
                    "end": 1207
                },
                {
                    "start": 1208,
                    "end": 1324
                }
            ],
            "ref_mentions": [
                {
                    "start": 208,
                    "end": 234,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 420,
                    "end": 434,
                    "matchedPaperCorpusId": "15270981"
                },
                {
                    "start": 1067,
                    "end": 1083,
                    "matchedPaperCorpusId": "3187251"
                },
                {
                    "start": 1098,
                    "end": 1119,
                    "matchedPaperCorpusId": "54120970"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9169921875
        },
        {
            "corpus_id": "10304140",
            "title": "Object-Oriented Programming for non-IT Students: Starting from Scratch",
            "text": "As mentioned above, we build UML (Unified Modelling Language) activity diagrams to describe algorithms in complicated tasks. We have been using a verbal description and pseudo code as well. Now, when we create Scratch projects as an introduction to programming, we can also use its scripts to visualize, formulate and describe the problem. \n\nAt the beginning, the teacher provides the students with a prepared model, which is analysed in a group. The analysis is followed by writing the program code according to the diagrams. Later on, students have to create the models themselves. \n\nIt has to be mentioned that according to tests [13] most of our students are visual learners [14], [15]. For them it is very important to see \"how it works\". Scratch, with its elements of attractiveness, helps those students to understand the main idea of creating an application. \n\nVBA already has a built-in visualising tool: students can follow the code execution using the Locals Window (Fig. 11). \n\nIt automatically displays all the names of the declared variables in the current procedure, their types and their values. When the Locals Window is visible, it is automatically updated every time -students can see and check each step and its result in their program. Python does not have such an opportunity, but still needs to be visualised. We show students the Online Python Tutor [16]. Using the visualizing tool, the students can follow each step of their code and check the values and types of the variables, as well as the order of the operators during the execution. It has to be noted that this tool has some drawbacks, as it does not support the Python graphics, time functions and work with files. However, for the beginners in programming it gives the understanding of the code execution (Fig. 12) \n\nMoreover, for our students we create short videos about the main terms, such as iterations, branching and the execution of the processes. It should be mentioned that we surely use sound and voice records in these videos to explain the complicated moments. In our work with educational visions we follow the ideas of Khan Academy [17]. \n\nIn addition, we always try to provide students\u00b4 applications with a similar content.",
            "score": 0.3560045765164695,
            "section_title": "VII. THE TEACHING METHODOLOGY",
            "char_start_offset": 16959,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 124
                },
                {
                    "start": 125,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 339
                },
                {
                    "start": 342,
                    "end": 446
                },
                {
                    "start": 447,
                    "end": 526
                },
                {
                    "start": 527,
                    "end": 583
                },
                {
                    "start": 586,
                    "end": 690
                },
                {
                    "start": 691,
                    "end": 743
                },
                {
                    "start": 744,
                    "end": 866
                },
                {
                    "start": 869,
                    "end": 987
                },
                {
                    "start": 990,
                    "end": 1111
                },
                {
                    "start": 1112,
                    "end": 1256
                },
                {
                    "start": 1257,
                    "end": 1332
                },
                {
                    "start": 1333,
                    "end": 1379
                },
                {
                    "start": 1380,
                    "end": 1564
                },
                {
                    "start": 1565,
                    "end": 1698
                },
                {
                    "start": 1699,
                    "end": 1799
                },
                {
                    "start": 1802,
                    "end": 1939
                },
                {
                    "start": 1940,
                    "end": 2057
                },
                {
                    "start": 2058,
                    "end": 2136
                },
                {
                    "start": 2139,
                    "end": 2223
                }
            ],
            "ref_mentions": [
                {
                    "start": 679,
                    "end": 683,
                    "matchedPaperCorpusId": "3046916"
                },
                {
                    "start": 685,
                    "end": 689,
                    "matchedPaperCorpusId": "14532870"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.30517578125
        },
        {
            "corpus_id": "243947929",
            "title": "Development of a GUI for automating quality control of dose calibrators using Python",
            "text": "The program was constituted of five classes: a class for the main window building, three classes for making modal dialogs, and the last one to create a canvas that figures render into. Each of these classes involves its own methods which can be divided into five groups depending on its functions. The first group gets information entered by the user, stores it in variables, and saves it into files. The second extracts data from files and displays it on the screen. Two principal groups help to obtain results, one for analyzing data and the other to visualize it on graphs. The last group calls all variables, data, and figures and assembles them into one file.",
            "score": 0.3544289123930477,
            "section_title": "Pandas, an open source Python package, was used to analyze data gathered in several tests. Data can be saved as csv files (Comma Separated Values file) using os and csv libraries then plotted by matplotlib (a comprehensive library for creating static, animated, and interactive visualizations in Python). Finally, reportlab library was called to create a pdf file that has combined all results.",
            "char_start_offset": 5248,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 184
                },
                {
                    "start": 185,
                    "end": 297
                },
                {
                    "start": 298,
                    "end": 400
                },
                {
                    "start": 401,
                    "end": 467
                },
                {
                    "start": 468,
                    "end": 576
                },
                {
                    "start": 577,
                    "end": 664
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.06646728515625
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "A computer program defines the operation of computer systems. However, \"the program given to a computer for solving a problem need not be in a written format\" [73]. This future-looking statement, dating back to the 1960s, inspired several generations of researchers to design and build visual programming systems. Today, visual programming systems (e.g., LabView [39], Unity Graph Editor [76], PromptChainer [84], ComfyUI [13] and Visual Blocks [18]) typically feature a node graph editor, providing users with a visual workspace to \"write\" their program using \"building blocks\" [28,68,89]. Recent work further explored the application of visual programming in education [9,35,40], XR creativity support [88,91,93], and robotics [14,30,31]. For example, Zhang et al. [93] connected the visual programming tool to the concept of teaching by demonstration [44,49,99], allowing users to rapidly customize AR effects in video creation. FlowMatic [91] extended traditional visual programming interfaces into 3D virtual environments, providing users with immersive authoring experiences. \n\nAdvancements in AI have introduced many repositories of advanced ML models [33,66], and an increasing number of researchers are exploring AI chains [41,86]. This progress has motivated HCI researchers to design and build a range of visual programming interfaces to support the AI development process [13,43,84]. For example, ChainForge is a web-based platform for developers to explore various LLM-related configuration and designs in a wide range of applications [4]. Visual Blocks enables creation and interaction of advanced ML pipelines that can leverage state-of-the-art computer vision and computer graphics models in the browser [18]. \n\nThis work contributes the technical system, implementation and evaluation of a novel AI assistant that enables the use of text-based instructions in visual programming of ML pipelines. Compared to typical workflows in which people manually build their pipelines, InstructPipe has the potential to accelerate ML pipeline prototyping in visual programming.",
            "score": 0.3544289123930477,
            "section_title": "Related Work 2.1 Visual Programming",
            "char_start_offset": 6886,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 61
                },
                {
                    "start": 62,
                    "end": 164
                },
                {
                    "start": 165,
                    "end": 313
                },
                {
                    "start": 314,
                    "end": 590
                },
                {
                    "start": 591,
                    "end": 740
                },
                {
                    "start": 741,
                    "end": 931
                },
                {
                    "start": 932,
                    "end": 1081
                },
                {
                    "start": 1084,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1395
                },
                {
                    "start": 1396,
                    "end": 1552
                },
                {
                    "start": 1553,
                    "end": 1725
                },
                {
                    "start": 1728,
                    "end": 1912
                },
                {
                    "start": 1913,
                    "end": 2082
                }
            ],
            "ref_mentions": [
                {
                    "start": 408,
                    "end": 412,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 445,
                    "end": 449,
                    "matchedPaperCorpusId": "258216977"
                },
                {
                    "start": 579,
                    "end": 583,
                    "matchedPaperCorpusId": "1529669"
                },
                {
                    "start": 583,
                    "end": 586,
                    "matchedPaperCorpusId": "259376453"
                },
                {
                    "start": 586,
                    "end": 589,
                    "matchedPaperCorpusId": "269753286"
                },
                {
                    "start": 671,
                    "end": 674,
                    "matchedPaperCorpusId": "267523023"
                },
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "258217657"
                },
                {
                    "start": 677,
                    "end": 680,
                    "matchedPaperCorpusId": "220885043"
                },
                {
                    "start": 704,
                    "end": 708,
                    "matchedPaperCorpusId": "269717820"
                },
                {
                    "start": 708,
                    "end": 711,
                    "matchedPaperCorpusId": "222799772"
                },
                {
                    "start": 711,
                    "end": 714,
                    "matchedPaperCorpusId": "264350354"
                },
                {
                    "start": 729,
                    "end": 733,
                    "matchedPaperCorpusId": "16198810"
                },
                {
                    "start": 733,
                    "end": 736,
                    "matchedPaperCorpusId": "207237260"
                },
                {
                    "start": 736,
                    "end": 739,
                    "matchedPaperCorpusId": "23415794"
                },
                {
                    "start": 767,
                    "end": 771,
                    "matchedPaperCorpusId": "264350354"
                },
                {
                    "start": 854,
                    "end": 858,
                    "matchedPaperCorpusId": "1504689"
                },
                {
                    "start": 858,
                    "end": 861,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 861,
                    "end": 864,
                    "matchedPaperCorpusId": "251252905"
                },
                {
                    "start": 942,
                    "end": 946,
                    "matchedPaperCorpusId": "222799772"
                },
                {
                    "start": 1163,
                    "end": 1166,
                    "matchedPaperCorpusId": "257833781"
                },
                {
                    "start": 1236,
                    "end": 1239,
                    "matchedPaperCorpusId": "238353829"
                },
                {
                    "start": 1391,
                    "end": 1394,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 1548,
                    "end": 1551,
                    "matchedPaperCorpusId": "262044762"
                },
                {
                    "start": 1720,
                    "end": 1724,
                    "matchedPaperCorpusId": "258216977"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96044921875
        },
        {
            "corpus_id": "249048171",
            "title": "Research on the Impacts of Cognitive Style and Computational Thinking on College Students in a Visual Artificial Intelligence Course",
            "text": "Visual programming plays an important role in programming education to promote students' understanding of programming and to maximize their engagement in problem-solving (Mladenovi\u0107 et al., 2021). Visual programming provides a programming interface that helps students learn programming concepts and processes (Lye and Koh, 2014;Chao, 2016;Essel et al., 2017;Mladenovi\u0107 et al., 2018;Scherer et al., 2020). In particular, Hu et al. (2021) indicated that visual programming can improve student's academic performance with a small to medium significant overall mean effect size in this area. A visual programming environment allows students to focus on developing and designing programs (Mladenovi\u0107 et al., 2018;Topalli and Cagiltay, 2018), so they become more motivated to solve programming problems without grammar constraints. Visual programming has major learning benefits for students, including an intuitive programming interface and reduced difficulties related to programming (Lye and Koh, 2014;Essel et al., 2017;Mladenovi\u0107 et al., 2018;Lindberg et al., 2019). Considering the need to effectively develop AI talents at the university level, it is necessary to consider the learning benefits provided by a visual programming learning environment. It helps university students quickly learn about AI and helps them gain a better understanding of AI.",
            "score": 0.3544289123930477,
            "section_title": "LITERATURE REVIEW Visual Programming Learning Environment",
            "char_start_offset": 6770,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 196
                },
                {
                    "start": 197,
                    "end": 405
                },
                {
                    "start": 406,
                    "end": 588
                },
                {
                    "start": 589,
                    "end": 826
                },
                {
                    "start": 827,
                    "end": 1066
                },
                {
                    "start": 1067,
                    "end": 1251
                },
                {
                    "start": 1252,
                    "end": 1353
                }
            ],
            "ref_mentions": [
                {
                    "start": 170,
                    "end": 195,
                    "matchedPaperCorpusId": "225393741"
                },
                {
                    "start": 310,
                    "end": 329,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 329,
                    "end": 340,
                    "matchedPaperCorpusId": "206930744"
                },
                {
                    "start": 340,
                    "end": 359,
                    "matchedPaperCorpusId": "157063390"
                },
                {
                    "start": 359,
                    "end": 383,
                    "matchedPaperCorpusId": "22570972"
                },
                {
                    "start": 383,
                    "end": 404,
                    "matchedPaperCorpusId": "216204126"
                },
                {
                    "start": 421,
                    "end": 437,
                    "matchedPaperCorpusId": "225492990"
                },
                {
                    "start": 684,
                    "end": 709,
                    "matchedPaperCorpusId": "22570972"
                },
                {
                    "start": 709,
                    "end": 736,
                    "matchedPaperCorpusId": "4012511"
                },
                {
                    "start": 981,
                    "end": 1000,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 1000,
                    "end": 1019,
                    "matchedPaperCorpusId": "157063390"
                },
                {
                    "start": 1019,
                    "end": 1043,
                    "matchedPaperCorpusId": "22570972"
                },
                {
                    "start": 1043,
                    "end": 1065,
                    "matchedPaperCorpusId": "69960068"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.927734375
        },
        {
            "corpus_id": "7271567",
            "title": "A visual programming language for drawing and executing flowcharts",
            "text": "With recent advances in graphical user interfaces, more and more tasks on computers have become easier to perform. Out of the belief that creating computer programs can also be one of them, visual programming languages (VPLs) have emerged. The goal of VPLs is to shift a part of work from the programmer to the IDE so that the programmer can focus more on algorithm logic than the syntax of the implementation programming language. In this article, the methods required to build a VPL are presented, with an emphasis on a novel method of code generation in a WHILE language. Also, the methods for achieving basic principles of VPLs will be shown \u2014 suitable visual presentation of information and guiding the programmer in the right direction using constraints. These methods are demonstrated on an example of vIDE, a VPL based on the Eclipse integrated development environment (IDE). The design of vIDE with respect to the Eclipse Graphical Modeling Framework (GMF) is described. The concept of a flowchart graphical notation is examined in contrast with the algorithm model it maps to. Finally, the disambiguity of the model representation of an algorithm is discussed and the methods for transforming it to an actual implementation in a programming language.",
            "score": 0.3544289123930477,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.966796875
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "For the development of the visual part of the program and a graphical user interface for desktop applications, the .NET Framework library (Windows Forms) and DevExpress components are used. The visual part is a component-oriented development in which each component solves a specific task. The chart itself is the body of a method, its components are separate parts of this method, and the sequence of connecting these components is the order in which they will be traversed. This way of connection allows using an unlimited number of nested conditional statements if, if-else and while, as a result of which the need for else-if is eliminated (see Figure 3). \n\nThe Events module does all real-time checks, monitors any changes in the drawing area. This module prevents the generation of program code if there are unconnected elements. The attempt to generate a code if there is an element in red activates a pop-up message on the screen informing that the generation cannot take place (see Figure 4). The last makes working with the program quite intuitive and thus reduces the probability of a compilation error.",
            "score": 0.3544289123930477,
            "section_title": "Figure 3. Nested conditional statement",
            "char_start_offset": 8471,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 289
                },
                {
                    "start": 290,
                    "end": 475
                },
                {
                    "start": 476,
                    "end": 659
                },
                {
                    "start": 662,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 835
                },
                {
                    "start": 836,
                    "end": 1001
                },
                {
                    "start": 1002,
                    "end": 1114
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88720703125
        },
        {
            "corpus_id": "269183392",
            "title": "Taking ASCII Drawings Seriously: How Programmers Diagram Code",
            "text": "Computer code is a form of human communication, and most code today is written as text. However, text is a limited media, especially when trying to describe inherently visual ideas. Programmers thus resort to visuals to articulate design decisions to their colleagues, e.g. by drawing a diagram on a whiteboard to illustrate relationships and procedures [45]. But these visual artifacts are ephemeral-they are rarely archived or documented digitally [21]. This fragmentation implies that text-based computer code can efectively convey only a portion of its author's thought processes that went into writing that code, thus placing burden on the reader to reconstruct its underlying ideas. We envision a future of programming where graphics sits alongside text and tightly integrate with it-where developers can use the most ftting representation for any given task. As a frst step towards this vision, we wish to understand how text and graphics currently integrate within source code. \n\nTo date, the primary media of code is monospace text, traditionally nicknamed \"ASCII\" after the infuential and widespread \"American Standard Code for Information Interchange\" text encoding format [16,47], of which more fexible modern encodings such as UTF-8 are a superset [24]. Historically, typewriters and teletypes 1were monospace for mechanical simplicity: each character used the exact same amount of space on the page [30]. The monospace tradition continues in modern text editors for programming. \n\nGiven that programming continues to be a text-based activity [14], one may expect there to be few, if any, graphical artifacts within real-world codebases. But instead, the simple grid-like arrangement of monospace text allows for robust alignment between lines of text. Thus we fnd frequent anecdotes of developers who appropriate text through creative uses of monospace text characters to approximate line drawings, which are commonly referred to as ASCII diagrams [54], such as the examples shown in Figure 1. \n\nHowever, beyond anecdotes, little is known about these diagrams in code. We can only speculate about why and how they are created, what roles they serve, and what information they display. In this work, we seek to reveal the world of ASCII diagrams.",
            "score": 0.35279080657428796,
            "section_title": "INTRODUCTION",
            "char_start_offset": 1198,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 87
                },
                {
                    "start": 88,
                    "end": 181
                },
                {
                    "start": 182,
                    "end": 359
                },
                {
                    "start": 360,
                    "end": 455
                },
                {
                    "start": 456,
                    "end": 688
                },
                {
                    "start": 689,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 985
                },
                {
                    "start": 988,
                    "end": 1266
                },
                {
                    "start": 1267,
                    "end": 1418
                },
                {
                    "start": 1419,
                    "end": 1492
                },
                {
                    "start": 1495,
                    "end": 1650
                },
                {
                    "start": 1651,
                    "end": 1765
                },
                {
                    "start": 1766,
                    "end": 2007
                },
                {
                    "start": 2010,
                    "end": 2082
                },
                {
                    "start": 2083,
                    "end": 2198
                },
                {
                    "start": 2199,
                    "end": 2259
                }
            ],
            "ref_mentions": [
                {
                    "start": 354,
                    "end": 358,
                    "matchedPaperCorpusId": "7525652"
                },
                {
                    "start": 450,
                    "end": 454,
                    "matchedPaperCorpusId": "6604218"
                },
                {
                    "start": 1556,
                    "end": 1560,
                    "matchedPaperCorpusId": "218483468"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3701171875
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "Diagrams and other graphical logic and/or model representations have been playing a role in software development since the appearance of the modern digital computers in the 1940s. In the beginning, the diagrams were paper-based aids, used to design and understand the software structure, but then, interest appeared in the direct use of diagrams as a solution to improve software development tools. This led to the appearing of visual software project management tools, visual editors for graphical interface creation, visual tools for software modeling and engineering, and visual programming languages [Cox 2007]. \n\nA Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as: \n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device. \n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]. \n\nVPLs have been explored and used in several domains, including, but not limited to, educational activities (e.g. learning to program), multimedia, video game development, system design and development, simulations, automation, data warehousing and business analytics [ Ray 2017]. \n\nAlthough several domains of applications already take advantage of the use of VPLs, the emerging field of Internetof-Things (IoT) is still lingering far behind other sectors. \n\nVisual Programming Languages are commonly used with the intent of abstracting low-level concepts and details into a more high-level logic, through the use of visual metaphors [Barricelli and Valtolina 2015;Thomas and Barry 2003]. The application of domain-specific visual programming languages to solve the need of abstraction from the low-level and heterogeneous devices that usually make a part in the IoT connected world can already be observed. We can consider, as an example, how graphical-based programming languages are already widely used for programming low-level devices such as Programmed Logic Controllers (PLCs) in high-production manufacturing systems [Younis and Frey 2003]. \n\nThe goal of this section is to review the landscape of visual programming environments (viz.",
            "score": 0.3509754580961078,
            "section_title": "Visual Programming for IoT",
            "char_start_offset": 44329,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 179
                },
                {
                    "start": 180,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 615
                },
                {
                    "start": 618,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 768
                },
                {
                    "start": 771,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1205
                },
                {
                    "start": 1206,
                    "end": 1221
                },
                {
                    "start": 1224,
                    "end": 1336
                },
                {
                    "start": 1337,
                    "end": 1503
                },
                {
                    "start": 1506,
                    "end": 1680
                },
                {
                    "start": 1683,
                    "end": 1912
                },
                {
                    "start": 1913,
                    "end": 2131
                },
                {
                    "start": 2132,
                    "end": 2372
                },
                {
                    "start": 2375,
                    "end": 2467
                }
            ],
            "ref_mentions": [
                {
                    "start": 752,
                    "end": 763,
                    "matchedPaperCorpusId": "48762803"
                },
                {
                    "start": 1209,
                    "end": 1220,
                    "matchedPaperCorpusId": "48762803"
                },
                {
                    "start": 1493,
                    "end": 1502,
                    "matchedPaperCorpusId": "30037917"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96337890625
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "Being learning tools, visual programming systems strike for a balance between programming facilities and ease-of-use. Thus, more advanced programming techniques may be left out, restricting deployment to small-scale projects. In this context, optional programming features may be provided targeted to more advanced learners as listed below: \n\n\u2022 Scopes may be defined by visual grouping, with local variables being geometrically contained. \u2022 Modules allow split programs into multiple units and reuse them in one or more projects. \u2022 Hybrid code enables contrast the visual code and its respective textual form altogether, enabling mixed editing, while keeping both views fully-synced and well-formed. \u2022 Source code that complements visual code, helpful for implementing complex modules, and also for supporting the cooperation of learners with experienced programmers.",
            "score": 0.3509754580961078,
            "section_title": "Extra Optional Elements",
            "char_start_offset": 11413,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 117
                },
                {
                    "start": 118,
                    "end": 225
                },
                {
                    "start": 226,
                    "end": 340
                },
                {
                    "start": 343,
                    "end": 438
                },
                {
                    "start": 439,
                    "end": 529
                },
                {
                    "start": 530,
                    "end": 699
                },
                {
                    "start": 700,
                    "end": 867
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94580078125
        },
        {
            "corpus_id": "250414169",
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "text": "A tangible output can be experienced and perceived through physical representations, unlike a visual output, which uses more mental representations (Chevalier et al., 2022;Marshall, 2007). Moreover, a visual programming environment with a tangible output also differs from a visual programming environment with an on-screen output in terms of the connections between the physical and digital representations (O'Malley & Fraser, 2004). Furthermore, it can be argued that a three-dimensional, physical representation provides different forms of information, immersion and engagement from a two-dimensional, visual, on-screen representation (Price et al., 2003). Some studies indicate that learning to program is more effective and meaningful when the learner operates a tangible and meaningful object (Horn & Bers, 2019;Papert, 1980;Resnick et al., 1990); other research claims that the visual characteristics of the more virtual world are a better way to develop mental representations of the program based on the structure of the data flow (Navarro-Prieto & Ca\u00f1as, 2001;Segura et al., 2020). In order to explain the learning outcomes resulting from different output modalities in programming, more research is needed into the influence of the interaction between a visual programming environment and a tangible or visual type of output (Skulmowski et al., 2016;Zhu, 2021). \n\nVisual programming environments use on-screen code elements that help novice programmers to easily understand and construct the process of programming (Price & Barnes, 2015). The advantages of these visual programming environments are that no specific syntax needs to be mastered and that the level of abstraction is low, due to the high extent of visualisation and generalisation (Weintrop & Wilensky, 2015). Visual programming environments are also intended to support the understanding and application of control flow structures (Chao, 2016). Due to their attractiveness, transparency and clarity, visual programming environments can help to increase user engagement in solving programming tasks (Asad et al., 2016). In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- L\u00f3pez et al., 2016).",
            "score": 0.3475544306000783,
            "section_title": "Theoretical framework",
            "char_start_offset": 13432,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 188
                },
                {
                    "start": 189,
                    "end": 434
                },
                {
                    "start": 435,
                    "end": 659
                },
                {
                    "start": 660,
                    "end": 1091
                },
                {
                    "start": 1092,
                    "end": 1372
                },
                {
                    "start": 1375,
                    "end": 1549
                },
                {
                    "start": 1550,
                    "end": 1784
                },
                {
                    "start": 1785,
                    "end": 1920
                },
                {
                    "start": 1921,
                    "end": 2094
                },
                {
                    "start": 2095,
                    "end": 2329
                }
            ],
            "ref_mentions": [
                {
                    "start": 148,
                    "end": 172,
                    "matchedPaperCorpusId": "247170773"
                },
                {
                    "start": 408,
                    "end": 432,
                    "matchedPaperCorpusId": "55769452"
                },
                {
                    "start": 638,
                    "end": 658,
                    "matchedPaperCorpusId": "3523310"
                },
                {
                    "start": 818,
                    "end": 831,
                    "matchedPaperCorpusId": "53769342"
                },
                {
                    "start": 1040,
                    "end": 1070,
                    "matchedPaperCorpusId": "16771725"
                },
                {
                    "start": 1070,
                    "end": 1090,
                    "matchedPaperCorpusId": "203701301"
                },
                {
                    "start": 1336,
                    "end": 1361,
                    "matchedPaperCorpusId": "10493691"
                },
                {
                    "start": 1526,
                    "end": 1548,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 1756,
                    "end": 1783,
                    "matchedPaperCorpusId": "207226901"
                },
                {
                    "start": 1907,
                    "end": 1919,
                    "matchedPaperCorpusId": "206930744"
                },
                {
                    "start": 2074,
                    "end": 2093,
                    "matchedPaperCorpusId": "63111506"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88818359375
        },
        {
            "corpus_id": "1063008",
            "title": "A General Framework for Overlay Visualization",
            "text": "The visualizer (shown as a dark box in Figure 1) gets a declarative list of visual specifications as input, e.g., a list of specifications to illustrate the execution of a for loop, while loop, or switch statement. The Visualizer creates the visual primitives corresponding to the visual specifications. The visual primitives in turn create the graphical primitives needed to render them. During rendering, the Visualizer sequences the rendering of the visual primitives, which in turn delegate the rendering to their corresponding graphical primitives.",
            "score": 0.3475544306000783,
            "section_title": "Visualizer:",
            "char_start_offset": 4351,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 214
                },
                {
                    "start": 215,
                    "end": 303
                },
                {
                    "start": 304,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 553
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7353515625
        },
        {
            "corpus_id": "51714945",
            "title": "Use of visual programming in the university education by means of free software",
            "text": "The term visual programming has started to be used in Informatics so far, however, there are different views on its meaning. The separation of visual programming from development tools of interfaces provides not only the certainty for this technology, but also opens the systems of modeling and programming in the education unknown to a wide range. The use of visual programming which is based on the free software provides the new perspective algorithmic culture formation of future professionals of non-computer specialists. A wide application of visual programming in the educational process is the perspective direction of the cognitive activity intensification, laying the foundations of the algorithmic competence. Visual simulation systems which are related to the creation of the unified means of any software, when are used in training activities allow not only to create models, determining the nature, categories and connections, but also to perform the experimental calculation of the model's conduct for parametric input data, identify behaviour of the system. Therefore the detection problem of the free software that supports visual programming is relevant and for its solution the general features of such systems and ways of their use have been analyzed. These results suggest the significant potential use of visual programming technologies in the educational activities and that there exist the free software which implements this technology and only enhances its value. Visual programming is an advanced technology, but also has directions and prospects. Although it has not got a large scale in programming yet but it has the experience in the educational application. The results of the visual programming use in the algorithmic culture formation are undeniable, and thus the further use with improvement techniques will allow to develop the future students' algorithmic competence.",
            "score": 0.3475544306000783,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9072265625
        },
        {
            "corpus_id": "11040530",
            "title": "Verificator: Educational Tool for Learning Programming",
            "text": "It is a 3-D Interactive Graphics Programming Environment that allows scripting and modeling prototype objects that a virtual simulation world is made of (Pausch et al., 1995). In simulations, students can use simple scripts to control the appearance and behavior of objects. During script execution, visualization allows students to establish correlation between the program and the animated action of the complex and thus understand how basic programming constructs operate. TRAKLA2 is a visual environment that allows the assessment of simulation of algorithms and data structures (Korhonen et al., 2003). VILLE is a visual tool that supports Java, C ++ and pseudo programming languages (Kaila et al., 2009). Programming examples can be simultaneously displayed in two programming languages, and thus show different implementations of programming concepts. In addition, VILLE allows monitoring of the execution of the program and thus of the result of changes in the output arising from changes in the value of variables. Finally, we should by all means mention BlueJ as an example of a static visualization tool whose characteristics are a directly parameterized call of the method and automatic generation of applet skeleton. Its basic purpose is acquiring object-oriented concepts in the Java programming language (K\u00f6lling et al., 2003). \n\nFrom all the aforementioned examples it can be concluded that visualization tools are very useful in teaching programming to novice students, primarily because they can show and explain programming concepts in a very simple way. However, their main disadvantage is that the majority of them are focused on only one programming language and the simplest program constructs. Furthermore, the aim of teaching programming is that students understand basic programming concepts and that they become able to apply those concepts during the problem solving process, regardless of implemented programming language. Unfortunately, most of these tools are too focused on the visualization component, and less on learning the syntax and semantics of the selected programming language. Therefore, we believe that the visualization tools are more appropriate for teaching programming in elementary schools, but not at universities where the student needs to learn algorithmic approach to solve given problems. Finally, the results of research that has followed the use of most of the aforementioned tools have not revealed any significantly better results and students still experience the same difficulties when learning basic programming (Milne and Rowe, 2002;Lahtinen et al., 2005;Butler and Morgan, 2007).",
            "score": 0.3475544306000783,
            "section_title": "Related Work",
            "char_start_offset": 9335,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 274
                },
                {
                    "start": 275,
                    "end": 475
                },
                {
                    "start": 476,
                    "end": 607
                },
                {
                    "start": 608,
                    "end": 710
                },
                {
                    "start": 711,
                    "end": 858
                },
                {
                    "start": 859,
                    "end": 1023
                },
                {
                    "start": 1024,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1342
                },
                {
                    "start": 1345,
                    "end": 1573
                },
                {
                    "start": 1574,
                    "end": 1717
                },
                {
                    "start": 1718,
                    "end": 1951
                },
                {
                    "start": 1952,
                    "end": 2118
                },
                {
                    "start": 2119,
                    "end": 2341
                },
                {
                    "start": 2342,
                    "end": 2641
                }
            ],
            "ref_mentions": [
                {
                    "start": 153,
                    "end": 174,
                    "matchedPaperCorpusId": "59702596"
                },
                {
                    "start": 583,
                    "end": 606,
                    "matchedPaperCorpusId": "59855353"
                },
                {
                    "start": 689,
                    "end": 709,
                    "matchedPaperCorpusId": "6167862"
                },
                {
                    "start": 1319,
                    "end": 1341,
                    "matchedPaperCorpusId": "2805887"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8583984375
        },
        {
            "corpus_id": "54577943",
            "title": "Enhanced Testing of Autonomous Underwater Vehicles Using Augmented Reality & JavaBeans",
            "text": "Monolithic programming approaches then make reconfiguration and extension almost impossible. Add-ons can sometimes be \"hacked\" into the existing program, but in essence it is still a very inflexible program that will eventually become obsolete because a new usage or platform is required. At this stage it may be too complicated to try and extend the existing program to fulfil the new requirements, so instead a new program is quickly created with a few differences but is in essence just as inflexible as the first. More time spent making generic modules with basic inputs and basic outputs in a configurable environment makes making changes later on quicker and easier. However, when completely new functionality is required, a configurable environment still has to be reprogrammed to incorporate new modules. This can be difficult unless the environment is specifically designed to allow extension. Visual programming (Hirakawa & Ichikawa, 1992) provides a solution for rapid module development and provides some ideas which can be harnessed to provide the basic idea behind a generic architecture for creating virtual environments. Visual programming is the activity of making programs through spatial manipulations of visual elements. It is not new and has been around since the very early 1970s when logic circuits were starting to be designed using Computer Aided Design (CAD) packages. Visual programming is more intuitive than standard computer programming because visual programming provides more direct communication between human and computer which given the correct visual queues makes it easier for the user to understand the relationships between entities, and thus makes connecting components easier. Consider the example of taking ice cube trays out of the freezer and placing one in a drink. The human way of doing this is simply to look to locate the ice cubes, use the hands to manipulate the ice cube out of the tray and then drop it into the drink. Thus any interface which allows the user to work in their natural way is going to make the job quicker. The other option, which is more like computer programming, is to have the human write down every single action required to do this. The visual programming approach might be to manipulate a visual representation of the ice cube trays by dragging and clicking a mouse. Programming is far more clunky and will take much longer as it is not as intuitive.",
            "score": 0.3475544306000783,
            "section_title": "Visual programming",
            "char_start_offset": 18461,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 92
                },
                {
                    "start": 93,
                    "end": 288
                },
                {
                    "start": 289,
                    "end": 517
                },
                {
                    "start": 518,
                    "end": 672
                },
                {
                    "start": 673,
                    "end": 812
                },
                {
                    "start": 813,
                    "end": 902
                },
                {
                    "start": 903,
                    "end": 1136
                },
                {
                    "start": 1137,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1394
                },
                {
                    "start": 1395,
                    "end": 1717
                },
                {
                    "start": 1718,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1971
                },
                {
                    "start": 1972,
                    "end": 2075
                },
                {
                    "start": 2076,
                    "end": 2207
                },
                {
                    "start": 2208,
                    "end": 2342
                },
                {
                    "start": 2343,
                    "end": 2426
                }
            ],
            "ref_mentions": [
                {
                    "start": 922,
                    "end": 949,
                    "matchedPaperCorpusId": "57747088"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91357421875
        },
        {
            "corpus_id": "237977073",
            "title": "The Role of distance learning via the Internet in Learning Programming: Learners' Point of View",
            "text": "The latter adopted the presentation of the content in those lessons, and it does not include rearranging, synthesis, or formulation of its topics. Rather, it was adopted and based on the explanatory texts accompanying the practicalsoftware application designed as a video that is shown to them in a series of computerized lessons. \n\nThe second axis: Visual Basic 6.0 programming \n\nThe programming language (Visual Basic) in its sixth edition is considered one of the most prominent programming languages with a graphical interface, according to which the programmer can design programs with great capabilities in many areas of life, whether educational, application or even administrative, and it is produced by Microsoft, the leader in the production of software of wide variety, popularity,meticulous design, and implementation. the programmer in general and students, in particular, can design a variety of programs within them, ranging in level of difficulty from simple to more complex with detailed serving various fields. Halverson (1999) stated that Visual Basic is a program that works to perform tasks It enables users to write effective programs that are compatible with Windows operating system, and it works according to some basic instructions and commands and programming procedures in it (p. 27). Currently, a group of newer versions of this programming language has appeared, noting that this language was fully compatible with the versions of many operating systems, but there havebeen changesforthe stop of support, after the launch of several newer versions of it, which led to the difficulty of the work and practically applying it by many students on their modern personal computers, incompatible with these versions. This programming language consists of the main interface that includes implicit tapes and commands, and a toolbox with severalcharacteristics of each object, and it is operated in several ways that have been demonstrated within the lessons intended to learn the topic of the current study, as well as it featured of accuracy and ease of design, implementation, and tracking of outcomes.",
            "score": 0.3470743066453365,
            "section_title": "Interaction between learners.",
            "char_start_offset": 12709,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 330
                },
                {
                    "start": 333,
                    "end": 378
                },
                {
                    "start": 381,
                    "end": 830
                },
                {
                    "start": 831,
                    "end": 1028
                },
                {
                    "start": 1029,
                    "end": 1307
                },
                {
                    "start": 1308,
                    "end": 1312
                },
                {
                    "start": 1313,
                    "end": 1739
                },
                {
                    "start": 1740,
                    "end": 2126
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.459716796875
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "We have reported on BridgeTalk, a new approach to visual languages for novice programmers. BridgeTalk is based on actual data about how novices learn to program. It allows novices to program with programming plans, and focuses novices on the interactions between plans, not on the implementation details for a particular plan. Beginning with plans as a basis for a novice programming language, we were forced to develop a programming formalism that could deal with multiple levels of detail, merged plan implementations, and interrelationships between plans. Finally, we used six \"design, implement, test, and redesign\" cycles to develop a specific visual representation for the language.\n\nA key contribution of this work is the systematic support for a plan-like view of programming. We feel that such support is essential if programming languages are to allow a programmer, novice or expert, to work with programming constructs that reflect actual world semantics. Unfortunately, \"high level programming language\" has come to mean more abstract data structures and more formal semantics. We advocate, and have demonstrated the feasability of, \"high level languages\" that reflect the semantics of real-world objects.\n\nConsistant with a language that makes a richer connection to the semantics of real-world objects, our language provides novices with a pathway from experience in the real-world, to real-world plans, to standard programming language constructs. Current software systems force a user to either use the system as is, or become a programmer. BridgeTalk illustrates an approach that provides a smoother transition with many intermediate steps along the way. That is, programming strictly with plans simplifies programming by allowing users to draw on their knowledge of real-world situations, but limits users to those plans provided in the system. Because the internals of the plans can be examined, modified, and specialized, users can extend the power of their system beyond the predefined plans.\n\nOne of the most important lessons of this work is the criticality of empiricial work in the design of visual languages. Without the extensive empirical work documented in this report, our language would be much poorer. Furthermore, the language would more than likely be unsuitable for use with novices. There is no reason to believe that languages designed based on purely formal and intuitive arguments will be usable. Until a suitable theory of visual interface design emerges, we feel that",
            "score": 0.34561661602998295,
            "section_title": "Conclusions",
            "char_start_offset": 56745,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80078125
        },
        {
            "corpus_id": "224865976",
            "title": "EUD-MARS: End-user development of model-driven adaptive robotics software systems",
            "text": "Tool-supported visual paradigms enable end-users to perform some of the programming tasks that professional programmers usually perform. Since we primarily intended EUD-MARS to be for end-users, we devised a visual programming tool to complement it. \n\nThis tool (Fig. 14) is web-based and uses Blockly. The latter is a JavaScript library created by Google to support the development of visual programming languages and tools [94]. Blockly represents coding concepts as interlocking blocks. Scratch, the end-user visual programming tool has been using interlocking blocks since before Blockly's initial release. Researchers have used Blockly to develop languages for several types of applications including model checking [95], web development [96], and data queries [97]. Blockly's paradigm is similar to jigsaw puzzles, which researchers introduced and evaluated in the area of end-user development [98,99]. We also used jigsaw puzzles as the visual notation for Visual Simple Transformations (ViSiT), which is an approach that empowers end-users to wire together previously incompatible IoT objects [100]. The previous work showed that end-users perceive visual interlocking blocks to be usable and learnable. Hence, we used this visualization paradigm for EUD-MARS since it is a promising choice. \n\nUsing the tool that we developed, end-users can drag visual programming blocks from a toolbar (Fig. 14a) onto a canvas (Fig. 14b). These blocks represent concepts such as actions, action sequences, events, and so on. End-users can save their visual programs to files and reload them later to continue their work (Fig. 14c). The toolbar contains some fixed elements such as the ones related to numbers and text. The toolbar also contains other elements such as actions, which are loaded dynamically based on the program's robot pool. End-users can drag and drop elements to move them around on the canvas. They can also delete individual elements or the entire program (Fig. 14d). End-users can zoom the canvas in and out to visualize the program in a better way on different resolutions. \n\nEnd-users can run their programs directly from the tool (Fig. 14e).",
            "score": 0.3441653753236377,
            "section_title": "Tool for end-users",
            "char_start_offset": 86859,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 136
                },
                {
                    "start": 137,
                    "end": 249
                },
                {
                    "start": 252,
                    "end": 302
                },
                {
                    "start": 303,
                    "end": 430
                },
                {
                    "start": 431,
                    "end": 489
                },
                {
                    "start": 490,
                    "end": 610
                },
                {
                    "start": 611,
                    "end": 771
                },
                {
                    "start": 772,
                    "end": 908
                },
                {
                    "start": 909,
                    "end": 1107
                },
                {
                    "start": 1108,
                    "end": 1211
                },
                {
                    "start": 1212,
                    "end": 1299
                },
                {
                    "start": 1302,
                    "end": 1432
                },
                {
                    "start": 1433,
                    "end": 1518
                },
                {
                    "start": 1519,
                    "end": 1625
                },
                {
                    "start": 1626,
                    "end": 1712
                },
                {
                    "start": 1713,
                    "end": 1834
                },
                {
                    "start": 1835,
                    "end": 1906
                },
                {
                    "start": 1907,
                    "end": 1981
                },
                {
                    "start": 1982,
                    "end": 2089
                },
                {
                    "start": 2092,
                    "end": 2159
                }
            ],
            "ref_mentions": [
                {
                    "start": 425,
                    "end": 429,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 721,
                    "end": 725,
                    "matchedPaperCorpusId": "27966302"
                },
                {
                    "start": 743,
                    "end": 747,
                    "matchedPaperCorpusId": "7626370"
                },
                {
                    "start": 766,
                    "end": 770,
                    "matchedPaperCorpusId": "18324831"
                },
                {
                    "start": 900,
                    "end": 904,
                    "matchedPaperCorpusId": "7388219"
                },
                {
                    "start": 904,
                    "end": 907,
                    "matchedPaperCorpusId": "14321554"
                },
                {
                    "start": 1101,
                    "end": 1106,
                    "matchedPaperCorpusId": "267872312"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9091796875
        },
        {
            "corpus_id": "4039308",
            "title": "Visual and textual programming languages: a systematic review of the literature",
            "text": "Throughout this review, we have discussed the benefits of learning a Visual Programming Language and whether or not the First Programming Language choice has profound effect on student performance and interest. It is clear that the most important thing educators can do is make their course interesting, and ensure it covers all the important elements needed to truly \"know\" programming. If a student of any age enjoys what they are doing, there is a better chance that they are going to understand it and continue studying it. \n\nIt has been demonstrated through the answers to the research questions that the actual choice of what tools to use does not matter, within reason. The use of a Visual Programming Lan will in most cases, be very helpful to a student. It may not be something to pursue for a longitudinal time frame, but as an introduction to CS, it is clearly beneficial and will generally lead to higher retention of knowledge and interest. \n\nWe present this paper in the hope that educators at all levels and in all institution types will examine the options available to them when they are teaching programming. This review may go some way to informing their decisions around the first programming language to use and the benefits of both text-based and visual-based programming languages.",
            "score": 0.3441653753236377,
            "section_title": "Discussion",
            "char_start_offset": 49087,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 210
                },
                {
                    "start": 211,
                    "end": 387
                },
                {
                    "start": 388,
                    "end": 527
                },
                {
                    "start": 530,
                    "end": 676
                },
                {
                    "start": 677,
                    "end": 762
                },
                {
                    "start": 763,
                    "end": 953
                },
                {
                    "start": 956,
                    "end": 1126
                },
                {
                    "start": 1127,
                    "end": 1304
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.783203125
        },
        {
            "corpus_id": "7271567",
            "title": "A visual programming language for drawing and executing flowcharts",
            "text": "In [4] a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time LabView and Simulink can be mentioned as the representatives of a big group -the data flow VPLs, described in [5], which are based around a functional programming style. A similar VPL, but presented as an online web service is Yahoo Pipes [6]. \n\nKTechlab [7] is a flowchart VPL used to describe hardware components. Scratch [8] is a good example of a WHILE language flowchart VPL that has taken the role of education through fun and interactive app programming. One drawback in Scratch is that it doesn't present the user with the source code generated from his flowchart, thus not encouraging gradual transition to classical programming as the user gets more experienced.",
            "score": 0.3441653753236377,
            "section_title": "B. Related work",
            "char_start_offset": 4177,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 182
                },
                {
                    "start": 183,
                    "end": 223
                },
                {
                    "start": 226,
                    "end": 619
                },
                {
                    "start": 620,
                    "end": 693
                },
                {
                    "start": 696,
                    "end": 765
                },
                {
                    "start": 766,
                    "end": 911
                },
                {
                    "start": 912,
                    "end": 1122
                }
            ],
            "ref_mentions": [
                {
                    "start": 3,
                    "end": 6,
                    "matchedPaperCorpusId": "13484911"
                },
                {
                    "start": 560,
                    "end": 563,
                    "matchedPaperCorpusId": "5257722"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93798828125
        },
        {
            "corpus_id": "267035296",
            "title": "Image Translation as Diffusion Visual Programmers",
            "text": "The DVP framework utilizes a series of visual programming operations to enable image translation, thereby enhancing its capacity for context-aware reasoning for arbitrary content manipu-Pseudo-code 2: Pseudo-code of in-context visual programming in a PyTorch-like style. \n\nclass VisualProgramming(): def __init__(self): # load pre-trained models and transfer them to the GPU def html(self, inputs: List): # return an string that visually represents the input and output steps. lation. Fig. 10 provides more results and showcases our advantages over strong baselines, i.e., Prompt2Prompt (Mokady et al., 2023) and VISPROG (Gupta & Kembhavi, 2023).",
            "score": 0.3441653753236377,
            "section_title": "C MORE QUALITATIVE RESULTS FOR IN-CONTEXT REASONING",
            "char_start_offset": 28337,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 270
                },
                {
                    "start": 273,
                    "end": 476
                },
                {
                    "start": 477,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 646
                }
            ],
            "ref_mentions": [
                {
                    "start": 587,
                    "end": 608,
                    "matchedPaperCorpusId": "253581838"
                },
                {
                    "start": 621,
                    "end": 645,
                    "matchedPaperCorpusId": "253734854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84375
        },
        {
            "corpus_id": "11795228",
            "title": "Visual definition of procedures for automatic virtual scene generation",
            "text": "Visual programming has been researched extensively in the past. In the following section a short overvies of the state of the art is presented.\n\nAfter that the recent advances in procedural scene modeling will be examined.",
            "score": 0.3441653753236377,
            "section_title": "Related work",
            "char_start_offset": 7120,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8828125
        },
        {
            "corpus_id": "60941791",
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "text": "Visual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
            "score": 0.3441653753236377,
            "section_title": "body",
            "char_start_offset": 1,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 235
                },
                {
                    "start": 236,
                    "end": 403
                },
                {
                    "start": 404,
                    "end": 673
                },
                {
                    "start": 674,
                    "end": 953
                },
                {
                    "start": 956,
                    "end": 1988
                },
                {
                    "start": 1991,
                    "end": 2095
                }
            ],
            "ref_mentions": [
                {
                    "start": 91,
                    "end": 94,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 949,
                    "end": 952,
                    "matchedPaperCorpusId": "220866115"
                },
                {
                    "start": 1011,
                    "end": 1014,
                    "matchedPaperCorpusId": "11750514"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9892578125
        },
        {
            "corpus_id": "268249114",
            "title": "Making Hybrid Languages: A Recipe",
            "text": "Programmers use programming languages to communicate their thoughts, both to computers and to other programmers. Linear text suffices for this purpose most of the time, but some thoughts are inherently geometric and better expressed visually. \n\nRecognizing this problem, researchers have devised many solutions ranging from purely visual languages [Resnick et al. 2009], to special-purpose IDEs [Perez and Granger 2007] various other strategies [Bein et al. 2020;Omar et al. 2021]. \n\nIn particular, Andersen et al. [2020] proposed the idea of a hybrid language, which combines textual code with miniature graphical user interfaces (GUIs), dubbed visual and interactive syntax. Using a hybrid language, programmers can communicate their thoughts with text most of the time and weave in visual interactive constructs when it is appropriate for the problem domain. \n\nFor example, consider the calculation of quadratic B\u00e9zier curves [Farin 2014]. The standard algorithm combines two tasks: finding midpoints and recursion. While the second is easily expressed via text, the first is a geometric idea that deserves a pictorial representation. The build-bez function in figure 1 illustrates how a programmer might use a hybrid variant of Clojure to convey these two ideas. It computes a set of B\u00e9zier points from three input points that form a triangle. While the embedded visual syntax depicts the midpoint (of midpoints) calculation, recursively computing the rest of the points remains textual. \n\nUnfortunately, existing attempts at visual syntax have fundamental flaws that either unreasonably disrupt a programmer's typical workflow, impose an undue burden on a language implementation, or both. For example, such solutions almost always force programmers to use one particular (new) IDE for their work, a non-starter for most. Andersen et al. [2020]'s solution forces a language implementation to maintain two different GUI libraries and keep them synchronized-when even one such library already imposes a serious amount of work for most languages. This duplication makes the implementation costly to unmaintain. It also means programmers will often have to implement the same GUI twice: once for the actual user interface-using the original GUI libraryand a second time for the visual syntax renderer-using the special-purpose library.",
            "score": 0.3441653753236377,
            "section_title": "MIXING TEXT WITH VISUAL AND INTERACTIVE SYNTAX",
            "char_start_offset": 801,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 112
                },
                {
                    "start": 113,
                    "end": 242
                },
                {
                    "start": 245,
                    "end": 481
                },
                {
                    "start": 484,
                    "end": 676
                },
                {
                    "start": 677,
                    "end": 861
                },
                {
                    "start": 864,
                    "end": 942
                },
                {
                    "start": 943,
                    "end": 1018
                },
                {
                    "start": 1019,
                    "end": 1137
                },
                {
                    "start": 1138,
                    "end": 1266
                },
                {
                    "start": 1267,
                    "end": 1347
                },
                {
                    "start": 1348,
                    "end": 1491
                },
                {
                    "start": 1494,
                    "end": 1694
                },
                {
                    "start": 1695,
                    "end": 1826
                },
                {
                    "start": 1827,
                    "end": 2048
                },
                {
                    "start": 2049,
                    "end": 2112
                },
                {
                    "start": 2113,
                    "end": 2336
                }
            ],
            "ref_mentions": [
                {
                    "start": 395,
                    "end": 419,
                    "matchedPaperCorpusId": "16637923"
                },
                {
                    "start": 463,
                    "end": 479,
                    "matchedPaperCorpusId": "235474027"
                },
                {
                    "start": 499,
                    "end": 521,
                    "matchedPaperCorpusId": "225067888"
                },
                {
                    "start": 929,
                    "end": 940,
                    "matchedPaperCorpusId": "207062075"
                },
                {
                    "start": 1827,
                    "end": 1849,
                    "matchedPaperCorpusId": "225067888"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5849609375
        },
        {
            "corpus_id": "818925",
            "title": "Catroid: a mobile visual programming system for children",
            "text": "There is a worldwide shortage of qualified software developers. This is due to rapidly increasing demand together with stagnating or even declining number of computer science students. This decline has been even more pronounced for females over the last 25 years, and it seems that even though younger girls can be interested in programming to the same degree as boys of their age, girls consistently seem to lose interest in their late teens [1,2]. At the same time our society increasingly relies on software which is thus less and less understood by the general population. Moreover, software development skills are not only of interest for obvious professional but also for philosophical reasons: Developing software is a skill that helps understanding the fundamental mechanisms and limitations underlying rational thinking. \n\nWhat is visual programming, and why do we use it? Visual programming predominantly consists in moving graphical elements instead of typing text. We use visual programming because, based on informal experiences, it seems aesthetically to be more attractive to kids than simple text, and the success of MIT's Scratch programming environment undeniably has proven in practice more than two million times that it is very appealing to kids 1 . Note that visual programming is not easy but that if children are motivated, they are ready to spend the necessary time: Visual programming is not about dumbing down programming but instead about motivation by avoiding frustration due to, e.g., spurious syntactic mumbo jumbo, unnecessarily complicated work flows, or hard to spot syntax errors as frequently encountered in mainstream programming languages. \n\nA drawback of visual programming? Visual programming has been criticized to not scale well to larger and more complex programs. However, practical evidence from visual programming environments shows that large and complex programs such as a 3D chess engine with an AI based machine opponent, multi level jump and run games, complex physics simulations, Sudoku solvers, and much more are possible with a hierarchical organization of program elements. \n\nWhy mobile devices? Worldwide there are ten times more mobile phones than PCs, and this ratio even is much more pronounced for children (think China and developing countries). Moreover, one's smartphone nowadays is always in one's pocket and can easily be used everywhere without preparation, e.g., when commuting to one's school using public transportation or at the backseat of the family car.",
            "score": 0.34326967834830613,
            "section_title": "INTRODUCTION Why programming for children?",
            "char_start_offset": 45,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 63
                },
                {
                    "start": 64,
                    "end": 184
                },
                {
                    "start": 185,
                    "end": 449
                },
                {
                    "start": 450,
                    "end": 576
                },
                {
                    "start": 577,
                    "end": 829
                },
                {
                    "start": 832,
                    "end": 881
                },
                {
                    "start": 882,
                    "end": 976
                },
                {
                    "start": 977,
                    "end": 1270
                },
                {
                    "start": 1271,
                    "end": 1678
                },
                {
                    "start": 1681,
                    "end": 1714
                },
                {
                    "start": 1715,
                    "end": 1808
                },
                {
                    "start": 1809,
                    "end": 2130
                },
                {
                    "start": 2133,
                    "end": 2152
                },
                {
                    "start": 2153,
                    "end": 2308
                },
                {
                    "start": 2309,
                    "end": 2528
                }
            ],
            "ref_mentions": [
                {
                    "start": 443,
                    "end": 446,
                    "matchedPaperCorpusId": "14395160"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88427734375
        },
        {
            "corpus_id": "266514821",
            "title": "EntangleVR++: evaluating the potential of using entanglement in an interactive VR scene creation system",
            "text": "Visual programming systems (VPS) offer an opportunity to enable novice and casual users to create complex programs by using graphical elements and little training Myers (1990).Because the variable states and data flows of a program are visualized, visual programming is often used in educational environments to help students understand relatively difficult concepts Tamilselvam et al. (2019);Pinto-Llorente et al. (2016); Krishnamoorthy and Kapila (2016).Visualization and immediate feedback in a VPS matches with the graphical interface concept of What-You-eXperience-Is-What-You-Get (WYXIWYG) Lee et al. (2005).In an ideal VR authoring tool, the creator would immediately see and experience the output during the creation process.The simplicity of creation provided by the combination of visual programming and WYXIWYG has led to the design of a few VR authoring tools and platforms in recent years.For example, Dreams20 is an immersive creation system on the PlayStation gaming console that is widely used by artists to create interactive VR mini-game worlds via its visual programming interface and scene composing tools.Scenior is a visual scripting system capable of generating VR training scenarios accompanied by a VR editor to interactively control and edit the generated training content Zikas et al. (2020).Ivy is a spatially situated visual programming tool that allows users to link IoT objects and insert logic constructs with visualized real-time data flow to compose mixed reality experiences Ens et al. (2017).FlowMatic is another recent system that provides a reactive visual programming and immersive authoring interface that allows the creator to compose interactive VR experiences Zhang and Oney (2020).EntangleVR++ leverages the benefits of visual programming as well as WYXIWYG interfaces to allow creators to interactively preview their composed visual programs without compiling and building.It supports a fast test and iteration process where artists can interact to see how multiple virtual objects are entangled in a scene and how they may produce different outcomes upon different interactions.",
            "score": 0.340807846142792,
            "section_title": "Visual Programming for VR Authoring",
            "char_start_offset": 9178,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 176
                },
                {
                    "start": 176,
                    "end": 456
                },
                {
                    "start": 456,
                    "end": 614
                },
                {
                    "start": 614,
                    "end": 733
                },
                {
                    "start": 733,
                    "end": 902
                },
                {
                    "start": 902,
                    "end": 1126
                },
                {
                    "start": 1126,
                    "end": 1319
                },
                {
                    "start": 1319,
                    "end": 1528
                },
                {
                    "start": 1528,
                    "end": 1725
                },
                {
                    "start": 1725,
                    "end": 1918
                },
                {
                    "start": 1918,
                    "end": 2124
                }
            ],
            "ref_mentions": [
                {
                    "start": 163,
                    "end": 175,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 393,
                    "end": 421,
                    "matchedPaperCorpusId": "7166572"
                },
                {
                    "start": 423,
                    "end": 455,
                    "matchedPaperCorpusId": "18184791"
                },
                {
                    "start": 596,
                    "end": 613,
                    "matchedPaperCorpusId": "5744929"
                },
                {
                    "start": 1299,
                    "end": 1318,
                    "matchedPaperCorpusId": "221070583"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.916015625
        },
        {
            "corpus_id": "54577943",
            "title": "Enhanced Testing of Autonomous Underwater Vehicles Using Augmented Reality & JavaBeans",
            "text": "Programming is far more clunky and will take much longer as it is not as intuitive. Therefore, visual programming aims to exploit natural human instincts in order to be as intuitive and effective as possible.",
            "score": 0.340807846142792,
            "section_title": "Visual programming",
            "char_start_offset": 20804,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 83
                },
                {
                    "start": 84,
                    "end": 208
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7880859375
        },
        {
            "corpus_id": "52053927",
            "title": "Rock bottom, the world, the sky: Catrobat, an extremely large-scale and long-term visual coding project relying purely on smartphones",
            "text": "In the last decade, a number of block-based visual programming tools, e.g., Scratch, have been introduced which should help teenagers to have an easier time when first practicing programming. These tools have all had very similar goals: they focus on younger learners, support novices in their first programming steps, they can be used in informal learning situations, and provide a visual/block-based programming language which allows teenagers to recognize blocks instead of recalling syntax (Tumlin, 2017). Unlike traditional programming languages, which require code statements and complex syntax rules, here graphical programming blocks are used that automatically snap together like Lego blocks when they make syntactical sense (Ford, 2009). \n\nAnother critical improvement of visual programming systems over classic text based programming languages is the fact that all elements of the programming environment and also the programming language itself, including the formula elements, are translated to the human language of the young users. Especially for human languages that are not written with the Latin alphabet, this is a huge advantage for users, as they are not used to think in English and very often have difficulties to even read Latin scripts. In case of developing countries, usually only a small percentage of the population understands English, in which most user interfaces are exclusively available, thus implicitly excluding a large part of the world's population. Localization of a software can revolutionize E-learning, resulting in more educated workforce and improved economy (Ghuman, 2017). Pocket Code supports localization and internationalization on the application level. The app's language and locale can be changed without changing the smartphone's interface language on the system level. Languages such as Sindhi and Pashto, which are yet to be supported by operating systems, can thus be seamlessly used by our users (Awwad, 2017). Catrobat shares this feature, which improves accessibility and inclusiveness to users from all regions of the world, e.g., with Scratch and Snap!, and this certainly contributes in a major way to the positive worldwide reception of these visual programming environments. Thus, visual programming languages provide an easier start and a more engaging experience for teenagers. The ease of use, and simplicity of such programming environments enables young people to become game makers, and by the seamless translation of their user interfaces, to collaborate with other users on a worldwide scale.",
            "score": 0.340807846142792,
            "section_title": "Trend 1: Block-based and Visual Coding",
            "char_start_offset": 11541,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 191
                },
                {
                    "start": 192,
                    "end": 509
                },
                {
                    "start": 510,
                    "end": 747
                },
                {
                    "start": 750,
                    "end": 1046
                },
                {
                    "start": 1047,
                    "end": 1261
                },
                {
                    "start": 1262,
                    "end": 1488
                },
                {
                    "start": 1489,
                    "end": 1619
                },
                {
                    "start": 1620,
                    "end": 1704
                },
                {
                    "start": 1705,
                    "end": 1823
                },
                {
                    "start": 1824,
                    "end": 1968
                },
                {
                    "start": 1969,
                    "end": 2239
                },
                {
                    "start": 2240,
                    "end": 2344
                },
                {
                    "start": 2345,
                    "end": 2565
                }
            ],
            "ref_mentions": [
                {
                    "start": 494,
                    "end": 508,
                    "matchedPaperCorpusId": "18077793"
                },
                {
                    "start": 734,
                    "end": 746,
                    "matchedPaperCorpusId": "60730266"
                },
                {
                    "start": 1954,
                    "end": 1967,
                    "matchedPaperCorpusId": "13550274"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.908203125
        },
        {
            "corpus_id": "264439184",
            "title": "WebWISE: Web Interface Control and Sequential Exploration with Large Language Models",
            "text": "Another application of LLMs is program generation [3]. VisProg [7] introduced the idea of visual programming, where programs call APIs to interpret and transform images using pre-trained models, solving tasks like image editing and Visual Question Answering (VQA). VisProg [7] and concurrent works [25,28,6,26] provide a prompt to the LLM that contains the API, a set of example programs, and an instruction. Visual programming methods produce impressive zero-shot results but are limited in that they generate one-shot programs without observing the image. Our approach generates programs in multiple steps and uses DOM elements to summarize the visual input. The method 'Recursively Criticizes and Improves' [14], a contemporaneous study, similarly employs LLMs for software interaction. Yet, their approach takes HTML as observations and incorporates multiple in-context examples.",
            "score": 0.340807846142792,
            "section_title": "Visual Programming",
            "char_start_offset": 5864,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 54
                },
                {
                    "start": 55,
                    "end": 264
                },
                {
                    "start": 265,
                    "end": 408
                },
                {
                    "start": 409,
                    "end": 557
                },
                {
                    "start": 558,
                    "end": 660
                },
                {
                    "start": 661,
                    "end": 789
                },
                {
                    "start": 790,
                    "end": 883
                }
            ],
            "ref_mentions": [
                {
                    "start": 63,
                    "end": 66,
                    "matchedPaperCorpusId": "253734854"
                },
                {
                    "start": 273,
                    "end": 276,
                    "matchedPaperCorpusId": "253734854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92041015625
        },
        {
            "corpus_id": "240916683",
            "title": "A Cross-Sectional Study Investigating Primary School Children\u2019s Coding Practices and Computational Thinking Using ScratchJr",
            "text": "code while also contributing to the development of their CT. With these programming tools the coding process can be performed via drag and drop of visual objects, known as blocks, using a modular editing interface which allows learners to develop and execute programs in a more intuitive and user-friendly way (Chao, 2016;Durak, 2020;Hu et al., 2021;Lye & Koh, 2014). This drag and drop process keeps young children more focused on the programming process itself and decreases their cognitive load (Durak, 2020;Mladenovic et al., 2018;Moors et al., 2018;Vasilopoulos & Van Schaik, 2019). In contrast to textbased programming, visual programming does not require children memorizing complex programming syntax or debugging errors in their codes (Durak, 2020;Lindberg et al., 2019). Instead, these programming tools are argued to enable the introduction of children to coding, via facilitating their understanding of how to use basic algorithmic forms through a smooth and straightforward visual mode of programming (Portelance & Bers, 2015).\n\nSuch visual-based environments enable children to construct meaningful programs with instant output, which in turn sustains their engagement with the programming process (Bers, 2018;Kong & Wang, 2019). Active engagement is significant in learning programming, otherwise, students' interest, artifacts and learning can be affected (Durak, 2020). Visual programming tools transform young children into active creators of games, animations, and interactive stories in various disciplines (e.g., language, science, or mathematics), which can boost their interest in CT learning (Mladenovic et al., 2018;Moors et al., 2018). Many of these visual-based tools work on touch devices (tablets) whose interactive interface makes them even more accessible to young learners and children (Hill et al., 2015).\n\nThe literature suggests that visual programming tools are most often used to foster the acquisition of coding skills and CT in educational contexts (de Araujo et al., 2016;Resnick et al., 2009;Shute et al., 2017), as they effectively facilitate the cognitive, motor, and social development of young children (Lee et al., 2013). This study examines CT using ScratchJr, which was especially designed for",
            "score": 0.340807846142792,
            "section_title": "The Role of Visual-Based Programming in Addressing Children's Difficulties With Coding and CT",
            "char_start_offset": 8363,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 310,
                    "end": 322,
                    "matchedPaperCorpusId": "206930744"
                },
                {
                    "start": 322,
                    "end": 334,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 334,
                    "end": 350,
                    "matchedPaperCorpusId": "225492990"
                },
                {
                    "start": 350,
                    "end": 366,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 498,
                    "end": 511,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 535,
                    "end": 554,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 554,
                    "end": 586,
                    "matchedPaperCorpusId": "67309000"
                },
                {
                    "start": 744,
                    "end": 757,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 757,
                    "end": 779,
                    "matchedPaperCorpusId": "69960068"
                },
                {
                    "start": 1014,
                    "end": 1039,
                    "matchedPaperCorpusId": "22376466"
                },
                {
                    "start": 1212,
                    "end": 1224,
                    "matchedPaperCorpusId": "52202617"
                },
                {
                    "start": 1372,
                    "end": 1385,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 1641,
                    "end": 1660,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 1818,
                    "end": 1837,
                    "matchedPaperCorpusId": "2173765"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80712890625
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "Abstract : We present BridgeTalk, a new approach to visual languages for novice programmers. The design of BridgeTalk is based on data about how novices learn to program. BridgeTalk allows novices to program with programming plans -- frame-like objects that capture essential program components like keep a running total and iterate down a data structure. Novices are focused on the interactions between plans, not on the implementation details for a particular plan. Beginning with plans as a basis for a novice programming language, we were forced to develop a programming formalism that can deal with multiple levels of detail, merged plan implementations, and interrelationships between plans. The actual visual presentation for the language is based on six design, implement, test with students, and redesign cycles. Keywords: Visual languages; Novice programming; Programming education; programming cognition.",
            "score": 0.340807846142792,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85009765625
        },
        {
            "corpus_id": "3874016",
            "title": "Visual programming for next-generation sequencing data analytics",
            "text": "We have highlighted the importance of creating a solid low-level base for NGS programming and a high-level base to scale up analytics, especially with the usage of visual tools. \n\nIn computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71][72][73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates [75,76]. VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design [77,78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required. \n\nHow can visual programming benefit NGS software development? \n\nCurrently, there are no 'pure' VP approaches being developed for NGS applications. \n\nGalaxy or UGENE workflow builders can be considered rudimental VP environments, but as discussed previously, they do not offer the same set of functions as the command-line and have limited interoperability (i.e. they work only within their parent environment and cannot build independent programs). However, there is potential for improving the workflow builders using the VP approach.",
            "score": 0.3384670555078445,
            "section_title": "Visual programming",
            "char_start_offset": 16563,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 177
                },
                {
                    "start": 180,
                    "end": 360
                },
                {
                    "start": 361,
                    "end": 529
                },
                {
                    "start": 530,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 647
                },
                {
                    "start": 648,
                    "end": 673
                },
                {
                    "start": 674,
                    "end": 786
                },
                {
                    "start": 787,
                    "end": 929
                },
                {
                    "start": 930,
                    "end": 1083
                },
                {
                    "start": 1084,
                    "end": 1371
                },
                {
                    "start": 1372,
                    "end": 1439
                },
                {
                    "start": 1440,
                    "end": 1637
                },
                {
                    "start": 1638,
                    "end": 1737
                },
                {
                    "start": 1740,
                    "end": 1800
                },
                {
                    "start": 1803,
                    "end": 1885
                },
                {
                    "start": 1888,
                    "end": 2187
                },
                {
                    "start": 2188,
                    "end": 2274
                }
            ],
            "ref_mentions": [
                {
                    "start": 389,
                    "end": 393,
                    "matchedPaperCorpusId": "60451974"
                },
                {
                    "start": 521,
                    "end": 525,
                    "matchedPaperCorpusId": "106672214"
                },
                {
                    "start": 525,
                    "end": 528,
                    "matchedPaperCorpusId": "11750514"
                },
                {
                    "start": 1431,
                    "end": 1435,
                    "matchedPaperCorpusId": "16049286"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94580078125
        },
        {
            "corpus_id": "58147301",
            "title": "Scalable Connectionless Iconic Programming",
            "text": "An experimental solely icon-based visual programming language has been designed and implemented and is reported here. After the implementation and testing of version 7 a thorough usability testing procedure was pursued before the implementation of version 8. This VPL is specifically designed to not use any connection lines in the visual presentation and to provide a fixed but resizable visual format to avoid the time-consuming visual rearrangement tasks in other icon-based VPLs. The language was also designed to be generic for building applications based upon any chosen system library. The language was made to enforce a number of simplifying programming constraints that foster good software engineering in the design of applications that it produces. The purpose of the implementation of this experimental language is firstly to see if a connectionless iconic programming language in this style is possible, viable and scalable for general purpose problem solving, and then to find its implications for how users must think about programming and software design to use this system well.",
            "score": 0.33748140519510234,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83740234375
        },
        {
            "corpus_id": "4883058",
            "title": "Teaching Programming Principles through a Game Engine",
            "text": "We used the strategy of gradual transition between the visual, always linked to games, and textual programming. The concepts treated in a first programming course included: setting and accessing variables, decision command and repetition. \n\nThe treatment of variables began with the use of predefined variables for the GameMaker environment: score, health and lives. These three variables define, respectively, the total points a player, a measure of living/damage and quantity of life. In order to introduce the concept of variable, we used the game The Scrolling Shooter [16], where experiments initially performed visual changes of these variables. As students gained experience in visually changing these variables, visual commands were gradually replaced by scripting commands, as shown in Figure 8: Then, we introduced the concept of declaration of variables. The environment GameMaker allows programmers to declare variables in the environment both visually and in text format. Typically, the use of the visual environment provides some initial facilities, in the sense that it is not necessary to specify the type in the declaration. In the textual environment, we can use the notion of type, syntax that resembles the C Language. Figure 9 illustrates an example of variable declaration in the visual and textual environments: Continuing the basic commands, we dealt with the conditional statement. This important concept of imperative programming can be tested with so much fun in a gaming environment: collisions between objects, winner of a game and the existence of a new phase are some examples presented in a systematic way to students. Normally, in other programming languages, these examples cannot easily be constructed because they depend on knowledge of graphics programming. Figure 10 shows an example of construction of the conditional statement, where you can notice the presence of blocks: Finally, the loop statement was covered. The GameMaker environment allows visual construction of repetitions in the style of the iteration statement, where is not necessary to define a counter, but only the number of times a particular block should be performed. In the final topic, it was adopted the same strategy above: gradual change of the visual environment to text. \n\nCompared to previous semesters, the use of the strategy of gradual change of the visual programming environment to the text allowed students to develop very early, complex programming logic within a game without relying on the constant challenges imposed by textual programming languages.",
            "score": 0.33748140519510234,
            "section_title": "Case study: a strategy for teaching basic programming concepts",
            "char_start_offset": 10699,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 111
                },
                {
                    "start": 112,
                    "end": 238
                },
                {
                    "start": 241,
                    "end": 366
                },
                {
                    "start": 367,
                    "end": 486
                },
                {
                    "start": 487,
                    "end": 651
                },
                {
                    "start": 652,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 984
                },
                {
                    "start": 985,
                    "end": 1141
                },
                {
                    "start": 1142,
                    "end": 1406
                },
                {
                    "start": 1407,
                    "end": 1650
                },
                {
                    "start": 1651,
                    "end": 1794
                },
                {
                    "start": 1795,
                    "end": 1953
                },
                {
                    "start": 1954,
                    "end": 2175
                },
                {
                    "start": 2176,
                    "end": 2285
                },
                {
                    "start": 2288,
                    "end": 2576
                }
            ],
            "ref_mentions": [
                {
                    "start": 573,
                    "end": 577,
                    "matchedPaperCorpusId": "14234211"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6083984375
        },
        {
            "corpus_id": "233859146",
            "title": "Design and Implementation of Real Time Health Care Monitoring System Based on IoT",
            "text": "It is a Microsoft development environment and programming language based on the famous BASIC language. It is classified within the programming languages of objects. Since Microsoft began issuing Visual Basic, it has been very successful and popular among programmers due to the ease of use in exchange for the extreme complexity faced by any programmer seeking to program Windows using the C language or C ++ programming. Visual Basic is suitable for database applications, applications for small companies, and accounting programs. It is convenient, easy, and performs the purpose in addition, allowing the programmer to focus on solving the problem, as he often finds technical difficulty while writing a program in Visual Basic. \n\nThe Visual Basic programming language was used in order to obtain a real-time data transfer, which is the main goal of the project, in addition to being an easy and understandable language and providing the ability to form a graphical interface to the user, and in addition it is an easy-to-implement language. This version of the program developed from the old version of the BASIC language that works under the DOS environment to this version that works under the Windows environment.",
            "score": 0.33748140519510234,
            "section_title": "VISUAL BASIC VB .NET",
            "char_start_offset": 9518,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 102
                },
                {
                    "start": 103,
                    "end": 164
                },
                {
                    "start": 165,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 532
                },
                {
                    "start": 533,
                    "end": 731
                },
                {
                    "start": 734,
                    "end": 1044
                },
                {
                    "start": 1045,
                    "end": 1220
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8046875
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
            "score": 0.33748140519510234,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93896484375
        },
        {
            "corpus_id": "220071641",
            "title": "Uvis: A Formula-Based End-User Tool for Data Visualization",
            "text": "Graphical libraries such as GDI+ [38] and Java 2D [39] are available for many programming languages. They provide basic components such as polygon, textbox and drop-down box. By means of a program, you can create any visualization, bind to any data and perform any interaction. The program can be integrated with development environments that allow programmers to build a user interface. The environments use the visual builder approach [22]. Programmers manually drag and drop graphical components (buttons, text boxes, etc.) and set their properties. However, programming is needed to make the interface functional.",
            "score": 0.33748140519510234,
            "section_title": "2) GRAPHICAL LIBRARIES",
            "char_start_offset": 10416,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 437,
                    "end": 441,
                    "matchedPaperCorpusId": "9950861"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.65625
        },
        {
            "corpus_id": "17399148",
            "title": "A Survey on Teaching and Learning Recursive Programming",
            "text": "Visual programming languages enable the composition of program constructs by manipulating graphical representations instead of writing text. Good and Brna (1996) were the first to investigate whether these languages provided a better support for learning recursion than textual languages, and concluded negatively. Spreadsheet languages are sometimes considered as visual programming languages or even functional languages, and Burnett et al. (2001) focused on testing recursive programs with them. Kim (2003) proposed a string of classroom exercises to learn recursion with Excel. \n\nVirtual worlds. Tasc\u00f3n-Vidarte et al. (2010) designed an interactive interface based on a tangible block-world with augmented reality to learn iteration on lists and aiming at the transfer of skills to directly write tail recursive definitions in Erlang. An earlier, three-dimensional virtual world was designed by Dann et al. (2001). For two-dimensional geometry considered as a virtual world, we have Logo.",
            "score": 0.33748140519510234,
            "section_title": "Multimedia Environments",
            "char_start_offset": 60137,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 140
                },
                {
                    "start": 141,
                    "end": 314
                },
                {
                    "start": 315,
                    "end": 498
                },
                {
                    "start": 499,
                    "end": 581
                },
                {
                    "start": 584,
                    "end": 599
                },
                {
                    "start": 600,
                    "end": 838
                },
                {
                    "start": 839,
                    "end": 918
                },
                {
                    "start": 919,
                    "end": 992
                }
            ],
            "ref_mentions": [
                {
                    "start": 141,
                    "end": 161,
                    "matchedPaperCorpusId": "62684178"
                },
                {
                    "start": 428,
                    "end": 449,
                    "matchedPaperCorpusId": "11031065"
                },
                {
                    "start": 499,
                    "end": 509,
                    "matchedPaperCorpusId": "63846569"
                },
                {
                    "start": 600,
                    "end": 628,
                    "matchedPaperCorpusId": "44012611"
                },
                {
                    "start": 899,
                    "end": 917,
                    "matchedPaperCorpusId": "9790523"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.673828125
        },
        {
            "corpus_id": "14638221",
            "title": "Learning Programming at the Computational Thinking Level via Digital Game-Play",
            "text": "Furthermore, their findings propose that mathematical and engineering thinking is not necessarily a main characteristic of CT because complex CT can also happen spontaneously. Recently, Guzdial [2] argues the research currently identified cognitive skills. Guzdial further discusses how these skills and abilities can be taught and what ways can be used to measure them. \n\nTo this end, the use of storytelling visual programming tools and digital game creation have been proposed as frameworks for teaching CT and computer programming because games are attractive and motivational in nature [7]. Visual programming tools are often perceived as ideal because they allow students to create various abstractions quickly without the need for excessive program code. To create a working scenario in these tools, students select different characters and behaviors from a repository of choices and then build scenes where each scene contains these characters and behaviors. Complex abstractions can be created through combining character attributes and behaviors, which inevitably requires an understanding of programming sequence, conditionals, iteration and methods. Furthermore, these environments remove the syntax rules of genuine programming languages and allow students to think through programmatic representations. Despite these advantages, recent studies argue that CT is not a synonym for programming and that although visual programming tools can be useful for creating enthusiasm in programming, it is arguable whether or not students with little or no programming background can develop skills in CT through this mechanism. For example, while using these tools, students might develop good programming practice or spontaneously acquire a CT strategy, but there is little feedback available to alert them to this. The corollary to this might be when students create a working linear scenario without considering reusable patterns and other good programming practices. In this case, students might create output that works by designing an inefficient programming strategy, such as a statement repeated lots of times without using a loop, because they do not possess the requisite level of knowledge to develop a better solution and the tool provides no feedback to address this. In other words, visual programming tools require a debug mechanism to support students in developing their abstractions as well as good programming practices. Moreover, it is crucial to underline that visual programming tools are not games and should not be considered as game based learning (GBL) environments because they lack some of the crucial features that exist in all good games, such as a rewarding mechanism and clear goals to drive students to discover more.",
            "score": 0.3373438259950756,
            "section_title": "Related Work and Discussions",
            "char_start_offset": 5986,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 256
                },
                {
                    "start": 257,
                    "end": 370
                },
                {
                    "start": 373,
                    "end": 595
                },
                {
                    "start": 596,
                    "end": 761
                },
                {
                    "start": 762,
                    "end": 966
                },
                {
                    "start": 967,
                    "end": 1161
                },
                {
                    "start": 1162,
                    "end": 1316
                },
                {
                    "start": 1317,
                    "end": 1630
                },
                {
                    "start": 1631,
                    "end": 1819
                },
                {
                    "start": 1820,
                    "end": 1973
                },
                {
                    "start": 1974,
                    "end": 2283
                },
                {
                    "start": 2284,
                    "end": 2442
                },
                {
                    "start": 2443,
                    "end": 2753
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84130859375
        },
        {
            "corpus_id": "198895618",
            "title": "Sketch-n-Sketch: Output-Directed Programming for SVG",
            "text": "For creative tasks, programmers face a choice: Use a GUI and sacrifice flexibility, or write code and sacrifice ergonomics?\n\nTo obtain both flexibility and ease of use, a number of systems have explored a workflow that we call output-directed programming. In this paradigm, direct manipulation of the program's graphical output corresponds to writing code in a general-purpose programming language, and edits not possible with the mouse can still be enacted through ordinary text edits to the program. Such capabilities provide hope for integrating graphical user interfaces into what are currently text-centric programming environments.\n\nTo further advance this vision, we present a variety of new output-directed techniques that extend the expressive power of SKETCH-N-SKETCH, an output-directed programming sys-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.\n\nUIST '19, October 20-23, 2019, New Orleans, LA, USA tem for creating programs that generate vector graphics. To enable output-directed interaction at more stages of program construction, we expose intermediate execution products for manipulation and we present a mechanism for contextual drawing. Looking forward to output-directed programming beyond vector graphics, we also offer generic refactorings through the GUI, and our techniques employ a domainagnostic provenance tracing scheme.\n\nTo demonstrate the improved expressiveness, we implement a dozen new parametric designs in SKETCH-N-SKETCH without text-based edits. Among these is the first demonstration of building a recursive function in an output-directed programming setting.",
            "score": 0.335227966172988,
            "section_title": "ABSTRACT",
            "char_start_offset": 11,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.50830078125
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "This systematic literature review analyzes the literature related to visual programming approaches, providing a background for new tools and methods, and identifying direction for further investigation. This review follows the guidelines described by Kitchenham and Charter [5]. The process consists of these main phases: (1) defining the review protocol including defining the research questions, methods to answer them, search strategy, and inclusion and exclusion criteria. \n\n(2) conducting the study by selecting the articles, evaluating their quality, and analyzing the results. (3) reporting the results.",
            "score": 0.33418562268932683,
            "section_title": "IV. METHODOLOGY",
            "char_start_offset": 18684,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 202
                },
                {
                    "start": 203,
                    "end": 278
                },
                {
                    "start": 279,
                    "end": 476
                },
                {
                    "start": 479,
                    "end": 583
                },
                {
                    "start": 584,
                    "end": 610
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8720703125
        },
        {
            "corpus_id": "6764231",
            "title": "A Proposed Framework for Development of a Visualizer Based on Memory Transfer Language (MTL)",
            "text": "As depicted in Figure 1, a visualizer is proposed to have three main parts: \n\n1. The controls window: constitutes controls for adding statements automatically in the code window (A place where a program is displayed). The controls are for \"Declaration\", \"Assignment\", \"Data Input\", \"Data Output\", \"Condition Statement\", \"Looping Statement\" and \"Insert text/statement\". \n\nThis approach allows novices to create simple programs without memorizing the syntax of a programming language in use, which in turn reduces cognitive load for beginners. In addition to that, novices are not vulnerable in making syntactical errors as everything is taken care by a visualizer. A novice is simply required to click the control of the functionality to be performed and follow instructions. However, a visualizer should leave the room for the conversant novices to write their program in the code window right from the scratch without using the built in controls to automatically generate codes. x, RESERVED Fig. 1 The Proposed Layout of a Visualizer Interface",
            "score": 0.33418562268932683,
            "section_title": "B. A Visualizer's Layout",
            "char_start_offset": 6302,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 75
                },
                {
                    "start": 78,
                    "end": 80
                },
                {
                    "start": 81,
                    "end": 217
                },
                {
                    "start": 218,
                    "end": 368
                },
                {
                    "start": 371,
                    "end": 541
                },
                {
                    "start": 542,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 774
                },
                {
                    "start": 775,
                    "end": 979
                },
                {
                    "start": 980,
                    "end": 1044
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.81787109375
        },
        {
            "corpus_id": "276575051",
            "title": "LogoMotion: Visually-Grounded Code Synthesis for Creating and Editing Animation",
            "text": "Visually-grounded code synthesis is powerful because it unlocks how code generation approaches can be guided by an AI's ability to analyze images. LogoMotion shows how to do this by building an HTML representation that is visually aware of what is on the canvas. The HTML representation reflects the visual hierarchy of the elements in the image and captures grouping information in the code hierarchy organization. LogoMotion demonstrates how a VLM can be applied to understand layer content, automatically make groups, and update the HTML representation when users interact with a layers panel. This is relevant to any design tool that has a layer panel. In tools like Adobe Illustrator and Figma, users engage with hundreds of layers and groups, and LogoMotion shows how an AI approach can solve classic painpoints like layer organization and group layers for users. Secondly, LogoMotion shows how a code generation approach can be guided by a design concept. This is powerful because it allows animation to move beyond templates and presets -LogoMotion outperforms an industry approach Magic Animate in this respect-and move towards semantically meaningful animation. Visually-grounded code synthesis can also extend to other animation tasks like slide animation (where visual hierarchy and grouping is key) or kinetic typography (where the motion must match the semantic meaning of the text). LogoMotion's visually-grounded program repair mechanism also has high generalizability. It can be effective for many other tasks where code renders visual output such as UI mockups, front-end prototyping, and game design. For example, if a UI prototype is generated from a visual mockup, it can be checked for if whether components meet the visual specification of the mockup. Furthermore, for this checking process to be able to isolate visual differences, visual reflection has to be able to support different \"beams of focus\". LogoMotion shows how to implement visually-grounded program repair with a layer-wise beam of focus and effectively solve 96% of detected errors within four attempts. Though in LogoMotion we only checked the last frame of the animation against the target layout, in future work, we can check intermediate frames of animation to build a deeper understanding of motion.",
            "score": 0.3333297780263668,
            "section_title": "Generalizability of Visually-Grounded Code Synthesis and Repair",
            "char_start_offset": 55471,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 262
                },
                {
                    "start": 263,
                    "end": 415
                },
                {
                    "start": 416,
                    "end": 596
                },
                {
                    "start": 597,
                    "end": 656
                },
                {
                    "start": 657,
                    "end": 869
                },
                {
                    "start": 870,
                    "end": 962
                },
                {
                    "start": 963,
                    "end": 1171
                },
                {
                    "start": 1172,
                    "end": 1397
                },
                {
                    "start": 1398,
                    "end": 1485
                },
                {
                    "start": 1486,
                    "end": 1619
                },
                {
                    "start": 1620,
                    "end": 1774
                },
                {
                    "start": 1775,
                    "end": 1927
                },
                {
                    "start": 1928,
                    "end": 2093
                },
                {
                    "start": 2094,
                    "end": 2294
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8359375
        },
        {
            "corpus_id": "251713000",
            "title": "CodeToon: Story Ideation, Auto Comic Generation, and Structure Mapping for Code-Driven Storytelling",
            "text": "Comics could benefit students learning object-oriented programming. Other programming paradigms such as functional programming may require identifying abstractions (e.g., pointers) important to them for custom visual vocabulary, which would help expand the set of visual vocabularies and advance our understanding mental models for programming. \n\nDesign Implications. Our work has interesting design implications for various domains. Our user study results suggest that the 1-to-1 mapping can be an effective, useful design when using comics as a complementary representation for code. This confirms the suggestion in the literature on multiple representational systems, which recommends making the mapping between multiple representations clear. For research areas-such as data and stats comics [5,41]-that also leverage comics in much the same way coding strip does, our insights concerning 1-to-1 mapping and the process of building comic expressions can help them explore a similar direction where they can also explore methods to auto generate comics from languages in their domain (e.g., R programming). Our work also leads to many interesting questions for comic authoring tools and coding tools. For instance, how can comic authoring tools utilize our idea of generating comics from language semantics and computational steps to enhance and diversify the authoring process? How can we design coding tools that offer ways to switch between code and other levels of abstraction (e.g., stories and comics)? How can we leverage such interaction to support various tasks programmers perform, e.g., reading and writing code, and debugging? What representations or abstractions can we support in these coding tools? How can we make their transitions seamless? How should we design these transitions and interactions so that we maximize the benefits of multiple representations? \n\nVisual Programming Environment for Artistic Activities. Using coding strips to teach and learn computer programming is a new and promising approach. Recent work showed that it can enhance student learning and address some challenges in teaching programming [33,36,38]. But there is still much work to be done. To ease its adoption, we need a curriculum containing a set of learning activities and guidelines in an accessible form, such as a cheat sheet, so that teachers can quickly reference and apply it to their teaching and lessons. Moreover, understanding the nature and impact of this approach needs to be further investigated.",
            "score": 0.330947891412248,
            "section_title": "Implications & Opportunities",
            "char_start_offset": 45583,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 67
                },
                {
                    "start": 68,
                    "end": 344
                },
                {
                    "start": 347,
                    "end": 367
                },
                {
                    "start": 368,
                    "end": 433
                },
                {
                    "start": 434,
                    "end": 585
                },
                {
                    "start": 586,
                    "end": 746
                },
                {
                    "start": 747,
                    "end": 1109
                },
                {
                    "start": 1110,
                    "end": 1203
                },
                {
                    "start": 1204,
                    "end": 1381
                },
                {
                    "start": 1382,
                    "end": 1511
                },
                {
                    "start": 1512,
                    "end": 1641
                },
                {
                    "start": 1642,
                    "end": 1716
                },
                {
                    "start": 1717,
                    "end": 1760
                },
                {
                    "start": 1761,
                    "end": 1878
                },
                {
                    "start": 1881,
                    "end": 1936
                },
                {
                    "start": 1937,
                    "end": 2029
                },
                {
                    "start": 2030,
                    "end": 2149
                },
                {
                    "start": 2150,
                    "end": 2190
                },
                {
                    "start": 2191,
                    "end": 2417
                },
                {
                    "start": 2418,
                    "end": 2514
                }
            ],
            "ref_mentions": [
                {
                    "start": 796,
                    "end": 799,
                    "matchedPaperCorpusId": "659424"
                },
                {
                    "start": 799,
                    "end": 802,
                    "matchedPaperCorpusId": "222353618"
                },
                {
                    "start": 2142,
                    "end": 2145,
                    "matchedPaperCorpusId": "229347790"
                },
                {
                    "start": 2145,
                    "end": 2148,
                    "matchedPaperCorpusId": "222223894"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.56689453125
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "This section describes a formal representation for plans that forms the basis for our visual programming environment to aid novices in learning to program. Our approach allows several representations of a problem solution. The user is able to navigate from one representation to another in order to obtain different points of view on the solution. The problem solution can be modified from any one of these representations, or levels. The solution is descriptive at the highest level, prescriptive at the lowest. This top level uses icons to identify specific plans that the user links together appropriately. At the lowest level is source code for a textual, procedural language, such as Pascal.",
            "score": 0.33092007672030155,
            "section_title": "Formal Description",
            "char_start_offset": 28910,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92919921875
        },
        {
            "corpus_id": "13395203",
            "title": "Visualizing Computer Programming in a Computer-based Simulated Environment",
            "text": "This paper investigated the challenges presented by computer programming (sequential/traditional, concurrent and parallel) for novice programmers and developers. The researcher involved Higher Education in Computer Science students learning programming at multiple levels, as they could well represent beginning programmers, who would struggle in successfully achieving a running program due to the complexity of this theoretical process, which has no similar real-life representation. The paper explored the difficulties faced by students in understanding this challenging, yet fundamental, subject of all Computer Science/Computing degree programmes, and focused on the advantages of visualization techniques to facilitate the learning of computer programming, with recommendations on effective computer-based simulated platforms to achieve this visualization. The paper recommended the application of virtual world technologies, such as \u2018Second Life\u2019, to achieve the visualization required to facilitate the understanding and learning of computer programming. The paper demonstrated extensive evidence on the advantages of these technologies to achieve program visualization, and how they facilitated enhanced learning of the programming process. The paper also addressed the benefits of collaboration and experimentation, which are ideal for learning computer programming, and how these aspects are strongly supported in virtual worlds.",
            "score": 0.33092007672030155,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.68212890625
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Visual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:",
            "score": 0.33092007672030155,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 5284,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 71
                },
                {
                    "start": 72,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 507
                },
                {
                    "start": 510,
                    "end": 698
                },
                {
                    "start": 699,
                    "end": 818
                },
                {
                    "start": 821,
                    "end": 975
                },
                {
                    "start": 976,
                    "end": 1057
                },
                {
                    "start": 1058,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1372
                },
                {
                    "start": 1373,
                    "end": 1484
                },
                {
                    "start": 1487,
                    "end": 1693
                },
                {
                    "start": 1694,
                    "end": 1855
                },
                {
                    "start": 1856,
                    "end": 2042
                },
                {
                    "start": 2043,
                    "end": 2138
                },
                {
                    "start": 2141,
                    "end": 2181
                }
            ],
            "ref_mentions": [
                {
                    "start": 502,
                    "end": 506,
                    "matchedPaperCorpusId": "15687689"
                },
                {
                    "start": 694,
                    "end": 697,
                    "matchedPaperCorpusId": "8272806"
                },
                {
                    "start": 813,
                    "end": 817,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 903,
                    "end": 906,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1182,
                    "end": 1185,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1531,
                    "end": 1534,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1557,
                    "end": 1560,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1787,
                    "end": 1790,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1795,
                    "end": 1798,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1926,
                    "end": 1929,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1993,
                    "end": 1996,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 2038,
                    "end": 2041,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 2089,
                    "end": 2092,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9912109375
        },
        {
            "corpus_id": "225067888",
            "title": "Adding interactive visual syntax to textual code",
            "text": "Several programming systems have enabled a mixture of some graphical and textual programming for decades. The four most prominent examples are Boxer, Hypercard, Scratch, and Smalltalk. \n\nBoxer [diSessa and Abelson 1986] allows developers to embed GUI elements within other GUI elements (\"boxing\"), to name such GUI elements, and to refer to these names in program code. That is, \"programs\" consist of graphical renderings of GUI objects and program text (inside the boxes). For example, a Boxer programmer could create a box that contains an image of a Tsuro tile, name it, and refer to this name in a unit test in a surrounding box. Boxer does not satisfy any of the other desiderata in section 2. In particular, it has poor support for creating new abstractions with regard to the GUI elements. \n\nScratch [Resnick et al. 2009], also an MIT product, is a fully graphical language system, with wide applications in education. In Scratch, users write their programs by snapping graphical blocks together. These blocks resemble puzzle pieces and snapping them together creates syntactically valid programs. Scratch offers limited, but growing [Harvey and M\u00f6nig 2010], capabilities for a programmer to make new block types. \n\nHypercard [Goodman 1988] gives users a graphical interface to make interactive documents. Authors have used hypercard to create everything from user interfaces to adventure games. While hypercard has been used in a wide variety of domains, it is not a general-purpose language. \n\nSmalltalk [Bergel et al. 2013;Goldberg and Robson 1983;Ingalls et al. 2008;Klokmose et al. 2015;R\u00e4dle et al. 2017] supports direct manipulation of GUI objects, often called live programming. Rather than separating code from objects, Smalltalk programs exist in a shared environment, the Morphic [Maloney et al. 2001] user interface. Programmers can visualize GUI objects, inspect and modify their code component, and re-connect them to the program. No Smalltalk systems truly accommodate general-purpose graphical-oriented programming as a primary mode, however. GRAIL [Ellis et al. 1969a,b] is possibly one of the oldest examples of graphical syntax. It allows users to create and program with graphical flow diagrams.",
            "score": 0.33092007672030155,
            "section_title": "Graphical and Live Languages",
            "char_start_offset": 52172,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 105
                },
                {
                    "start": 106,
                    "end": 184
                },
                {
                    "start": 187,
                    "end": 369
                },
                {
                    "start": 370,
                    "end": 473
                },
                {
                    "start": 474,
                    "end": 633
                },
                {
                    "start": 634,
                    "end": 796
                },
                {
                    "start": 799,
                    "end": 925
                },
                {
                    "start": 926,
                    "end": 1003
                },
                {
                    "start": 1004,
                    "end": 1104
                },
                {
                    "start": 1105,
                    "end": 1220
                },
                {
                    "start": 1223,
                    "end": 1312
                },
                {
                    "start": 1313,
                    "end": 1402
                },
                {
                    "start": 1403,
                    "end": 1500
                },
                {
                    "start": 1503,
                    "end": 1693
                },
                {
                    "start": 1694,
                    "end": 1835
                },
                {
                    "start": 1836,
                    "end": 1951
                },
                {
                    "start": 1952,
                    "end": 2065
                },
                {
                    "start": 2066,
                    "end": 2154
                },
                {
                    "start": 2155,
                    "end": 2222
                }
            ],
            "ref_mentions": [
                {
                    "start": 193,
                    "end": 219,
                    "matchedPaperCorpusId": "6259653"
                },
                {
                    "start": 1141,
                    "end": 1164,
                    "matchedPaperCorpusId": "62609287"
                },
                {
                    "start": 1558,
                    "end": 1578,
                    "matchedPaperCorpusId": "37427503"
                },
                {
                    "start": 1578,
                    "end": 1599,
                    "matchedPaperCorpusId": "3449397"
                },
                {
                    "start": 1599,
                    "end": 1617,
                    "matchedPaperCorpusId": "9336023"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77685546875
        },
        {
            "corpus_id": "265456115",
            "title": "Visual Programming for Zero-Shot Open-Vocabulary 3D Visual Grounding",
            "text": "As illustrated in Figure 11, the prompts for generating 3D visual programs include four components as follows: \u2022 Task explanation: We first describe the 3DVG task in natural language and provide it to the LLMs. \n\n\u2022 Function and variable definition: We define a set of functions and variables corresponding to the modules in the visual programming approach, such as LOC and LEFT. \u2022 In-context examples: We provide contextual examples illustrating how visual programs are structured and applied to guide LLMs. \u2022 Best practices and tips: We conclude with essential tips and best practices to ensure the effectiveness of the programs, highlighting the key aspects that guarantee optimal performance. These four components collaboratively facilitate the LLM to understand the task requirement, thereby allowing it to construct effective visual programs for the 3DVG task.",
            "score": 0.33092007672030155,
            "section_title": "Prompts for Generating 3D Visual Program",
            "char_start_offset": 32513,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 210
                },
                {
                    "start": 213,
                    "end": 378
                },
                {
                    "start": 379,
                    "end": 507
                },
                {
                    "start": 508,
                    "end": 695
                },
                {
                    "start": 696,
                    "end": 866
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91845703125
        },
        {
            "corpus_id": "62816171",
            "title": "An Evaluation of Open Digital Gaming Platforms for Developing Computational Thinking Skills",
            "text": "Scratch is a free creation tool for small games, animations, and interactive resources. Scratch is a visual programming language created by MIT's Lifelong Kindergarten Lab in 2002, with an editing and execution system in the cloud. With an important orientation to the user community and an open approach, it allows to share and derive programs from others. Due to its significant history and implementation, there are many tutorials for users, teachers, and parents. The structure of programming components differentiates elements such as control structures, events, operators, data, or sensors. The elements that are manipulated by Scratch are configurable images and sounds, allowing you to set up 2D animations and video games of a certain level of complexity. \n\nScratch was one of the first tools to be established and has therefore greatly influenced most of the ones listed in this chapter. It uses the visual puzzle metaphor for the programming pieces, where each block has a shape that can only be combined with other compatible blocks, and a color that determines the block type.",
            "score": 0.33092007672030155,
            "section_title": "Scratch (https://scratch.mit.edu/)",
            "char_start_offset": 21601,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 87
                },
                {
                    "start": 88,
                    "end": 231
                },
                {
                    "start": 232,
                    "end": 357
                },
                {
                    "start": 358,
                    "end": 467
                },
                {
                    "start": 468,
                    "end": 596
                },
                {
                    "start": 597,
                    "end": 764
                },
                {
                    "start": 767,
                    "end": 897
                },
                {
                    "start": 898,
                    "end": 1089
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.50244140625
        },
        {
            "corpus_id": "63194770",
            "title": "PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI",
            "text": "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education. This research was conducted to the teachers who teach Al-Quran for children learning in order to know the benefit of using visual programming in terms of creating an animation and game education.Several approach has been applied in this research. The first is surveying the knowledge in computer programming by using questioners. Following that, we provide a training of using visual programming and the last is conduction survey in order to know the progress of learning accuisiton.Based on the questioner\u2019s data,it can be found that visual programming is very useful to introduce computer programming for people who have limited computer background. The data shows that 60% respondent believe that the visual programming is easy to follow, while the rest says it is hard to do. Furthermore, some of the participants are able to create simple education game",
            "score": 0.33092007672030155,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.95068359375
        },
        {
            "corpus_id": "69964488",
            "title": "Towards a visual guide for communicating uncertainty in Visual Analytics",
            "text": "Especially in the domain of computer science, a lot of effort has gone into simplifying complex processes into representations that can be understood by non-experts.A prominent example is the visualisation of algorithm mechanics into flow charts for computer programming classes [36].By replacing programming instructions with a visual representation that summarises long steps of code and highlights important decision components, researchers have reported an increase in confidence as well as a reduction of errors and task completion times for students [37], especially when these visualisations could be manipulated interactively [38].\n\nOn a more formal basis, such a transformation of sets of instructions into graphical modules or glyph-based notations is described by the field of visual languages in computing [39].With the help of various specification formalisms, visual languages translate complex processes into abstract depictions that can be understood by non-computer scientists and employed by these for otherwise hard-to accomplish tasks.\n\nUsing such a visual language and combining building blocks of graphical and textual elements, users can intuitively define behavioural requirements for algorithms [40] and have the process of probabilistic reasoning explained to them in an easy-to-understand manner [41].This way, non-experts may gain insight and understanding into an otherwise \"black box\" system [42].Beyond process explanation, visual languages are also used to conceptually design structures that have several layers of complexity and interactions that are difficult to keep in mind with every step of the design process.Here, the transformation into a symbolic representation hides unnecessary convolution from the design phase, allowing the user to focus while the computer automatically ensures adherence to constructional constraints [43].\n\nIn a more casual context, visual languages are used to support laymen with the creation of games.By simplifying game mechanics into a set of graphical, interconnected building blocks that form a library of actions and meanings, non-programmers, such as educators outside the field of computing, can build computer games themselves and focus on content creation and story line, rather than on the acquisition of programming skills [44,45].The power of visual representation for describing complex coherences is even being employed to support managers in understanding organisational structures and optimising workflows [46].",
            "score": 0.33092007672030155,
            "section_title": "Visual languages and visualisation toolkits",
            "char_start_offset": 15198,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 165
                },
                {
                    "start": 165,
                    "end": 284
                },
                {
                    "start": 284,
                    "end": 639
                },
                {
                    "start": 641,
                    "end": 823
                },
                {
                    "start": 823,
                    "end": 1055
                },
                {
                    "start": 1057,
                    "end": 1328
                },
                {
                    "start": 1328,
                    "end": 1427
                },
                {
                    "start": 1427,
                    "end": 1649
                },
                {
                    "start": 1649,
                    "end": 1871
                },
                {
                    "start": 1873,
                    "end": 1970
                },
                {
                    "start": 1970,
                    "end": 2311
                },
                {
                    "start": 2311,
                    "end": 2496
                }
            ],
            "ref_mentions": [
                {
                    "start": 279,
                    "end": 283,
                    "matchedPaperCorpusId": "15456703"
                },
                {
                    "start": 556,
                    "end": 560,
                    "matchedPaperCorpusId": "17872192"
                },
                {
                    "start": 634,
                    "end": 638,
                    "matchedPaperCorpusId": "1494033"
                },
                {
                    "start": 1220,
                    "end": 1224,
                    "matchedPaperCorpusId": "36096796"
                },
                {
                    "start": 1323,
                    "end": 1327,
                    "matchedPaperCorpusId": "13958559"
                },
                {
                    "start": 1866,
                    "end": 1870,
                    "matchedPaperCorpusId": "195709707"
                },
                {
                    "start": 2303,
                    "end": 2307,
                    "matchedPaperCorpusId": "268428958"
                },
                {
                    "start": 2307,
                    "end": 2310,
                    "matchedPaperCorpusId": "9645139"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87548828125
        },
        {
            "corpus_id": "231785967",
            "title": "Hybrid Java: The creation of a Hybrid Programming Environment",
            "text": "\u2022 Some students found that more time was required to complete a program in a blocksbased environment as opposed to a text-based environment. \u2022 The students recounted how text-based languages often require less lines of code to be written in comparison to the number of blocks needed in a blocks-based language. \u2022 The lack of authenticity held by blocks-based programming languages in the sense that the blocks-based language was not similar enough to traditional text-based languages to effectively educate others in the ways of computer programming. \n\nSome efforts have been undertaken by researchers to bridge this gap in the past. One large area of focus has been the creation of text-based programming environments with some visual cues or elements. For example, K\u00f6lling, Quig, Patterson, & Rosenberg have developed the BlueJ programming system (2003) and K\u00f6lling has developed the Greenfoot programming environment (2010). Both environments seek to solve a particular problem. BlueJ is presented as a learning tool to aid with the difficulty of teaching object-oriented programming to novice programmers. Greenfoot has similar goals but targets itself at younger students and uses topics such as game development to help teach the concepts. Both tools aim to fill this educational gap, but neither are marketed as complete solutions, with the assumption that students will still migrate to a text-based language afterwards. \n\nA pertinent question that could be asked here is \"Is there a tool with a more longitudinal focus, or one which can be used interchangeably with a text-based language?\". With the ever changing landscape of literature in the area of FPL, and with some of it often being contradictory, the authors undertook a systematic literature review to examine the prevalence of visual and textual programming languages in education, with the aim of determining the best FPL approaches (Noone & Mooney, 2018). This review centred around two research questions: \n\n\u2022 Are there any benefits of learning a visual programming language over a traditional text-based language? \u2022 Does the choice of First Programming Language make a difference? What languages are the best ones to teach? \n\nA very quick summary of the results of this study would be to say that visual programming languages are extremely beneficial when taught to the \"right age group\". The study also further pointed to the existence of this \"educational gap\" around the ages of 14-17 where neither language type is ideal.",
            "score": 0.33061267187900995,
            "section_title": "Motivation and Background",
            "char_start_offset": 5616,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 140
                },
                {
                    "start": 141,
                    "end": 310
                },
                {
                    "start": 311,
                    "end": 550
                },
                {
                    "start": 553,
                    "end": 633
                },
                {
                    "start": 634,
                    "end": 753
                },
                {
                    "start": 754,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 981
                },
                {
                    "start": 982,
                    "end": 1109
                },
                {
                    "start": 1110,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1428
                },
                {
                    "start": 1431,
                    "end": 1599
                },
                {
                    "start": 1600,
                    "end": 1926
                },
                {
                    "start": 1927,
                    "end": 1977
                },
                {
                    "start": 1980,
                    "end": 2086
                },
                {
                    "start": 2087,
                    "end": 2153
                },
                {
                    "start": 2154,
                    "end": 2196
                },
                {
                    "start": 2199,
                    "end": 2361
                },
                {
                    "start": 2362,
                    "end": 2498
                }
            ],
            "ref_mentions": [
                {
                    "start": 1903,
                    "end": 1925,
                    "matchedPaperCorpusId": "4039308"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.373291015625
        },
        {
            "corpus_id": "266514821",
            "title": "EntangleVR++: evaluating the potential of using entanglement in an interactive VR scene creation system",
            "text": "The idea of direct manipulation has been explored in tool design for 2D visual art creation.Prior studies have shown that, for artists who are unfamiliar with programming concepts, manual manipulation and epistemic action on the target creation can help them better understand how the functions in the program behave Hempel and Chugh (2016); Li et al. (2020).Similarly, for programming virtual object behaviors, the creators may have a better understanding of their editing process if they can directly manipulate the object's interaction states while seeing a visual representation of perceivable changes.In our work, we used a Bloch sphere to visualize the probabilities of an super object with sliders to control its state, in addition to numeric value control of its state.During our study, we noticed that participants with lesser programming experience used the visual interface and the reactive outcome of slider control more than those with greater programming experience.They asked for even more interactivity and direct manipulation of super objects such as drag and drop features, to let them set more properties of objects in the scene.They also seemed to rely more on the interactive preview feature to test out their designs on the probabilities of super objects instead of trusting the numeric value representations, although it does not mean that they do not need the numeric reference.In contrast, accurate numeric control seemed to be more desired by those with greater programming experience, and they expressed explicit preference for a scripting interface over a visual programming interface.Not surprisingly, they tended to use the input field on the interface to type in an exact numeric value for object state control instead of using a slider to roughly reach the desired state.Therefore, it is useful to keep both ways of object state control to accommodate creators of different programming levels while permitting more direct manipulation.",
            "score": 0.3291111347970113,
            "section_title": "Allow More Direct Manipulation",
            "char_start_offset": 40549,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 92
                },
                {
                    "start": 92,
                    "end": 359
                },
                {
                    "start": 359,
                    "end": 606
                },
                {
                    "start": 606,
                    "end": 777
                },
                {
                    "start": 777,
                    "end": 980
                },
                {
                    "start": 980,
                    "end": 1148
                },
                {
                    "start": 1148,
                    "end": 1402
                },
                {
                    "start": 1402,
                    "end": 1613
                },
                {
                    "start": 1613,
                    "end": 1803
                },
                {
                    "start": 1803,
                    "end": 1967
                }
            ],
            "ref_mentions": [
                {
                    "start": 317,
                    "end": 340,
                    "matchedPaperCorpusId": "11286540"
                },
                {
                    "start": 342,
                    "end": 358,
                    "matchedPaperCorpusId": "210174639"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.360595703125
        },
        {
            "corpus_id": "54974188",
            "title": "E-Block: A Tangible Programming Tool with Graphical Blocks",
            "text": "Papert and Resnick et al. mentioned in their contributions that learning how to program may result in changes to the ways people think [1,2]. Early studies with Logo also showed that when introduced in a structured way, computer programming can help children improve visual memories and basic numbers senses as well as develop problemsolving techniques and language skills [3]. However, most of the existing programming languages are designed for professionals and are based on texts and symbols which are difficult for children to understand [4,5]. Hence, previous research works are conducted aiming at lowering the barrier of programming for children [6]. \n\nGraphical programming has some significant advantages over textual programming especially in providing visual cues for young programmers [7,8]. However, the usage of keyboard and mouse which are major input methods in GUI may be difficult for children [9,10]. What is more is GUI's nature drawback that it falls short of embracing the richness of human's interaction with physical world [11]. This kind of activities contribute to children's learning [12]. \n\nArtificial intelligence with tangible programming is kind of feasible programming method for children [13]. Tangible interaction can stimulate multiple senses of children and develop their cognitive abilities [14]. In addition, compared with directly operating computers, using physical objects to interact with computer is much easier to involve children in the process [15]. Instead of using lines of dull codes, the program becomes a collection of physical objects. Children can write programs by assembling the physical objects without keystrokes [16]. Thus, the programming could be more intuitive to children. \n\nBased on our previous work-T-maze [17], this paper proposes a tangible programming tool: E-Block, which is designed for children aged 5 to 9. It defines the programming blocks and the sensors as the input and enables children to write programs to complete the tasks in the computer as Figure 1 shows. The symbol on the programming block's surface is used to help children understand the function of each block. The sequence information is transferred to computer by microcomputers and then translated into semantic information. In E-Block, children need first to find a path for the character to escape the maze in programming stage and then run the program and trigger sensors when necessary in running stage.",
            "score": 0.3284280750592592,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 141
                },
                {
                    "start": 142,
                    "end": 377
                },
                {
                    "start": 378,
                    "end": 549
                },
                {
                    "start": 550,
                    "end": 658
                },
                {
                    "start": 661,
                    "end": 804
                },
                {
                    "start": 805,
                    "end": 920
                },
                {
                    "start": 921,
                    "end": 1053
                },
                {
                    "start": 1054,
                    "end": 1117
                },
                {
                    "start": 1120,
                    "end": 1227
                },
                {
                    "start": 1228,
                    "end": 1334
                },
                {
                    "start": 1335,
                    "end": 1496
                },
                {
                    "start": 1497,
                    "end": 1588
                },
                {
                    "start": 1589,
                    "end": 1676
                },
                {
                    "start": 1677,
                    "end": 1735
                },
                {
                    "start": 1738,
                    "end": 2038
                },
                {
                    "start": 2039,
                    "end": 2148
                },
                {
                    "start": 2149,
                    "end": 2265
                },
                {
                    "start": 2266,
                    "end": 2448
                }
            ],
            "ref_mentions": [
                {
                    "start": 138,
                    "end": 140,
                    "matchedPaperCorpusId": "207590899"
                },
                {
                    "start": 373,
                    "end": 376,
                    "matchedPaperCorpusId": "60968997"
                },
                {
                    "start": 543,
                    "end": 546,
                    "matchedPaperCorpusId": "26242194"
                },
                {
                    "start": 654,
                    "end": 657,
                    "matchedPaperCorpusId": "15744652"
                },
                {
                    "start": 801,
                    "end": 803,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 913,
                    "end": 916,
                    "matchedPaperCorpusId": "10048690"
                },
                {
                    "start": 916,
                    "end": 919,
                    "matchedPaperCorpusId": "14930642"
                },
                {
                    "start": 1048,
                    "end": 1052,
                    "matchedPaperCorpusId": "462228"
                },
                {
                    "start": 1112,
                    "end": 1116,
                    "matchedPaperCorpusId": "17738532"
                },
                {
                    "start": 1222,
                    "end": 1226,
                    "matchedPaperCorpusId": "62725567"
                },
                {
                    "start": 1329,
                    "end": 1333,
                    "matchedPaperCorpusId": "7831671"
                },
                {
                    "start": 1671,
                    "end": 1675,
                    "matchedPaperCorpusId": "7387738"
                },
                {
                    "start": 1772,
                    "end": 1776,
                    "matchedPaperCorpusId": "565775"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51806640625
        },
        {
            "corpus_id": "258184800",
            "title": "Closed group private chat application with translation feature with firebase database",
            "text": "Block-based programming is a revolutionary way for developers to code using visual block elements, rather than typing complex commands. It eradicates syntax errors, making it more accessible and user-friendly. It is particularly useful for beginners or children who are interested in programming, as it eliminates the need for learning complicated code syntax. Block-based programming simplifies the process of implementing logic, making it incredibly intuitive for young users. It stands in contrast to higher-level programming languages that can require the learning of challenging concepts. With block-based programming, children can easily learn how to run programs and showcase their creativity.",
            "score": 0.3277985876980237,
            "section_title": "About block-based coding",
            "char_start_offset": 9470,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 135
                },
                {
                    "start": 136,
                    "end": 209
                },
                {
                    "start": 210,
                    "end": 360
                },
                {
                    "start": 361,
                    "end": 478
                },
                {
                    "start": 479,
                    "end": 593
                },
                {
                    "start": 594,
                    "end": 700
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.426025390625
        },
        {
            "corpus_id": "277634411",
            "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
            "text": "Step-level task decomposition: Visual Programming inherently organizes logical steps into a program flow symbolically, closely mirroring the CoT approach where complex tasks are decomposed into sequential segments. This alignment with CoT step-by-step nature ensures each code block in Visual Programming correlates with a CoT reasoning step, facilitating a seamless transition from code to CoT. \n\n3) Multi-dimensional statement evaluation: Furthermore, the modular design of Visual Programming supports multidimensional evaluation. Each module can be independently assessed through intermediate variables, code logic, and compilation data, reflecting key aspects such as data integrity and logical flow. This provides a more comprehensive assessment of the reasoning process. \n\nInspired by Visual Programming, we introduce SVIP, a method that generates executable code to solve visual tasks and seamlessly translates the creation of code and its ana-lytical evaluation into corresponding steps and assessments within the CoT framework. As shown in Figure 2, this is a two-phase code-to-CoT process. In the code generation ( 1 ) and assessment ( 2 ) phase, we begin by generating Python programs for each task, using least-to-most prompting. Subsequently, we conduct a multi-dimensional analysis of these blocks by evaluating their compilability, logic, and function calls. In the CoT conversion ( 3 ) and alignment ( 4 ) phase, we convert the generated code into sequential CoT statements and then map the detailed analysis of each code block into step-level multi-dimensional annotations within these statements. Finally, to capitalize on the evaluations derived from SVIP, we train our reward model SVIP-Reward using a multi-head attention mechanism called TriAtt-CoT. This mechanism is specifically designed to attentively weigh and integrate the varied dimensions of relevance, logic, and attributes assessed in each CoT step. \n\nThe advantages of SVIP-Reward are apparent throughout the entire MLLM pipeline. During the data cleaning phase, SVIP-Reward enhances the selection process by identifying high-quality multimodal reasoning samples based on critical dimensions. During the training phase, it automatically provides multi-dimensional supervisory signals at each step for reinforcement learning. During the inference phase, it leverages reward signals to select the best candidate step for test-time scaling, thereby enhancing the model's reasoning ability at a relatively low computational cost [6,38].",
            "score": 0.3276843530888929,
            "section_title": "2)",
            "char_start_offset": 3572,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 214
                },
                {
                    "start": 215,
                    "end": 395
                },
                {
                    "start": 398,
                    "end": 532
                },
                {
                    "start": 533,
                    "end": 704
                },
                {
                    "start": 705,
                    "end": 776
                },
                {
                    "start": 779,
                    "end": 1036
                },
                {
                    "start": 1037,
                    "end": 1099
                },
                {
                    "start": 1100,
                    "end": 1241
                },
                {
                    "start": 1242,
                    "end": 1373
                },
                {
                    "start": 1374,
                    "end": 1614
                },
                {
                    "start": 1615,
                    "end": 1771
                },
                {
                    "start": 1772,
                    "end": 1931
                },
                {
                    "start": 1934,
                    "end": 2013
                },
                {
                    "start": 2014,
                    "end": 2175
                },
                {
                    "start": 2176,
                    "end": 2307
                },
                {
                    "start": 2308,
                    "end": 2515
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.95263671875
        },
        {
            "corpus_id": "257365325",
            "title": "Hiding task-oriented programming complexity: an industrial case study",
            "text": "In literature, visual programming interfaces commonly use flow diagrams, behaviour trees, blocks, and icons (Stenmark, Haaae, and Topp, 2017). Some visual programming systems propose personal graphical user interfaces (Schou et al., 2018) that use buttons, menus, windows, textual inputs, and sliders. The standard IEC-61131-3, which defines programming languages for automation, provide visual programming languages, such as the Function Block (FB) or the Sequential Flow Chart (SFC), that can also be used for robot programming as standard languages (Thormann and Winkler, 2021;Rendiniello et al., 2020). These languages are suitable for beginner programmers. The execution speed of visual applications is slow, and the programming requires more time than a textual one. A complex task requires a large number of operations, users spend time making room for things, encasing and rearranging them in macros, and the overall program can get crowded. \n\nAugmented/virtual reality allows overlapping the real-world environment with a virtual one. With this technology, some information or programming tools can appear directly in the environment. The possibility of overlapping a virtual robot and objects allows the operator to use the programming by demonstration without interacting directly with the robot (Blankemeyer et al., 2018). Visualising virtual panels with programming information (e.g., robot trajectory or parameter values) allows the operator to make decisions (Gadre et al., 2019). Using physical auxiliary tools (Ong et al., 2020) or object detection software (Apostolopoulos et al., 2022) can facilitate the user programming. This technology presents a high implementation cost; it needs to be more flexible as it is programmed for a specific task and prone to failures in case of environmental changes. \n\nNatural language programming uses speech and text to create programs. Usually, this technique works in parallel with another programming technique. The high complexity of human language requires some constraints, and this type of language cannot describe the action in its entirety. In literature, natural language programming was combined with programming by demonstration (Quintero et al., 2018), visual programming (Huang and Cakmak, 2017), and augmented reality (Andronas et al., 2021).",
            "score": 0.3276843530888929,
            "section_title": "Related works",
            "char_start_offset": 10548,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 142
                },
                {
                    "start": 143,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 606
                },
                {
                    "start": 607,
                    "end": 661
                },
                {
                    "start": 662,
                    "end": 772
                },
                {
                    "start": 773,
                    "end": 949
                },
                {
                    "start": 952,
                    "end": 1043
                },
                {
                    "start": 1044,
                    "end": 1143
                },
                {
                    "start": 1144,
                    "end": 1334
                },
                {
                    "start": 1335,
                    "end": 1495
                },
                {
                    "start": 1496,
                    "end": 1641
                },
                {
                    "start": 1642,
                    "end": 1819
                },
                {
                    "start": 1822,
                    "end": 1891
                },
                {
                    "start": 1892,
                    "end": 1969
                },
                {
                    "start": 1970,
                    "end": 2104
                },
                {
                    "start": 2105,
                    "end": 2312
                }
            ],
            "ref_mentions": [
                {
                    "start": 108,
                    "end": 141,
                    "matchedPaperCorpusId": "17034241"
                },
                {
                    "start": 218,
                    "end": 238,
                    "matchedPaperCorpusId": "46998839"
                },
                {
                    "start": 552,
                    "end": 580,
                    "matchedPaperCorpusId": "237597380"
                },
                {
                    "start": 580,
                    "end": 605,
                    "matchedPaperCorpusId": "222219690"
                },
                {
                    "start": 1307,
                    "end": 1333,
                    "matchedPaperCorpusId": "69786079"
                },
                {
                    "start": 1474,
                    "end": 1494,
                    "matchedPaperCorpusId": "86846328"
                },
                {
                    "start": 1527,
                    "end": 1545,
                    "matchedPaperCorpusId": "201246976"
                },
                {
                    "start": 1575,
                    "end": 1604,
                    "matchedPaperCorpusId": "247402386"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89697265625
        },
        {
            "corpus_id": "273147365",
            "title": "Advanced Game Engine Wizardry for Visual Programming Environments",
            "text": "We formulate requirements for a visual programming environment with coding and debugging facilities that offers: \n\n1. a navigation view for creating programs, running them, opening new views, and navigating between tabs. We use Raven and Rascal to create a visual programming environment. For navigating between views, we design a familiar browser-like view, including an initial screen and tabs, as shown in Figure 8. The tree and tabular views offer controls that map directly to REPL commands that work on the syntax. To create them, we implement renderers that generate the user interface based on the program state. Figures 9 and 10 shows how Raven renders an example program. These editors share an identical left-hand side. This allows the user to navigate between views smoothly with the \"Available Editors\" drop-down. Finally, the runtime view, shown in Figure 11, enables interaction with running machine programs. The source code of the LiveSML, including the visual editors and the REPL interpreter, is available on GitHub3 .",
            "score": 0.3276843530888929,
            "section_title": "Visual Live Programming Environment",
            "char_start_offset": 20044,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 112
                },
                {
                    "start": 115,
                    "end": 220
                },
                {
                    "start": 221,
                    "end": 288
                },
                {
                    "start": 289,
                    "end": 418
                },
                {
                    "start": 419,
                    "end": 520
                },
                {
                    "start": 521,
                    "end": 620
                },
                {
                    "start": 621,
                    "end": 681
                },
                {
                    "start": 682,
                    "end": 730
                },
                {
                    "start": 731,
                    "end": 826
                },
                {
                    "start": 827,
                    "end": 924
                },
                {
                    "start": 925,
                    "end": 1037
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8798828125
        },
        {
            "corpus_id": "256827582",
            "title": "ELEA - Build your own Evolutionary Algorithm in your Browser",
            "text": "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations. \n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour. \n\nBlockly [2,5] is an example of such a VPS. It is an open-source, client-side library for the programming language JavaScript, providing an editor representing coding concepts as interlocking blocks. Blockly typically runs in a web browser, but it can also generate correct stand-alone code in JavaScript, Python, PHP, Lua, Dart, etc. Figure 1 shows an example of Blockly running in a browser. The default graphical user interface of the Blockly editor consists of (1) a toolbox, which holds available blocks, and where a user can select blocks; and (2) a workspace, where a user can drag, drop and rearrange blocks. The workspace also includes, by default, zoom icons, and a trash can to delete blocks. Assembly of code consists in drag and drop of functional blocks, giving a final visual impression much like pseudo-code. For ELEA, we leverage that Blockly is open-source and that custom blocks can be created. Each block consists of a definition, which defines the visual appearance, and a generator, which describes the block's translation to executable code. Blocks can be written in JavaScript, but they can also be defined using blocks.",
            "score": 0.3276843530888929,
            "section_title": "BACKGROUND ON VISUAL PROGRAMMING",
            "char_start_offset": 6291,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 153
                },
                {
                    "start": 154,
                    "end": 284
                },
                {
                    "start": 287,
                    "end": 359
                },
                {
                    "start": 362,
                    "end": 443
                },
                {
                    "start": 444,
                    "end": 522
                },
                {
                    "start": 523,
                    "end": 613
                },
                {
                    "start": 616,
                    "end": 658
                },
                {
                    "start": 659,
                    "end": 814
                },
                {
                    "start": 815,
                    "end": 1008
                },
                {
                    "start": 1009,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1318
                },
                {
                    "start": 1319,
                    "end": 1439
                },
                {
                    "start": 1440,
                    "end": 1528
                },
                {
                    "start": 1529,
                    "end": 1679
                },
                {
                    "start": 1680,
                    "end": 1759
                }
            ],
            "ref_mentions": [
                {
                    "start": 34,
                    "end": 37,
                    "matchedPaperCorpusId": "14591095"
                },
                {
                    "start": 355,
                    "end": 358,
                    "matchedPaperCorpusId": "41867280"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96435546875
        },
        {
            "corpus_id": "13395203",
            "title": "Visualizing Computer Programming in a Computer-based Simulated Environment",
            "text": "This paper focuses on a different visualization technique, which involves the application of virtual world technologies to visualize complex theory concepts of computer programming in order to enhance students\" understanding and learning of this subject at the HE level. The research involved HE in Computer Science students in a university center in England, UK. Visualization scenarios were designed in the virtual world of \"Second Life\" to support the learning of challenging programming concepts as part of the HE Computer Science Year-1 and Year-2 programming courses. These visualization scenarios were scripted by the researcher using the programming language embedded within Second Life, called \"Linden Labs Scripting Language (LSL)\". Many researchers confirmed the similarity of syntax and semantics between LSL and C++ language, which the selected HE students were studying as part of their Computer Science qualification. In [29], authors highlighted that the LSL\"s main syntax and operators are expressive of those in Java and C++ programming languages. It explained that Second Life implements a compiler for the LSL language that contains C++ source code. In [10], authors confirmed the above by saying that the programming of objects in Second Life is performed by the use of LSL scripting language, the keywords www.ijacsa.thesai.org and structure of which are similar to those in C Language. The way the variables are declared in LSL language is the same as that in C++, and the multiple methods of creating a loop in LSL are almost identical to those in C++ [30]. \n\nIn the visualization scenarios designed for this research, a number of eye-catching 3D objects were chosen to be programmed by learners within Second Life, e.g. Pok\u00e9mon. This was meant to enable them to visualize the execution of challenging program instructions in order to improve their understanding of the relationship between the scripts and the actual implementation process and results. The type of the 3D objects was selected to add interest for learners and make their learning process enjoyable. These visualization scenarios enabled learners to view the immediate effects of script changes on each 3D object, i.e. visualizing the program execution. This assisted learners to understand how each program instruction works. Particular emphasis was placed on instructions related to loops and functionsfor the Introduction to Programming course, and on classes and objectsfor the Object-Oriented Programming course.",
            "score": 0.3276843530888929,
            "section_title": "C. Application of Virtual World Technologies in the Learning of Computer Programming",
            "char_start_offset": 20021,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 270
                },
                {
                    "start": 271,
                    "end": 363
                },
                {
                    "start": 364,
                    "end": 573
                },
                {
                    "start": 574,
                    "end": 742
                },
                {
                    "start": 743,
                    "end": 932
                },
                {
                    "start": 933,
                    "end": 1065
                },
                {
                    "start": 1066,
                    "end": 1169
                },
                {
                    "start": 1170,
                    "end": 1349
                },
                {
                    "start": 1350,
                    "end": 1408
                },
                {
                    "start": 1409,
                    "end": 1581
                },
                {
                    "start": 1584,
                    "end": 1744
                },
                {
                    "start": 1745,
                    "end": 1753
                },
                {
                    "start": 1754,
                    "end": 1977
                },
                {
                    "start": 1978,
                    "end": 2089
                },
                {
                    "start": 2090,
                    "end": 2243
                },
                {
                    "start": 2244,
                    "end": 2316
                },
                {
                    "start": 2317,
                    "end": 2507
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.580078125
        },
        {
            "corpus_id": "268379810",
            "title": "A Picture Is Worth a Thousand Words: Exploring Diagram and Video-Based OOP Exercises to Counter LLM Over-Reliance",
            "text": "The proposed notation and diagrams present a new visual language relevant for the specificities of teaching and learning OO design and programming.These diagrams require that students first understand the problem by analysing the diagrammatic sample sets, and then proceed to define an object model and/or algorithm which solves it, with or without the help of a LLM.\n\nDiagrams and videos can prescribe more or less directed tasks, according to educators' goals, by using clues such as 'Implement in class Main', 'Represent these concepts', and so on.However, educators should avoid exposing too much information textually or verbally, since some textual instructions can be parsed from images [13] and audio interpretation tools are also emerging [19].\n\nWe consider this model to have three advantages: (1) it forces students to interpret test cases and infer a problem description; (2), it should prevent direct 'copy-and-prompting' from the assignment description to the LLM; and, (3) it requires students that wish to use an LLM to create prompts that guide it towards the goal.Although these last two ideas might seem contradictory, we believe that both have some pedagogical value, since it is important that students gain some experience with using LLMs in an authentic way, as helpers for solving coding problems, due to the likelihood that they will use these tools professionally [2,4].\n\nDuring the experiment, we observed some interesting student behaviours which we believe should guide future work on this topic.One interesting aspect was, at least in some cases, students' difficulties in interpreting the diagrams prompted interesting discussions between students and teachers.When the doubts were not obvious, we would engage with the student and help them reach the expected interpretation by themselves.For example, when a student asked \"What does this 'N + 1' tasks mean?\", the teacher pointed out that, before the function call, the object indicated 'N tasks', and then asked the student what they thought was happening that resulted in the change from 'N tasks' to 'N + 1 tasks'.As for the videos, at least one student transcribed the video to a text document.We informally asked the student for their reasons, and they indicated doing it to support offline work because they didn't have an internet connection at all times.",
            "score": 0.32737847949529064,
            "section_title": "Discussion",
            "char_start_offset": 17397,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 147
                },
                {
                    "start": 147,
                    "end": 367
                },
                {
                    "start": 369,
                    "end": 551
                },
                {
                    "start": 551,
                    "end": 753
                },
                {
                    "start": 755,
                    "end": 1082
                },
                {
                    "start": 1082,
                    "end": 1396
                },
                {
                    "start": 1398,
                    "end": 1525
                },
                {
                    "start": 1525,
                    "end": 1692
                },
                {
                    "start": 1692,
                    "end": 1821
                },
                {
                    "start": 1821,
                    "end": 2100
                },
                {
                    "start": 2100,
                    "end": 2181
                },
                {
                    "start": 2181,
                    "end": 2345
                }
            ],
            "ref_mentions": [
                {
                    "start": 1393,
                    "end": 1395,
                    "matchedPaperCorpusId": "250144196"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.505859375
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "The notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming. \n\nWhile visual programming adoption ranges from rapid application development, interactive software configurations, and system administration, it became popular for educational purposes, in particular for teaching programming skills. In this framework, Scratch (Maloney et al., 2010), a block-based tool and Lego Mindstorms\u2122 (Vallance et al., 2009) are amongst the most well-known visual tools in learning contexts. Historically, visual programing systems have been deployed to introduce students in the programming universe before being enabled to manage and master professional source-based programming languages. In this context, their scope is generally considered to be restricted in the early stages of acquiring programming skills. But today, there are visual tools for professional development purposes, ranging from business process, Internet of Things, 3d graphics and robotics, meaning their scope is not merely restricted to learning activities. Also, such tools support an important activity in the development lifecycle that is not always substituted by text-based counterparts, thus retaining a distinct and critical role. In this sense, for certain development skills, professional programmers may still have to learn using visual tools before switching (if they ever do) to the most powerful programminglanguage basis. This interplay between visual tools for leaning, with typical professional programming environments, is depicted under Figure 1. \n\nIn an educational context, emphasis is put on blending user experience (Law et al., 2009) with learning experience (Tawfik et al., 2021) to optimally support programming tasks. We define this combination as programming experience (see Figure 2) to better highlight and contextualise the importance of the programming task. In this context, we carried out a systematic analysis briefed in this paper, resulting in key design requirements linking to programming experience, with a summary provided under Figure 3.",
            "score": 0.3244780451268607,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 114
                },
                {
                    "start": 115,
                    "end": 280
                },
                {
                    "start": 281,
                    "end": 393
                },
                {
                    "start": 396,
                    "end": 627
                },
                {
                    "start": 628,
                    "end": 809
                },
                {
                    "start": 810,
                    "end": 1009
                },
                {
                    "start": 1010,
                    "end": 1132
                },
                {
                    "start": 1133,
                    "end": 1351
                },
                {
                    "start": 1352,
                    "end": 1531
                },
                {
                    "start": 1532,
                    "end": 1729
                },
                {
                    "start": 1730,
                    "end": 1858
                },
                {
                    "start": 1861,
                    "end": 2037
                },
                {
                    "start": 2038,
                    "end": 2183
                },
                {
                    "start": 2184,
                    "end": 2372
                }
            ],
            "ref_mentions": [
                {
                    "start": 100,
                    "end": 112,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 655,
                    "end": 677,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 719,
                    "end": 742,
                    "matchedPaperCorpusId": "208013563"
                },
                {
                    "start": 1932,
                    "end": 1950,
                    "matchedPaperCorpusId": "10465690"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97265625
        },
        {
            "corpus_id": "196154601",
            "title": "Visualization of logistic algorithm in Wilson model",
            "text": "This combination of means of implementing the integrated development environment of Microsoft Visual Studio 2015 (i.e. the C # language and the \"Dot Net Framework\" virtual machine) chosen allows one to write graphical interface software without any difficulties. \n\nThe program itself consists of the function that takes as an argument a planning horizon and a timer with a period of 0.1 second and a step of 0.01 days (this is about 14 minutes 24 seconds). This allows one to build a smooth visual animation that illustrates the situation on the specified planning horizon.",
            "score": 0.3244780451268607,
            "section_title": "Means of computer realization",
            "char_start_offset": 5266,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 262
                },
                {
                    "start": 265,
                    "end": 456
                },
                {
                    "start": 457,
                    "end": 573
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.411376953125
        },
        {
            "corpus_id": "158235604",
            "title": "Perceptions of Scratch Programming among Secondary School Students in KwaZulu-Natal, South Africa",
            "text": "Due to the rapid growth of digital technology \"individuals are required to use a growing variety of technical, cognitive, and sociological skills in order to perform tasks and solve problems in digital environments\" (Eshet-Alkalai, 2004, p. 93). To assist in the attaining of these skills, teaching students to program has been introduced into primary and secondary education curriculums. Pendergast (2006) states that the significance of a well-constructed introduction to programming course cannot be over-emphasised, as it was observed that many students found difficulties with understanding the programming process as well as familiarising themselves with the various programming constructs. Visual programming tools like Alice, a programming language developed by Carnegie Mellon University, and Scratch, are favoured with younger introductory students (Lye, & Koh, 2014). Alice, which was developed before Scratch, is used to teach students general programming concepts as well as object-oriented programming (OOP) concepts. Much effort has gone into the development of visual programming tools for young individuals (Meerbaum-Salant, Armoni, & Ben-Ari, 2013), with these tools being used by young children and as a preliminary learning tool for secondary schools and universities. Visual programming tools such as these create a non-threatening, fun environment for students to develop software, in a way that aims to reduce the anxiety and fear often associated with learning programming (Meerbaum-Salant et al., 2013). It is believed that through these environments, students will be more open to continuing their study of programming. \n\nA study by Boyle, Bradley, Chalk, Jones and Pickard (2003) focused specifically on a \"visual approach\", making use of graphical shapes to teach abstract programming concepts which were available to students in a virtual learning environment (VLE). Boyle et al. (2003) implemented this approach with an introduction to programming course, and found a 12% to 23% increase in the pass rate over the previous year's students who did not have a VLE-and a graphics-based approach. The results of a questionnaire handed to students during mid-semester showed that 95% of students judged the graphics-based approach to learning programming to be \"good\" or \"very good\" (Boyle et al., 2003).",
            "score": 0.3244780451268607,
            "section_title": "Effectiveness of using programming and visual tools",
            "char_start_offset": 9276,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 245
                },
                {
                    "start": 246,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 878
                },
                {
                    "start": 879,
                    "end": 1031
                },
                {
                    "start": 1032,
                    "end": 1288
                },
                {
                    "start": 1289,
                    "end": 1528
                },
                {
                    "start": 1529,
                    "end": 1645
                },
                {
                    "start": 1648,
                    "end": 1895
                },
                {
                    "start": 1896,
                    "end": 2122
                },
                {
                    "start": 2123,
                    "end": 2329
                }
            ],
            "ref_mentions": [
                {
                    "start": 389,
                    "end": 406,
                    "matchedPaperCorpusId": "264655814"
                },
                {
                    "start": 859,
                    "end": 877,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 1497,
                    "end": 1527,
                    "matchedPaperCorpusId": "16831477"
                },
                {
                    "start": 1659,
                    "end": 1706,
                    "matchedPaperCorpusId": "17271778"
                },
                {
                    "start": 1896,
                    "end": 1915,
                    "matchedPaperCorpusId": "17271778"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.54052734375
        },
        {
            "corpus_id": "269622739",
            "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
            "text": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
            "score": 0.3244780451268607,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.95263671875
        },
        {
            "corpus_id": "268249114",
            "title": "Making Hybrid Languages: A Recipe",
            "text": "Several programming systems have enabled a mixture of some graphical and textual programming for decades. The four most prominent examples are Boxer, Hypercard, Scratch, and Smalltalk. Boxer [diSessa and Abelson 1986] allows developers to embed GUI elements within other GUI elements (\"boxing\"), to name such GUI elements, and to refer to these names in program code. That is, \"programs\" consist of graphical renderings of GUI objects and program text (inside the boxes). For example, a Boxer programmer could create a box that contains an image of a board game tile, name it, and refer to this name in a unit test in a surrounding box. Boxer does not, however, satisfy any of the other desiderata listed in section 2. In particular, it has poor support for creating new abstractions with regard to the GUI elements. \n\nScratch [Resnick et al. 2009] is a fully graphical language system widely used in education. In Scratch, users write their programs by snapping graphical blocks together. These blocks resemble puzzle pieces and snapping them together creates syntactically valid programs. Scratch offers limited, but growing, capabilities for a programmer to make new block types [Harvey and M\u00f6nig 2010]. These created block types, however, are themselves created through text. \n\nLabVIEW [Kodosky 2020] is a commercial visual language targeted at scientists and engineers. It is widely adopted in its target communities. While it is possible to create robust products using LabVIEW, extending it with new types of visualizations is non-trivial, and it is rarely done. \n\nHypercard [Goodman 1988] gives users a graphical interface to make interactive documents. Authors have used Hypercard to create everything from user interfaces to adventure games. While Hypercard has been used in a wide variety of domains, it is not a general-purpose language. \n\nBefore the Sandbox project, Smalltalk [Bergel et al. 2013;Goldberg and Robson 1983;Ingalls et al. 2008;Klokmose et al. 2015;R\u00e4dle et al. 2017] supported direct manipulation of GUI objects, often called live programming. Rather than separating code from objects, Smalltalk programs exist in a shared environment called the Morphic user interface [Maloney and Imagineering 2001].",
            "score": 0.3244780451268607,
            "section_title": "Graphical and Live Languages",
            "char_start_offset": 46481,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 105
                },
                {
                    "start": 106,
                    "end": 367
                },
                {
                    "start": 368,
                    "end": 471
                },
                {
                    "start": 472,
                    "end": 636
                },
                {
                    "start": 637,
                    "end": 816
                },
                {
                    "start": 819,
                    "end": 911
                },
                {
                    "start": 912,
                    "end": 989
                },
                {
                    "start": 990,
                    "end": 1090
                },
                {
                    "start": 1091,
                    "end": 1206
                },
                {
                    "start": 1207,
                    "end": 1279
                },
                {
                    "start": 1282,
                    "end": 1374
                },
                {
                    "start": 1375,
                    "end": 1422
                },
                {
                    "start": 1423,
                    "end": 1569
                },
                {
                    "start": 1572,
                    "end": 1661
                },
                {
                    "start": 1662,
                    "end": 1751
                },
                {
                    "start": 1752,
                    "end": 1849
                },
                {
                    "start": 1852,
                    "end": 2071
                },
                {
                    "start": 2072,
                    "end": 2229
                }
            ],
            "ref_mentions": [
                {
                    "start": 1182,
                    "end": 1205,
                    "matchedPaperCorpusId": "62609287"
                },
                {
                    "start": 1935,
                    "end": 1955,
                    "matchedPaperCorpusId": "37427503"
                },
                {
                    "start": 1955,
                    "end": 1976,
                    "matchedPaperCorpusId": "3449397"
                },
                {
                    "start": 1976,
                    "end": 1993,
                    "matchedPaperCorpusId": "9336023"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.52392578125
        },
        {
            "corpus_id": "52911975",
            "title": "GameControllerizer: Middleware to Program Inputs for Augmenting Digital Games",
            "text": "The visual programming element is a programming environment that prescribes the logic used for transforming the information relayed by the external input element into inputs for the game. It employs Node-RED. \n\nNode-RED is a framework for receiving, converting, and transmitting messages on a server. As all processes are defined by process blocks (nodes) on a GUI, it is possible to apply them to the input data by simply connecting them together. Accordingly, it has low learning cost, which renders it suitable for the type of rapid prototyping assumed in this study.",
            "score": 0.3244780451268607,
            "section_title": "Visual Programming Element",
            "char_start_offset": 9851,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 187
                },
                {
                    "start": 188,
                    "end": 208
                },
                {
                    "start": 211,
                    "end": 300
                },
                {
                    "start": 301,
                    "end": 448
                },
                {
                    "start": 449,
                    "end": 570
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78662109375
        },
        {
            "corpus_id": "186749406",
            "title": "Microsoft Visual Basic 6.0 Software to Develop Mathematics Teaching Materials",
            "text": "Visual Basic is a computer programming language, in [12] is commands or instructions that are understood by computers to perform certain tasks. Visual Basic besides being referred to as a programming language, it is also often referred to as a tool (tool) to produce Windows-based application programs. \n\nIn Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach. \n\nVisual Basic allows the creation of Graphical User Interface (GUI) or programming applications that use the graphical display as a communication tool with the user. In Visual Basic to create a user interface display is relatively easy to do because only need to put graphics objects into the source (form) that has been provided by Visual Basic. After that, simply set the properties of these objects. Some of the capabilities or benefits of Visual Basic include: 1. To create a Window-based application program 2. To create program help objects such as ActiveX controls, Help files, internet applications and so on. \n\nVisual basic components are very important. These components will help us in making the program. The first time opening Visual Basic will appear several components, namely, among others, the menu bar, toolbar, form, project window, properties window, and form layout window, as shown below: [5] Figure 1 Example display of Microsoft Visual Basic 6.0 Information: \n\n1. Menu Bar used to select specific tasks such as saving projects, opening projects, etc. \n\n2. The Main Toolbar used to perform certain tasks quickly. \n\n3. Toolbox window, this window contains components that you can use to develop the user interface. \n\n4. Form Designer window, this window is your place to design the user interface of your application. So, this window resembles a canvas for a painter. 5. Project window, this window contains an overview of all modules contained in your application. \n\nYou can use Ctrl + R to display the project window or use the Project Explorer icon. 6. The Properties window is a list of object properties that are currently selected. For example, you can change the foreground color and background color. You can use F4 to display the properties window.",
            "score": 0.3244780451268607,
            "section_title": "Visual Basic",
            "char_start_offset": 6767,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 143
                },
                {
                    "start": 144,
                    "end": 302
                },
                {
                    "start": 305,
                    "end": 525
                },
                {
                    "start": 526,
                    "end": 624
                },
                {
                    "start": 627,
                    "end": 791
                },
                {
                    "start": 792,
                    "end": 972
                },
                {
                    "start": 973,
                    "end": 1028
                },
                {
                    "start": 1029,
                    "end": 1093
                },
                {
                    "start": 1094,
                    "end": 1243
                },
                {
                    "start": 1246,
                    "end": 1289
                },
                {
                    "start": 1290,
                    "end": 1342
                },
                {
                    "start": 1343,
                    "end": 1608
                },
                {
                    "start": 1611,
                    "end": 1700
                },
                {
                    "start": 1703,
                    "end": 1761
                },
                {
                    "start": 1764,
                    "end": 1862
                },
                {
                    "start": 1865,
                    "end": 1965
                },
                {
                    "start": 1966,
                    "end": 2113
                },
                {
                    "start": 2116,
                    "end": 2200
                },
                {
                    "start": 2201,
                    "end": 2203
                },
                {
                    "start": 2204,
                    "end": 2285
                },
                {
                    "start": 2286,
                    "end": 2356
                },
                {
                    "start": 2357,
                    "end": 2405
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.982421875
        },
        {
            "corpus_id": "3681992",
            "title": "PWCT: visual language for IoT and cloud computing applications and systems",
            "text": "Alice is a VPL where objects are manipulated in a 3D world (as shown in figure 2). It was developed at Carnegie Mellon University; it gives students the chance to learn about objectoriented programming concepts without the syntax frustrations imposed by text-based programming languages. With Alice, a programmer using a Graphical User Interface (GUI) environment selects program constructs and methods from lists of available choices.",
            "score": 0.3244780451268607,
            "section_title": "Figure 1. Scratch Environment",
            "char_start_offset": 3515,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 82
                },
                {
                    "start": 83,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 435
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84326171875
        },
        {
            "corpus_id": "268253340",
            "title": "The Visual Debugger: Past, Present, and Future",
            "text": "Traditionally, stack frame variables are represented textually, such as in Figure 1 (a), a screenshot of the variables view in IntelliJ IDEA for a Binary Search Tree (BST). \n\nThe Visual Debugger represents the same information graphically as an object diagram. Using the Visual Debugger is straightforward since it opens automatically during debugging in the IDE. The Visual Debugger visualizes the variables in the scope of the debugging session (see, for example, Figure 1  The graphical visualization does not replace the textual debugging view but aims to augment the debugging experience to improve program comprehension [16]. Concretely, the Visual Debugger is non-intrusive since it can be used alongside the traditional textual debugging available in the IDE. \n\nThe Visual Debugger automatically updates the debug information as the IntelliJ IDEA debugger whenever a user steps through the source code or reaches a new breakpoint. Moreover, the objects a debugging variable refers to can be loaded by double-clicking an object in the object diagram, similar to how it works in most textual debuggers. For example, in Figure 1, all objects the green object refers to were loaded. The goal is to make the Visual Debugger familiar by adopting how textual debuggers work such that a transition is smooth. \n\nA new video demonstration of the Visual Debugger is available at https://www.youtube.com/watch?v=LsAMTnLxWJw, showcasing the improvements discussed in subsection 2.3, which were made since our last publication [16].",
            "score": 0.32179097905136533,
            "section_title": "Description",
            "char_start_offset": 2536,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 172
                },
                {
                    "start": 175,
                    "end": 260
                },
                {
                    "start": 261,
                    "end": 363
                },
                {
                    "start": 364,
                    "end": 631
                },
                {
                    "start": 632,
                    "end": 767
                },
                {
                    "start": 770,
                    "end": 938
                },
                {
                    "start": 939,
                    "end": 1108
                },
                {
                    "start": 1109,
                    "end": 1186
                },
                {
                    "start": 1187,
                    "end": 1308
                },
                {
                    "start": 1311,
                    "end": 1526
                }
            ],
            "ref_mentions": [
                {
                    "start": 626,
                    "end": 630,
                    "matchedPaperCorpusId": "254908052"
                },
                {
                    "start": 1521,
                    "end": 1525,
                    "matchedPaperCorpusId": "254908052"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.634765625
        },
        {
            "corpus_id": "54577943",
            "title": "Enhanced Testing of Autonomous Underwater Vehicles Using Augmented Reality & JavaBeans",
            "text": "Visual programming is a good idea, however, due to its visual nature it places requirements on how a module is written. This usually requires that the low level components be programmed in a specially designed language which provides more information to the visual programming interface. This leads to visual programming only being used for more specific uses, such as connecting data flows using CAD packages. However, visual programming can become far more powerful if it places nearly zero restrictions on how the low level components are created i.e. the programming language used. In order for visual programming to be widely accepted it has to some how make use of existing software components even if they are not designed to be used in this way. One such method of visual programming exists whereby components only have to implement a few simple \"programming conventions\" in order to be able to be used visually. These special software components are called JavaBeans and are based on the Java programming language (Sun Microsystems). JavaBean visual programming tools work on the basis that a Java class object has been programmed adhering to certain coding conventions. Using this assumption the visual programming tool is able to use introspection techniques to infer what the inputs and outputs to a Java class and then display these as properties to the user. Thanks to Java's relatively high level byte code compilation layer, it is relatively simple for a JavaBean processor to analyse any given class and produce a set of properties which a user can edit visually. Therefore, removing the need for the programmer to write code in order to allow the configuration of Java class objects. JavaBean programming environments currently exist which allow a user to connect and configure JavaBeans to make 2D GUI based applications. The BeanBuilder (https://beanbuilder.dev.java.net) is one such program which provides the user with an intuitive visual interface for creating software out of JavaBeans. However, this doesn't provide any extra guidance other than graphical property sheet generation. A virtual environment is needed for mixed reality testing scenarios and this cannot be easily provided using the BeanBuilder's current platform. However, JavaBeans offer a very flexible base upon which a virtual environment development tool can be built. Since it can easily be extended via JavaBeans and all the advantages of JavaBeans can be harnessed.",
            "score": 0.32131392627199273,
            "section_title": "JavaBeans",
            "char_start_offset": 21026,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 119
                },
                {
                    "start": 120,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 410
                },
                {
                    "start": 411,
                    "end": 585
                },
                {
                    "start": 586,
                    "end": 753
                },
                {
                    "start": 754,
                    "end": 920
                },
                {
                    "start": 921,
                    "end": 1042
                },
                {
                    "start": 1043,
                    "end": 1179
                },
                {
                    "start": 1180,
                    "end": 1372
                },
                {
                    "start": 1373,
                    "end": 1580
                },
                {
                    "start": 1581,
                    "end": 1701
                },
                {
                    "start": 1702,
                    "end": 1840
                },
                {
                    "start": 1841,
                    "end": 2010
                },
                {
                    "start": 2011,
                    "end": 2107
                },
                {
                    "start": 2108,
                    "end": 2252
                },
                {
                    "start": 2253,
                    "end": 2362
                },
                {
                    "start": 2363,
                    "end": 2462
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92626953125
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "There are two basic reasons to turn to a visual language in a programming language for novices.\n\nFirst, a visual language provides the flexibility and expressiveness needed for a novice language to express a large vocabulary of programming plans. In our experience, a linear textual version of a plan-based programming language is quite unwieldy. Second, from a point of view of novice cognitive capability, a visual language is less likely to tax a novice's working memory. We discuss each of these points in detail.",
            "score": 0.3213007535264759,
            "section_title": "How Can Visual Languages Help Novices",
            "char_start_offset": 16488,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78466796875
        },
        {
            "corpus_id": "221802417",
            "title": "A Visual Language for Composable Inductive Programming",
            "text": "Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality. The use of multiple notations does not improve on this situation. \n\nWhilst visual programming has always seemed like a good idea, it has constantly grappled with the following issues: \n\n\u2022 Diagrams take up a lot of space on the screen compared to equivalent code; \n\n\u2022 Software is complex and diagrams of software can quickly become incomprehensible; \n\n\u2022 It often takes longer to produce a diagram than the equivalent code in a conventional language; \n\n\u2022 Literal visual languages have all of the same concepts as equivalent conventional programming language (variables, conditions, control structures, etc.) so learning such a visual language is not significantly easier; \n\n\u2022 Languages and frameworks often employ many classes and methods making it difficult to remember, find or discover relevant components and functions; \n\n\u2022 There are often too many concepts to represent visually in a distinctive or recognisable way so visual languages often rely heavily on textual annotation. \n\nThese issues have never been completely addressed. This is mostly due to the intrinsic complexity of the various visual languages themselves. While visual programming plays an important role in some areas a complete and compelling visual programming language remains elusive. \n\nAbstraction is often identified as a possible way of addressing some of these problems. As with conventional programming languages there is much interest in approaches that involve different programming paradigms, higher level languages and higher order programming. Unfortunately none of these approaches have addressed the issues associated with visual programming to a significant extent.",
            "score": 0.3213007535264759,
            "section_title": "Visual Programming",
            "char_start_offset": 5129,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 191
                },
                {
                    "start": 192,
                    "end": 257
                },
                {
                    "start": 260,
                    "end": 375
                },
                {
                    "start": 378,
                    "end": 454
                },
                {
                    "start": 457,
                    "end": 540
                },
                {
                    "start": 543,
                    "end": 640
                },
                {
                    "start": 643,
                    "end": 861
                },
                {
                    "start": 864,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1172
                },
                {
                    "start": 1175,
                    "end": 1225
                },
                {
                    "start": 1226,
                    "end": 1316
                },
                {
                    "start": 1317,
                    "end": 1450
                },
                {
                    "start": 1453,
                    "end": 1540
                },
                {
                    "start": 1541,
                    "end": 1719
                },
                {
                    "start": 1720,
                    "end": 1844
                }
            ],
            "ref_mentions": [
                {
                    "start": 31,
                    "end": 35,
                    "matchedPaperCorpusId": "115528616"
                },
                {
                    "start": 35,
                    "end": 38,
                    "matchedPaperCorpusId": "271709362"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.857421875
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "The works found in [7], [26] and [29] analyzed a limited number of visual programming approaches and techniques since article retrieval mainly focused on EUD approaches in general as opposed to visual programming approaches. For example, the work found in [29] classified the articles based on broad EUD techniques that do not cover all VPL classifications, whilst the authors of [7] primarily investigated EUD with reference to EUD-related conferences and missed relevant visual programming journals. Other review studies such as [8] and [10] surveyed visual programming environments in specific domains such as robotics and IoT, thereby overlooking a broach view of VPL approaches applied in multiple domains beyond IoT and robotics. \n\nFurthermore, as Table 1 shows, the existing review studies have barely touched on the empirical evidence, evaluation methods and measures that back up the validity of the visual programming tools. \n\nTherefore, there is a need for a systematic identification of articles describing and analyzing approaches and visual programming techniques used in multiple domains and backed up by empirical evidence, in order to obtain an in-depth analysis and understanding of the visual programming research. \n\nBy systematically analyzing 30 articles presenting visual programming tools representing various approaches (blockbased, diagram-based, form-based and icon-based), this study contributes: (1) an in-depth analysis of the visual programming approaches currently used to enable the creation of software applications used in several domains beyond the traditional ones (such as computer science education); (2) a characterization of the trends and technologies used for the development of visual programming tools; (3) an in-depth explanation of the empirical evidence used to back up the validity of the study, and (4) the discussion of open challenges and future research directions specific to visual programming tools. \n\nThis study will help the research community in the field of end-user development aiming at designing and evaluating visual programming tools. Such tools might adapt some ideas from the tools surveyed in this study, while addressing the discussed challenges and considering the suggested future research directions. \n\nThe rest of the article is organized as follows. It first gives a background of visual programming as a subset of EUD as well as its categories. Then, the article discusses the review studies in related areas. Thereafter, the study explains the methodology of this systematic literature review including the research questions.",
            "score": 0.3213007535264759,
            "section_title": "I. INTRODUCTION",
            "char_start_offset": 2088,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 224
                },
                {
                    "start": 225,
                    "end": 501
                },
                {
                    "start": 502,
                    "end": 735
                },
                {
                    "start": 738,
                    "end": 934
                },
                {
                    "start": 937,
                    "end": 1233
                },
                {
                    "start": 1236,
                    "end": 1954
                },
                {
                    "start": 1957,
                    "end": 2098
                },
                {
                    "start": 2099,
                    "end": 2271
                },
                {
                    "start": 2274,
                    "end": 2322
                },
                {
                    "start": 2323,
                    "end": 2418
                },
                {
                    "start": 2419,
                    "end": 2483
                },
                {
                    "start": 2484,
                    "end": 2601
                }
            ],
            "ref_mentions": [
                {
                    "start": 19,
                    "end": 22,
                    "matchedPaperCorpusId": "195856963"
                },
                {
                    "start": 24,
                    "end": 28,
                    "matchedPaperCorpusId": "14139027"
                },
                {
                    "start": 33,
                    "end": 37,
                    "matchedPaperCorpusId": "67770007"
                },
                {
                    "start": 256,
                    "end": 260,
                    "matchedPaperCorpusId": "67770007"
                },
                {
                    "start": 380,
                    "end": 383,
                    "matchedPaperCorpusId": "195856963"
                },
                {
                    "start": 531,
                    "end": 534,
                    "matchedPaperCorpusId": "219455753"
                },
                {
                    "start": 539,
                    "end": 543,
                    "matchedPaperCorpusId": "30037917"
                },
                {
                    "start": 1424,
                    "end": 1427,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9482421875
        },
        {
            "corpus_id": "265517097",
            "title": "BlocklyVR: Exploring Block-based Programming in Virtual Reality",
            "text": "Programming in Virtual Reality covers a plethora of programming activities, such as live programming, virtual scene creation, code comprehension, and learning. Live programming [23] provides immediate feedback on output changes and the benefits of immersion in the virtual space. For example, Castelo-Branco et al. [10] studied live programming in VR for architectural 3D models and received positive feedback from end-users. However, users found using a physical keyboard cumbersome and suggested direct manipulation techniques for code interaction, which we employed in our work. Another research direction explored the creation of virtual scenes with virtual controls. For instance, EngtangleVR [11] used a hybrid approach in which certain details of VR scenes can be edited with sliders and checkboxes within the virtual environment and the rest of the scene -with a visual-programming interface. The example of FlowMatic [77] put a visual-programming interface inside the VR scene. Users can thereby directly program the behavior of objects in the scene without taking off their VR headsets. Some projects have employed VR for program comprehension [19] that entails tracing a program flow [12] by visualizing it on a 3D spatial layout. For example, Dominic et al. [16] compared programmers' comprehension of Java code in VR with a desktop setting and found that their implementation made comprehension more difficult. In contrast, a study on ExplorViz [31], a tool for 3D-visualizing Java code in VR, demonstrated that participants solved more comprehensive tasks correctly in ExplorViz compared to browsing the textual code base, but zooming in and out of the 3D-visualization was found cumbersome. Lastly, research projects focused on learning programming in immersive spaces [37,64,67,71]. For example, Cubely [72] and VR-OCKS [60] are two block-based environments that allow the users to walk around and directly interact with the blocks instead of sitting down and interacting with a ray-cast pointer. Participants preferred Cubely over the desktop interface Blockly due to its immersiveness and two-handed interaction [72].",
            "score": 0.3213007535264759,
            "section_title": "Programming in Virtual Reality",
            "char_start_offset": 8001,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 159
                },
                {
                    "start": 160,
                    "end": 279
                },
                {
                    "start": 280,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 581
                },
                {
                    "start": 582,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 900
                },
                {
                    "start": 901,
                    "end": 986
                },
                {
                    "start": 987,
                    "end": 1096
                },
                {
                    "start": 1097,
                    "end": 1241
                },
                {
                    "start": 1242,
                    "end": 1423
                },
                {
                    "start": 1424,
                    "end": 1705
                },
                {
                    "start": 1706,
                    "end": 1798
                },
                {
                    "start": 1799,
                    "end": 2012
                },
                {
                    "start": 2013,
                    "end": 2135
                }
            ],
            "ref_mentions": [
                {
                    "start": 177,
                    "end": 181,
                    "matchedPaperCorpusId": "15034682"
                },
                {
                    "start": 315,
                    "end": 319,
                    "matchedPaperCorpusId": "220962930"
                },
                {
                    "start": 698,
                    "end": 702,
                    "matchedPaperCorpusId": "244731659"
                },
                {
                    "start": 926,
                    "end": 930,
                    "matchedPaperCorpusId": "222799772"
                },
                {
                    "start": 1195,
                    "end": 1199,
                    "matchedPaperCorpusId": "231632922"
                },
                {
                    "start": 1270,
                    "end": 1274,
                    "matchedPaperCorpusId": "221823309"
                },
                {
                    "start": 1458,
                    "end": 1462,
                    "matchedPaperCorpusId": "224900526"
                },
                {
                    "start": 1788,
                    "end": 1791,
                    "matchedPaperCorpusId": "235749806"
                },
                {
                    "start": 1791,
                    "end": 1794,
                    "matchedPaperCorpusId": "233991697"
                },
                {
                    "start": 1794,
                    "end": 1797,
                    "matchedPaperCorpusId": "248419448"
                },
                {
                    "start": 1819,
                    "end": 1823,
                    "matchedPaperCorpusId": "37365753"
                },
                {
                    "start": 1836,
                    "end": 1840,
                    "matchedPaperCorpusId": "203701301"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.865234375
        },
        {
            "corpus_id": "246022597",
            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
            "text": "Not only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
            "score": 0.3213007535264759,
            "section_title": "Introduction",
            "char_start_offset": 4515,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 108
                },
                {
                    "start": 109,
                    "end": 366
                },
                {
                    "start": 367,
                    "end": 542
                },
                {
                    "start": 543,
                    "end": 603
                },
                {
                    "start": 606,
                    "end": 692
                },
                {
                    "start": 693,
                    "end": 801
                },
                {
                    "start": 802,
                    "end": 852
                },
                {
                    "start": 853,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 1069
                },
                {
                    "start": 1070,
                    "end": 1273
                },
                {
                    "start": 1274,
                    "end": 1566
                },
                {
                    "start": 1567,
                    "end": 1688
                },
                {
                    "start": 1689,
                    "end": 1823
                },
                {
                    "start": 1824,
                    "end": 1900
                },
                {
                    "start": 1901,
                    "end": 2156
                },
                {
                    "start": 2157,
                    "end": 2205
                },
                {
                    "start": 2206,
                    "end": 2277
                }
            ],
            "ref_mentions": [
                {
                    "start": 1065,
                    "end": 1068,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1901,
                    "end": 1905,
                    "matchedPaperCorpusId": "15999236"
                },
                {
                    "start": 1908,
                    "end": 1911,
                    "matchedPaperCorpusId": "35216497"
                },
                {
                    "start": 1911,
                    "end": 1914,
                    "matchedPaperCorpusId": "221243933"
                },
                {
                    "start": 1914,
                    "end": 1917,
                    "matchedPaperCorpusId": "31119847"
                },
                {
                    "start": 2166,
                    "end": 2170,
                    "matchedPaperCorpusId": "15999236"
                },
                {
                    "start": 2173,
                    "end": 2176,
                    "matchedPaperCorpusId": "35216497"
                },
                {
                    "start": 2176,
                    "end": 2179,
                    "matchedPaperCorpusId": "221243933"
                },
                {
                    "start": 2179,
                    "end": 2182,
                    "matchedPaperCorpusId": "31119847"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97216796875
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Diagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.",
            "score": 0.3213007535264759,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 9585,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 95
                },
                {
                    "start": 96,
                    "end": 307
                },
                {
                    "start": 308,
                    "end": 374
                },
                {
                    "start": 375,
                    "end": 469
                },
                {
                    "start": 470,
                    "end": 642
                },
                {
                    "start": 645,
                    "end": 750
                }
            ],
            "ref_mentions": [
                {
                    "start": 84,
                    "end": 88,
                    "matchedPaperCorpusId": "74221"
                },
                {
                    "start": 90,
                    "end": 94,
                    "matchedPaperCorpusId": "143658620"
                },
                {
                    "start": 637,
                    "end": 641,
                    "matchedPaperCorpusId": "19780225"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97998046875
        },
        {
            "corpus_id": "264130933",
            "title": "Determining the Effectiveness of the 3D Alice Programming Environment at the Computer Science I Level",
            "text": "The motivation for changing the manner in which programming is taught in educational institutions comes from the recognition that there has been and continues to be a significant decline in the number of students entering the fields of computer science, computer engineering, and computer programming (Dann, Cooper, & Pausch, 2005;Kessler, 2005;Morris, 2004;Pausch & Conway, 2000;Tucci, 2005;Vegso, 2005). In North America numerous computer departments have reported significant drops in enrolment in their first year computer programs and are struggling to retain even a small number of students in the second and higher year levels (Kessler, 2005;Tucci, 2005;Vegso, 2005). In order to address this problem and to introduce students to a more intuitive \"objects-first\" approach to programming, Carnegie Mellon University (CMU) developed a richly-interactive 3D graphical programming development environment called Alice (Dann et al., 2005). This visual programming environment offers:\n\n\u2022 ease of construction of virtual worlds and situating subtasks to solve in this world; \u2022 a reduction in complexity of details for beginner programmers; and \u2022 visualization of objects in a 3D environment situated in a meaningful context (Dann et al., 2005).\n\nThe Alice programming environment provides a means through which students build virtual worlds where objects and their behaviours are situated in a \"real\" context (Dann et al., 2005). Alice offers the programmer a way to develop realistic 3D animations and programs that support rich interaction with the user (e.g., computer games). A brief description of the Alice environment is described below. Alice is free and is available from http://www.alice.org. Teaching materials are also free and may be found at: http://www.aliceprogramming.net.\n\nAs an example of a virtual world that can be created in Alice, consider a problem involving an interactive game in which the user drives a car for a driving test. A scene from this virtual world may look like that presented in Figure 1. In order to create and manipulate virtual worlds, Alice provides a Virtual World Editor that has numerous features. Figure 2 depicts the Virtual World Editor. In this editor, students can add 3D objects from a local or internet-based gallery of objects (bottom section) and arrange",
            "score": 0.3213007535264759,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78857421875
        },
        {
            "corpus_id": "35147680",
            "title": "Visualisation of live code",
            "text": "Generally, a programmer cannot work with their eyes closed; a programmer's text editor is a visual interface 1 . Text editors have gained many features over the last few decades, to the point where we no longer call them text editors but Interactive Development Environments (IDEs). The visual presentation of code has developed its own aesthetic; colour is used to highlight syntax, fonts have been designed for code (e.g. ProFont, proggy), and visual tools for navigating around treelike code structures. Nonetheless computation is fundamentally about symbol manipulation, and the composition of symbols lies at the heart of every IDE. When our eyes saccade across code, the shapes on the screen are categorised into these symbols, and we perceive them as the tokens (words) and statements (sentences) making up our program. The computer interprets code as a one dimensional string of discrete symbols, but humans perceive it as symbols within a spatial scene. Expert programmers may be able to chunk larger blocks of code as meaningful entities; less experienced live code audiences may become stuck on small details, but an elaborate dance of spatial change to code is evident over time. \n\nOur perception of source code is aided not only by spatial organisation, but also by colour highlighting, in-line documentation and the well chosen names given to abstractions and data structures. These features are collectively known as secondary syntax2 , being that ignored by the interpreter but of benefit to programmers in understanding and organising their code. A challenge to those pushing the boundaries of programming language design is to find ways of taking what is normally secondary syntax as primary. For example the ColorForth language uses colour as primary syntax, replacing the need for punctuation. Even more radically, the instruction set of the Piet language illustrated in Figure 2 is formed by first order colour relationships within a two dimensional grid; instructions include directional modifiers so that control flow travels in two dimensions. Piet, among many other esoteric languages, is inspired by the two dimensional syntax of Befunge shown in Fig. 1, a textual language where arrow-like characters change the direction of control flow. Some languages bordering on mainstream, such as Haskell and to a lesser extent Python have a syntax that takes two dimensional arrangement into account when grouping statements, although this is otherwise unusual.",
            "score": 0.3213007535264759,
            "section_title": "PERCEIVING CODE",
            "char_start_offset": 2123,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 112
                },
                {
                    "start": 113,
                    "end": 282
                },
                {
                    "start": 283,
                    "end": 423
                },
                {
                    "start": 424,
                    "end": 506
                },
                {
                    "start": 507,
                    "end": 637
                },
                {
                    "start": 638,
                    "end": 826
                },
                {
                    "start": 827,
                    "end": 962
                },
                {
                    "start": 963,
                    "end": 1191
                },
                {
                    "start": 1194,
                    "end": 1390
                },
                {
                    "start": 1391,
                    "end": 1563
                },
                {
                    "start": 1564,
                    "end": 1710
                },
                {
                    "start": 1711,
                    "end": 1813
                },
                {
                    "start": 1814,
                    "end": 2067
                },
                {
                    "start": 2068,
                    "end": 2265
                },
                {
                    "start": 2266,
                    "end": 2479
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6845703125
        },
        {
            "corpus_id": "209164949",
            "title": "The Development of a Visual Output Approach for Programming via the Application of Cognitive Load Theory and Constructivism",
            "text": "Among the popular visual programming language environment are Scratch and Alice which is widely used in primary and secondary schools [3], [18], [19]. In the visual programming language environments, programs are created by manipulating graphical components rather than writing textually. Creating programs is easier as there is no compilation errors and students are not required to know the syntax of a specific programming language. \n\nScratch was developed by Lifelong Kindergarten, MIT Media Lab in 2007 and is designed for students ages 8 and older. Author in [20] reports that students learning Scratch during primary school will easily learn advanced topics in high school. They don't have much trouble learning new topics and can reach a higher level of understanding for most basic concepts. As a result, some students choose to take programming courses in higher education. Students are also seen to have a high level of motivation and self-confidence. \n\nAlice is a programming environment developed by the researchers in Carnegie Mellon. Alice provides an environment where students are able to drag-and-drop objects to create animations in three-dimensional. C++/Java programs are generated automatically. In higher institution Alice is usually used as a course in parallel with Computer Science 1 (CS1) or Computer Science 0 (CS0) courses [21]. CS1 generally refers to the first computer programming course in the computer science programme while CS0 is the programming related course at the pre-university level. From this study it was found that students taking Alice courses are better compared to those who do not take Alice courses in CS1. In this case, Alice is an additional course rather than being used extensively in the CS1 programming course.",
            "score": 0.3213007535264759,
            "section_title": "B. Visual Programming Approach",
            "char_start_offset": 3691,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 150
                },
                {
                    "start": 151,
                    "end": 288
                },
                {
                    "start": 289,
                    "end": 435
                },
                {
                    "start": 438,
                    "end": 554
                },
                {
                    "start": 555,
                    "end": 680
                },
                {
                    "start": 681,
                    "end": 800
                },
                {
                    "start": 801,
                    "end": 883
                },
                {
                    "start": 884,
                    "end": 962
                },
                {
                    "start": 965,
                    "end": 1048
                },
                {
                    "start": 1049,
                    "end": 1170
                },
                {
                    "start": 1171,
                    "end": 1217
                },
                {
                    "start": 1218,
                    "end": 1357
                },
                {
                    "start": 1358,
                    "end": 1526
                },
                {
                    "start": 1527,
                    "end": 1657
                },
                {
                    "start": 1658,
                    "end": 1767
                }
            ],
            "ref_mentions": [
                {
                    "start": 139,
                    "end": 143,
                    "matchedPaperCorpusId": "27633066"
                },
                {
                    "start": 145,
                    "end": 149,
                    "matchedPaperCorpusId": "126127386"
                },
                {
                    "start": 565,
                    "end": 569,
                    "matchedPaperCorpusId": "207220407"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92724609375
        },
        {
            "corpus_id": "273147365",
            "title": "Advanced Game Engine Wizardry for Visual Programming Environments",
            "text": "Visual programming environments have the potential to make programming more accessible to programmers of all backgrounds and skill levels. Domain-Specific Languages (DSLs) empower non-programmers with notations and abstractions aimed at particular problem domains [25]. DSLs have been shown to help non-programmers raise their productivity and improve the code quality, e.g., in robotics [10], banking [20], and digital forensics [23]. We aim to support the development of visual programming environments for DSLs. Specifically, we study how to create interactive input and feedback mechanisms that bring the code to life. \n\nLanguage workbenches and meta-programming languages provide techniques and approaches that support prototyping DSLs, e.g., compilers and interpreters [5]. However, generic language technology often has limited support for creating advanced visual programming environments. As a result, creating user-friendly and aesthetically pleasing prototypes is costly and time-consuming. Language engineers need tools and techniques that accelerate the development of prototypes that are easy to deploy, maintain, and extend. \n\nGame engines have been specifically designed to create rich interactive user experiences, e.g., games, apps, and other visualizations. Using powerful tool sets, developers can easily maintain and deploy user-friendly, feature-rich visual applications across platforms. Unfortunately, language workbenches and game engines are currently separate technological spaces. Until now, the combination of this technology in generic solutions for language engineering has not yet been explored. As a result, the potential of game engines for prototyping visual editors for DSLs is still largely unknown. \n\nWe aim to bridge the gap between these technologies by automating the creation of visual programming environments using game engines. A pilot study on this topic shows that Godot in particular offers a solid foundation [2,27]. Godot comes with out-of-the-box support for C, C++, and C#, and recently JVM-based languages such as Kotlin or Java [3]. We investigate how Godot can be leveraged in generic language technology for prototyping of visual editors for DSLs. \n\nWe propose Raven, a novel meta-framework that exposes key 2D functionalities of Godot in a reusable, programmable user interface. We illustrate its potential in two ways.",
            "score": 0.3213007535264759,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 138
                },
                {
                    "start": 139,
                    "end": 269
                },
                {
                    "start": 270,
                    "end": 435
                },
                {
                    "start": 436,
                    "end": 514
                },
                {
                    "start": 515,
                    "end": 622
                },
                {
                    "start": 625,
                    "end": 779
                },
                {
                    "start": 780,
                    "end": 897
                },
                {
                    "start": 898,
                    "end": 1001
                },
                {
                    "start": 1002,
                    "end": 1139
                },
                {
                    "start": 1142,
                    "end": 1276
                },
                {
                    "start": 1277,
                    "end": 1410
                },
                {
                    "start": 1411,
                    "end": 1508
                },
                {
                    "start": 1509,
                    "end": 1627
                },
                {
                    "start": 1628,
                    "end": 1736
                },
                {
                    "start": 1739,
                    "end": 1872
                },
                {
                    "start": 1873,
                    "end": 1965
                },
                {
                    "start": 1966,
                    "end": 2086
                },
                {
                    "start": 2087,
                    "end": 2203
                },
                {
                    "start": 2206,
                    "end": 2335
                },
                {
                    "start": 2336,
                    "end": 2376
                }
            ],
            "ref_mentions": [
                {
                    "start": 264,
                    "end": 268,
                    "matchedPaperCorpusId": "264769167"
                },
                {
                    "start": 402,
                    "end": 406,
                    "matchedPaperCorpusId": "14922174"
                },
                {
                    "start": 430,
                    "end": 434,
                    "matchedPaperCorpusId": "7011074"
                },
                {
                    "start": 1961,
                    "end": 1964,
                    "matchedPaperCorpusId": "264307073"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93359375
        },
        {
            "corpus_id": "9455741",
            "title": "Modeling Creativity: Case Studies in Python",
            "text": ". In 2005 Reas and Fry received the prestigious Golden Nica award for their work. Processing is based on the Java 2D graphics library and influenced by technologies such as PostScript and OpenGL. This work has in turn led to the development of Wiring, a Processing spin-off for electronics, and Arduino, a microcontroller chip designed \"to make things talk\" in interdisciplinary projects (Igoe, 2007). It is interesting to note how derivatives of DBN are reminiscent of Maeda's initial goal -achieving simplicity in the digital age (Maeda, 2006). Processing describes itself as a \"sketchbook\" for programming, using combinations of simple commands such as line() and rotate(). Wiring is \"thoughtfully created with designers and artists in mind\" 9 (i.e., a non-technical audience) and openFrameworks is intended for \"folks using computers for creative, artistic expression\" 10 . DrawBot and its derivative NodeBox adopt the Python programming language, which arguably has simpler syntax than Java (no curly braces or semicolons).\n\nSecond, there is not much room for abstraction: users will tend to think along the lines of what is possible with the built-in features (buttons, sliders, menus) and not about what they want (Cleveland, 2004). These limitations are mitigated when users can freely combine any kind of functionality in the form of programming code. For beginners, it is often helpful to explain this paradigm in terms of a cooking recipe: RECIPE We can think of programming code as a recipe, a set of instructions that describes how to prepare or make something.\n\nINGREDIENTS Any kind of functionality can freely be combined in programming code. Compared to a prepackaged dinner (i.e, buttons and sliders) you have to do a bit of work but you can do it any way you want, mixing any ingredients you like.\n\nCOOKBOOK Programming code is written down. It captures the creation process, as opposed to mouse gestures, and as such can be reused, adapted, shared and studied.  In recent years, effort appears to focus on JavaScript visualization toolkits such as WebGL and Processing.js. JavaScript is a programming language that is commonly used in web pages. As such, these visualization toolkits are directly available in the",
            "score": 0.3211757253660561,
            "section_title": "OPEN SOURCE",
            "char_start_offset": 50544,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1221,
                    "end": 1238,
                    "matchedPaperCorpusId": "62589642"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.331298828125
        },
        {
            "corpus_id": "42407428",
            "title": "Give the people what they want: studying end-user needs for enhancing the web",
            "text": "Over the last decade, researchers and companies have developed a large number of EUP systems for the Web (WebEUP). Those WebEUP tools commonly took a combination of three approaches: scripting, visual programming, and inductive programming including programming-by-demonstration (Cypher et al., 1993) and programming-by-example (Lieberman, 2001). First, scripting languages for WebEUP (Bolin et al., 2005;Leshed et al., 2008; https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/) offer natural and domain-specific commands instead of machine-oriented general-purpose syntax of traditional languages such as C or Java. However, end-users of script languages still need to memorize commands and type accurate details. In order to make programming more accessible to users without programming expertise, EUP systems often employ visual programming techniques including drag-and-drop for organizing graphical widgets of operations, and flowcharts showing program structure (Wong & Hong, 2007;Cameron & Churchill, 2009). While visual programming techniques make programming more intuitive, they are usually less expressive and scalable than scripting languages. \n\nRecent work employs inductive program synthesis techniques-such as programmingby-example and demonstration (Cypher et al., 1993;Gulwani, 2010;Rinard, 2012)that enable end-users to express their needs via demonstrations and examples of what they are trying to accomplish, and the systems generate programs that are consistent with the examples. Such programs include string manipulation (Gulwani, 2011), text processing (Yessenov et al., 2013), and geometric drawing (Cheema, Gulwani & LaViola, 2012). Especially for the Web, the ''Reform'' system (Toomim et al., 2009) enables end-users to attach UI enhancements to arbitrary sites by selecting a few elements on the page. One approach (Nichols & Lau, 2008) enabled end users to re-author a simplified mobile version of web applications by demonstrating the task and directly choosing page elements. Another system (Mac\u00edas & Fabio, 2008) allowed users to modify the source code of a web page, and then created a generalized modification of similar pages.",
            "score": 0.31994681928238367,
            "section_title": "End-user programming on the web",
            "char_start_offset": 5303,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 114
                },
                {
                    "start": 115,
                    "end": 346
                },
                {
                    "start": 347,
                    "end": 487
                },
                {
                    "start": 488,
                    "end": 625
                },
                {
                    "start": 626,
                    "end": 723
                },
                {
                    "start": 724,
                    "end": 1023
                },
                {
                    "start": 1024,
                    "end": 1164
                },
                {
                    "start": 1167,
                    "end": 1510
                },
                {
                    "start": 1511,
                    "end": 1667
                },
                {
                    "start": 1668,
                    "end": 1839
                },
                {
                    "start": 1840,
                    "end": 2016
                },
                {
                    "start": 2017,
                    "end": 2171
                }
            ],
            "ref_mentions": [
                {
                    "start": 279,
                    "end": 300,
                    "matchedPaperCorpusId": "106672214"
                },
                {
                    "start": 385,
                    "end": 405,
                    "matchedPaperCorpusId": "13974578"
                },
                {
                    "start": 405,
                    "end": 425,
                    "matchedPaperCorpusId": "5989563"
                },
                {
                    "start": 977,
                    "end": 996,
                    "matchedPaperCorpusId": "795921"
                },
                {
                    "start": 996,
                    "end": 1022,
                    "matchedPaperCorpusId": "18613203"
                },
                {
                    "start": 1274,
                    "end": 1295,
                    "matchedPaperCorpusId": "106672214"
                },
                {
                    "start": 1309,
                    "end": 1322,
                    "matchedPaperCorpusId": "5804148"
                },
                {
                    "start": 1586,
                    "end": 1609,
                    "matchedPaperCorpusId": "9869498"
                },
                {
                    "start": 1633,
                    "end": 1666,
                    "matchedPaperCorpusId": "9137334"
                },
                {
                    "start": 1714,
                    "end": 1735,
                    "matchedPaperCorpusId": "304701"
                },
                {
                    "start": 1853,
                    "end": 1874,
                    "matchedPaperCorpusId": "14877395"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6591796875
        },
        {
            "corpus_id": "1063008",
            "title": "A General Framework for Overlay Visualization",
            "text": "Researchers have found that on problem-solving transfer tasks [10] animation with narration outperforms animation only, narration only, or narration before animation. Similarly, on recall tasks, narration with visual presentation outperforms narration before visual presentation [1]. These results support a dual-coding hypothesis [13] that suggests two types of connections among stimuli and representations: representational connections between stimuli and the corresponding representations (verbal and visual), and referential connections between verbal and visual representations. \n\nWhat if visual presentation is superimposed on narration? In programming problems, what if visual presentation is superimposed on the program code? We conjecture that this will promote better referential connections between visual and verbal representations and result in better transfer from visual representation to the concepts being learned. To support such visualization, we have developed a framework of what we will henceforth refer to as overlay visualization. \n\nOverlay Visualization is the superimposition of graphics on the material to be visualized. In the context of programming, it is superimposing graphics on code. We will first describe a general framework for overlay visualization in section 2. Next, in section 3, we will discuss some applications of overlay visualization for program visualization. We will illustrate with examples from our implementation of overlay visualization for programming tutors called problets (www.problets.org) [6]. In section 4, we will present the current implementation. Finally in section 5, we will discuss the advantages of overlay visualization and compare it with prior work.",
            "score": 0.3196347652910029,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 283
                },
                {
                    "start": 284,
                    "end": 584
                },
                {
                    "start": 587,
                    "end": 644
                },
                {
                    "start": 645,
                    "end": 734
                },
                {
                    "start": 735,
                    "end": 932
                },
                {
                    "start": 933,
                    "end": 1055
                },
                {
                    "start": 1058,
                    "end": 1148
                },
                {
                    "start": 1149,
                    "end": 1217
                },
                {
                    "start": 1218,
                    "end": 1406
                },
                {
                    "start": 1407,
                    "end": 1546
                },
                {
                    "start": 1547,
                    "end": 1551
                },
                {
                    "start": 1552,
                    "end": 1609
                },
                {
                    "start": 1610,
                    "end": 1719
                }
            ],
            "ref_mentions": [
                {
                    "start": 62,
                    "end": 66,
                    "matchedPaperCorpusId": "145786614"
                },
                {
                    "start": 279,
                    "end": 282,
                    "matchedPaperCorpusId": "202239842"
                },
                {
                    "start": 1547,
                    "end": 1550,
                    "matchedPaperCorpusId": "9015928"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.60009765625
        },
        {
            "corpus_id": "5015407",
            "title": "Teaching GUI-Programming Concepts to Prospective K12 ICT Teachers: MIT App Inventor as an Alternative to Text-Based Languages",
            "text": "These enable the developer to create programming expressions by combining through -drag and drop\u2016 or other GUI actions blocks that visually represent programming constructs, as opposed to using text to form expressions in the conventional -text-based\u2016 approach. \n\nAlthough the original purpose of this approach to programming has been to create easier and more practical means for the end-users to develop software applications (Mohamad et al., 2011) there have been researchers claiming that blocks-based visual languages may be used as educational tools in programming (Navarro-Prieto & Ca\u00f1as, 2001) and that they may be beneficial especially for novice students (Maloney, Resnick, Rusk, Silverman, & Eastmond, 2010). In fact, the programming blocks approach have been considered to be such a great way to simplify programming that, there even exists research that aims to teach programming concepts to young children by employing physically tangible blocks (Horn & Jacob, 2006;McNerney, 2004;Wang, Zhang, & Wang, 2011;Wyeth & Purchase, 2002). The main advantage to blocks-based visual programming is that textual syntax, which may largely differ from one programming language to the other, has been replaced with universal blocks that interact with each other only in meaningful ways, much like pieces of a puzzle, leaving less room for error. This enables novices to practice the semantics instead of syntax, lets them code in elements that display a higher-level fashion resembling pseudo-code, eliminates the need to -memorize\u2016 textual code constructs (which is especially the problem in students that do not have English as their mother tongue), while avoiding typing mistakes and type errors in general (Klassen, 2006). However, it should also be noted that blocks-based visual languages that have been used in education so far have mostly been prepared for a target audience of younger age levels in mind (Kelleher, Pausch, & Kiesler, 2007;Utting, Cooper, K\u00f6lling, Maloney, & Resnick, 2010). As such, the idea of using blocks-based visual languages to aid the education of adults in programming has not been encountered often in the literature, at least for a certain period.",
            "score": 0.31815208617474316,
            "section_title": "Introduction",
            "char_start_offset": 3816,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 261
                },
                {
                    "start": 264,
                    "end": 719
                },
                {
                    "start": 720,
                    "end": 1045
                },
                {
                    "start": 1046,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1727
                },
                {
                    "start": 1728,
                    "end": 2000
                },
                {
                    "start": 2001,
                    "end": 2184
                }
            ],
            "ref_mentions": [
                {
                    "start": 428,
                    "end": 450,
                    "matchedPaperCorpusId": "5674825"
                },
                {
                    "start": 571,
                    "end": 601,
                    "matchedPaperCorpusId": "16771725"
                },
                {
                    "start": 665,
                    "end": 718,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 995,
                    "end": 1021,
                    "matchedPaperCorpusId": "565775"
                },
                {
                    "start": 1021,
                    "end": 1044,
                    "matchedPaperCorpusId": "59857513"
                },
                {
                    "start": 1711,
                    "end": 1726,
                    "matchedPaperCorpusId": "5181040"
                },
                {
                    "start": 1914,
                    "end": 1949,
                    "matchedPaperCorpusId": "3910027"
                },
                {
                    "start": 1949,
                    "end": 1999,
                    "matchedPaperCorpusId": "17911112"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92041015625
        },
        {
            "corpus_id": "234144988",
            "title": "Micro: Bit as a Tool for Improvement of Education",
            "text": "I understand the instructions of a visual programming language and can predict the outcome of a program written using the language. I understand how computers process information.",
            "score": 0.31815208617474316,
            "section_title": "First",
            "char_start_offset": 2874,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 131
                },
                {
                    "start": 132,
                    "end": 179
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51416015625
        },
        {
            "corpus_id": "252233721",
            "title": "A case study of the integration of Algorithm Visualizations in Hungarian programming education",
            "text": "In this study, I will introduce how Algorithm Visualizations (AV) can help programming education or, in this case, the acquisition of basic programming theorems. I used two di erent methods to test this: in the first round, I examined in a larger group how much the students' ability to solve specific tasks changes after being introduced to a visualization tool, and then, what was their motivation and experience during this process. In the second round, I looked for the components that could be important when choosing a tool with the help of an in-depth interview with a smaller number of individuals. In both cases, I describe the research, experience, and results of the study, and then summarize them at the end. \nSubject Classification: 97P10",
            "score": 0.31815208617474316,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.49560546875
        },
        {
            "corpus_id": "214286175",
            "title": "Immersive Algorithmic Design Live Coding in Virtual Reality",
            "text": "The creation of a workflow for programming in VR has been attempted by Elliot et al. (2015) with the RiftSketch project, and by Robert Krahn with CodeChisel3D [2]. Both tools offer a LC environment built for VR, with text editors floating in the scene for users to code in. Nevertheless, both solutions were only tested with simple graphical models and they were not applied in an architectural context. \n\nIn the architectural context, having the code displayed alongside the model in the VE allows professionals to change their models at will without taking their HMD off or leaving the VE. By transporting the programming environment to the VE we can have architects, and clients for that matter, inside the virtual representation of the projects, developing the algorithmic descriptions of the models, applying changes and visualizing them, in real time.",
            "score": 0.31815208617474316,
            "section_title": "PROGRAMMING IN VIRTUAL REALITY",
            "char_start_offset": 6316,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 163
                },
                {
                    "start": 164,
                    "end": 273
                },
                {
                    "start": 274,
                    "end": 403
                },
                {
                    "start": 406,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 857
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.53759765625
        },
        {
            "corpus_id": "277634411",
            "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
            "text": "Visual Programming [10,27] is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code [20]. Recently, several works have attempted to leverage the interpretability of visual programming, such as VPD [12], which simplifies multimodal learning by distilling tool use and programmatic reasoning into smaller models and Define [9] reimagines visual programming as a task of modular programming and optimization through feedback. \n\nInspired by these works, we further considered treating the execution process of code and its intermediate variables as a CoT decision sequence. The advantage of using programs as CoT in SVIP is evident: code is inherently verifiable and evaluable. Fact [8] eliminates redundant elements through static analysis of Python code's AST and converts them into natural language CoT, while PropTest [13] generates test code to validate the answers. These works provide a solid backbone for us-we can transform the evaluation of CoT steps into the evaluation of code, thereby addressing the challenge of evaluating CoT steps in natural language.",
            "score": 0.31815208617474316,
            "section_title": "Visual Programming as Decision Sequence",
            "char_start_offset": 9524,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 620
                },
                {
                    "start": 623,
                    "end": 767
                },
                {
                    "start": 768,
                    "end": 871
                },
                {
                    "start": 872,
                    "end": 1065
                },
                {
                    "start": 1066,
                    "end": 1261
                }
            ],
            "ref_mentions": [
                {
                    "start": 19,
                    "end": 23,
                    "matchedPaperCorpusId": "253734854"
                },
                {
                    "start": 23,
                    "end": 26,
                    "matchedPaperCorpusId": "257505358"
                },
                {
                    "start": 282,
                    "end": 286,
                    "matchedPaperCorpusId": "258212542"
                },
                {
                    "start": 395,
                    "end": 399,
                    "matchedPaperCorpusId": "265693898"
                },
                {
                    "start": 519,
                    "end": 522,
                    "matchedPaperCorpusId": "265351923"
                },
                {
                    "start": 877,
                    "end": 880,
                    "matchedPaperCorpusId": "269188197"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.953125
        },
        {
            "corpus_id": "15432848",
            "title": "The Design of EzWindows: A Graphics API for an Introductory Programming Course",
            "text": "This paper has described the rationale and design of EzWindows-a graphics API for a beginning object-oriented programming course. EzWindows has proven to be extremely popular. Its popularity is due to several factors. While simple to use, EzWindows allows beginning students to build surprisingly polished programs. This power helps motivate the students. Its O-O implementation serves as an excellent case study for students who had used it. It is platform and compiler independent. Finally, to the best of our knowledge it is the first graphics package that allows beginning programmers to use the mouse as an input device that they control.",
            "score": 0.31815208617474316,
            "section_title": "Summary",
            "char_start_offset": 15612,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 217
                },
                {
                    "start": 218,
                    "end": 315
                },
                {
                    "start": 316,
                    "end": 355
                },
                {
                    "start": 356,
                    "end": 442
                },
                {
                    "start": 443,
                    "end": 483
                },
                {
                    "start": 484,
                    "end": 643
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2047119140625
        },
        {
            "corpus_id": "44123962",
            "title": "Using Elm to Introduce Algebraic Thinking to K-8 Students",
            "text": "Our Graphics library, GraphicSVG, is based on the original Elm Graphics module which targeted HTML canvas elements, and it is partially backwards compatible. GraphicSVG's principal types (Stencil, Shape and Collage) model real-world concepts: Stencil describes a recipe for creating a shape; for example, a circle with a certain radius, a rectangle with a width and height or text with a certain font and size: \n\nBut, like a real-life stencil, a visible shape is not created until the user fills it in or traces its edge: \n\nThus, a concrete analogy explains why shapes cannot show up on the screen unless they are filled or outlined. This architecture limits the number of parameters each function takes, making them easy to learn or even guess, and the types match students intuition closely enough that we do not have to talk about them. The limited number of arguments also make it easy to put all the basic functions in an interactive crib sheet (Figure 1). The types Stencil and Shape are introduced to students orally and we use the structure of the ShapeCreator to reinforce this. We do not use type signatures, but students see the type names in compiler errors, e.g., when they try to move a Stencil rather than a Shape. They never use constructors for these types directly, using exposed functions instead, some of which simplify the underlying type construction. Fortunately, Elm's type errors (e.g. found a Stencil where a Shape was expected) also match their intuitive understanding of these types, and need little explanation, and, so far, students who choose to attempt more complicated user interaction are able to build a workable understanding of Elm types from there. (See the last section to learn how we plan to use types as a teaching tool in the future.) Figure 1: ShapeCreator: As a consequence of GraphicSVG's design, we were able to expose the combinatorial nature of shape construction in an interactive tool for API discovery.",
            "score": 0.31815208617474316,
            "section_title": "GraphicSVG",
            "char_start_offset": 14817,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 410
                },
                {
                    "start": 413,
                    "end": 521
                },
                {
                    "start": 524,
                    "end": 633
                },
                {
                    "start": 634,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 961
                },
                {
                    "start": 962,
                    "end": 1087
                },
                {
                    "start": 1088,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1373
                },
                {
                    "start": 1374,
                    "end": 1410
                },
                {
                    "start": 1411,
                    "end": 1686
                },
                {
                    "start": 1687,
                    "end": 1777
                },
                {
                    "start": 1778,
                    "end": 1954
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1614990234375
        },
        {
            "corpus_id": "201886175",
            "title": "Vision system in quality control automation",
            "text": "A graphical-based language allows the user to work directly with graphics. A project is a collection of files that makes the user program. They may consist of form, modules, and active x controls [8]. \n\nThe visual basic software version 6 is used as a graphical user interface. Firstly when the software is opened it asks for new project. Standard EXE is opted and option open is clicked. A form window is opened. In the form window, text boxes, labels, command buttons, picture boxes are created. Properties of all the created icons are set according to the requirement. Double click on the particular icon allow us to write the code. For this project, area of the co-ordinates is specified to find the surface roughness. In the particular area of the co-ordinates, maximum and minimum pixel values are extracted. Minimum pixel value is assigned to the text11.text and maximum value is assigned to the text12.text. These maximum and minimum values are used to find the intensity factor of the component. Text1.text is assigned to the intensity factor formula. If the text1.text value is less than the 0.5 then the PC give the message to microcontroller to deliver the component in the delivery end. If the text1.text value is greater than the 0.5 then the PC give the message to microcontroller to deliver the component in the grinding end. At the same time surface roughness of the component is picked corresponding to intensity factor value and is displayed in the GUI. The Graph of intensity factor versus surface roughness is also displayed.",
            "score": 0.31815208617474316,
            "section_title": "Graphical User Interface",
            "char_start_offset": 7468,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 74
                },
                {
                    "start": 75,
                    "end": 138
                },
                {
                    "start": 139,
                    "end": 200
                },
                {
                    "start": 203,
                    "end": 277
                },
                {
                    "start": 278,
                    "end": 338
                },
                {
                    "start": 339,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 413
                },
                {
                    "start": 414,
                    "end": 497
                },
                {
                    "start": 498,
                    "end": 571
                },
                {
                    "start": 572,
                    "end": 635
                },
                {
                    "start": 636,
                    "end": 722
                },
                {
                    "start": 723,
                    "end": 814
                },
                {
                    "start": 815,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 915
                },
                {
                    "start": 916,
                    "end": 1004
                },
                {
                    "start": 1005,
                    "end": 1060
                },
                {
                    "start": 1061,
                    "end": 1078
                },
                {
                    "start": 1079,
                    "end": 1199
                },
                {
                    "start": 1200,
                    "end": 1217
                },
                {
                    "start": 1218,
                    "end": 1341
                },
                {
                    "start": 1342,
                    "end": 1472
                },
                {
                    "start": 1473,
                    "end": 1546
                }
            ],
            "ref_mentions": [
                {
                    "start": 196,
                    "end": 199,
                    "matchedPaperCorpusId": "60146225"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.17529296875
        },
        {
            "corpus_id": "268272915",
            "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
            "text": "LabVIEW, short for Laboratory Virtual Instrument Engineering Workbench, is a visual programming environment commonly used in measurement, automation, or control applications. Unlike traditional text-based programming languages, LabVIEW utilizes a graphical data flow programming paradigm where the code is represented in the form of interconnected graphical elements called virtual instruments, denoted as VIs, that can be perceived as functions or subroutines in conventional programming languages. The abstract syntax is typically represented as a data flow graph or a block diagram, where each VI or block is a self-contained unit of code or a native function. The execution of the program is then conceptualized as a flow of data, where variables are propagated via the wires through a sequential series of connected functions, which execute as soon as all data is available on the inputs. \n\nThe core of each VI is divided into two interdependent parts: the front panel, which represents the user interface, and the block diagram, i.e., the code, responsible for the program's logic and functionality. The visual representation of both parts of a simple part of a code is demonstrated in Fig 1. \n\nIf we analyze this part of the code from the programmer's viewpoint, the created method in LabVIEW carries the name add_pi and has one numeric input as a parameter. The output of this function is then an input value increased by the value of \u03c0. However, in a much deeper sense of the language, the created program contains four basic objects (two input objects, a function, and an output), where each object is represented by a specific icon in the block diagram. These objects can be considered instances of objects in object-oriented programming, and therefore each of the four elements contains its own private data and methods (such as captions, labels, or set-value methods). Since every single object inserted in the block diagram is a child of a prime class called LabVIEW Object, each element created in the block diagram and also on the front panel is a child of this class. Hence, if we are able to refer to any object by using a pointer, we can also programmatically change its publicly accessible data or invoke its publicly accessible methods. It is also possible to get this reference through all objects contained in the data of our \"main\" object, which is our program.",
            "score": 0.31815208617474316,
            "section_title": "Labview development environment language syntax",
            "char_start_offset": 9164,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 174
                },
                {
                    "start": 175,
                    "end": 499
                },
                {
                    "start": 500,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 893
                },
                {
                    "start": 896,
                    "end": 1105
                },
                {
                    "start": 1106,
                    "end": 1198
                },
                {
                    "start": 1201,
                    "end": 1365
                },
                {
                    "start": 1366,
                    "end": 1445
                },
                {
                    "start": 1446,
                    "end": 1664
                },
                {
                    "start": 1665,
                    "end": 1881
                },
                {
                    "start": 1882,
                    "end": 2084
                },
                {
                    "start": 2085,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2385
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7666015625
        },
        {
            "corpus_id": "270218725",
            "title": "Understanding On-the-Fly End-User Robot Programming",
            "text": "Many programs written today do not rely entirely on professional programmers or roboticists [e.g., 23,30,38,47,71].Instead, end users with discrete domain expertise drive software development, specifically by contributing to obtaining a complete and consistent set of system requirements [37,68].Thus, seminal work in the software engineering field [e.g., 7,38] provides pointers on how to facilitate end-user specification, particularly at the exploratory phase [28] of the software lifecycle.Dialogue is an accessible paradigm for rapid prototyping based on its use in daily human communication [1].Porfirio et al. [50] proposed an approach that utilized speech gathered from \"role-playing\" to synthesize human-robot interaction scenarios.Within the end-user specification frame, visual programming interfaces are frequently utilized.Flow-based visual interfaces allow users to conceptualize programs as processes [72].In RoboFlow [2], edits to default programs can be easily made with the assistance of a flow-based visual expression.\n\nDisplay of readily distinguishable domain-specific operation units to end users has proven successful when deployed on a visual interface.The system implemented and evaluated by Senft et al. [59] only exposes the graphical representation of the task-level (high-level) actions to the user, which in turn allowed effective teleoperation of users for individuals with varying levels of expertise.More recently, deep learning and large-language modeling (LLM) methods are gaining attention for \"prompt-based prototyping\" [e.g., 5,35].ChatGPT (GPT-3.5 and GPT-4 [48]) and its related work [e.g., 9,49] serve as distinct use cases where the representation format of question-answer pairs closely resemble that of interpersonal communication, borrowing dynamics of turn-taking.",
            "score": 0.31809594140296127,
            "section_title": "Approaches to End-user Specification",
            "char_start_offset": 1610,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 115,
                    "end": 296
                },
                {
                    "start": 296,
                    "end": 494
                },
                {
                    "start": 494,
                    "end": 601
                },
                {
                    "start": 601,
                    "end": 741
                },
                {
                    "start": 741,
                    "end": 836
                },
                {
                    "start": 836,
                    "end": 921
                },
                {
                    "start": 921,
                    "end": 1037
                },
                {
                    "start": 1039,
                    "end": 1177
                },
                {
                    "start": 1177,
                    "end": 1433
                },
                {
                    "start": 1433,
                    "end": 1570
                },
                {
                    "start": 1570,
                    "end": 1810
                }
            ],
            "ref_mentions": [
                {
                    "start": 99,
                    "end": 102,
                    "matchedPaperCorpusId": "938801"
                },
                {
                    "start": 102,
                    "end": 105,
                    "matchedPaperCorpusId": "46225607"
                },
                {
                    "start": 105,
                    "end": 108,
                    "matchedPaperCorpusId": "128364433"
                },
                {
                    "start": 108,
                    "end": 111,
                    "matchedPaperCorpusId": "27027620"
                },
                {
                    "start": 111,
                    "end": 114,
                    "matchedPaperCorpusId": "795921"
                },
                {
                    "start": 288,
                    "end": 292,
                    "matchedPaperCorpusId": "18462889"
                },
                {
                    "start": 292,
                    "end": 295,
                    "matchedPaperCorpusId": "5754137"
                },
                {
                    "start": 356,
                    "end": 358,
                    "matchedPaperCorpusId": "67770007"
                },
                {
                    "start": 358,
                    "end": 361,
                    "matchedPaperCorpusId": "128364433"
                },
                {
                    "start": 463,
                    "end": 467,
                    "matchedPaperCorpusId": "12507561"
                },
                {
                    "start": 597,
                    "end": 600,
                    "matchedPaperCorpusId": "233739950"
                },
                {
                    "start": 617,
                    "end": 621,
                    "matchedPaperCorpusId": "204812000"
                },
                {
                    "start": 916,
                    "end": 920,
                    "matchedPaperCorpusId": "207224165"
                },
                {
                    "start": 933,
                    "end": 936,
                    "matchedPaperCorpusId": "6019483"
                },
                {
                    "start": 1230,
                    "end": 1234,
                    "matchedPaperCorpusId": "237421166"
                },
                {
                    "start": 1566,
                    "end": 1569,
                    "matchedPaperCorpusId": "248419856"
                },
                {
                    "start": 1633,
                    "end": 1636,
                    "matchedPaperCorpusId": "267511688"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.345703125
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "One of the characteristics of visual programming is programming in more the one dimension. One of the available dimensions for PWCT users is the time dimension where the programmer can move forward/backward during the application construction process and the programmer can run the application at any point on the time dimension to test the programmer before or after adding a step to the steps tree. This can be done easily using a slider control available in the Goal/Module Designer. PWCT is a hybrid system where we can design programs visually without writing source code by hand but we still can see the generated textual source code which is generated and managed in the background.\n\nWe can see the textual source code behind each step in the goal designer and we can get the source code behind all the steps when we run the application or using a utility comes with PWCT and called the Code Extractor application. PWCT Contains a tool called the Goal/Module Viewer which contains some of the features available through the goal designer but enable the programmer to work with more than one step at the same time where each node in the steps tree contains a checkbox for selecting the step.\n\nUsing checkboxes more than one step can be selected then we can do different operations of the selected steps like (Cut, Copy, Insert, Delete , Move Up, Move Down and Enable/Disable). When you open any project/application developed using PWCT and instead of looking at the design to see how to create like this program, simply you can see a movie that teach you how to design the program using PWCT step by step To do that from the Goal/Module designer press The Time Machine button then select the item (Play as Movie from the first time frame).\n\nThen the steps will disappear from the Goal/Module designer and you will see how every step will be added by selecting the required component then entering the data to the interaction pages.\n\nThis feature reduces the need for sample documentation because every sample developed using PWCT is a movie that can be played.\n\nAlso this feature help in program understanding where the program can use this feature and keep watching instead of manually moving through the visual representation  Table 14 we see the students' progress in learning PWCT through the free remote learning course. The first column in the table represent the student ID (instead of the student name) and the second column contains the number",
            "score": 0.31799825558419087,
            "section_title": "A.5 The Time Dimension",
            "char_start_offset": 86564,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93359375
        },
        {
            "corpus_id": "214243289",
            "title": "VB2ALGO: An Educational Reverse Engineering Tool to Enhance High School Students\u2019 Learning Capacities in Programming",
            "text": "An educational software assessment tool, VB2ALGO, for a visual programming course has been developed and the effects of it on the high school students\u2019 performances, motivation and cognitive skills were explored. The tool inherits algorithm visualization technique together with reverse engineering approach; it takes the visual basic source code as an input and generates pseudocode and flowchart as an output. First, an experimental research methodology was applied, whereby pre-tests and post-tests were conducted to estimate the effect of using the software tool on student performances towards learning visual programming course. Then, the effect of the tool on students\u2019 motivation and cognitive skills were measured with students\u2019 questionnaires. Finally, teachers\u2019 class management skills were investigated with teachers\u2019 questionnaires in terms of time-management for better teaching experiences. The experiment was carried out with 294 students from 4 different high schools which had divided into experimental group and control groups. Parametric statistical tests were applied and results showed that the use of software tool reveals better performances for the experimental group as compared to the control group. In addition, the results of the students\u2019 questionnaires confirmed an increment in students' motivation and cognitive skills in programming language classes as compared to the traditional class. It also results in the improvement of students' learning capacities and knowledge about programming concepts. Finally, results of the teachers\u2019 quantitative analysis outlined that use of the software tool encourages teachers to complete more examples inside the classroom with better time management.",
            "score": 0.31624148845093086,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.73095703125
        },
        {
            "corpus_id": "270526114",
            "title": "Mirror, Mirror, on The Wall, How Do We Measure What Our Students do in Scratch Programming?",
            "text": "Scratch is a visual programming language primarily designed for education. It uses a blockbased system, allowing users to create applications by combining visual components such as images, sounds, and videos with scripted functionalities. The logic of these applications is defined by assembling pre-defined blocks, similar to building with Lego bricks (Ford (Jr.), 2014; Stewart & Baek, 2023). Each block represents a specific command or action, guiding the application through various tasks. Additionally, Scratch provides a wide range of media resources, including graphics and sound effects, as well as features for designing personalized graphical and audio elements (Ford (Jr.), 2014). It offers a comprehensive environment that empowers users of all ages (Stewart & Baek, 2023). The intuitive visual programming language removes barriers, allowing beginners to easily dive into application development and receive immediate feedback on their creations (Ford (Jr.), 2014). This fosters a hands-on learning experience that helps users grasp fundamental programming concepts (Rose et al., 2017). \n\nBeyond being a programming language, Scratch is also a valuable pedagogical tool when integrated into different subject areas and learning environments (Stewart & Baek, 2023;Voinohovska & Doncheva, 2021;Resnick & Rusk, 2020). According to the study by Silva et al. (2022), integrating Scratch into mathematics education enhances the teaching and learning process. This approach promotes a more meaningful, creative, and playful learning experience, as reported by four Mathematics undergraduate students from a Federal Public Institution in the Midwest. In a pilot project conducted by Naz et al (2017), the effectiveness of Scratch programming in K-12 classrooms was investigated. The project aimed to support nineteen K-12 teachers from middle and high schools with no prior programming experience. \n\nThe teachers received training in a \"hybrid format\" that combined face-to-face and online training. Pre-and post-assessments revealed a significant improvement in students' performance when utilizing Scratch programming. Furthermore, Bahar's (2021) study explored the integration of Scratch, a visual programming language, into language teaching for children. The study aimed to assess its impact on language development and cognitive skills, as well as identify benefits and challenges from the perspectives of students and teachers.",
            "score": 0.31503165799208427,
            "section_title": "Literature Review Scratch Programming",
            "char_start_offset": 3884,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 74
                },
                {
                    "start": 75,
                    "end": 238
                },
                {
                    "start": 239,
                    "end": 394
                },
                {
                    "start": 395,
                    "end": 493
                },
                {
                    "start": 494,
                    "end": 691
                },
                {
                    "start": 692,
                    "end": 785
                },
                {
                    "start": 786,
                    "end": 978
                },
                {
                    "start": 979,
                    "end": 1099
                },
                {
                    "start": 1102,
                    "end": 1327
                },
                {
                    "start": 1328,
                    "end": 1465
                },
                {
                    "start": 1466,
                    "end": 1655
                },
                {
                    "start": 1656,
                    "end": 1783
                },
                {
                    "start": 1784,
                    "end": 1902
                },
                {
                    "start": 1905,
                    "end": 2004
                },
                {
                    "start": 2005,
                    "end": 2125
                },
                {
                    "start": 2126,
                    "end": 2264
                },
                {
                    "start": 2265,
                    "end": 2439
                }
            ],
            "ref_mentions": [
                {
                    "start": 1276,
                    "end": 1305,
                    "matchedPaperCorpusId": "233772013"
                },
                {
                    "start": 1354,
                    "end": 1373,
                    "matchedPaperCorpusId": "253005339"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.869140625
        },
        {
            "corpus_id": "15385453",
            "title": "Predictive modelling for HCI problems in novice program editors",
            "text": "Programming education is highly topical, and there are several actively-developed novice programming tools that have been widely used, and cited in the literature. These range from child-user \"block\" building systems (like Scratch) to Greenfoota Java game-based development tool used in schools -to \"pure\" visual programming systems, based on flow-chart-style diagrams (such as Lego Mindstorms). There are other systems that sit between the above, such as Alice, StarLogo TNG, and numerous other variations on the \"block\" metaphor. \n\nThere are also \"mainstream\" programming languages that are judged to be the simplest of their kind, used to teach beginners (such as Python, Java, or variants of Basic). All of these systems look, superficially, very differentthey range from toy-like graphics, to monospace text, to complex flow diagrams and lines. However, there are interactions that are common to several of the differently-styled editor types, and there are also systems that look similar, but behave very differently in terms of interaction design. In this paper, we extend previous cognitive modelling work to four new programming systems (McKay 2012). The initial goal of that study was to compare several \"benchmark\" systems to a new editor in development, as part of the design process. Results of the previous paper, which highlighted differences in some visually-similar visual languages, and feedback we received, suggested that there may be other systems that could be approached in this way. This short paper reports on a second series of models, discusses their strengths and weaknesses, and compares them to each other, and to the systems in the first set. We acknowledge, for the record, that viscosity, through task time, is only one of the issues in novice programming systems. A system with low viscosity would not necessarily meet the other (educational) requirements for beginner systems, but observations suggest that excessively viscous interactions may still be problematic for some types of novice user.",
            "score": 0.31503165799208427,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 163
                },
                {
                    "start": 164,
                    "end": 395
                },
                {
                    "start": 396,
                    "end": 531
                },
                {
                    "start": 534,
                    "end": 703
                },
                {
                    "start": 704,
                    "end": 849
                },
                {
                    "start": 850,
                    "end": 1054
                },
                {
                    "start": 1055,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1296
                },
                {
                    "start": 1297,
                    "end": 1506
                },
                {
                    "start": 1507,
                    "end": 1673
                },
                {
                    "start": 1674,
                    "end": 1797
                },
                {
                    "start": 1798,
                    "end": 2030
                }
            ],
            "ref_mentions": [
                {
                    "start": 1146,
                    "end": 1158,
                    "matchedPaperCorpusId": "4505341"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.47216796875
        },
        {
            "corpus_id": "277634411",
            "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
            "text": "Visual programming is typically a one-step process, generating code in a single pass from beginning to end. However, even with varied outputs via temperature adjustment, it lacks iterative interaction and alternative path exploration. In SVIP, we adopt a least-to-most [41] prompt strategy, incrementally generating code starting with the current block. This approach allows for the generation of subsequent code blocks, enabling multiple decision-making pathways and enhancing dynamic exploration of the visual task. \n\nSpecifically, we input a query q, visual input v, and instruction prompt p (as detailed in Appendix D) to a code generator \u03c0. The goal of the code generator is not to generate a complete executable code but rather to generate a code block b 1 = \u03c0(q, v, p) that completes the first subtask. Based on the generated code sequence c = [b 1 , ..., b n ], we then generate the next step b n+1 = \u03c0(q, v, p, c), continuing this process until a termination character is reached, at this time c represents a complete program. Through this process, we can generate the visual program block by block. Further-more, at each step, we generate X subnodes, which leads to a tree structure T = {b 1 , ..., b n } with code blocks b as the nodes. The path from the root to the leaf nodes represents a complete program, and we use C = {c 1 , ..., c k } to denote the set of codes that solve the problem q. The least-to-most visual program generation in SVIP scales adaptively with the query's complexity. More complex problems generate more subtasks and step-level samples, reflecting the intuition that harder problems warrant more solutions.",
            "score": 0.31503165799208427,
            "section_title": "Least-to-Most Visual Program Generation",
            "char_start_offset": 11404,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 107
                },
                {
                    "start": 108,
                    "end": 234
                },
                {
                    "start": 235,
                    "end": 353
                },
                {
                    "start": 354,
                    "end": 517
                },
                {
                    "start": 520,
                    "end": 645
                },
                {
                    "start": 646,
                    "end": 809
                },
                {
                    "start": 810,
                    "end": 1035
                },
                {
                    "start": 1036,
                    "end": 1108
                },
                {
                    "start": 1109,
                    "end": 1247
                },
                {
                    "start": 1248,
                    "end": 1405
                },
                {
                    "start": 1406,
                    "end": 1504
                },
                {
                    "start": 1505,
                    "end": 1643
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8232421875
        },
        {
            "corpus_id": "108298861",
            "title": "SOFTWARE FOR LINE OF BALANCE IN PROJECTS OF HIGHWAYS",
            "text": "Several programming environments are used to build software such as conventional programming languages (Pascal, C, and Visual Basic (VB)) and general purpose programming languages (Prolog, Lisp, Loops, and OPS5). Conventional programming languages are designed and optimized for procedural manipulation of data such as numbers and arrays. \n\nIn building the proposed software, the present research chose Visual Basic, one of the most widely used computer programming languages, in building the software. It not only creates Windows programs, but also takes full advantage of the graphical way that Windows works by letting programmers develop their systems by using a computer mouse. Visual Basic is truly revolutionary and gives programmers a much more capable, efficient, and flexible way to write computer software programs [22]. This programming language offers ease of use, which is a requirement of the user interface [23]and writes codes in a simple syntax in a natural mathematic language. \n\nVisual Basic is an event-driven language in which code is executed in response to events. These events come from either Windows itself or the users. Visual Basic uses forms designed to interact with the user running the system. The Windows dialogue box guides the user when operating the system. Visual Basic makes programming enjoyable and reduces the effort required of the programmer. While it simplifies programming and makes it as easy as dragging graphic  [Su and Lucko [14] objects onto the screen by using a mouse, the programming language forms the background of everything that occurs in a running Visual Basic program. However, the language is a secondary consideration to user interface. A Windows program offers a high degree of user interaction by using graphical elements that form the objects on the window which the user sees. \n\nVisual Basic provides the developer with the power and flexibility required to support a complex application. In addition, VB can provide the software with computing speed and flexibility and offers a large set of tools which allow the developer to build and design customized software suitable for the intended application. This process requires long development time and skill of experienced programmers to develop sophisticated and appropriate software. The developed software is a Windowsbased application created in the Visual Basic development environment which contains all resources to build powerful Windows-based programs efficiently and quickly.",
            "score": 0.31503165799208427,
            "section_title": "Selection of Software Building Environment",
            "char_start_offset": 5846,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 212
                },
                {
                    "start": 213,
                    "end": 338
                },
                {
                    "start": 341,
                    "end": 502
                },
                {
                    "start": 503,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 831
                },
                {
                    "start": 832,
                    "end": 996
                },
                {
                    "start": 999,
                    "end": 1088
                },
                {
                    "start": 1089,
                    "end": 1147
                },
                {
                    "start": 1148,
                    "end": 1226
                },
                {
                    "start": 1227,
                    "end": 1294
                },
                {
                    "start": 1295,
                    "end": 1386
                },
                {
                    "start": 1387,
                    "end": 1628
                },
                {
                    "start": 1629,
                    "end": 1698
                },
                {
                    "start": 1699,
                    "end": 1842
                },
                {
                    "start": 1845,
                    "end": 1954
                },
                {
                    "start": 1955,
                    "end": 2169
                },
                {
                    "start": 2170,
                    "end": 2301
                },
                {
                    "start": 2302,
                    "end": 2501
                }
            ],
            "ref_mentions": [
                {
                    "start": 826,
                    "end": 830,
                    "matchedPaperCorpusId": "37727719"
                },
                {
                    "start": 923,
                    "end": 927,
                    "matchedPaperCorpusId": "109670188"
                },
                {
                    "start": 1475,
                    "end": 1479,
                    "matchedPaperCorpusId": "5502341"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.73974609375
        },
        {
            "corpus_id": "242467846",
            "title": "Reciprocity Effect between Cognitive Style and Mixed Learning Method on Computer Programming Skill",
            "text": "In other words, program code is made based on specific events or functions so that the sequence of program execution is also an event. In contrast to structured or procedural programming, it will execute program code from the beginning to the end of the program sequentially (Anggrawan, 2018). The visual programming language that is most popular today is Visual Basic.Net or VB.Net (Anggrawan, 2018). VB.Net is an object-oriented programming language (Yindi, 2016;Othman et al., 2018). VB. Net has the advantage of being of the visual programming language and high interest from students who learn it (Zhang et al., 2011). VB.NET is useful for applying network interfaces and operate records databases (Othman et al., 2018).",
            "score": 0.31503165799208427,
            "section_title": "Introduction",
            "char_start_offset": 8582,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 134
                },
                {
                    "start": 135,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 401
                },
                {
                    "start": 402,
                    "end": 486
                },
                {
                    "start": 487,
                    "end": 490
                },
                {
                    "start": 491,
                    "end": 623
                },
                {
                    "start": 624,
                    "end": 725
                }
            ],
            "ref_mentions": [
                {
                    "start": 452,
                    "end": 465,
                    "matchedPaperCorpusId": "58438510"
                },
                {
                    "start": 465,
                    "end": 485,
                    "matchedPaperCorpusId": "57191604"
                },
                {
                    "start": 602,
                    "end": 622,
                    "matchedPaperCorpusId": "14759986"
                },
                {
                    "start": 703,
                    "end": 724,
                    "matchedPaperCorpusId": "57191604"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84619140625
        },
        {
            "corpus_id": "271740895",
            "title": "Virtual Reality in the Classroom: Transforming the Teaching of Electrical Circuits in the Digital Age",
            "text": "The programming behind the graphical user interface (GUI) was executed in the C# (C Sharp) programming language, utilizing the Visual Studio 2019 Integrated Development Environment (IDE) and integrating it into the Unity video game engine. The development process involved coding various scripts related to entry, GUI navigation, instructions, question-and-answer interactions, final results, and circuit creation. These scripts underpin the interactions within each module of the virtual learning environment, facilitating a seamless and interactive educational experience.",
            "score": 0.31503165799208427,
            "section_title": "Graphical User Interface Coding and Programming",
            "char_start_offset": 29533,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 239
                },
                {
                    "start": 240,
                    "end": 414
                },
                {
                    "start": 415,
                    "end": 574
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2362060546875
        },
        {
            "corpus_id": "258979042",
            "title": "Kinesthetic Feedback for Understanding Program Execution",
            "text": "This method consisted of using the block-based visual programming language called Scratch. The Scratch display can be primarily divided into two displays: the \"code editor\" display and the \"stage + sprite\" display (Figure 1). In this experiment, both displays were visible to the experimenter whereas the participant sat in front of a computer screen with a \"stage + sprite\" display only. For each trial, the experimenter implemented a sequence of commands using the code editor. The result of the program implementation was displayed to the participant in the form of sprite movement on the stage. Similar to the narrative method, the participants were allowed to request a repetition of the sprite movement sequence until they felt confident about their understanding of the program. They were only allowed a single attempt to repeat a sequence of commands back to the experimenter. This information (i.e., the sequence of instructions and planar positions) was recorded in a Microsoft Excel document for later processing.",
            "score": 0.31503165799208427,
            "section_title": "Visual Only (Computer Animation)",
            "char_start_offset": 11488,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 90
                },
                {
                    "start": 91,
                    "end": 225
                },
                {
                    "start": 226,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 479
                },
                {
                    "start": 480,
                    "end": 598
                },
                {
                    "start": 599,
                    "end": 785
                },
                {
                    "start": 786,
                    "end": 884
                },
                {
                    "start": 885,
                    "end": 1024
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85986328125
        },
        {
            "corpus_id": "204151637",
            "title": "Parametrical design tool and the production of technical data for superadobe domes",
            "text": "Visual programming languages may be argued to have begun in the sixties, when a computer graphic experiment named GRAIL (Graphical input language) was presented as computer programming via flowcharts (ELLIS; HEAFNER; SIBLEY, 1969a)(ELLIS; HEAFNER; SIBLEY, 1969b). Nowadays, the most successful VPLs work as plug-ins in a CAD or BIM modeling system, such as Dynamo for Revit and Grasshopper for Rhinoceros (Grasshopper also connect to Archicad and VisualArq). In this research, the adopted set is the second one.",
            "score": 0.31503165799208427,
            "section_title": "Research validation",
            "char_start_offset": 7973,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 263
                },
                {
                    "start": 264,
                    "end": 458
                },
                {
                    "start": 459,
                    "end": 511
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.779296875
        },
        {
            "corpus_id": "269183392",
            "title": "Taking ASCII Drawings Seriously: How Programmers Diagram Code",
            "text": "While text remains the dominant medium for programming, signifcant research has investigated the use of visuals for assisting, explaining, teaching, and even doing programming. These investigations are rooted in the thesis that text and visuals, as two diferent media, have complimentary representational capabilities which can be integrated simultaneously to amplify problem-solving, learning, and communication [22,46,60]. Below, we review prior work that uses visual artifacts to assist in problem-solving for software development, as communication and educational tools to teach programming, and as part or as the whole of a programming language.",
            "score": 0.31503165799208427,
            "section_title": "RELATED WORK",
            "char_start_offset": 4911,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 176
                },
                {
                    "start": 177,
                    "end": 424
                },
                {
                    "start": 425,
                    "end": 650
                }
            ],
            "ref_mentions": [
                {
                    "start": 417,
                    "end": 420,
                    "matchedPaperCorpusId": "240766028"
                },
                {
                    "start": 420,
                    "end": 423,
                    "matchedPaperCorpusId": "2580513"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7529296875
        },
        {
            "corpus_id": "267616931",
            "title": "LLMs for Coding and Robotics Education",
            "text": "In the realm of Visual Programming Code Generation, research has explored innovative approaches to translating visual inputs into executable code. Among these approaches, leveraging multimodal models to interpret and generate code from visual diagrams, such as the FIRST LEGO League (FLL) block diagrams, represents a cutting-edge frontier. ChainCoder introduces a multi-pass code generation framework that uses a unique syntax hierarchy to enhance stepwise reasoning in LLMs, aiming to improve code accuracy and syntactic coherence. It employs a syntax-aware tokenizer and a specialized transformer to leverage structured, syntactically aligned data for progressive, multi-level code generation [46]. VISPROG is a system that leverages the in-context learning capabilities of language models to transform natural language instructions into visual programs for complex visual tasks, enabling the creation of sophisticated visual solutions directly from user inputs [18]. However, our investigations reveal that not all multimodal models are equally proficient at generating high-quality code from such visual inputs. For instance, while GPT-4V demonstrates remarkable capability in this domain, another model, Copilot, falls short. This discrepancy may stem from several factors. First, Copilot might struggle with prompts not written in English, highlighting a potential language bias. Second, its generation and evaluation modules, primarily trained on natural images, may not effectively interpret visual diagrams, which are fundamentally different in structure and content from typical photographic imagery. \n\nIn light of these challenges, our research pivoted towards leveraging textual prompts to generate pseudocode as an intermediary step. This approach capitalizes on the superior textual processing capabilities of multimodal models over their visual processing counterparts. By instructing the model to generate step-by-step, finely represented pseudocode instead of a coarse overview, we harness the model's linguistic strengths. Our prompts are meticulously crafted to guide the model in this process, resulting in more accurate and functional code generation. \n\nOur testing, conducted in a zero-shot learning context, underscores the potential of these models. However, it also opens avenues for further exploration into few-shot learning and fine-tuning strategies. Such enhancements could significantly improve the models' code generation capabilities, especially when dealing with complex visual inputs or domain-specific requirements.",
            "score": 0.31503165799208427,
            "section_title": "Visual Programming Code Generation",
            "char_start_offset": 24668,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 340
                },
                {
                    "start": 341,
                    "end": 533
                },
                {
                    "start": 534,
                    "end": 701
                },
                {
                    "start": 702,
                    "end": 970
                },
                {
                    "start": 971,
                    "end": 1116
                },
                {
                    "start": 1117,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1279
                },
                {
                    "start": 1280,
                    "end": 1386
                },
                {
                    "start": 1387,
                    "end": 1611
                },
                {
                    "start": 1614,
                    "end": 1747
                },
                {
                    "start": 1748,
                    "end": 1885
                },
                {
                    "start": 1886,
                    "end": 2041
                },
                {
                    "start": 2042,
                    "end": 2173
                },
                {
                    "start": 2176,
                    "end": 2274
                },
                {
                    "start": 2275,
                    "end": 2380
                },
                {
                    "start": 2381,
                    "end": 2552
                }
            ],
            "ref_mentions": [
                {
                    "start": 965,
                    "end": 969,
                    "matchedPaperCorpusId": "253734854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.736328125
        },
        {
            "corpus_id": "248524774",
            "title": "Low-Code Programming Models",
            "text": "This article reviews research relevant to low-code programming models with a focus on visual programming, programming by demonstration, and programming by natural language. It maps low-code techniques to target users and discusses common building blocks, strengths, and weaknesses. This article argues that domain-specific languages and the model-view-controller pattern constitute a common backbone and unifying principle across low-code techniques.",
            "score": 0.31503165799208427,
            "section_title": "CONCLUSION",
            "char_start_offset": 38185,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 172
                },
                {
                    "start": 173,
                    "end": 281
                },
                {
                    "start": 282,
                    "end": 450
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7314453125
        },
        {
            "corpus_id": "196196006",
            "title": "Fifty years of the psychology of programming",
            "text": "with diagrams rather than text -followed routine use of diagrams by professional programmers (especially the flowcharts ubiquitous in the 1970s) and systems analysts (in the various approaches to business-oriented planning of data files and processing). However programming languages themselves, from FORTRAN and COBOL on, used teletype characters, with manual translation from diagrammatic designs to text that could be processed by compilers. This textual nature of programming \"language\" had not been inevitable -indeed the first formal proposal by Goldstine and Von Neumann (1947) was purely diagrammatic. However the economics of interactive graphical displays, despite the early celebrity of Sutherland's Sketchpad (1963/2003) meant that mass-market deployment of graphical user interfaces had only become feasible in the mid 1980s. \n\nIn the following 13 years of the IEEE Symposia on Visual Languages until the series ended in 2000, the research presented focused primarily on description of specific languages (129 papers), and on theoretical or engineering frameworks for classes of visual language (125 papers). In addition to these topics that might be regarded as core to visual programming languages, the VL symposia also paid significant attention to visualisation of software and data (62 papers), and other aspects of graphical user interface design more generally (67 papers). Other regular themes included discussion of diagrammatic modelling languages and notations (38 papers), algorithms for parsing, layout or rendering of visual languages (30 papers), and other types of interactive drawing tool (28 papers). Some specialist topics have remained a constant minority interest, including tools for the construction or generation of user interfaces (14 papers) and the use of inference methods for end-user programming by example (11 papers). However, it is remarkable how few of the papers published in this period of the series paid attention to theories of human factors that justified the change from textual to visual language, or empirical studies that attempted to measure or evaluate the benefits of that change, with only one or two papers each year dealing with those topics. As noted by Blackwell in a 1996 paper, subsequently recognised with an award for most influential paper after 20 years (Blackwell 1996), research in the field relied mainly on theories of pop psychology, folk wisdom, or personal subjective intuition to justify its core technical concerns.",
            "score": 0.31503165799208427,
            "section_title": "A C C E P T E D M A N U S C R I P T",
            "char_start_offset": 31159,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 253
                },
                {
                    "start": 254,
                    "end": 444
                },
                {
                    "start": 445,
                    "end": 609
                },
                {
                    "start": 610,
                    "end": 838
                },
                {
                    "start": 841,
                    "end": 1121
                },
                {
                    "start": 1122,
                    "end": 1393
                },
                {
                    "start": 1394,
                    "end": 1631
                },
                {
                    "start": 1632,
                    "end": 1862
                },
                {
                    "start": 1863,
                    "end": 2205
                },
                {
                    "start": 2206,
                    "end": 2495
                }
            ],
            "ref_mentions": [
                {
                    "start": 552,
                    "end": 584,
                    "matchedPaperCorpusId": "62644505"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.70703125
        },
        {
            "corpus_id": "249962176",
            "title": "Maniposynth: Bimodal Tangible Functional Programming",
            "text": "Without side effects, the order of computation is negligible. The user may gather the parts they need in any order and worry later about how to assemble them. Alas, the standard practice of writing functional programs as linear, textual code obscures this opportunity for non-linearity. Placing values on a 2D canvas instead highlights it. \n\nNon-linearity matters. Not all humans are linear thinkers, and not even all programmers think linearly at all times. (How often are large blocks of code written top-to-bottom from scratch?) A non-linear environment can offer a creative space more inviting to folks whose standard workflow naturally entails concrete exploration rather than abstract planning. \n\nWhile Eros highlighted how non-linear editing dovetails with pure functional programming, its mechanism for composing TVs may tip the balance too far from the abstract in favor of the concrete. Once a value has been composed, it obscures how it came to be. TVs are labeled with a brief expression, but this one line is inadequate for any computation of modest size. Moreover, once composed, how does one change the computation that produced a TV? Value manipulation alone may be inadequate for carefully specifying abstract algorithms. Perhaps there is a middle ground that allows both non-linear, concrete direct manipulation on values and traditional editing of ordinary code. That middle ground is the subject of this paper. In particular, we seek to answer the question: environment with synthesis features called (The Magnificent) Maniposynth. We demonstrate both how non-linear visual editing can integrate with linear code, as well as show novel editing features made possible by the value-centric display. \n\nTo gain an initial understanding of the system, we implemented an external corpus of 38 example programs. For additional insights, we conducted an in-depth exploratory study with two external professional functional programmers, whose feedback informed the evolution of Maniposynth. We describe their use of the tool and discuss additional observations through investigative lenses from the Cognitive Dimensions of Notation framework [25]. \n\nSection 2 introduces Maniposynth with a running example. Section 3 describes the technical implementation of the tool and the synthesizer. Section 4 presents insights from implementing a corpus of examples and the qualitative user study. Section 5 presents related work, and Section 6 discusses avenues for continued exploration.",
            "score": 0.31437250311188025,
            "section_title": "Introduction",
            "char_start_offset": 2335,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 61
                },
                {
                    "start": 62,
                    "end": 158
                },
                {
                    "start": 159,
                    "end": 286
                },
                {
                    "start": 287,
                    "end": 339
                },
                {
                    "start": 342,
                    "end": 364
                },
                {
                    "start": 365,
                    "end": 458
                },
                {
                    "start": 459,
                    "end": 531
                },
                {
                    "start": 532,
                    "end": 700
                },
                {
                    "start": 703,
                    "end": 896
                },
                {
                    "start": 897,
                    "end": 959
                },
                {
                    "start": 960,
                    "end": 1068
                },
                {
                    "start": 1069,
                    "end": 1238
                },
                {
                    "start": 1239,
                    "end": 1381
                },
                {
                    "start": 1382,
                    "end": 1430
                },
                {
                    "start": 1431,
                    "end": 1551
                },
                {
                    "start": 1552,
                    "end": 1716
                },
                {
                    "start": 1719,
                    "end": 1824
                },
                {
                    "start": 1825,
                    "end": 2001
                },
                {
                    "start": 2002,
                    "end": 2158
                },
                {
                    "start": 2161,
                    "end": 2217
                },
                {
                    "start": 2218,
                    "end": 2299
                },
                {
                    "start": 2300,
                    "end": 2398
                },
                {
                    "start": 2399,
                    "end": 2490
                }
            ],
            "ref_mentions": [
                {
                    "start": 2153,
                    "end": 2157,
                    "matchedPaperCorpusId": "11750514"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.265625
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "NOTE: that the words \"step\", \"control\", and \"component\" are used interchangeably and they all mean a graphical control also the words \"goal\" and \"module\" are used interchangeably to mean a programming module.\n\nThe basic idea behind the Graphical Code Replacement (GCR) was to find a way to make the visual programming language fully equivalent to a traditional textual programming language and to overcome all the limitations and weaknesses of VPLs. Looking at the structure of code written in textual programming languages, it can be easily seen that the code contains a set of instructions and commands written as statements in a specific syntax. The statements are arranged in nested structures similar to a computer tree with one or more nodes/leaves. A complex statement such as \"For Loop\" can be represented with a node that can be expanded, while a simple statement such as a \"printf()\" can be represented with a leaf. For example, the code shown in Figure 10 is written in C. This code can be seen as a tree of statements or steps (a step here is defined as a visual component) arranged in a way to print numbers from 1 to 3, print a message, and then continue Printing 4 to 10. Keep in mind that each instruction in any programming language consists of two parts: the operation, and the required data for the specification of that operation. To better describe the concept, the following equivalences can be used:\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of Instructions (Steps Tree) \u2022 Instruction IS EQUIVALENT TO a function F(X), where F is the operation or the function and X is the required data.\n\n\u2022 Text code structure IS EQUIVALENT TO Nested structures of F(X). Notice that F can be any function and X can be any input data.\n\nWhen the above equivalences are applied to the C code shown in Figure 10 Step's Description/Label Print Text \"This message between number 3 and number 4\" Table 5. Shows the replacement process for one line of code.\n\nAt this point many questions need to be answered. How the steps will be generated automatically? How will they determine what the program will do? How can the developer/programmer control and manage the program as she does with traditional languages? GCR uses the Nested Tree (Steps Tree) to represent the structure of the program. Instead of",
            "score": 0.3138523027044761,
            "section_title": "Graphical Code Replacement Method",
            "char_start_offset": 55501,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9482421875
        },
        {
            "corpus_id": "258987846",
            "title": "AI for Low-Code for AI",
            "text": "Most AI development today involves Python programming with popular libraries such as scikit-learn (sklearn) [28]. Unfortunately, writing code, even in a language as high-level as Python, is hard for citizen developers [22]-people who lack formal training in programming but nevertheless write programs as part of their everyday work. This is a fairly common situation for data scientists, among others. AI programming libraries also tend to be large and change regularly. Needing to remember hundreds of AI operators and their arguments slows down even professional developers. \n\nLow-code programming [32] reduces the amount of textual code developers write by offering alternative programming interfaces. In recent years, it has been embraced by software vendors to both democratize software development and increase productivity. Most low-code offerings for building AI pipelines currently favor visual programming [6,12,18]. While visual programming helps users navigate complex pipelines, it poorly supports discoverability of API components in large APIs due to the large range of options and limited screen space. In parallel, programming by natural language (PBNL) has recently soared in popularity. Tools like Copilot [1] and ChatGPT [2] can generate code from natural language prompts in which users describe what they want to accomplish, which is especially helpful in ecosystems with large APIs. However, these tools still generate code, which can be complicated and hard to understand [34], especially without formal training in programming. \n\nAt the intersection of these two paradigms, we propose Low-Coder, the first low-code tool to combine visual programming with PBNL. We conjecture that the respective strengths of these two lowcode techniques can compensate for each other's weaknesses. PBNL uses AI to help users retrieve and use programming constructs based on natural language queries. This does not always return correct programs, necessitating a way to help users understand and fix generated programs. Visual programming complements PBNL by providing a clear, unambiguous representation of the program that users can directly manipulate to experiment with alternatives. Our goal is to help people who know what they want to accomplish (e.g., build a data processing pipeline) but face syntactic barriers from the programming language and library (the how part).",
            "score": 0.3133213796293054,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 113
                },
                {
                    "start": 114,
                    "end": 333
                },
                {
                    "start": 334,
                    "end": 402
                },
                {
                    "start": 403,
                    "end": 471
                },
                {
                    "start": 472,
                    "end": 577
                },
                {
                    "start": 580,
                    "end": 705
                },
                {
                    "start": 706,
                    "end": 831
                },
                {
                    "start": 832,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 1119
                },
                {
                    "start": 1120,
                    "end": 1206
                },
                {
                    "start": 1207,
                    "end": 1406
                },
                {
                    "start": 1407,
                    "end": 1553
                },
                {
                    "start": 1556,
                    "end": 1686
                },
                {
                    "start": 1687,
                    "end": 1806
                },
                {
                    "start": 1807,
                    "end": 1908
                },
                {
                    "start": 1909,
                    "end": 2027
                },
                {
                    "start": 2028,
                    "end": 2195
                },
                {
                    "start": 2196,
                    "end": 2387
                }
            ],
            "ref_mentions": [
                {
                    "start": 218,
                    "end": 222,
                    "matchedPaperCorpusId": "1894216"
                },
                {
                    "start": 601,
                    "end": 605,
                    "matchedPaperCorpusId": "224777697"
                },
                {
                    "start": 917,
                    "end": 920,
                    "matchedPaperCorpusId": "408188"
                },
                {
                    "start": 920,
                    "end": 923,
                    "matchedPaperCorpusId": "6995153"
                },
                {
                    "start": 923,
                    "end": 926,
                    "matchedPaperCorpusId": "13861754"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6513671875
        },
        {
            "corpus_id": "258987846",
            "title": "AI for Low-Code for AI",
            "text": "Low-code programming allows citizen developers to create programs with minimal coding effort, typically via visual (e.g. drag-and-drop) interfaces. In parallel, recent AI-powered tools such as Copilot and ChatGPT generate programs from natural language instructions. We argue that these modalities are complementary: tools like ChatGPT greatly reduce the need to memorize large APIs but still require their users to read (and modify) textual programs, whereas visual tools abstract away most or all program text but struggle to provide easy access to large APIs. At their intersection, we propose LowCoder, the first low-code tool for developing AI pipelines that supports both a visual programming interface (LowCoderVP) and an AI-powered natural language interface (LowCoderNL). We leverage this tool to provide some of the first insights into whether and how these two modalities help programmers by conducting a user study. We task 20 developers with varying levels of AI expertise with implementing four ML pipelines using LowCoder, replacing the LowCoderNL component with a simple keyword search in half the tasks. Overall, we find that LowCoder is especially useful for (i) Discoverability: using LowCoderNL, participants discovered new operators in 75% of the tasks, compared to just 32.5% and 27.5% using web search or scrolling through options respectively in the keyword-search condition, and (ii) Iterative Composition: 82.5% of tasks were successfully completed and many initial pipelines were further successfully improved. Qualitative analysis shows that AI helps users discover how to implement constructs when they know what to do, but still fails to support novices when they lack clarity on what they want to accomplish. Overall, our work highlights the benefits of combining the power of AI with low-code programming.",
            "score": 0.31283534664945445,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7255859375
        },
        {
            "corpus_id": "55832579",
            "title": "GUIs without Pain \u2013 the Declarative Way",
            "text": "Graphical User Interfaces (GUIs) are required by almost all modern applications. Generally, developers utilize three main approaches to creating them: \u2022 Defining GUIs using manually written source code. Every popular programming language has its own dedicated libraries. In case of Java it could be Swing (Walrath, 2004) or SWT (Guojie, 2005). C# developers have WinForms (Sells, 2006); \u2022 Utilizing dedicated visual editors (designers) which allow for \u201cdrawing\u201d a GUI and for generating an appropriate source code. The quality of such generators varies considerably. Some of them allow for round-trip engineering (i.e. (Jigloo, 2009)). In contrast, there are also solutions which act as pure generators; \u2022 Using a special declarative approach. The idea is to focus on \u201cwhat to do\u201d rather than \u201chow to do it\u201d. A recent, commercially used example of such an approach is MS XAML. Particular GUI items are defined using a dedicated programming language (or a description language). Unfortunately, most of the presented approaches require quite serious involvement from the programmer. The first one, is definitely the most time-consuming and also needs specified knowledge. The second one, saves some time but needs a lot of attention during designing process. The last one utilizes probably the easiest approach for having a decent user communication layer in an application. Following the declarative way, a programmer focuses on what to do rather than how to do it. Such a method saves time and ensures less programming errors in the final product. In this chapter we would like to: \u2022 Present existing declarative solutions, \u2022 Briefly describe our previous proposal for the Java language: the senseGUI library (Trzaska, 2008) and fully discuss the new one called the GCL language. Both of them have been implemented and are publicly available (together with source codes) using the following addresses: http://go.mtrzaska.com/?sensegui and http://gcl-dsl.googlecode.com/. The first prototype called the senseGUI utilizes annotations existing in the Java language (they also exist in other programming languages like MS C#). The annotations allow the programmer for marking particular parts of a source code defining class structures. Using such simple annotations, the programmer",
            "score": 0.3124692052301792,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.447265625
        },
        {
            "corpus_id": "11795228",
            "title": "Visual definition of procedures for automatic virtual scene generation",
            "text": "The presented visual programming language was successfully used in the domain of procedural generation using a set of methods exposed to the user through an API, fulfilling the goals stated in Section 3.2.\n\nA proof-of-concept solution for the scenario of modeling urban scenes was presented and it offers:\n\n\u2022 building generation -procedurally assembled and premade in Blender [47] \u2022 details placement -various objects can be added, such as trees, billboards, traffic signs, bus stops. . .\n\n\u2022 city layout generation -a Manhattan-like grid can be calculated, enabling arrangement of objects relative to it\n\n\u2022 randomness -all the parameters can be specified through intervals, rough values and random parts of the procedure could be executed even, resulting in more non-deterministic and interesting scenes\n\nThe flowcharts and resulting scenes presented in Section 6.3 show that the methods of visual programming and procedural generation can be used together to quite satisfying results -especially considering the relatively small number of procedural generation methods utilized here in comparison to the very complex systems described in [28,30,29,27].\n\nThe procedural generation methods were designed in a way to suit the context of visual programming by masking the implementation complexity with a high-level interface of a scripting language Python [22] that gets presented inisde the VPL. In Section 6.2 a side-by-side comparison shows that the usage of the library's native interface would burden the user with having to write more text inside a visual program to achieve the same functionality and we can therefore conclude that creating a high-level interface is a good choice.",
            "score": 0.311939090775342,
            "section_title": "Procedural modeling through visual programming",
            "char_start_offset": 70270,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1139,
                    "end": 1143,
                    "matchedPaperCorpusId": "2417221"
                },
                {
                    "start": 1143,
                    "end": 1146,
                    "matchedPaperCorpusId": "6328791"
                },
                {
                    "start": 1146,
                    "end": 1149,
                    "matchedPaperCorpusId": "7593720"
                },
                {
                    "start": 1149,
                    "end": 1152,
                    "matchedPaperCorpusId": "53236631"
                },
                {
                    "start": 1354,
                    "end": 1358,
                    "matchedPaperCorpusId": "58972585"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.86376953125
        },
        {
            "corpus_id": "248387201",
            "title": "Designing activities and tools to support university students' creative and collaborative exploration of physical computing",
            "text": "Sentance and Csizmadia (2017) observed that in schools, programming is perceived to be the most challenging aspect of computer science: students have problems with connecting the theoretical concepts to the practical applications and thinking computationally, as well as breaking problems into smaller pieces was perceived difficult. Visual programming tools have been developed to help with these challenges and aim to make programming more accessible for non-technical students. However, the differences between visual programming and traditional text-based programming are considerably extensive. Visual programming languages simplify procedures and guide the user through the creation, for example, with blocks that snap together or use colour-coding. Vihavainen, Paksula and Luukkainen (2011) noticed that a common problem when teaching text-based programming languages is that the focus is too much on learning specific syntax or semantics rather than understanding the process. When students understand the process of coding, they can construct more meaningful programs. Also, Przybylla & Romeike (2014) assert that physical computing encourages learners to use their imagination and creativity, focusing more on ideas, not on technical limitation. Physical computing takes a hands-on approach to understand computational thinking, building tangible artefacts to visualise the abstract programming concepts. \n\nProgramming and electronics are fundamental design disciplines, and therefore they should be taught through design activities rather than limiting education to textbook readings and \"cookbook\" laboratory exercises (Buechley, Eisenberg, & Elumeze, 2007). Even if the outcome does not turn out to be as hoped, students can revise their ideas and create a new version. Iversen and colleagues (2016) argue that design-based activities with tangible digital artefacts provide learners with competencies that reach beyond STEM (Science, Technology, Engineering, and Mathematics) skills. New digital tools, such as 3D printers, laser cutters, and construction kits should expand the forms of learning in classrooms enabling children to learn through the processes of constructing and thinking rather than disabling their thinking by letting them merely carry out ready planned projects. As a matter of fact, design thinking, and computational thinking are both tools for problem-solving (Bowler, 2014). \n\nLearning through design argues that students construct their knowledge by designing and creating meaningful projects and that learning is the most effective when pupils are engaged in creating a tangible artefact .",
            "score": 0.311939090775342,
            "section_title": "Background",
            "char_start_offset": 2990,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 333
                },
                {
                    "start": 334,
                    "end": 480
                },
                {
                    "start": 481,
                    "end": 599
                },
                {
                    "start": 600,
                    "end": 755
                },
                {
                    "start": 756,
                    "end": 984
                },
                {
                    "start": 985,
                    "end": 1077
                },
                {
                    "start": 1078,
                    "end": 1255
                },
                {
                    "start": 1256,
                    "end": 1414
                },
                {
                    "start": 1417,
                    "end": 1670
                },
                {
                    "start": 1671,
                    "end": 1782
                },
                {
                    "start": 1783,
                    "end": 1997
                },
                {
                    "start": 1998,
                    "end": 2296
                },
                {
                    "start": 2297,
                    "end": 2412
                },
                {
                    "start": 2415,
                    "end": 2629
                }
            ],
            "ref_mentions": [
                {
                    "start": 756,
                    "end": 797,
                    "matchedPaperCorpusId": "3016237"
                },
                {
                    "start": 1084,
                    "end": 1110,
                    "matchedPaperCorpusId": "6485878"
                },
                {
                    "start": 1631,
                    "end": 1669,
                    "matchedPaperCorpusId": "18437979"
                },
                {
                    "start": 2397,
                    "end": 2411,
                    "matchedPaperCorpusId": "143257820"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82861328125
        },
        {
            "corpus_id": "229296521",
            "title": "HOW TO EVALUATE A PROGRAM WRITTEN BY CHILDREN: A PROGRAM EVALUATION SUPPORT TOOL FOR ELEMENTARY SCHOOL TEACHERS",
            "text": "In the material published by Ministry of Education, Culture, Sports, Science and Technology (MEXT), visual programming is mentioned as a specific educational method (Ministry of Education, Culture, Sports, Science and Technology, n.d.). As a visual programming language learning environment, there are programming developed by MEXT (Ministry of Education, Culture, Sports, Science and Technology, n.d.), VISCUIT (Digitalpocket c2018) developed by NTT and so on. This application covers for Scratch program which is cited in many books as an example in programming education for elementary school. Scratch (MIT Media Laboratory c2019) is a one of visual programming language learning environment developed by MIT Media Lab in 2006 and is used by more than 20 million people in more than 150 countries. In the Scratch 2.0, by combining 12 types and 144 blocks, a visual program can be created without even using a code as shown in Figure 1. Created program also can be shared with other users.",
            "score": 0.311939090775342,
            "section_title": "Visual Programming",
            "char_start_offset": 1755,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 236
                },
                {
                    "start": 237,
                    "end": 461
                },
                {
                    "start": 462,
                    "end": 596
                },
                {
                    "start": 597,
                    "end": 800
                },
                {
                    "start": 801,
                    "end": 938
                },
                {
                    "start": 939,
                    "end": 991
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8310546875
        },
        {
            "corpus_id": "264371146",
            "title": "Core competencies of K-12 computer science education from the perspectives of college faculties and K-12 teachers",
            "text": "Some of the visual programming languages, such as Scratch and Alice, are block-based languages in the programming environments, of which students can drag and drop coding blocks to the workspace. Thus, novice CS learners can focus on the computational concepts and logic without being bothered by the syntax (Bau et al., 2017;Kelleher & Pausch, 2005). Some research argues that visual programming languages might be more appropriate for novice learners as they are easier to learn (Bau et al., 2017;Chen et al., 2020;Malan & Leitner, 2007). For example, Chen et al. (2020) analyzed data from 10,000 undergraduate students who enrolled in CS courses and found that students whose first programming language was visual performed better than did students whose first programming language was textual when the programming languages were first introduced in K-12 stages. Moreover, the visual languages and environments provide scaffolds and enable knowledge transfer. Research indicates that visual programming languages are used in K-12 CT education. For example, Hsu et al. (2018) and Lockwood and Mooney (2017) find that many schools have utilized visual programming languages to teach CT skills. Other studies indicate that using visual programming languages to teach students CT skills is effective in elementary education (The Horizon Report, 2017). Application of visual program languages in K-12 CS education is found to significantly improve students' understanding of computational concepts and computation practices (Saez-Lopez et al., 2016), logical thinking skills (Lindh and Holgersson 2007), and problem-solving skills in general (Chou 2018). \n\nGiven the mixed opinions of introducing visual or textual programming languages in K-12 CS education, Xu et al. (2019) conduct a meta-analysis on the block-based versus textual programming on student learning outcomes by reviewing 13 publications. They find a small effect size in favor of block-based programming languages on cognitive learning outcomes and suggest more research on the effectiveness of using block-based programming languages for novice learners in the future. \n\nTo sum up, the epistemology of K-12 CS education, including its necessity, its core competencies as well as programming languages that should be taught in its implementation, still need to be clarified.",
            "score": 0.311939090775342,
            "section_title": "Programming Languages in CS Education",
            "char_start_offset": 8102,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 195
                },
                {
                    "start": 196,
                    "end": 351
                },
                {
                    "start": 352,
                    "end": 540
                },
                {
                    "start": 541,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 962
                },
                {
                    "start": 963,
                    "end": 1046
                },
                {
                    "start": 1047,
                    "end": 1194
                },
                {
                    "start": 1195,
                    "end": 1350
                },
                {
                    "start": 1351,
                    "end": 1652
                },
                {
                    "start": 1655,
                    "end": 1902
                },
                {
                    "start": 1903,
                    "end": 2134
                },
                {
                    "start": 2137,
                    "end": 2339
                }
            ],
            "ref_mentions": [
                {
                    "start": 326,
                    "end": 350,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 517,
                    "end": 539,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 1060,
                    "end": 1077,
                    "matchedPaperCorpusId": "52813623"
                },
                {
                    "start": 1522,
                    "end": 1547,
                    "matchedPaperCorpusId": "27633066"
                },
                {
                    "start": 1573,
                    "end": 1600,
                    "matchedPaperCorpusId": "31042634"
                },
                {
                    "start": 1640,
                    "end": 1651,
                    "matchedPaperCorpusId": "55683453"
                },
                {
                    "start": 1757,
                    "end": 1773,
                    "matchedPaperCorpusId": "67914194"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78466796875
        },
        {
            "corpus_id": "11795228",
            "title": "Visual definition of procedures for automatic virtual scene generation",
            "text": "In [6] a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two interesting concepts are mentioned:\n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand its meaning\n\n\u2022 effective use of computer display -showing only the information important to the user at that given time, considering the context These two factors are something important if a VPL is to scale well to a project of a larger scope. By keeping them in mind as guidelines while designing a VPL, one could get closer to the usability classical programming currently offers.",
            "score": 0.311939090775342,
            "section_title": "Advances in visual programming",
            "char_start_offset": 7376,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 3,
                    "end": 6,
                    "matchedPaperCorpusId": "13484911"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.880859375
        },
        {
            "corpus_id": "236780515",
            "title": "Cognition of Graphical Notation for Processing Data in ERDAS IMAGINE",
            "text": "Textual programming languages encode information as a sequence of characters, while visual languages encode information using the spatial layout of graphic (or text) elements. Text information is linear one-dimensional. Visual representation is two-dimensional (spatial).",
            "score": 0.311939090775342,
            "section_title": "\uf0b7",
            "char_start_offset": 1293,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 219
                },
                {
                    "start": 220,
                    "end": 271
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.27978515625
        },
        {
            "corpus_id": "259335765",
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "text": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
            "score": 0.311939090775342,
            "section_title": "Visual Programming",
            "char_start_offset": 4631,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 76
                },
                {
                    "start": 77,
                    "end": 187
                },
                {
                    "start": 188,
                    "end": 278
                },
                {
                    "start": 279,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 548
                },
                {
                    "start": 549,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 788
                },
                {
                    "start": 789,
                    "end": 1016
                },
                {
                    "start": 1019,
                    "end": 1094
                },
                {
                    "start": 1095,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1323
                },
                {
                    "start": 1324,
                    "end": 1441
                },
                {
                    "start": 1442,
                    "end": 1583
                },
                {
                    "start": 1584,
                    "end": 1737
                },
                {
                    "start": 1738,
                    "end": 1796
                },
                {
                    "start": 1797,
                    "end": 1816
                },
                {
                    "start": 1817,
                    "end": 1926
                },
                {
                    "start": 1927,
                    "end": 2022
                },
                {
                    "start": 2023,
                    "end": 2189
                },
                {
                    "start": 2190,
                    "end": 2356
                }
            ],
            "ref_mentions": [
                {
                    "start": 145,
                    "end": 148,
                    "matchedPaperCorpusId": "253196672"
                },
                {
                    "start": 148,
                    "end": 150,
                    "matchedPaperCorpusId": "235383033"
                },
                {
                    "start": 167,
                    "end": 170,
                    "matchedPaperCorpusId": "10976181"
                },
                {
                    "start": 183,
                    "end": 186,
                    "matchedPaperCorpusId": "35735491"
                },
                {
                    "start": 783,
                    "end": 787,
                    "matchedPaperCorpusId": "51750550"
                },
                {
                    "start": 1089,
                    "end": 1093,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1226,
                    "end": 1230,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1436,
                    "end": 1440,
                    "matchedPaperCorpusId": "198986538"
                },
                {
                    "start": 1578,
                    "end": 1582,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1820,
                    "end": 1823,
                    "matchedPaperCorpusId": "253196672"
                },
                {
                    "start": 2045,
                    "end": 2049,
                    "matchedPaperCorpusId": "239681487"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.96240234375
        },
        {
            "corpus_id": "269188197",
            "title": "Fact :Teaching MLLMs with Faithful, Concise and Transferable Rationales",
            "text": "Visual programming is a burgeoning field that employs neural symbols [17] or Python modules [14,47] for task synthesis and execution. While it offers enhanced performance and interpretability through precise image manipulation via code, its dependency on multiple models and prolonged inference times necessitates substantial computational resources. In contrast, our approach and Visual Program Distillation (VPD) [20] diverge significantly in handling program-based methods. VPD simplifies multimodal learning by distilling tool use and programmatic reasoning into smaller models but retains unnecessary execution traces, lacks precise spatial task execution, and overlooks the verification of transferability. Our method addresses these limitations through Efficient Rationale Editing: Unlike VPD, we implement controllable editing to refine programs into concise rationales; Enhanced Spatial Task Execution: Our approach exhibits superior spatial reasoning capabilities, enabling more accurate completion of spatial tasks compared to VPD; Verified Transferability: We also emphasize and validate the transferability of program-based rationales to end-to-end models which VPD simply ignored it. These distinctions underscore our contribution to integrating complex reasoning within MLLMs.",
            "score": 0.311939090775342,
            "section_title": "RELATED WORK 2.1 Visual Program Distillation",
            "char_start_offset": 7862,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 350
                },
                {
                    "start": 351,
                    "end": 476
                },
                {
                    "start": 477,
                    "end": 712
                },
                {
                    "start": 713,
                    "end": 1197
                },
                {
                    "start": 1198,
                    "end": 1291
                }
            ],
            "ref_mentions": [
                {
                    "start": 69,
                    "end": 73,
                    "matchedPaperCorpusId": "253734854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8603515625
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "Here, we provide more low-level implementation details on Code Interpreter. The Code Interpreter parses generated pseudocode into a visual programming pipeline for visualization at the Visual Blocks workspace. Figure 12 shows the data type definition of graphs, nodes, and edges in the system. The example JSON file to be parsed into the Typescript interface is available at the Visual Blocks website 5 . Our code defines a visual programming pipeline into an array of serialized nodes,  ( ). When the user adds a new node to a pipeline, it adds a new \"SerializedNode\", containing the edge definition between this new node and other nodes in the current workspace, to the current \"SerialedGraph\". This mechanism ensures that nodes can be incrementally added in the order they appear in the pseudocode order while maintaining the integrity of the graph by clearly defining dependencies and data flow between nodes. Algorithm 1 further shows how InstructPipe parses code and incrementally adds nodes to formulate a final serialized graph.",
            "score": 0.311939090775342,
            "section_title": "B.2 Code Interpreter",
            "char_start_offset": 56044,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 75
                },
                {
                    "start": 76,
                    "end": 209
                },
                {
                    "start": 210,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 404
                },
                {
                    "start": 405,
                    "end": 492
                },
                {
                    "start": 493,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 913
                },
                {
                    "start": 914,
                    "end": 1036
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7607421875
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "We formulated two main research questions: \n\n\u2022 RQ1: What visual programming tools have been proposed in the literature to support end-user developers? \n\n\u2022 RQ2: What evaluation methods have been used by the authors of these tools? \n\nWe used several dimensions to answer the two research questions. Tables 2 and 3 show the list of dimensions used to answer the questions. The formulation of dimensions is inspired by those proposed in [29] to obtain general information of EUD, EUP, and EUSE tools. \n\nWe used five dimensions to answer the first research question (RQ1). RQ1-D1 documents the VPL classification of the tools. RQ1-D2 describes the specific interaction styles the tools use. We used the interaction styles described in [81]. RQ1-D3 documents the type of users whom the tools are targeting. RQ1-D4 describes the fields where the tools are used. RQ1-D5 identifies the hardware environment in which the tools live. \n\nWe used seven dimensions to answer the second research question (RQ2). RQ2-D1 reports the existing empirical evidence for the efficacy of the proposed tools. RQ2-D2 identifies the types of users who participated in the evaluation. RQ2-D3 reports the number of test participants, while RQ2-D4 describes the level of the programming skills that test participants have. RQ2-D5 states the evaluation methods used to evaluate the proposed tools, while RQ2-D6 reports the evaluation measures used to evaluate the tools. Finally, RQ2-D7 reports whether the tools are accessible online. Tool accessibility allows authors to receive feedback from a larger community.",
            "score": 0.311939090775342,
            "section_title": "A. RESEARCH QUESTIONS",
            "char_start_offset": 19320,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 42
                },
                {
                    "start": 45,
                    "end": 150
                },
                {
                    "start": 153,
                    "end": 229
                },
                {
                    "start": 232,
                    "end": 296
                },
                {
                    "start": 297,
                    "end": 369
                },
                {
                    "start": 370,
                    "end": 496
                },
                {
                    "start": 499,
                    "end": 567
                },
                {
                    "start": 568,
                    "end": 621
                },
                {
                    "start": 622,
                    "end": 685
                },
                {
                    "start": 686,
                    "end": 735
                },
                {
                    "start": 736,
                    "end": 800
                },
                {
                    "start": 801,
                    "end": 854
                },
                {
                    "start": 855,
                    "end": 922
                },
                {
                    "start": 925,
                    "end": 995
                },
                {
                    "start": 996,
                    "end": 1082
                },
                {
                    "start": 1083,
                    "end": 1155
                },
                {
                    "start": 1156,
                    "end": 1291
                },
                {
                    "start": 1292,
                    "end": 1438
                },
                {
                    "start": 1439,
                    "end": 1503
                },
                {
                    "start": 1504,
                    "end": 1582
                }
            ],
            "ref_mentions": [
                {
                    "start": 433,
                    "end": 437,
                    "matchedPaperCorpusId": "67770007"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.74169921875
        },
        {
            "corpus_id": "250414169",
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "text": "Based on preliminary studies and research in the literature, our main research question is: What is the influence of the type of output in a visual SRA-programming environment on the development of CT and complex programming concepts among primary school pupils? Supplementary to the main research question, our sub-questions are: 1 To what extent can the influence on the development of CT be attributed to the evocation of SRA thinking and the type of output (tangible/on-screen) in SRAprogramming? 2 What is the impact of visual SRA-programming environments (task design) on the understanding of complex programming concepts? 3 What is the influence of the understanding of complex programming concepts on CT? \n\nThese sub-questions result in the following hypotheses: \n\n1. Pupils who apply SRA-programming in a visual programming environment show the development of CT. 2. Applying SRA-programming in a visual programming environment with visual, on-screen output leads to a higher level of development of CT compared to SRAprogramming in a visual environment with tangible output. 3. The application of SRA-programming in a visual programming environment with visual, on-screen output has a greater impact on the understanding of complex programming concepts than SRA-programming in a visual environment with tangible output.",
            "score": 0.311939090775342,
            "section_title": "Research question, sub-questions and hypotheses",
            "char_start_offset": 19305,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 262
                },
                {
                    "start": 263,
                    "end": 628
                },
                {
                    "start": 629,
                    "end": 712
                },
                {
                    "start": 715,
                    "end": 770
                },
                {
                    "start": 773,
                    "end": 1084
                },
                {
                    "start": 1085,
                    "end": 1329
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.485107421875
        },
        {
            "corpus_id": "250414169",
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "text": "Nothing can be grasped in a hands-on way, and the execution of the programming action cannot be seen from more than one point of view (Sapounidis et al., 2015). When there is a physically perceptible, tangible output of the programming operation, concrete artefacts are controlled by the computer program (Chen et al., 2017;Jonassen, 2006). The information obtained from the execution of the programming intervention is perceptible in a three-dimensional way, from all points of view (Korkmaz, 2018). Imagination and reasoning abilities are stimulated at a low level of abstraction, and the execution is tangible at any moment (Bers, 2020;Ilieva, 2010;Wang et al., 2014). In addition, users can check their expectations of the execution in physical reality, at any point in time (Marshall, 2007). \n\nBuilding on the above theoretical exploration, we hypothesise a relation between the SRA approach in a visual programming environment with different types of output and an influence on computational thinking. In addition, depending on the evocation of SRA thinking, we expect an influence on CT caused by a greater understanding of the concepts of programming. It is also expected that the more complex concepts of programming will initiate a more profound development of CT, and that the direct feedback obtained from visual output during visual programming will be more powerful than the feedback that can be derived from the execution of a visual program using a physical artefact. Our conceptual model, shown in Fig. 1, provides an overview of the relationships and interconnections between the independent and dependent variables, in which some connections are reciprocal.",
            "score": 0.311939090775342,
            "section_title": "Theoretical framework",
            "char_start_offset": 17577,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 160
                },
                {
                    "start": 161,
                    "end": 340
                },
                {
                    "start": 341,
                    "end": 500
                },
                {
                    "start": 501,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 796
                },
                {
                    "start": 799,
                    "end": 1007
                },
                {
                    "start": 1008,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1483
                },
                {
                    "start": 1484,
                    "end": 1676
                }
            ],
            "ref_mentions": [
                {
                    "start": 305,
                    "end": 324,
                    "matchedPaperCorpusId": "26877671"
                },
                {
                    "start": 484,
                    "end": 499,
                    "matchedPaperCorpusId": "64016264"
                },
                {
                    "start": 639,
                    "end": 652,
                    "matchedPaperCorpusId": "112054558"
                },
                {
                    "start": 652,
                    "end": 670,
                    "matchedPaperCorpusId": "10053624"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.76708984375
        },
        {
            "corpus_id": "255699199",
            "title": "Shoot2Learn: Fix-and-Play Educational Game for Learning Programming; Enhancing Student Engagement by Mixing Game Playing and Game Programming",
            "text": "Program visualization tools are designed to engage the students by visualizing the effects of each line of the code using graphics and animations (Fouh et al., 2012). This will help the student to formulate his own mental model of how a program is being executed in a notional machine. The term \"notional machine\" was coined by du Boulay et al. (1981) to denote the high-level abstraction of the hardware and software features of a computing agent, which includes, the compiler, OS, RAM, CPU, and I/O systems. This type of mental model is required for a programmer to comprehend the structure and dynamics of the underlying execution agent of their program. Jeliot's family of tools is considered one of the most-studied PV tools (Jeliot 3,n.d.). \n\nAlgorithm animation tools are used to visualize data movements in complex algorithms and are generally used in CS2 courses. Comprehensive reviews of visualization tools are given in (Hundhausen et al., 2002;Price et al., 1993;Saito et al., 2017). A few past research indicated that PV alone is not sufficient to support learning programming (Naps et al., 2003;Pears & Rogalli, 2011). \n\nSyntax-free, block-based, drag-and-drop microworlds Papert (1980) argues that the programming languages should be not only simple and entertaining for the students to learn (\"low-floor\"), but also powerful enough for the practitioners to build complex useful systems (\"high-ceilings\"). However, in general, popular programming languages have unusual syntax and complex semantics. One of the challenges in learning programming is understanding the semantics of different language constructs and their syntaxes. Without this comprehensive knowledge, devising and implementing a solution to a considerably complex problem will be challenging. Drag-and-Drop visual programming environments like Alice, Scratch, and App-Inventor (Turbak et al., 2014) are designed to address this difficulty-they allow a novice learner to develop problem-solving skills without being hindered by the complexities of syntax and semantics of the programming language. Students need not worry about the properties of the underlying notional machine.",
            "score": 0.311939090775342,
            "section_title": "Program visualization (PV) / Algorithm animation (AA)",
            "char_start_offset": 8146,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 285
                },
                {
                    "start": 286,
                    "end": 509
                },
                {
                    "start": 510,
                    "end": 657
                },
                {
                    "start": 658,
                    "end": 746
                },
                {
                    "start": 749,
                    "end": 872
                },
                {
                    "start": 873,
                    "end": 995
                },
                {
                    "start": 996,
                    "end": 1132
                },
                {
                    "start": 1135,
                    "end": 1420
                },
                {
                    "start": 1421,
                    "end": 1514
                },
                {
                    "start": 1515,
                    "end": 1644
                },
                {
                    "start": 1645,
                    "end": 1774
                },
                {
                    "start": 1775,
                    "end": 2078
                },
                {
                    "start": 2079,
                    "end": 2159
                }
            ],
            "ref_mentions": [
                {
                    "start": 146,
                    "end": 165,
                    "matchedPaperCorpusId": "1212293"
                },
                {
                    "start": 331,
                    "end": 351,
                    "matchedPaperCorpusId": "38215294"
                },
                {
                    "start": 931,
                    "end": 956,
                    "matchedPaperCorpusId": "270116183"
                },
                {
                    "start": 956,
                    "end": 975,
                    "matchedPaperCorpusId": "3163293"
                },
                {
                    "start": 975,
                    "end": 994,
                    "matchedPaperCorpusId": "28314150"
                },
                {
                    "start": 1090,
                    "end": 1109,
                    "matchedPaperCorpusId": "1555643"
                },
                {
                    "start": 1109,
                    "end": 1131,
                    "matchedPaperCorpusId": "25527478"
                },
                {
                    "start": 1859,
                    "end": 1880,
                    "matchedPaperCorpusId": "61427297"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.59423828125
        },
        {
            "corpus_id": "214190405",
            "title": "An Intelligent Tutoring System to Facilitate the Learning of Programming through the Usage of Dynamic Graphic Visualizations",
            "text": "Function definition (Figure 2a): It provides information related to the name of the function and its input arguments. This is the first graphic representation with which a full visualization must begin. The arrow of the traffic sign includes the reading direction of the visualization. \n\n\u2022 Conditional statement (Figure 2b): It provides information related to the condition. This condition will then be used to set the new execution flow that will be followed by the program; if the condition is met, the program will execute its left side, otherwise its right side. \n\n\u2022 Loop statement (Figure 2c): It provides information about the condition to be met to enter the loop. If the condition is fulfilled, the execution flow will be driven to the right road of the graphic representation, running all the sentences on such side. Otherwise, the execution flow will be driven through the left road. In both cases, the arrows on the road show the direction to be followed. Using a roundabout, we make an analogy with the concept of repetition. \n\n\u2022 Function return (Figure 2d): It provides information related to the function that is finished including its name and variables to be returned. \n\n\u2022 Evaluation of expressions (Figure 2e): It provides information related to arbitrary expressions such as assignments, function calls, etc. We use a tunnel to illustrate the evaluation of the expression when the vehicle goes through it. \n\n\u2022 Breakpoint (Figure 2f): It provides a mechanism to stop the program execution as if it is a debugger. In this case, and with the aim of being integrated with the rest of the metaphor, we use a traffic cone. \n\n\u2022 Thread (Figure 2g  The decisions about the design in the graphic representations were inspired by the \"Vienna Convention on Road Signs and Signal\" (1968) [39] whose proposals were adopted internationally by most countries. This presented a direct advantage to those students who were obtaining a driving license, since they were already familiar with such designs. \n\nThese visualizations could be displayed through an AR device. Among the state-of-the-art devices, Microsoft HoloLens excelled thanks to the immersion and interaction capabilities that it offered. This way, students could benefit from using the ITS through a natural interface more intuitive for them. \n\nThe system facilitated the construction of the visualizations by generating them automatically from the source code of the programs.",
            "score": 0.311939090775342,
            "section_title": "\u2022",
            "char_start_offset": 14220,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 117
                },
                {
                    "start": 118,
                    "end": 202
                },
                {
                    "start": 203,
                    "end": 285
                },
                {
                    "start": 288,
                    "end": 374
                },
                {
                    "start": 375,
                    "end": 566
                },
                {
                    "start": 569,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 825
                },
                {
                    "start": 826,
                    "end": 893
                },
                {
                    "start": 894,
                    "end": 966
                },
                {
                    "start": 967,
                    "end": 1037
                },
                {
                    "start": 1040,
                    "end": 1184
                },
                {
                    "start": 1187,
                    "end": 1326
                },
                {
                    "start": 1327,
                    "end": 1423
                },
                {
                    "start": 1426,
                    "end": 1529
                },
                {
                    "start": 1530,
                    "end": 1634
                },
                {
                    "start": 1637,
                    "end": 1861
                },
                {
                    "start": 1862,
                    "end": 2003
                },
                {
                    "start": 2006,
                    "end": 2067
                },
                {
                    "start": 2068,
                    "end": 2201
                },
                {
                    "start": 2202,
                    "end": 2306
                },
                {
                    "start": 2309,
                    "end": 2441
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77001953125
        },
        {
            "corpus_id": "270619487",
            "title": "Whiteboard-of-Thought: Thinking Step-by-Step Across Modalities",
            "text": "The goal of this work is to equip MLLMs with the ability to create images and visually process them to better answer queries.Our approach operates this whiteboard by synthesizing drawing code, exe-cuting this code to create the drawing, and parsing the resulting image before producing a final answer.Fig. 1 shows an example of the full procedure.\n\nCreating visuals with MLLMs.Current MLLMs typically do not inherently possess the ability to produce outputs in the visual domain.Instead, we will show how we can create visuals using a model that only produces text.\n\nThe images we create for visual reasoning tend to be minimal, abstract, and symbolic (Tversky, 2011).We use code as a natural way to create such visuals.Leveraging what models already know about common Python libraries like Matplotlib or Turtle enables this capability to emerge zeroshot, without needing any specialized, hand-crafted modules (though these could be made to adapt the technique to specific domains).We discuss other approaches such as text-to-image models in the Appendix.\n\nIn order to generate the code, we provide the MLLM with the query and prompt it to write code to visualize it.For each query, we prompt the MLLM with the input You write code to create visualizations using the {Matplotlib/Turtle} library in Python, which the user will run and provide as images.\n\nDo NOT produce a final answer to the query until considering the visualization.along with the query.The model then decides what visualization code to write based on the query.Full prompting and inference details for code generation can be found in the Appendix.\n\nThe resulting code is then passed to a runtime environment to render it in image form.In this case, we use the Python interpreter with the previouslymentioned visualization libraries.\n\nProcessing the generated visuals.To process the resulting image, we make use of the MLLM's intrinsic multimodal input capacity.This obviates the need for external tools, like handcrafted visual modules (Gupta and Kembhavi, 2022;Sur\u00eds et al., 2023), leading to a tightly self-contained method.",
            "score": 0.31030941291773134,
            "section_title": "Whiteboard-of-Thought",
            "char_start_offset": 7108,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 125
                },
                {
                    "start": 125,
                    "end": 301
                },
                {
                    "start": 301,
                    "end": 347
                },
                {
                    "start": 349,
                    "end": 377
                },
                {
                    "start": 377,
                    "end": 479
                },
                {
                    "start": 479,
                    "end": 565
                },
                {
                    "start": 567,
                    "end": 668
                },
                {
                    "start": 668,
                    "end": 720
                },
                {
                    "start": 720,
                    "end": 982
                },
                {
                    "start": 982,
                    "end": 1055
                },
                {
                    "start": 1057,
                    "end": 1167
                },
                {
                    "start": 1167,
                    "end": 1352
                },
                {
                    "start": 1354,
                    "end": 1433
                },
                {
                    "start": 1433,
                    "end": 1454
                },
                {
                    "start": 1454,
                    "end": 1529
                },
                {
                    "start": 1529,
                    "end": 1615
                },
                {
                    "start": 1617,
                    "end": 1703
                },
                {
                    "start": 1703,
                    "end": 1800
                },
                {
                    "start": 1802,
                    "end": 1835
                },
                {
                    "start": 1835,
                    "end": 1929
                },
                {
                    "start": 1929,
                    "end": 2094
                }
            ],
            "ref_mentions": [
                {
                    "start": 652,
                    "end": 667,
                    "matchedPaperCorpusId": "1299022"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.223876953125
        },
        {
            "corpus_id": "17525634",
            "title": "Selecting a first programming Language to Teach Prospective Teachers - Case Examples from Two Programs",
            "text": "When developing a program in Alice, users do not have to type the program. Instead, users pull down objects and align them according with specified commands that are already drawn for the user [11]. As the user pulls a particular object, another dropdown menu appears that gives the user options to choose from. The key here is that there is no room to make syntax errors when using Alice. Instead, efforts can be directed to understand the mechanism and the concepts of the program [10]. \n\nThe mechanism of program development is more direct in Alice than in other programming languages. Program development in Alice begins by creating what is termed as -world\u2016 which is the stage for placing objects that work together to produce an intended output. All the objects are placed in a defined and visually apparent library, thus making it is easier to look them over and make them work. So the point that can be made here is: there are no syntax errors in Alice. As a result, students do not get frustrated looking over and over their code to find syntax errors. The other point that can be made here is that due to the -visual\u2016 nature of Alice program, the mechanism of developing a program is more visible and direct that other languages.",
            "score": 0.30993927710567926,
            "section_title": "Alice Syntax and Mechanism",
            "char_start_offset": 13815,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 74
                },
                {
                    "start": 75,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 311
                },
                {
                    "start": 312,
                    "end": 389
                },
                {
                    "start": 390,
                    "end": 488
                },
                {
                    "start": 491,
                    "end": 588
                },
                {
                    "start": 589,
                    "end": 751
                },
                {
                    "start": 752,
                    "end": 885
                },
                {
                    "start": 886,
                    "end": 961
                },
                {
                    "start": 962,
                    "end": 1061
                },
                {
                    "start": 1062,
                    "end": 1239
                }
            ],
            "ref_mentions": [
                {
                    "start": 193,
                    "end": 197,
                    "matchedPaperCorpusId": "9343096"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.468994140625
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "The goal of this section is to review the landscape of visual programming environments (viz. Integrated Development Environments or other kind of development toolkits) and their inter-winded visual programming languages (which can be novel or only an adaptation of an already existent visual language) in the context of the IoT and characterize them. In order to do so, a novel characterization methodology was developed based on previous work on characterizing VPLs, with considerations about the IoT domain and the development toolkits associated with the VPLs. \n\nThe paper is structured as follows: in Section 5.2.1 it is given an overview of the literature about characterizing VPLs. Section 5.2.5 presents a proposal on how to characterize Visual Programming for IoT (languages and supporting development toolkits). An overview of the available languages for IoT is given on Section 5.2.6 and a comparison of those is given on Section 5.2.7. Some final remarks are given on Section ??.",
            "score": 0.30890824356701446,
            "section_title": "Visual Programming for IoT",
            "char_start_offset": 46704,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 92
                },
                {
                    "start": 93,
                    "end": 350
                },
                {
                    "start": 351,
                    "end": 563
                },
                {
                    "start": 566,
                    "end": 687
                },
                {
                    "start": 688,
                    "end": 820
                },
                {
                    "start": 821,
                    "end": 946
                },
                {
                    "start": 947,
                    "end": 990
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83056640625
        },
        {
            "corpus_id": "258979042",
            "title": "Kinesthetic Feedback for Understanding Program Execution",
            "text": "This method consisted of using the block-based visual programming language called Scratch. The Scratch display can be primarily divided into two displays: the \"code editor\" display and the \"stage + sprite\" display (Figure 1). In this experiment, both displays were visible to the experimenter whereas the participant sat in front of a computer screen with a \"stage + sprite\" display only. For each trial, the experimenter implemented a sequence of commands using the code editor. The result of the program implementation was displayed to the participant in the form of sprite movement on the stage. Similar to the narrative method, the participants were allowed to request a repetition of the sprite movement sequence until they felt confident about their understanding of the program. They were only allowed a single attempt to repeat a sequence of commands back to the experimenter. This information (i.e., the sequence of instructions and planar positions) was recorded in a Microsoft Excel document for later processing. \n\nof commands, and their end points, to the experimenter verbally. The user response information was recorded using a Microsoft Excel worksheet for later processing.",
            "score": 0.30887401304497075,
            "section_title": "Visual Only (Computer Animation)",
            "char_start_offset": 10261,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 90
                },
                {
                    "start": 91,
                    "end": 225
                },
                {
                    "start": 226,
                    "end": 388
                },
                {
                    "start": 389,
                    "end": 479
                },
                {
                    "start": 480,
                    "end": 598
                },
                {
                    "start": 599,
                    "end": 785
                },
                {
                    "start": 786,
                    "end": 884
                },
                {
                    "start": 885,
                    "end": 1024
                },
                {
                    "start": 1027,
                    "end": 1091
                },
                {
                    "start": 1092,
                    "end": 1190
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82666015625
        },
        {
            "corpus_id": "233523782",
            "title": "Holistic Requirements Analysis For Specifying New Systems For 3D Media Production and Promotion",
            "text": "Visual programming is gaining ground for setting the behaviour of objects. \n\nWebGPU standard will change the landscape of web browsers graphics with more realistic graphics. Cospaces and Tinkercad have low resolution.",
            "score": 0.30887401304497075,
            "section_title": "Cospaces, Tinkercad",
            "char_start_offset": 5683,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 74
                },
                {
                    "start": 77,
                    "end": 173
                },
                {
                    "start": 174,
                    "end": 217
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.654296875
        },
        {
            "corpus_id": "267631545",
            "title": "Synthesis regarding the general aspects of studying visual programming in pre-university education",
            "text": "The tools and platforms for visual programming have become popular worldwide, and many educational institutions are integrating them into the school curriculum to familiarize students with programming and computational thinking. This contributes to preparing students for the constantly evolving digital world and helps them become active and competent citizens in the technology era. The proposed research aims to conduct an analysis of educational policies regarding the implementation of visual programming, both in schools in the Republic of Moldova and in education systems of other countries such as Romania, the United Kingdom, Estonia, or Spain. Aspects to be analyzed include established competencies, educational levels at which visual programming is introduced, programming languages and platforms used, as well as available resources. The goal of this analysis is to identify the experiences, approaches, and best practices used in the reference countries regarding the integration of visual programming in pre-university education. It also aims to propose concrete suggestions for improving the study of visual programming in the Republic of Moldova. These suggestions include recommendations for the curriculum, educational resources, and teacher training to ensure proper preparation of students in the field of visual programming. Visual programming plays a significant role in developing digital skills and computational thinking in students, providing them with the opportunity to express their creativity, learn essential technological skills, and develop logical and systematic thinking.",
            "score": 0.30887401304497075,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6962890625
        },
        {
            "corpus_id": "271088887",
            "title": "Text2VP: Generative AI for Visual Programming and Parametric Modeling",
            "text": "For this simple test case, Text2VP successfully generated C# scripts that produced the desired visual programming workflow on the Grasshopper canvas. The model fully met the parametric modeling objectives on the first attempt (Figures 3 and 4).",
            "score": 0.30887401304497075,
            "section_title": "Single-Object 2D Modeling",
            "char_start_offset": 18342,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 149
                },
                {
                    "start": 150,
                    "end": 244
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.859375
        },
        {
            "corpus_id": "243857547",
            "title": "The Design of Parameter Modeling Software Applicable for Turbine Control Systems of Power Units Operated at Deep Shaving States",
            "text": "Visualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result. The visualized programming environment for Python is designed using the wxPython graphics library. wxPython is a GUI toolkit for Python. It makes it easy for Python programmers to create programs with robust and powerful GUIs.",
            "score": 0.30887401304497075,
            "section_title": "Overview of Python-based Visualized Design",
            "char_start_offset": 7795,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 259
                },
                {
                    "start": 260,
                    "end": 358
                },
                {
                    "start": 359,
                    "end": 396
                },
                {
                    "start": 397,
                    "end": 486
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9501953125
        },
        {
            "corpus_id": "213072323",
            "title": "Algorithm source codes generation for ensuring N-version software diversity",
            "text": "Nowadays software engineers and designers use visual programming languages to create software, including N-version one, by manipulating graphical elements [1][2][3]. Special development environments, debuggers, and translators have been developed for visual programming languages [4][5][6][7]. \n\nAt present, a great number of practical tasks in the field of software have been efficiently solved. Moreover, the problems are often solved with the help of the existing well-known algorithms that need only some modification to be applied for a specific task. Moreover the demand for high quality software solutions satisfying the users' needs with minimum lead-time and cost effectiveness is increasing with the ever-growing pace of life and development of new technologies. \n\nModern software engineering practices the development of domain-specific programming languages to solve specific practical problems and describe the domain objects. To develop complex domainspecific languages, specialized tools are used [8,9]. Visual languages such as flowcharts and UML activity diagrams have been developed and widely used to describe software algorithms [10,11]. At the same time, there is no full-fledged unified application-oriented symbolic (text) language for the description of program algorithms. \n\nWith the language intended for practical application it will be possible to introduce a uniform system of software algorithms created with different visual languages, using their various notations. It will be possible to use a single code generator tool for the algorithm described in the target programming language, instead of selecting a specific code-generator tool for a particular diagram. In turn, this will significantly speed up the development of software, N-version software in particular, since considerable time and resources are spent to develop various versions of software units, which should only differ in the way of implementation, for example, the algorithm used to solve a very specific problem.",
            "score": 0.30887401304497075,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 165
                },
                {
                    "start": 166,
                    "end": 293
                },
                {
                    "start": 296,
                    "end": 396
                },
                {
                    "start": 397,
                    "end": 556
                },
                {
                    "start": 557,
                    "end": 772
                },
                {
                    "start": 775,
                    "end": 939
                },
                {
                    "start": 940,
                    "end": 1018
                },
                {
                    "start": 1019,
                    "end": 1157
                },
                {
                    "start": 1158,
                    "end": 1297
                },
                {
                    "start": 1300,
                    "end": 1497
                },
                {
                    "start": 1498,
                    "end": 1695
                },
                {
                    "start": 1696,
                    "end": 2016
                }
            ],
            "ref_mentions": [
                {
                    "start": 158,
                    "end": 161,
                    "matchedPaperCorpusId": "53080324"
                },
                {
                    "start": 283,
                    "end": 286,
                    "matchedPaperCorpusId": "7827511"
                },
                {
                    "start": 286,
                    "end": 289,
                    "matchedPaperCorpusId": "37160034"
                },
                {
                    "start": 289,
                    "end": 292,
                    "matchedPaperCorpusId": "53080971"
                },
                {
                    "start": 1015,
                    "end": 1017,
                    "matchedPaperCorpusId": "52094868"
                },
                {
                    "start": 1149,
                    "end": 1153,
                    "matchedPaperCorpusId": "11249653"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8564453125
        },
        {
            "corpus_id": "246560699",
            "title": "Algorithmic Design in Virtual Reality",
            "text": "The present research proposes to augment the workflow proposed by Castelo-Branco et al. [32], namely by (1) focusing on the textual paradigm alone, (2) depicting the building blocks of the proposed system in order to provide readers with a reproducible methodology they can use, and (3) performing preliminary evaluation exercises to understand the main benefits and challenges of the proposed solution. \n\nAlthough it is possible to use the interaction mechanisms available in visual programming to manipulate code in VR, the complexity of the models that most benefit from immersive visualization make visual programming an inviable solution. Despite being more difficult to learn, textual programming languages tend to offer more expressive power, scalability, flexibility, and efficiency than visual ones [34,35]. Hence, we propose to enrich the design experience by integrating a textual-based AD practice, which natively supports extensive design changes, with VR, an intrinsically interactive and immersive medium. The following sections present ADVR, a methodology for interacting with textual AD programs and models in VR. To achieve the aforementioned goals, this investigation involved the following steps: \n\n1. \n\nStudying existing solutions for the integration of parametric solutions in VR.",
            "score": 0.30887401304497075,
            "section_title": "Goals and Methods",
            "char_start_offset": 9278,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 403
                },
                {
                    "start": 406,
                    "end": 643
                },
                {
                    "start": 644,
                    "end": 816
                },
                {
                    "start": 817,
                    "end": 1020
                },
                {
                    "start": 1021,
                    "end": 1130
                },
                {
                    "start": 1131,
                    "end": 1216
                },
                {
                    "start": 1219,
                    "end": 1221
                },
                {
                    "start": 1224,
                    "end": 1302
                }
            ],
            "ref_mentions": [
                {
                    "start": 88,
                    "end": 92,
                    "matchedPaperCorpusId": "214286175"
                },
                {
                    "start": 808,
                    "end": 812,
                    "matchedPaperCorpusId": "203200869"
                },
                {
                    "start": 812,
                    "end": 815,
                    "matchedPaperCorpusId": "62524830"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.392822265625
        },
        {
            "corpus_id": "236566925",
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "text": "Pattison and J. Hummel. (2004) defined it as the modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer (10) . \n\nThe researchers defined it as Programming that relies primarily on graphical interfaces in interaction. It depends also on seeing graphics and images and interacting with them completely by the user. This may add fun and interaction in the use and creates an atmosphere of positive interaction by the secondary stage students.",
            "score": 0.30887401304497075,
            "section_title": "Visual programming",
            "char_start_offset": 15795,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 23
                },
                {
                    "start": 24,
                    "end": 211
                },
                {
                    "start": 212,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 479
                },
                {
                    "start": 482,
                    "end": 585
                },
                {
                    "start": 586,
                    "end": 681
                },
                {
                    "start": 682,
                    "end": 808
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91357421875
        },
        {
            "corpus_id": "258968122",
            "title": "Neural Task Synthesis for Visual Programming",
            "text": "In existing visual programming platforms, programming tasks are hand-curated by tutors and the available set of tasks is typically very limited, posing a major hurdle for novices in mastering the missing concepts (Zhi et al., 2019;Ahmed et al., 2020). To this end, we seek to design generative models that can automatically synthesize visual programming tasks for a given specification (see Figure 1). \n\nStudent is working on task T ref , struggling with obtaining a solution code C ref . \n\nAI system extracts the specifications \u03c8 in for a simpler task. \n\nAI system generates a task T out based on \u03c8 in , and delivers it to student. \n\n(a) An interaction between student and AI system.",
            "score": 0.30887401304497075,
            "section_title": "Introduction",
            "char_start_offset": 1440,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 251
                },
                {
                    "start": 252,
                    "end": 401
                },
                {
                    "start": 404,
                    "end": 488
                },
                {
                    "start": 491,
                    "end": 553
                },
                {
                    "start": 556,
                    "end": 632
                },
                {
                    "start": 635,
                    "end": 684
                }
            ],
            "ref_mentions": [
                {
                    "start": 213,
                    "end": 231,
                    "matchedPaperCorpusId": "67866622"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92041015625
        },
        {
            "corpus_id": "13395203",
            "title": "Visualizing Computer Programming in a Computer-based Simulated Environment",
            "text": "Particular emphasis was placed on instructions related to loops and functionsfor the Introduction to Programming course, and on classes and objectsfor the Object-Oriented Programming course. \n\nTo demonstrate the benefit obtained from these visualization scenarios, below is an example of a program instruction handled by this research, which was visualized within Second Life. Learners found this instruction extremely difficult to understand and to imagine how it works and what the potential execution outcomes are. They considered visualizing this instructions\" execution within Second Life very beneficial to their understanding of its function, structure and results. The advantages of visualizing programming instructions within the virtual platform were confirmed by students\" answers to the following question asked by the researcher to the learners at the end of a whole session explaining the \"For Loop\" in the physical classroom: \"Which of these two For-Loop scripts result in moving the object six steps towards the X-axis?\" \n\n(1) For (i=0; i<6; i++) llSetPos(llGetPos()+<i,0,0>); \n\n(2) For (i=0; i<6; i++) llSetPos(llGetPos()+<1,0,0>); Some students were confident of their answer, and some were not. Those who were not 100% confident were permitted by the researcher to provide a prediction based on their current/background understanding of programming. It was a surprise to both the researcher and learners that all the answers of confident learners were wrong, while around half of not fully confident learners gave the correct answer; however, they were unable to correctly justify it. This was then followed by using the virtual environment to visualize the execution of the above code. When the students worked on moving their \"Pok\u00e9mons\" in Second Life, they were able to view the difference in the number of steps moved by the object as a result of the execution of each script sample. Following this visualization, they were able to provide confident explanations on how each \"For Loop\" of the above works.",
            "score": 0.30887401304497075,
            "section_title": "C. Application of Virtual World Technologies in the Learning of Computer Programming",
            "char_start_offset": 22338,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 190
                },
                {
                    "start": 193,
                    "end": 376
                },
                {
                    "start": 377,
                    "end": 517
                },
                {
                    "start": 518,
                    "end": 672
                },
                {
                    "start": 673,
                    "end": 1036
                },
                {
                    "start": 1039,
                    "end": 1092
                },
                {
                    "start": 1095,
                    "end": 1213
                },
                {
                    "start": 1214,
                    "end": 1368
                },
                {
                    "start": 1369,
                    "end": 1603
                },
                {
                    "start": 1604,
                    "end": 1705
                },
                {
                    "start": 1706,
                    "end": 1906
                },
                {
                    "start": 1907,
                    "end": 2028
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83740234375
        },
        {
            "corpus_id": "84187268",
            "title": "MP net as abstract model of communication for message-passing applications",
            "text": "The motivation and original idea for the work presented here comes from the work on the tool Kaira [3,4,2]. Kaira is a development environment for applications using MPI. It strictly separates the communication and computational layers of the application. The former one is specified via a visual programming language while the latter one is written in C++. From the combination of these two inputs the MPI code of the resulting application is eventually generated. Despite many nice features the Kaira is provided with, it has not been used by people other than those from the developer's group. Yet the idea of using a visual form for describing communication seems to be right because it emphasizes the spatial character of the communication. However, it turned out that using this visual form as an input which is provided and created by programmers, is similarly demanding as writing the application using MPI. \n\nThe current work aims to reverse the process and instead of modeling the communication via a visual language, the goal is to provide an abstract model of communication for an existing code of an MPI application. In a fully automatic way without need of any modification in the analyzed program. Hence, it shifts the paradigm from the field of visual programming to program visualization. In this way, the programmer is a reader of such model and not its creator. \n\nThe genre of visual programming has been defined by Grafton and Ichikawa [7] and includes three distinct areas: graphics techniques that provide both static and dynamic multidimensional views of software, graphics-based high-level programming languages, and animation of algorithms and software [16]. Their work was later refined by Myers [14]. He strongly distinguished visual programming, program visualization, and other high-level programming paradigms. Moreover, he also provided two taxonomies for the classification of programming systems, one for visual programming and the other for program visualization. A nice overview of possible program visualization is summarized in [12]. A brief overview of these categories can be seen in Figure 2. Each category is filled with examples. As can be seen, the program visualization is divided into four quadrants according to whether the analysis is done on code or data and whether a static or dynamic aspect is investigated. MP nets fall into the static-code analysis.",
            "score": 0.30887401304497075,
            "section_title": "Related work",
            "char_start_offset": 2975,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 107
                },
                {
                    "start": 108,
                    "end": 170
                },
                {
                    "start": 171,
                    "end": 255
                },
                {
                    "start": 256,
                    "end": 357
                },
                {
                    "start": 358,
                    "end": 465
                },
                {
                    "start": 466,
                    "end": 596
                },
                {
                    "start": 597,
                    "end": 745
                },
                {
                    "start": 746,
                    "end": 915
                },
                {
                    "start": 918,
                    "end": 1129
                },
                {
                    "start": 1130,
                    "end": 1212
                },
                {
                    "start": 1213,
                    "end": 1305
                },
                {
                    "start": 1306,
                    "end": 1380
                },
                {
                    "start": 1383,
                    "end": 1683
                },
                {
                    "start": 1684,
                    "end": 1727
                },
                {
                    "start": 1728,
                    "end": 1840
                },
                {
                    "start": 1841,
                    "end": 1997
                },
                {
                    "start": 1998,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2132
                },
                {
                    "start": 2133,
                    "end": 2171
                },
                {
                    "start": 2172,
                    "end": 2358
                },
                {
                    "start": 2359,
                    "end": 2402
                }
            ],
            "ref_mentions": [
                {
                    "start": 1678,
                    "end": 1682,
                    "matchedPaperCorpusId": "35258578"
                },
                {
                    "start": 1722,
                    "end": 1726,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 2065,
                    "end": 2069,
                    "matchedPaperCorpusId": "33953106"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8916015625
        },
        {
            "corpus_id": "4793447",
            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
            "text": "This paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.",
            "score": 0.30887401304497075,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97021484375
        },
        {
            "corpus_id": "270559828",
            "title": "Program Synthesis Benchmark for Visual Programming in XLogoOnline Environment",
            "text": "XLogoOnline [14] is a visual programming platform based on Logo programming language [37] and is widely used by tens of thousands of students every year [38,39].In this work, we focus on the Mini-level (XLogoOnline-Mini).In XLogoOnline-Mini, each task includes a text description of the goal and code constraints, along with a two-dimensional visual grid.The visual grid features a turtle and various elements such as fruits, shapes, colors, lines, walls, and forbidden areas.To solve the task, one needs to write a program to direct the turtle's movement in the visual grid to achieve the specified goal.Figure 1 shows illustrative examples of tasks, the required skills, and solution codes.\n\nRequired skills for XLogoOnline-Mini.We examine the skills required for solving visual programming tasks in XLogoOnline-Mini.Specifically, the visual programming tasks in our domain cover the following skills:",
            "score": 0.30887401304497075,
            "section_title": "Background on XLogoOnline-Mini Programming",
            "char_start_offset": 6242,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 161
                },
                {
                    "start": 161,
                    "end": 221
                },
                {
                    "start": 221,
                    "end": 355
                },
                {
                    "start": 355,
                    "end": 476
                },
                {
                    "start": 476,
                    "end": 605
                },
                {
                    "start": 605,
                    "end": 692
                },
                {
                    "start": 694,
                    "end": 731
                },
                {
                    "start": 731,
                    "end": 819
                },
                {
                    "start": 819,
                    "end": 903
                }
            ],
            "ref_mentions": [
                {
                    "start": 157,
                    "end": 160,
                    "matchedPaperCorpusId": "232172217"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94873046875
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "There are several issues still to be resolved with BridgeTalk. These issues fall into the general areas of visual appearence, implementation, and usage. We take up each topic separately.\n\nThe most problematic issue with the visual appearence of BridgeTalk is the difficulty of expressing nesting. In particular, the current version can visually express only one level of nesting, and that one level with only a fixed number of contained elements. The problem is that there must be only a small finite amount of space to put a contained element if the parent icon is visually containing them. Inevitably, we will need to go to some sort of grow/shrink scheme for the contained elements. We have resisted this because it is inherently disturbing and confusing unless the grow/shrink transistion is smooth and obviously reversable. Most visual languages address this problem by using small icon elements that expand to windows. This solution is unacceptable due to our experience suggesting the importance of icon shapes suggesting the icon usage.\n\nThe BridgeTalk implementation is still incomplete. In particular, we still have not completed the browsers that allow a user to navigate the structures showing plan inheritance and implementation, as pictured in Figures 8 and 9. We will have a challenge in distinguishing this representation from the specific plan icons used at the surface level. On the otherhand, we feel these structures are a crucial tool for teaching students to understand the management of abstraction.\n\nThe final area of future work suggested by this work is the most complex: how is this tool and approach best used? In our attempt to tease apart the expression of intentions to a computer, we have become increasingly suspicious of the glib discussion of \"top-down design\" found in most programming textbooks. In particular, the design of BridgeTalk shows that programming design involves many different mappings, including: informal to formal, declarative to procedural, goals to plans and processes, natural language to Pascal, linear structure to tree structure, and weakly constrained to strongly constrained. We believe that programming texts do their students a disservice by presenting a design model that at best ignores the differences between novices and experts, and at worst is completly unrelated to actual programming practice.",
            "score": 0.3075240179874536,
            "section_title": "Future Steps",
            "char_start_offset": 54366,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.619140625
        },
        {
            "corpus_id": "270226547",
            "title": "Learning to Edit Visual Programs with Self-Supervision",
            "text": "We have presented a system that learns how to edit visual programs in a goal-directed fashion. We develop a self-supervised bootstrapping approach that allows us to train an edit network for domains that lack ground-truth program annotations. We compare our proposed paradigm, that jointly finetunes a one-shot model and an edit network, against the alternative of using only a one-shot model, and find that our approach infers more accurate program reconstructions. Further, we find this performance gap is more pronounced when more time is spent on program search or when less training data is available. Finally, we justified the design of our method with an ablation experiment. \n\nWhile our proposed approach advances the field of visual program induction, it does come with a few limitations. Compared with prior work, we need to train another network, this impacts the time required for both pretraining and finetuning stages. Moreover, the full benefit of using an edit network is best realized with a more complex program search, and as such we use search-time budgets that are slightly more costly compared with prior work. Though our formulation would offer improved performance for work-flows that can afford to spent more time on program search, it would be useful to consider potential speed-ups of our system [7]. Finally we note that our current formulation requires access to a domain-aware findEdits operation that can analytically find a set of edits that realizes a transformation from a start program to an end program. While we find that our implementation generalizes across a range of visual programming domains, in future work, it would be interesting to consider to what degree this domain-aware procedure could be replaced by more general program difference algorithms [32]. Looking ahead, we believe our framework can serve as inspiration for how to train networks that learn how to edit programs without ground-truth annotations over an even wider array of program synthesis tasks. \n\nTable 3: We evaluate reconstruction accuracy for \"challenge\" tasks that come from concepts or categories not present in the target training set. For both layout and 3D CSG, we observe that our joint paradigm that integrates an edit network with one-shot models outperforms the alternative of using only one-shot models.",
            "score": 0.30654300668007606,
            "section_title": "Discussion",
            "char_start_offset": 30732,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 94
                },
                {
                    "start": 95,
                    "end": 242
                },
                {
                    "start": 243,
                    "end": 466
                },
                {
                    "start": 467,
                    "end": 606
                },
                {
                    "start": 607,
                    "end": 682
                },
                {
                    "start": 685,
                    "end": 797
                },
                {
                    "start": 798,
                    "end": 932
                },
                {
                    "start": 933,
                    "end": 1132
                },
                {
                    "start": 1133,
                    "end": 1327
                },
                {
                    "start": 1328,
                    "end": 1539
                },
                {
                    "start": 1540,
                    "end": 1800
                },
                {
                    "start": 1801,
                    "end": 2009
                },
                {
                    "start": 2012,
                    "end": 2156
                },
                {
                    "start": 2157,
                    "end": 2331
                }
            ],
            "ref_mentions": [
                {
                    "start": 1795,
                    "end": 1799,
                    "matchedPaperCorpusId": "265659878"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7919921875
        },
        {
            "corpus_id": "15911792",
            "title": "Visualization of Object-oriented (Java) Programs",
            "text": "We provide an explicit, consistent, execution model for OO programs, specifically Java, together with a tool that visualizes the model This equips the student with a model to think and communicate about OO programs. Especially for an e-learning situation this is significant. Firstly, such a model supports the interaction with teachers and provides a sound basis for the understanding of other e-learning material concerning programming. Secondly, the tool supports acquiring proficiency with the model in an e-learning setting by giving precise information to hone his/her conceptualization of program execution. The model is advanced in that it accommodates multi-threading. The tool is flexible in that it directly uses the Java Virtual Machine for the visualization: extensions and adaptations can thus make use of the information the actual execution provides. A case in point is modeling the execution of code involving user interaction through the Graphic User Interface library. We consider several options here. Keywords: Object-oriented programming; Program visualization",
            "score": 0.3058360598962842,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5546875
        },
        {
            "corpus_id": "216202070",
            "title": "Web Application to Support the Learning of Programming Through the Graphic Visualization of Programs",
            "text": "Figure 8 shows a screenshot of the web application once it has started the execution of a program that is responsible for calculating the factorial of a number, and after having pressed the step by step control several times. The animation of the program is in a step where there are several blocks of instances of method calls (in dark brown color), as well as blocks that represent the conditional control structures if and else (in black and gray color), which are part of the execution of the program. Additionally, the blocks of variables (in light brown color) are observed, which are stacked on the block of the method or control structure to which they belong. It can also be seen the source code of the program that is running in the text editor, where the last instruction that was executed in the animation is marked, with orange background color, as well as the instruction that will be executed in the next step, with pink background color. This program is more complex than the previous one and shows the way in which the stack of method calls and control structures are visually represented in the application, as well as the creation of variables corresponding to each of them.",
            "score": 0.3058360598962842,
            "section_title": "Program to calculate the factorial of a number",
            "char_start_offset": 28961,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 225
                },
                {
                    "start": 226,
                    "end": 505
                },
                {
                    "start": 506,
                    "end": 668
                },
                {
                    "start": 669,
                    "end": 953
                },
                {
                    "start": 954,
                    "end": 1193
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.73681640625
        },
        {
            "corpus_id": "6764231",
            "title": "A Proposed Framework for Development of a Visualizer Based on Memory Transfer Language (MTL)",
            "text": "Numerous program visualization tools have been developed and deployed. Though the rationale behind all visualizers is almost the same, each one has come up with unique features and functionalities and distinct ways of helping novices to program. Mutua et al [8] posit that, visualization tools have been developed to supplement the learning process; in that regard various forms of teaching aids, models and software systems are deployed in enhancing the learning process. Different visualizers for different programming languages such as C, C++ and JAVA are available today. Kasurinen et al [4], deployed a program visualization tool (Turtlet) to enhance student motivation and interest towards programming in the introductory programming course by applying visualization tool to lecture demonstrations. Alice, a 3-D interactive graphics programming environment developed with a goal to make it easy for novices to develop interesting 3-D environments and to explore the new medium of interactive 3-D graphics. Alice serves as a good programming language for the novice programmers as they can follow up and see how their animated programs run [9]. Some other visualizers developed include BlueJ, Jeliot, JPie and Scratch.",
            "score": 0.3058360598962842,
            "section_title": "B. Program Visualization Tools",
            "char_start_offset": 3528,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 70
                },
                {
                    "start": 71,
                    "end": 245
                },
                {
                    "start": 246,
                    "end": 472
                },
                {
                    "start": 473,
                    "end": 575
                },
                {
                    "start": 576,
                    "end": 804
                },
                {
                    "start": 805,
                    "end": 1011
                },
                {
                    "start": 1012,
                    "end": 1149
                },
                {
                    "start": 1150,
                    "end": 1223
                }
            ],
            "ref_mentions": [
                {
                    "start": 258,
                    "end": 261,
                    "matchedPaperCorpusId": "208974128"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7939453125
        },
        {
            "corpus_id": "231785967",
            "title": "Hybrid Java: The creation of a Hybrid Programming Environment",
            "text": "Some researchers and educators have had good success using a visual FPL as their language of choice (Aktunc, 2013;Asamoah, 2006;Noone & Mooney, 2019a). \n\nResearch has shown that there is a certain age group (13-16 year olds) where many students begin to consider visual programming languages too limited; but they are still at a point where they consider text-based languages too verbose and difficult to learn (Cheung et al., 2009). There is an increasing need for languages that combine the power of a text-based language with the simplistic design of a visual language. These so-called hybrid programming languages would allow for the introduction of more complex programming concepts to students in a more welcoming and more suitable interface. A need for a hybrid language is growing alongside the increasing interest among young people in computer programming. To satisfy this need, we have created a programming environment that combines the effectiveness of a text-based programming language with the ease of use of a visual programming language. We call this programming environment \"Hybrid Java\". The goal for this environment is to combine the power of a text-based language with the ease of use of a visual language which may be used as a first programming language or as a bridge when moving from a visual language to a textbased language.",
            "score": 0.3058360598962842,
            "section_title": "Introduction",
            "char_start_offset": 2226,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 151
                },
                {
                    "start": 154,
                    "end": 433
                },
                {
                    "start": 434,
                    "end": 572
                },
                {
                    "start": 573,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 866
                },
                {
                    "start": 867,
                    "end": 1054
                },
                {
                    "start": 1055,
                    "end": 1106
                },
                {
                    "start": 1107,
                    "end": 1352
                }
            ],
            "ref_mentions": [
                {
                    "start": 100,
                    "end": 114,
                    "matchedPaperCorpusId": "16916893"
                },
                {
                    "start": 411,
                    "end": 432,
                    "matchedPaperCorpusId": "10839854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.64794921875
        },
        {
            "corpus_id": "128364433",
            "title": "The state of the art in end-user software engineering",
            "text": "Eagan and Stasko 2008], and tailoring [Trigg andB\u00f8dker 1994, Kahler 2001] include parameterization of existing programs, but not direct modification of a program's source code. Visual programming refers to a set of interaction techniques and visual notations for expressing programs. The phrase often implies use by end-user programmers, but visual notations are not always targeted at a particular type of programming practice. Domain-specific languages are programming languages designed for writing programs for a particular kind of context or practice. End-user programming may or may not involve such languages, since what defines end-user programming is the intent, not the choice of languages or tools. Finally, scripts and scripting languages are often distinguished from programs and programming languages by the use of machine interpretation rather than compilation and their \"high-level\" use in coordinating the functions of multiple programs or services. The phrase end-user programming, because it is often conflated with inexperience, often connotes the use of scripting languages since these languages have the reputation of being easier to learn.",
            "score": 0.3058360598962842,
            "section_title": "End-User Programming",
            "char_start_offset": 17257,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 38,
                    "end": 48,
                    "matchedPaperCorpusId": "15325916"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89501953125
        },
        {
            "corpus_id": "276684953",
            "title": "Two Approaches for Programming Education in the Domain of Graphics: An Experiment",
            "text": "Participants answered a post-survey with the following questions, all on a seven-point Likert scale from 1 (\"not at all true\") to 7 (\"completely true\"): \n\n14:38 I found the preceding lessons interesting. I feel that I learned about programming concepts from these lessons. I already knew beforehand how to do graphical programming similar to what was taught in the lessons. I already knew beforehand all the general programming content (variables, functions, loops, etc.) that was covered in the lessons. Programming with graphics is fun. I like programming with graphics more than the text-based programming we have done in CS1. I would like to learn more about programming with graphics.",
            "score": 0.3058360598962842,
            "section_title": "C Post-Survey",
            "char_start_offset": 72160,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 152
                },
                {
                    "start": 155,
                    "end": 203
                },
                {
                    "start": 204,
                    "end": 272
                },
                {
                    "start": 273,
                    "end": 373
                },
                {
                    "start": 374,
                    "end": 504
                },
                {
                    "start": 505,
                    "end": 538
                },
                {
                    "start": 539,
                    "end": 629
                },
                {
                    "start": 630,
                    "end": 689
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.31787109375
        },
        {
            "corpus_id": "270620622",
            "title": "VDebugger: Harnessing Execution Feedback for Debugging Visual Programs",
            "text": "We hereby discuss the potential limitations of our work: \n\n(1) In this work, our critic model can provide basic explanations of identified errors by predicting errors locations. However, human programmers may benefit from more detailed explanations in natural language. The automatic collection of such text-rich description is very challenging. Therefore, obtaining expert annotations would be a valu-able though costly future step to enhance the interpretability of the debugging process. \n\n(2) Our work mainly focuses on established tasks such as visual question answering and visual grounding. While these tasks demonstrate the effectiveness of our framework, real-world applications often require systems to interact dynamically with humans, respond to open-ended questions, and perform on-demand reasoning. Although our current work does not directly address these complex, real-world scenarios, we believe our method is generic framework that can be adapted for such applications. Exploring the application of our selfdebugging method to more in-the-wild and diverse scenarios is an exciting direction for future research. \n\n(3) Following prior work (Gupta and Kembhavi, 2023;Sur\u00eds et al., 2023), our method utilizes a text-only language model (LLM) to generate visual programs, which may introduce limitations to its capabilities. Incorporating visual information and/or jointly training the debugger with foundational VLMs could be a valuable direction for future research, potentially further enhancing its self-critic capabilities. \n\nVisual programming and end-to-end VLMs are two different approaches to visual reasoning. Visual programming invokes multiple foundation VLMs through code, while end-to-end VLMs directly take an image as input and generate texts as output. Despite their seemingly different methodologies, visual programming is a complementary technique that can be combined with end-to-end VLMs to offer additional benefits. Firstly, visual programming can integrate with more powerful VLMs to further enhance performance as shown in Table 8. Secondly, despite the rapid development of endto-end VLMs, they still have difficulty reasoning with compositional concepts such as counting and spatial relationship. Visual programming offer benefits in tasks like such as compositional reasoning, counting, and enhancing interpretability.",
            "score": 0.3058360598962842,
            "section_title": "Limitations",
            "char_start_offset": 22667,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 56
                },
                {
                    "start": 59,
                    "end": 177
                },
                {
                    "start": 178,
                    "end": 269
                },
                {
                    "start": 270,
                    "end": 345
                },
                {
                    "start": 346,
                    "end": 490
                },
                {
                    "start": 493,
                    "end": 597
                },
                {
                    "start": 598,
                    "end": 812
                },
                {
                    "start": 813,
                    "end": 987
                },
                {
                    "start": 988,
                    "end": 1129
                },
                {
                    "start": 1132,
                    "end": 1338
                },
                {
                    "start": 1339,
                    "end": 1542
                },
                {
                    "start": 1545,
                    "end": 1633
                },
                {
                    "start": 1634,
                    "end": 1783
                },
                {
                    "start": 1784,
                    "end": 1952
                },
                {
                    "start": 1953,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2237
                },
                {
                    "start": 2238,
                    "end": 2360
                }
            ],
            "ref_mentions": [
                {
                    "start": 1157,
                    "end": 1183,
                    "matchedPaperCorpusId": "253734854"
                },
                {
                    "start": 1183,
                    "end": 1202,
                    "matchedPaperCorpusId": "257505358"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85693359375
        },
        {
            "corpus_id": "274423109",
            "title": "ScratchEval: Are GPT-4o Smarter than My Child? Evaluating Large Multimodal Models with Visual Programming Challenges",
            "text": "Recent advancements in large multimodal models (LMMs) have showcased impressive code generation capabilities, primarily evaluated through image-to-code benchmarks. However, these benchmarks are limited to specific visual programming scenarios where the logic reasoning and the multimodal understanding capacities are split apart. To fill this gap, we propose ScratchEval, a novel benchmark designed to evaluate the visual programming reasoning ability of LMMs. ScratchEval is based on Scratch, a block-based visual programming language widely used in children's programming education. By integrating visual elements and embedded programming logic, ScratchEval requires the model to process both visual information and code structure, thereby comprehensively evaluating its programming intent understanding ability. Our evaluation approach goes beyond the traditional image-to-code mapping and focuses on unified logical thinking and problem-solving abilities, providing a more comprehensive and challenging framework for evaluating the visual programming ability of LMMs. ScratchEval not only fills the gap in existing evaluation methods, but also provides new insights for the future development of LMMs in the field of visual programming. Our benchmark can be accessed at https://github.com/HKBUNLP/ScratchEval .",
            "score": 0.3058360598962842,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.74755859375
        },
        {
            "corpus_id": "271993454",
            "title": "Developing Programming Competencies in School-Students With Block-Based Tools in Chile, Ecuador, and Peru",
            "text": "Schools can review their primary activities to incorporate and apply computational thinking across core subjects, necessitating adjustments to teaching curricula to encompass programming competencies and block-based environments tailored for children, such as Scratch and TinkerCAD [36]. Various fields incorporate computational thinking into their research endeavors, suggesting that developing programming competencies can be a rewarding and engaging pursuit [10]. \n\nMladenovi\u0107, Boljat, and \u017danko [62] studied programming concepts, mainly focusing on loops, comparing their use in Scratch, Logo, and Python. The study found that most misconceptions about loops are significantly reduced when they use block-based programming languages, such as Scratch, rather than text-based programming languages. The study also found that while students were equally successful in completing tasks in Logo and Python, issues arose predominantly with Python when nested loops were involved. These findings underscore the suitability of visual programming languages like Scratch for teaching programming to K-12 novices, mainly through game development. By eliminating syntax obstacles, students can concentrate on grasping fundamental algorithms. Moreover, compared to text-based languages, visual programming significantly minimizes misconceptions.",
            "score": 0.3058360598962842,
            "section_title": "D. RELATED WORK",
            "char_start_offset": 18562,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 466
                },
                {
                    "start": 469,
                    "end": 609
                },
                {
                    "start": 610,
                    "end": 800
                },
                {
                    "start": 801,
                    "end": 977
                },
                {
                    "start": 978,
                    "end": 1139
                },
                {
                    "start": 1140,
                    "end": 1233
                },
                {
                    "start": 1234,
                    "end": 1336
                }
            ],
            "ref_mentions": [
                {
                    "start": 461,
                    "end": 465,
                    "matchedPaperCorpusId": "253880901"
                },
                {
                    "start": 499,
                    "end": 503,
                    "matchedPaperCorpusId": "22570972"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.630859375
        },
        {
            "corpus_id": "266741858",
            "title": "A Vision Check-up for Language Models",
            "text": "For this study, we evaluate four language models, each tested on four different programming languages. \n\n(i) Language models: We evaluate the visual competence of GPT-3.5 (both text-davinci-003 and  GPT-3.5-turbo models) and GPT-4 3 . Models, like Llama2 (chat 70B), GPT-J, and GPT-2 failed to generate executable image-rendering code reliably and are excluded from analysis in the main paper but are included in the SM. \n\n(ii) Programming languages. To validate that a model's visual capability is not restricted to a specific programming language we use four programming languages with different expressiveness. These are: python-matplotlib, pythonturtle, Processing (built over Java), and TikZ (built over Tex). A model's ability to generate and recognize the same visual concept across programming languages hints at the model possibly having a coherent and language-agnostic representation of that concept.",
            "score": 0.3058360598962842,
            "section_title": "Models and Programming Languages tested",
            "char_start_offset": 11260,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 102
                },
                {
                    "start": 105,
                    "end": 212
                },
                {
                    "start": 213,
                    "end": 234
                },
                {
                    "start": 235,
                    "end": 420
                },
                {
                    "start": 423,
                    "end": 450
                },
                {
                    "start": 451,
                    "end": 613
                },
                {
                    "start": 614,
                    "end": 714
                },
                {
                    "start": 715,
                    "end": 911
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1842041015625
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "InstructPipe contributes a framework for generating specifications for visual programming pipelines based on text prompts from users. To characterize the system's performance, we designed a technical evaluation to assess the accuracy of the generated graphs for a variety of prompts.",
            "score": 0.3058360598962842,
            "section_title": "Technical Evaluation",
            "char_start_offset": 25268,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 283
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5185546875
        },
        {
            "corpus_id": "232093833",
            "title": "SIMDGiraffe: Visualizing SIMD Functions",
            "text": "They must also be maintained and updated. \n\nEven if the performance of these tools were to be optimized, vector programming will probably remain the choice of certain types of programmers such as library developers (Wang et al., 2014). Therefore, we have to face the difficulties inherent in vector programming if we really want to benefit from the advantages it offers. Precisely, to face these difficulties, the actors of vector programming have developed several strategies including communication through images. These visual representations are used as well to explain an isolated vector instruction (InstLatX64, 2018;Stupachenko, 2015) as to explain a vector code (Dirty hands coding, 2019; Mu\u0142a and Lemire, 2018). The common weakness of all these uses of images is that they only target those particular cases for which these images are produced, but also, they can be biased as they can be subject to the expert blind spot effect (Nathan et al., 2001). These uses of visual representations are software visualization albeit at a rudimentary level.",
            "score": 0.3058360598962842,
            "section_title": "Works on Intrinsic Functions",
            "char_start_offset": 5872,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 41
                },
                {
                    "start": 44,
                    "end": 235
                },
                {
                    "start": 236,
                    "end": 370
                },
                {
                    "start": 371,
                    "end": 516
                },
                {
                    "start": 517,
                    "end": 720
                },
                {
                    "start": 721,
                    "end": 960
                },
                {
                    "start": 961,
                    "end": 1055
                }
            ],
            "ref_mentions": [
                {
                    "start": 215,
                    "end": 234,
                    "matchedPaperCorpusId": "10432040"
                },
                {
                    "start": 706,
                    "end": 719,
                    "matchedPaperCorpusId": "8265597"
                },
                {
                    "start": 938,
                    "end": 959,
                    "matchedPaperCorpusId": "14779203"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1925048828125
        },
        {
            "corpus_id": "15725477",
            "title": "Effectiveness of Combining Algorithm and Program Animation: A Case Study with Data Structure Course",
            "text": "The normal method is to use an external visualizer system, so the program must send set of commands to that visualizer in order to animate the execution of the program and the data structure related with. The external visualization engine reads the commands from the generated file from the algorithm, and then starts to animate the algorithm after its actual program finished. This study is a report of the Embedded Animation Courseware System the author designed and implemented; the embedding strategy bypasses the necessity of the data-structure code having to send commands to the independent visualization system. The animation is performed within the program script and this method produces more reliable animations. The strategies of the normal method of visualization and the embedding method are illustrated through Figures 1 and 2. The quick sort algorithm is demonstrated in Figure 3, provides the implementation in C++ at the left-hand side, indicates the current statement to be executed in white color, the array shape with values, indexes and special variables are showed on the top, the most important variables can be tracked with their in-progress values on the right-hand side, and the user will be guided and supplied by additional information through the system message area which appears at the bottom of the code area, in addition to the system stack. Through system stack, which is in brown color, the user has a chance to trace the recursion without missing the sequence, after the call of sort(1,4) finished, the algorithm will return to sort(1,5) in order to continue. The figure shows that the algorithm now is running sort(1,4) and from the code area the user can see that the current statement to execute is colored in white which is a function call of swap(A[i], A[j]), this function will be loaded, the system stack will grow, and the function code will be shown on the code area to start executing and showing its local variables. \n\nThe Binary Search Tree (BST) is demonstrated through Figures 4 and 5, additional parts were added, the new parts are directions and user input area, as showed in Figure 5. Directions is a list of possible commands or functions applied to the BST, and the user input is for accept the user command, so the student is free to call the suitable function.",
            "score": 0.3058360598962842,
            "section_title": "Method of Visualization",
            "char_start_offset": 14463,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 204
                },
                {
                    "start": 205,
                    "end": 377
                },
                {
                    "start": 378,
                    "end": 619
                },
                {
                    "start": 620,
                    "end": 723
                },
                {
                    "start": 724,
                    "end": 1375
                },
                {
                    "start": 1376,
                    "end": 1596
                },
                {
                    "start": 1597,
                    "end": 1964
                },
                {
                    "start": 1967,
                    "end": 2318
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.50927734375
        },
        {
            "corpus_id": "259335765",
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "text": "To help novice programmers write syntactically correct programs, we chose to implement our study using a custom graphical programming language. Programs like the \"hour of code\" have demonstrated that novice programmers, even those in elementary school, can solve problems using graphical programming languages [7,8,10]. Prior work on serious games has identified that block-based programming is a common pattern in programming games related to conditional and iterative control structures [35]. The programming language for our study was implemented using Google Blockly [36]. Figure 2 shows the development environment for programs written as part of this study. At the beginning of the study, the programmer has access to only two blocks -Start Token and Move Right. Start Token is equivalent to the start of a thread in a parallel program, and Move Right is an action that can be taken by a token on the game board, which is equivalent to an action taken by a thread in a parallel program. As the participant progresses through the study, they gain access to additional and more complex blocks. Each new block is explained to the participant by example in the introductory rounds of the study. Once the participant has completed the example problems and learned all of the required blocks, they move on to solving parallel programming problems using these blocks.",
            "score": 0.3058360598962842,
            "section_title": "Graphical Programming",
            "char_start_offset": 17297,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 143
                },
                {
                    "start": 144,
                    "end": 319
                },
                {
                    "start": 320,
                    "end": 494
                },
                {
                    "start": 495,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 768
                },
                {
                    "start": 769,
                    "end": 992
                },
                {
                    "start": 993,
                    "end": 1097
                },
                {
                    "start": 1098,
                    "end": 1196
                },
                {
                    "start": 1197,
                    "end": 1366
                }
            ],
            "ref_mentions": [
                {
                    "start": 310,
                    "end": 313,
                    "matchedPaperCorpusId": "235383033"
                },
                {
                    "start": 313,
                    "end": 315,
                    "matchedPaperCorpusId": "10976181"
                },
                {
                    "start": 489,
                    "end": 493,
                    "matchedPaperCorpusId": "215844219"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78369140625
        },
        {
            "corpus_id": "236447670",
            "title": "Guided Optimization for Image Processing Pipelines",
            "text": "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes [31]. Alice [32] and Scratch [33] are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks. Weintrop and Wilensky found that block-based programming tools were easier to use for high school students than text-based alternatives [34]. \n\nInspired by the prior work on VPLs, Roly-poly offers an interactive block-like visualization of the execution of the image processing pipeline. Compared with manual text-based scheduling, we narrow users' freedom by only providing a set of choices. However, our design choices are that using visual constraints in Roly-poly will help users focus only on essential ideas, not on syntactical mistakes. Also, some VPLs assign colors to categories based on their functionalities (e.g., control blocks and operators blocks). This inspired Roly-poly to assign distinguished colors to different functions.",
            "score": 0.3058360598962842,
            "section_title": "E. Visual Programming Language",
            "char_start_offset": 15457,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 349
                },
                {
                    "start": 350,
                    "end": 491
                },
                {
                    "start": 494,
                    "end": 637
                },
                {
                    "start": 638,
                    "end": 742
                },
                {
                    "start": 743,
                    "end": 893
                },
                {
                    "start": 894,
                    "end": 1013
                },
                {
                    "start": 1014,
                    "end": 1092
                }
            ],
            "ref_mentions": [
                {
                    "start": 193,
                    "end": 197,
                    "matchedPaperCorpusId": "34589974"
                },
                {
                    "start": 205,
                    "end": 209,
                    "matchedPaperCorpusId": "62491646"
                },
                {
                    "start": 222,
                    "end": 226,
                    "matchedPaperCorpusId": "273180521"
                },
                {
                    "start": 486,
                    "end": 490,
                    "matchedPaperCorpusId": "207226901"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.876953125
        },
        {
            "corpus_id": "230622482",
            "title": "An Interactive Serious Mobile Game for Supporting the Learning of Programming in JavaScript in the Context of Eco-Friendly City Management",
            "text": "Many studies [50,51] claim that problems in programming education arise due to the complexity of abstractions and concepts of programming such as variables, arrays, functions, or loops. To overcome this barrier for learning programming, the principles of visual programming, which focus on the use of visual abstractions corresponding to programming abstractions [52], are adopted. The selection of topics follows the list of suggested topics of an undergraduate computer science course by ACM Computing Curricula [53]. \n\nThe concepts that our system supports are common programming algorithms: linear algorithms, branching (conditional) algorithms, iterative algorithms, search and sorting algorithms, recursion, tree raversal, and graph algorithms. We describe the gamification of these algorithms in more detail in the following subsections.",
            "score": 0.3058360598962842,
            "section_title": "Gamification of Programming Algorithms",
            "char_start_offset": 17963,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 185
                },
                {
                    "start": 186,
                    "end": 381
                },
                {
                    "start": 382,
                    "end": 519
                },
                {
                    "start": 522,
                    "end": 750
                },
                {
                    "start": 751,
                    "end": 844
                }
            ],
            "ref_mentions": [
                {
                    "start": 13,
                    "end": 17,
                    "matchedPaperCorpusId": "4012511"
                },
                {
                    "start": 17,
                    "end": 20,
                    "matchedPaperCorpusId": "207696810"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87109375
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "A visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners. Advances in machine learning (ML) further stimulate growing interest in visual programming. Open-source ML hubs (e.g., TF-Hub [1], PyTorch-Hub [57], and Hugging Face [83]) contribute large numbers of encapsulated modules that accelerate AI project development and experimentation, and such libraries provide important resources for an ML-based visual programming platform. Recent advancements in large language models (LLMs) [3,8,77] and findings on Chain-of-Thought [81] have further stimulated community-wide interest in visual programming [4,19,84,86], suggesting further potential in the interactive exploration of AI chains. \n\nDespite the development of visual programming platforms in various domains, we observed that existing systems share one similar characteristic: users usually initiate a creative process in the workspace \"from scratch\". This implies that users need to 1) select nodes, 2) ideate the pipeline structure, and finally, 3) connect nodes within a completely empty workspace. As was also highlighted in existing literature in programming tools [92,95], such processes can easily overwhelm users, especially those who are unfamiliar with a particular visual programming platform. Providing pipeline templates may reduce on-boarding efforts [9,21], but the templates inherently lack flexibility and are not easily adaptable to users' specific needs. Similar issues also arise when users write programs using text-based editors (there exist many built-in functions in a particular programming language and multiple variables in a program), but advances in LLM assistants show that such challenges can be effectively reduced. For example, GitHub Copilot [23] enables users to generate code by simply describing users' requirements in natural language.",
            "score": 0.3058360598962842,
            "section_title": "Introduction",
            "char_start_offset": 1548,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 123
                },
                {
                    "start": 124,
                    "end": 291
                },
                {
                    "start": 292,
                    "end": 497
                },
                {
                    "start": 498,
                    "end": 589
                },
                {
                    "start": 590,
                    "end": 870
                },
                {
                    "start": 871,
                    "end": 1127
                },
                {
                    "start": 1130,
                    "end": 1348
                },
                {
                    "start": 1349,
                    "end": 1498
                },
                {
                    "start": 1499,
                    "end": 1701
                },
                {
                    "start": 1702,
                    "end": 1870
                },
                {
                    "start": 1871,
                    "end": 2144
                },
                {
                    "start": 2145,
                    "end": 2270
                }
            ],
            "ref_mentions": [
                {
                    "start": 641,
                    "end": 645,
                    "matchedPaperCorpusId": "202786778"
                },
                {
                    "start": 926,
                    "end": 928,
                    "matchedPaperCorpusId": "218971783"
                },
                {
                    "start": 928,
                    "end": 931,
                    "matchedPaperCorpusId": "13756489"
                },
                {
                    "start": 1040,
                    "end": 1043,
                    "matchedPaperCorpusId": "262044762"
                },
                {
                    "start": 1043,
                    "end": 1046,
                    "matchedPaperCorpusId": "264514979"
                },
                {
                    "start": 1046,
                    "end": 1049,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 1049,
                    "end": 1052,
                    "matchedPaperCorpusId": "238353829"
                },
                {
                    "start": 1567,
                    "end": 1571,
                    "matchedPaperCorpusId": "271903516"
                },
                {
                    "start": 1762,
                    "end": 1765,
                    "matchedPaperCorpusId": "267523023"
                },
                {
                    "start": 1765,
                    "end": 1768,
                    "matchedPaperCorpusId": "2452365"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9638671875
        },
        {
            "corpus_id": "258987846",
            "title": "AI for Low-Code for AI",
            "text": "We developed LowCoder, a low-code tool that combines visual programming, LowCoder VP , and programming by natural language (PBNL), LowCoder NL , to help developers of all backgrounds create AI pipelines. We used LowCoder to provide some of the first insights into whether and how visual programming and PBNL help programmers by conducting user studies across four tasks with (NL condition) and without (keyword condition) LowCoder NL . Overall, LowCoder helped developers compose (85% of tasks) and iterate (72.5% of tasks) over AI pipelines. Furthermore, LowCoder NL helped users discover previously-unknown operators in 75% of tasks, compared to just 22.5% (12.5% in the NL condition and 32.5% in the keyword condition) using web search. Our qualitative analysis showed that PBNL helped users discover how to implement various parts of the pipeline when they know what to do. However, it failed to support novices when they lacked clarity on what they want to accomplish, which may suggest a worthwhile target for improving AI-based program assistants. Our work demonstrates the promise of combining both an AI-powered natural language interface and a visual interface for helping developers of all backgrounds create AI pipelines without writing code.",
            "score": 0.3044050792962486,
            "section_title": "CONCLUSION",
            "char_start_offset": 51274,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 203
                },
                {
                    "start": 204,
                    "end": 435
                },
                {
                    "start": 436,
                    "end": 542
                },
                {
                    "start": 543,
                    "end": 739
                },
                {
                    "start": 740,
                    "end": 877
                },
                {
                    "start": 878,
                    "end": 1054
                },
                {
                    "start": 1055,
                    "end": 1254
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80615234375
        },
        {
            "corpus_id": "9082292",
            "title": "Computer-supported Techniques to Increase Students Engagement in Programming",
            "text": "The animation tools provide a visual metaphor that significantly helps the understanding of complex concepts. Therefore, these tools allow the students to find the dynamics of hard to understand but extremely important processes. In this way, the student is stimulated to progress in his activity (Hundhausen et al., 2002). \n\nSeveral authors have been concerned about the use of graphic interfaces that enable a way of communication between the user and the computer not restricted to a textual form (Hansen et al., 1999) (Stasko and Kehoe, 1996) (Hundhausen and Douglas, 2000). \n\nAiming to enhance the learning process, many educators and computer scientists have been working on animation, visualization and simulation systems (computational programs). The great motivation is to appeal to the human visual system potential. \n\nThe key question is how to apply these methods in order to help students to deal with complex concepts. \n\nMany researches (Brown and Sedgewick, 1985) (Korhonen, 2003), (Kerren and Stasko, 2002) have been working to identify the rules that should be followed while designing and creating visualizations and animations effective for teaching. As computer programs can be hard to understand when presented in a textual format, it is expected that a better comprehension could be achieved with an animated graphic format (Pereira, 2002). \n\nAn animation is a natural approach of expressing behaviours. Particularly, the animation of an algorithm is a dynamic visualization of their main abstraction. So, its importance lies on the ability to describe the algorithm logical essence. \n\nWhen inspecting the control and data of a program to understand its behaviour, we have two big choices: do it during code execution (debugging), or simulate the execution in another environment (Pereira, 2002). For teaching purposes we believe that the second approach is clearly the most interesting (Stasko and Kehoe, 1996). \n\nSeveral authors have worked on this problem. They develop less complex and appealing environments than the professional environments, with important features for novice programmers. These systems allow understanding important aspects in programming through the animation of pseudocode, flowcharts, or programs written in specific or in a general programming languages (such as Pascal, C, Java, and others). The most interesting and appealing are those that allow students to introduce and simulate their own algorithms and programs.",
            "score": 0.30433034961170197,
            "section_title": "ANIMATION",
            "char_start_offset": 7705,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 109
                },
                {
                    "start": 110,
                    "end": 229
                },
                {
                    "start": 230,
                    "end": 323
                },
                {
                    "start": 326,
                    "end": 578
                },
                {
                    "start": 581,
                    "end": 754
                },
                {
                    "start": 755,
                    "end": 826
                },
                {
                    "start": 829,
                    "end": 932
                },
                {
                    "start": 935,
                    "end": 1169
                },
                {
                    "start": 1170,
                    "end": 1362
                },
                {
                    "start": 1365,
                    "end": 1425
                },
                {
                    "start": 1426,
                    "end": 1523
                },
                {
                    "start": 1524,
                    "end": 1605
                },
                {
                    "start": 1608,
                    "end": 1818
                },
                {
                    "start": 1819,
                    "end": 1934
                },
                {
                    "start": 1937,
                    "end": 1981
                },
                {
                    "start": 1982,
                    "end": 2118
                },
                {
                    "start": 2119,
                    "end": 2343
                },
                {
                    "start": 2344,
                    "end": 2469
                }
            ],
            "ref_mentions": [
                {
                    "start": 297,
                    "end": 322,
                    "matchedPaperCorpusId": "270116183"
                },
                {
                    "start": 500,
                    "end": 520,
                    "matchedPaperCorpusId": "18842215"
                },
                {
                    "start": 547,
                    "end": 577,
                    "matchedPaperCorpusId": "1900909"
                },
                {
                    "start": 951,
                    "end": 977,
                    "matchedPaperCorpusId": "16535037"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.529296875
        },
        {
            "corpus_id": "51968814",
            "title": "Introducing Computer Science to High School Students Through Logic Programming",
            "text": "Another prominent feature of these environments is to encourage and facilitate tinkering and fit the needs of students who prefer tinkering to logic and planning (Papert 1980;Resnick and Rosenbaum 2013). On the one hand, these languages and environments have been very successful in reaching a large K-12 population. On the other hand, more research is needed to understand how computation thinking occurs as students are tinkering while using visual programming languages (Guzdial 2004;Lye and Koh 2014). While substantial efforts have been made in introducing CS to younger audiences through visual programming languages which are largely procedural or OO based, logic programming (LP) based approaches have been largely ignored by the K-12 Computer Science education research community (Pears et al. 2007;Lye and Koh 2014), despite continuing efforts in both teaching and research on LP.",
            "score": 0.3042147968452378,
            "section_title": "Introduction",
            "char_start_offset": 2105,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 203
                },
                {
                    "start": 204,
                    "end": 316
                },
                {
                    "start": 317,
                    "end": 505
                },
                {
                    "start": 506,
                    "end": 890
                }
            ],
            "ref_mentions": [
                {
                    "start": 487,
                    "end": 504,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 808,
                    "end": 825,
                    "matchedPaperCorpusId": "11994747"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.433837890625
        },
        {
            "corpus_id": "246992283",
            "title": "Student-Teachers\u2019 Abilities and Attitudes towards Scratch as a Multimedia Construction tool to Represent Physical Geography Phenomena",
            "text": "The aim of this paper is to describe a didactic intervention that aimed to introduce pre-service teachers to visual programming with the ultimate goal of enabling them to support their students on constructing multimedia in the context of Geography in the future. Students created multimedia software about Physical Geography topics using MIT Scratch. The way the students used scientific knowledge and did the didactic transformation in order to build their artefacts has been presented elsewhere. In this article students\u2019 ability and attitudes on programming are examined. More specifically, we study the techniques and programming structures students use, as an indicator of what students learned. Furthermore, we study difficulties on programming and other technical difficulties they confront, as well as their attitudes towards Scratch which developed through the didactic intervention. The results are encouraging since students create software that work properly and develop a positive attitude toward Scratch.",
            "score": 0.3037302375756505,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.430908203125
        },
        {
            "corpus_id": "1746109",
            "title": "Improving usability of interactive graphics specification and implementation with picking views and inverse transformation",
            "text": "A number of works have tackled usability of programming, including psychology of programming, cognitive dimensions of notation [9], or API usability [17]. For example, [10] and [11] enable the programmer to describe interactive state with state machines [18]. Most usability studies target generalpurpose languages or APIs rather than tools for building interactive systems [3]. Exceptions include Myers' study of the programming practices of graphical designers [1]. Our work builds up on these concerns, and proposes a practical method that aims at improving usability of specification and implementation of graphical interaction. Artistic resizing is a technique that enables to specify how graphical components resize when users resize the container window [19]. It is an example of how a specification can be turned from a program to graphical description. Our work is in the same vein, in that it improves the Closeness of Mapping between the phenomenon and its description. \n\nDescribing graphics with Data Flow has been extensively studied in the past. For example, Fabrik is a direct manipulation -based user interface builder that enables a designer to specify transforms between widget with a visual flow language [20]. Events flow in the same flow graph that describes the geometrical transforms, so that they are automatically transformed to a position relative to the graphically transformed widget. Garnet uses one-way constraints, which can be considered as data flow, to propagate changes [21]. In order to improve interactive graphics programming, [22] proposes solutions to facilitate mixing of data flow of input and scene graph for output. \n\nThe inverse of model-view matrix is often used to retrieve an object that has undergone multiple 3D transforms (due to change of point of view, or due to modeling) [12]. [23] discusses how to enable users to change data through visualization and a data-flow. Metisse [15] and Fa\u00e7ade [24] rely on inverse transforms to handle user manipulation in rotated views. However, none discusses how to design inverse transformations to reflect users' manipulation into the models.",
            "score": 0.3037277090202986,
            "section_title": "VIII. RELATED WORK",
            "char_start_offset": 31167,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 154
                },
                {
                    "start": 155,
                    "end": 259
                },
                {
                    "start": 260,
                    "end": 378
                },
                {
                    "start": 379,
                    "end": 467
                },
                {
                    "start": 468,
                    "end": 632
                },
                {
                    "start": 633,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 861
                },
                {
                    "start": 862,
                    "end": 980
                },
                {
                    "start": 983,
                    "end": 1059
                },
                {
                    "start": 1060,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1412
                },
                {
                    "start": 1413,
                    "end": 1510
                },
                {
                    "start": 1511,
                    "end": 1659
                },
                {
                    "start": 1662,
                    "end": 1831
                },
                {
                    "start": 1832,
                    "end": 1920
                },
                {
                    "start": 1921,
                    "end": 2022
                },
                {
                    "start": 2023,
                    "end": 2132
                }
            ],
            "ref_mentions": [
                {
                    "start": 127,
                    "end": 130,
                    "matchedPaperCorpusId": "13447890"
                },
                {
                    "start": 168,
                    "end": 172,
                    "matchedPaperCorpusId": "18534709"
                },
                {
                    "start": 177,
                    "end": 181,
                    "matchedPaperCorpusId": "312236"
                },
                {
                    "start": 254,
                    "end": 258,
                    "matchedPaperCorpusId": "13360080"
                },
                {
                    "start": 374,
                    "end": 377,
                    "matchedPaperCorpusId": "17004610"
                },
                {
                    "start": 463,
                    "end": 466,
                    "matchedPaperCorpusId": "1310663"
                },
                {
                    "start": 761,
                    "end": 765,
                    "matchedPaperCorpusId": "12733444"
                },
                {
                    "start": 1224,
                    "end": 1228,
                    "matchedPaperCorpusId": "2924265"
                },
                {
                    "start": 1505,
                    "end": 1509,
                    "matchedPaperCorpusId": "7833402"
                },
                {
                    "start": 1565,
                    "end": 1569,
                    "matchedPaperCorpusId": "1469945"
                },
                {
                    "start": 1832,
                    "end": 1836,
                    "matchedPaperCorpusId": "14732879"
                },
                {
                    "start": 1929,
                    "end": 1933,
                    "matchedPaperCorpusId": "6954513"
                },
                {
                    "start": 1945,
                    "end": 1949,
                    "matchedPaperCorpusId": "7812663"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.501953125
        },
        {
            "corpus_id": "230282866",
            "title": "On some innovations in teaching the formal semantics using software tools",
            "text": "The using of this book assumes the coordination with particular modules of our software package. We note that standard teaching methods -explanation and model calculation using board where the r\u00f4le of the educator/teacher is indispensable cannot be so simply omitted. We think that modern visualizing methods can significantly help and we want to apply them but we do not want to avoid using standard methods as well [28]. \n\nThe practical outcomes of using the software package will be used in teaching computer science courses in the field of software engineering focusing on the design and development of correct programs and systems, not only at the domestic university and at a cooperating university, Johannes Kepler University in Linz, Austria, or other universities where related and similar courses are a part of curriculum. One of the advantages can be also putting this software into practice for distance learning. Our software tool (or the complete software package) can serve as a modern interactive learning tool, as a support for new teachers of the course, as a tool for IT experts using formal methods or for other interested experts. \n\nThe proposed teaching software can help teachers and educators in providing a better and illustrative form for the students: \n\n-during the lectures, the teacher can present examples directly and interactively; or at least use prepared examples depicted on screen-shots; -at laboratory exercises and seminars, examples can be explained step-wise with possible change of input parameters to show the differences in programs' simulations. \n\nThe teaching software can be very useful for students especially in the following cases: \n\n-during the laboratory work for simulation of program execution, when examining the conditions of how results will program produce based on input parameters; -in the phase of self-study and self-preparation for testing or exams; -when doing research or simulations when the visual output is needed. \n\nMoreover, the program provides visual output that can be stored into graphic file. Another option is to export the L A T E X source of the produced visual output that can be used in other projects. We consider both output forms as very important for future work in studying, teaching and preparing output materials. \n\nThe theoretical outcomes of using the software package can find their application in the field of further research on the issue of interactive and experiential teaching of theoretical principles in computer science.",
            "score": 0.3032198517758842,
            "section_title": "Motivation for bringing innovations to teaching",
            "char_start_offset": 17304,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 96
                },
                {
                    "start": 97,
                    "end": 267
                },
                {
                    "start": 268,
                    "end": 422
                },
                {
                    "start": 425,
                    "end": 832
                },
                {
                    "start": 833,
                    "end": 925
                },
                {
                    "start": 926,
                    "end": 1151
                },
                {
                    "start": 1154,
                    "end": 1278
                },
                {
                    "start": 1281,
                    "end": 1589
                },
                {
                    "start": 1592,
                    "end": 1680
                },
                {
                    "start": 1683,
                    "end": 1981
                },
                {
                    "start": 1984,
                    "end": 2066
                },
                {
                    "start": 2067,
                    "end": 2181
                },
                {
                    "start": 2182,
                    "end": 2299
                },
                {
                    "start": 2302,
                    "end": 2517
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1190185546875
        },
        {
            "corpus_id": "252305562",
            "title": "Digitizing Arudh and Qowafi Classics as Android-Based Student Learning Media Using Flutter",
            "text": "Visual code can be used to develop mobile, web, desktop and cloud applications. Visual Code makes it easy to write code that supports several types of programming, such as C++, C#, Java, Python, PHP, GO [12] [13]. Visual Code has the ability to identify the type of programming language used and provide color variations according to the function in the code series. Visual Studio Code has also been integrated into Github [14]. Dart is an object-oriented, class-based language with a C-style syntax. Darts can be compiled to native code or JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and type inference [15]. Dart is an interesting programming language which is getting more and more popular day by day. The language is scalable and can be used to write simple scripts or full-featured applications. Use Case Diagrams are usually referred to as behavior diagrams that are used to describe a series of actions (use cases) that several systems or systems (subjects) must or can perform in collaboration with one or more external users of the system (actors). Each use case must provide some observable and valuable result for the actors or other stakeholders of the system. Use Case Diagrams are used to capture dynamic aspects of the system. In general, it aims to collect the needs of a system, get views from outside the system, identify factors that affect the system both internally and externally, show the interaction between actors and the system. Class diagrams provide an overview of the relationship between the tables in the database [16]. Each class has attributes and methods or functions according to the process that occurs [17]. From the design of the diagram, it will be known how the relationship between the tables in the database and what input processes are in it. Activity Diagrams describe the workflow (workflow) or activities of a system or business process. After creating a Use Case model, each scenario in the Use Case will be described more clearly in the activity diagram. Activity diagram is a modeling that describes a working system of an object or a system, an activity diagram is described with a structured flow of the work process from the use case that is being processed from the starting point to the end point, each activity is described with notations according to its function [17] [18].",
            "score": 0.30292936753411603,
            "section_title": "Literature Review",
            "char_start_offset": 6905,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 79
                },
                {
                    "start": 80,
                    "end": 213
                },
                {
                    "start": 214,
                    "end": 366
                },
                {
                    "start": 367,
                    "end": 428
                },
                {
                    "start": 429,
                    "end": 500
                },
                {
                    "start": 501,
                    "end": 552
                },
                {
                    "start": 553,
                    "end": 645
                },
                {
                    "start": 646,
                    "end": 740
                },
                {
                    "start": 741,
                    "end": 836
                },
                {
                    "start": 837,
                    "end": 1093
                },
                {
                    "start": 1094,
                    "end": 1208
                },
                {
                    "start": 1209,
                    "end": 1277
                },
                {
                    "start": 1278,
                    "end": 1490
                },
                {
                    "start": 1491,
                    "end": 1586
                },
                {
                    "start": 1587,
                    "end": 1680
                },
                {
                    "start": 1681,
                    "end": 1821
                },
                {
                    "start": 1822,
                    "end": 1919
                },
                {
                    "start": 1920,
                    "end": 2038
                },
                {
                    "start": 2039,
                    "end": 2366
                }
            ],
            "ref_mentions": [
                {
                    "start": 208,
                    "end": 212,
                    "matchedPaperCorpusId": "212558645"
                },
                {
                    "start": 423,
                    "end": 427,
                    "matchedPaperCorpusId": "235192578"
                },
                {
                    "start": 640,
                    "end": 644,
                    "matchedPaperCorpusId": "55011688"
                },
                {
                    "start": 1675,
                    "end": 1679,
                    "matchedPaperCorpusId": "237772371"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.658203125
        },
        {
            "corpus_id": "250414169",
            "title": "Effect of SRA-programming on computational thinking through different output modalities",
            "text": "Several limitations and considerations can be identified regarding the results of this research. Due to these a certain lack of generalisability of the results obtained should be taken into account. During the course of this research, it may be the case that non-experimental variables played a determining role in the final results. Reasons for this may include that pupils continued to work with programming environments at home or within their current primary school curriculum, or that pupils have developed over time as a result of their standard educational programme. In addition, our findings could also be explained by taking into account children's familiarity with computer games with visual output representing tangibles and/or their previous computer experience. \n\nThis research made use of two visual programming environments: Bomberbot, with an on-screen output, and Lego EV-3 Mindstorms, with a tangible output. In order to be able to generalise the results of our research, it should be replicated with other visual programming environments with different types of on-screen and tangible output. The issues of whether the nature of the programming task and the level of difficulty affect the outcome and learning effects should also be examined. There are also arguments that the use of visual programming environments with incentives provides a low threshold for giving guidance to users; the user is guided more explicitly through the tasks, and it is therefore questionable whether these incentives restrict freedom of choice. \n\nIt would also be interesting to further investigate (1) whether the use of SRA-programming in a visual programming environment in which a tangible output is first used and then a visual output (or vice versa) yields a greater understanding of complex programming concepts; (2) whether this can be attributed to the application of SRA and ( 3) to what extent this results in the subsequent measurable development of CT. We note that SRA-programming of robotics with tangible output involves a very different form of application of SRA compared to visual SRA-programming with on-screen output. Learning to apply SRA in one environment may have (dis) advantages in the other. In follow-up research, it would be worthwhile to further clarify the relationship between the use of SRA-programming, the sequence in which the type of programming environment is applied, and possible differences in the development of CT.",
            "score": 0.3029181395327343,
            "section_title": "Limitations and follow-up research",
            "char_start_offset": 56118,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 96
                },
                {
                    "start": 97,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 333
                },
                {
                    "start": 334,
                    "end": 574
                },
                {
                    "start": 575,
                    "end": 775
                },
                {
                    "start": 778,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 1112
                },
                {
                    "start": 1113,
                    "end": 1262
                },
                {
                    "start": 1263,
                    "end": 1546
                },
                {
                    "start": 1549,
                    "end": 1967
                },
                {
                    "start": 1968,
                    "end": 2140
                },
                {
                    "start": 2141,
                    "end": 2221
                },
                {
                    "start": 2222,
                    "end": 2460
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.65771484375
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "A VPL's framework is a collection of tools that enable the developers to create new VPLs in less time with less efforts and better quality by utilizing ready to use and well tested tools [31].\n\nIn this thesis we created a visual programming languages' framework to use for developing the general-purpose visual programming language. In the Appendix C. we shows the designers in our visual programming languages' framework.",
            "score": 0.3028248728546346,
            "section_title": "Visual Programming Languages' Frameworks",
            "char_start_offset": 15159,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9169921875
        },
        {
            "corpus_id": "253049931",
            "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
            "text": "On the other hand, we infer from our observations that visual languages by themselves provide too little support to enable non-programmers to implement complex, realistic tasks without additional assistance. \n\nThe remainder of this paper is structured as follows: We provide a short introduction to block-based programming languages in Section 2 together with a description of the industry context. Section 3 details the study design including research questions and experiment procedure. We show experiment results in Section 4, list participant feedback on usability aspects in Section 5 before discussing the results and their implications in Section 6. We review related work in Section 7 before concluding this paper with an outlook on future work in Section 8.",
            "score": 0.3028248728546346,
            "section_title": "Introduction",
            "char_start_offset": 2300,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 207
                },
                {
                    "start": 210,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 488
                },
                {
                    "start": 489,
                    "end": 656
                },
                {
                    "start": 657,
                    "end": 766
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3896484375
        },
        {
            "corpus_id": "11795228",
            "title": "Visual definition of procedures for automatic virtual scene generation",
            "text": "The goal of this thesis is to present a visual programming language as a tool for the definition of procedures for automatic scene generation. The methods for building a visual programming language are a continuation of the work done in [33] and procedural generation is researched as a possible domain for the visual programming language.",
            "score": 0.3028248728546346,
            "section_title": "Goals",
            "char_start_offset": 16954,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 237,
                    "end": 241,
                    "matchedPaperCorpusId": "7271567"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.93212890625
        },
        {
            "corpus_id": "221802417",
            "title": "A Visual Language for Composable Inductive Programming",
            "text": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
            "score": 0.3028248728546346,
            "section_title": "Visual Programming",
            "char_start_offset": 2695,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 89
                },
                {
                    "start": 90,
                    "end": 230
                },
                {
                    "start": 231,
                    "end": 412
                },
                {
                    "start": 415,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 615
                },
                {
                    "start": 616,
                    "end": 687
                },
                {
                    "start": 690,
                    "end": 798
                },
                {
                    "start": 799,
                    "end": 887
                },
                {
                    "start": 890,
                    "end": 927
                },
                {
                    "start": 930,
                    "end": 973
                },
                {
                    "start": 976,
                    "end": 1015
                },
                {
                    "start": 1018,
                    "end": 1160
                },
                {
                    "start": 1161,
                    "end": 1305
                },
                {
                    "start": 1308,
                    "end": 1523
                },
                {
                    "start": 1524,
                    "end": 1590
                },
                {
                    "start": 1591,
                    "end": 1734
                },
                {
                    "start": 1735,
                    "end": 1837
                },
                {
                    "start": 1838,
                    "end": 1959
                },
                {
                    "start": 1962,
                    "end": 2039
                },
                {
                    "start": 2040,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2322
                },
                {
                    "start": 2325,
                    "end": 2433
                },
                {
                    "start": 2434,
                    "end": 2625
                }
            ],
            "ref_mentions": [
                {
                    "start": 551,
                    "end": 554,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 604,
                    "end": 608,
                    "matchedPaperCorpusId": "5257722"
                },
                {
                    "start": 611,
                    "end": 614,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 670,
                    "end": 674,
                    "matchedPaperCorpusId": "44279097"
                },
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "30037917"
                },
                {
                    "start": 677,
                    "end": 680,
                    "matchedPaperCorpusId": "158715"
                },
                {
                    "start": 683,
                    "end": 686,
                    "matchedPaperCorpusId": "425881"
                },
                {
                    "start": 793,
                    "end": 797,
                    "matchedPaperCorpusId": "561505"
                },
                {
                    "start": 2105,
                    "end": 2109,
                    "matchedPaperCorpusId": "30404857"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9736328125
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "These Hybrid approaches, however, are very bound to specific well-known text programming languages and do not provide more language independent approaches. The usage of more language independent text in the blocks is an essential part of the education, because students that already have some experience in well-known text programming language will not be able to use their previous experience to outcompete other students with no previous experience in assignment in which this could be important. Moreover, usage of more universal Hybrid Visual-Textual notation would make development of cross-translation to multiple text languages easier. \n\nA significant adaptation addressing some downsides reviewed could be made using a \"semigraphical\" approach, in which students still have to describe a language independent \"pseudocode\" in some of the visual components of the VPL, which makes it a Hybrid VPL (HVPL). The last would allow a smoother transition from a visual environment to a subsequent classic text environment. On the other hand, cross-compiling code from VPL to more than one text programming language allows students to perform comparative analysis on the linguistic constructions of different well-known text programming languages. Using the hybrid visual-text approach teaches students algorithmic thinking while describing an algorithm as code. \n\nThis paper presents an author's environment for performing a VPL with a hybrid visual-text approach (HVTA). Based on a visual block chart editor, a cross-translator is created from the code generated by the visual editor to a language for immediate execution or compilation, (linking) and execution. The developed environment is suitable for teaching first year students in a higher education institution in Introduction to Programming Languages and can be used as an integrated environment for programming training through VPL.",
            "score": 0.3028248728546346,
            "section_title": "Introduction",
            "char_start_offset": 1943,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 155
                },
                {
                    "start": 156,
                    "end": 498
                },
                {
                    "start": 499,
                    "end": 642
                },
                {
                    "start": 645,
                    "end": 910
                },
                {
                    "start": 911,
                    "end": 1021
                },
                {
                    "start": 1022,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1360
                },
                {
                    "start": 1363,
                    "end": 1470
                },
                {
                    "start": 1471,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1891
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8115234375
        },
        {
            "corpus_id": "60941791",
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "text": "Visual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169",
            "score": 0.3028248728546346,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.958984375
        },
        {
            "corpus_id": "225541919",
            "title": "Studi Komparatif Program Visual Dinamis untuk Pembelajaran Algoritma dan Pemograman Berorientasi Objek",
            "text": "As beginners, many first-year students have difficulty understanding object-oriented programming material. To help students learn algorithmic and object-oriented programming material researchers have developed visual programming (PV). Visual programming is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming. This research aims to compare three dynamic PV tools for object-oriented learning programming that are the most studied. To determine the PV to be compared, a survey was conducted in an online journal database, such as IEEE explore, ACM, and several well-known online publishers. From the survey results, three dynamic PVs were chosen, most widely discussed, namely Jeliot 3, Ville and Jive. All three tools are installed and studied. Comparison results show that each dynamic PV has advantages on certain characteristics. The instructor can choose visual programming by considering the advantages of each PV.",
            "score": 0.3028248728546346,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9658203125
        },
        {
            "corpus_id": "6764231",
            "title": "A Proposed Framework for Development of a Visualizer Based on Memory Transfer Language (MTL)",
            "text": "In this section we present a proposed framework that could be used in developing a visualizer based on the MTL framework. A visualizer should be designed to aid a novice programmer to visualize a program as it is being executed by the machine. A visualizer is expected to allow a novice to construct his/her program of choice by either using the built in controls to automatically insert codes or coding from the scratch. Once the code is entered, the execution of the lines of code can be triggered and execution begins. A visualizer highlights (in colour) each and every line it executes at a particular point in time and displays the effect to a machine over the RAM blocks. A visualizer is anticipated to allow a novice to select the mode of program execution. The first mode is line by line execution, where the tool reads one line at a time, highlights a line in colour, and finally shows the code effect over the RAM blocks. In this mode a novice's intervention is needed to allow a visualizer to execute the next line. The second mode of execution allows for a complete run, where the tool executes the program from the beginning to the end while showing the code effect over the RAM blocks. A visualizer shall provide user friendly error messages that provide suggestions and guide a novice on how to rectify the reported errors. In this paper we will demonstrate examples of codes/programs in VB .Net, however in implementation; one may choose whatever language of choice.",
            "score": 0.3028248728546346,
            "section_title": "A. Overview",
            "char_start_offset": 4791,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 121
                },
                {
                    "start": 122,
                    "end": 243
                },
                {
                    "start": 244,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 521
                },
                {
                    "start": 522,
                    "end": 677
                },
                {
                    "start": 678,
                    "end": 764
                },
                {
                    "start": 765,
                    "end": 931
                },
                {
                    "start": 932,
                    "end": 1026
                },
                {
                    "start": 1027,
                    "end": 1199
                },
                {
                    "start": 1200,
                    "end": 1338
                },
                {
                    "start": 1339,
                    "end": 1482
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.76708984375
        },
        {
            "corpus_id": "262701504",
            "title": "PVC.js: visualizing C programs on web browsers for novices",
            "text": "We propose a new visualization technique for C languages called PVC.js. It is a browser-based JavaScript application inspired by previous studies. The application is open-access and free to try at the listed address (see Section 1). The experiment reveals that PVC.js is useful not only to novices, but also to programmers in general. \n\nIn the future, we plan to investigate whether PVC.js can help students learn programming by evaluating users' programming skills after using PVC.js. Moreover, we will continue to develop and improve PVC.js. For example, our visualize application currently supports only C language. It does not support the full range of C language syntax and standard library functions. We are also planning to improve PVC.js to increase the support functions, support multiple programming languages and incorporate some suitable block-based representation (e.g. blockly 15 can transpile blocks to code). Such block-based representation can make it easier for the learners to avoid using not supported features and also protect them from syntax errors.",
            "score": 0.3028248728546346,
            "section_title": "Conclusions and future work",
            "char_start_offset": 27874,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 71
                },
                {
                    "start": 72,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 232
                },
                {
                    "start": 233,
                    "end": 334
                },
                {
                    "start": 337,
                    "end": 485
                },
                {
                    "start": 486,
                    "end": 543
                },
                {
                    "start": 544,
                    "end": 618
                },
                {
                    "start": 619,
                    "end": 706
                },
                {
                    "start": 707,
                    "end": 882
                },
                {
                    "start": 883,
                    "end": 924
                },
                {
                    "start": 925,
                    "end": 1072
                }
            ],
            "ref_mentions": [
                {
                    "start": 891,
                    "end": 893,
                    "matchedPaperCorpusId": "16369862"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.282470703125
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "The current version of the visual language is shown in Figure 19. This design was influenced by jig-saw puzzle pieces. The mechanics of this version work out better than the previous version. In addition, control flow is more explicit, following the keyed tabs on each object top-down. Data objects are rectangular shapes with tabs on their left and right sides. Originally, these data objects were placed over a recepticle that contained a \"velco\" substance for sticking them to. This was later changed to being simply holes that were filled with the data objects. There are still problems to be overcome in this current version of the visual language. For instance, the issue of nesting plans has still not been fully addressed. In addition, there is still some concern that the shapes of the plans are not adequate in their ability to evoke understanding by the user.\n\nDespite the difficulties with the current version, what is clear at this point is that the use of a visual language is effective.",
            "score": 0.3028248728546346,
            "section_title": "Generation 6",
            "char_start_offset": 53349,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.63232421875
        },
        {
            "corpus_id": "58394",
            "title": "Towards rule-based visual programming of generic visual systems",
            "text": "As this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
            "score": 0.3028248728546346,
            "section_title": "Genericity",
            "char_start_offset": 20066,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 447
                },
                {
                    "start": 448,
                    "end": 580
                },
                {
                    "start": 581,
                    "end": 731
                },
                {
                    "start": 732,
                    "end": 912
                },
                {
                    "start": 913,
                    "end": 1045
                }
            ],
            "ref_mentions": [
                {
                    "start": 950,
                    "end": 954,
                    "matchedPaperCorpusId": "43464074"
                },
                {
                    "start": 1040,
                    "end": 1044,
                    "matchedPaperCorpusId": "8161155"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94287109375
        },
        {
            "corpus_id": "67486810",
            "title": "Prospects and opportunities for visual programming technologies and tools application in educating at school",
            "text": "Article depicts typical problems that students encounter when mastering programming. For each problem, a number of existing specialized software environments offering a solution is displayed. Analyses of programming environments elements and the selection of those who are directly involved in solving problems are conducted. In the end, aggregation of the best solution is carried out and an assumption about the possibility of combining the best elements is made. Initially, the school computer science course was focused on the formation of computer programming and computer skills. Now the main part of the course is devoted to the study of applied software and information technologies. At the same time, classical programming languages developed in the last century are used for learning more. The first successful attempt to create an alternative programming language that could act as an educational tool is the Logo language. A similar display method can be found in many programming environments, where the user does not need to have programming skills, but be able to make a workable algorithm. This allows you not to be distracted by programming language, but to design a program from blocks. Each of the visual programming environments mentioned in the article is not without a number of drawbacks. However, even with this state of affairs, there is a tendency to expand the use of visual programming languages in teaching.",
            "score": 0.3028248728546346,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80029296875
        },
        {
            "corpus_id": "46557970",
            "title": "Deuce: A Lightweight User Interface for Structured Editing",
            "text": "(This Paper) Implementation in S S . We implement D within S S , an interactive functional programming system for generating Scalable Vector Graphics (SVG). In S S , the user writes a program (shown on the le half of Figure 1) in a core functional language, called L , to compute SVG output (shown on the right). Unlike traditional programming languages, however, in S S the user may interact with the output of the program-adding new shapes, relating and grouping shapes, and modifying properties such as as positions, sizes, and colors-and S S synthesizes updates to the L program in response to the user's actions with the output. Whereas that work provides capabilities for directly manipulating the output of a program, our goal in this work is to provide capabilities for directly manipulating the code itself. We also demonstrate how domain-speci c structured transformations can be co-designed with the D interface, providing automated support that is tailored to a speci c programming se ing. Nevertheless, most of the features provided in D work for arbitrary L programs (not just those used to compute SVGs) and, thus, may be adapted and extended to code editors for other programming languages.\n\nContributions and Outline. is paper makes the following contributions:\n\n\u2022 We present the design of D , a code editor equipped with a lightweight, direct manipulation interface to identify, invoke, and con gure structured program transformations while retaining the freedom and familiarity of traditional text-based editing. Our design can be instantiated with di erent sets of program transformations for di erent se ings. ( \u00a73.1) \u2022 We instantiate D with a set of structured transformations for several general-purpose prototyping and refactoring tasks. Most of these transformations are common to existing refactoring tools, but two transformations-Move De nitions and Make Equal-are, to the best of our knowledge, novel. ( \u00a73.2) \u2022 We implement D within S S , extend the set of structured transformations for a few domain-speci c tasks, and evaluate the new structured editing features through a series of examples. ( \u00a74) Our implementation and videos of our examples are available at h p://ravichugh.github.io/sketch-n-sketch/. Next, in \u00a72,",
            "score": 0.3028248728546346,
            "section_title": "Mouse-Edit Code",
            "char_start_offset": 4413,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1683349609375
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "Visual programming systems are currently the primary instruments for the early teaching of basic programming skills, while they are increasingly deployed in various domains for rapid development by non-professional programmers. Compared to tools for professional programming, there are many functionality layers and features that can be introduced to improve the programming experience and better support the overall learning process. \n\nIn this paper, we presented a brief but systematic account of key design requirements for future visual development systems, relying on the new notion of programming experience, while having a primary learning orientation. Overall, we believe that such requirements can be more effectively addressed separately, by cooperating tools, within open and extensible future visual development environments.",
            "score": 0.3028248728546346,
            "section_title": "CONCLUSIONS",
            "char_start_offset": 20782,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 227
                },
                {
                    "start": 228,
                    "end": 434
                },
                {
                    "start": 437,
                    "end": 659
                },
                {
                    "start": 660,
                    "end": 837
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89013671875
        },
        {
            "corpus_id": "13395203",
            "title": "Visualizing Computer Programming in a Computer-based Simulated Environment",
            "text": "The use of visualization helped the programming students to better understand these aspects, because visual representations are easier to retain and handle, and that having an instant visualization of instruction results enabled students to directly judge whether their idea was right or wrong [13]. Second Life users were able to create avatars and 3D objects, and to program their behavior using the Linden Scripting Language (LSL); the benefit of this is the students\" ability to execute the programming code concurrently and that several students are able to www.ijacsa.thesai.org simultaneously work over the same code and/or object, which provided the advantage of immediate presentation of program execution [13].",
            "score": 0.3028248728546346,
            "section_title": "D. Previous Applications of Virtual World Technologies in the Learning of Computer Programming",
            "char_start_offset": 40386,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 299
                },
                {
                    "start": 300,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 720
                }
            ],
            "ref_mentions": [
                {
                    "start": 294,
                    "end": 298,
                    "matchedPaperCorpusId": "16546410"
                },
                {
                    "start": 715,
                    "end": 719,
                    "matchedPaperCorpusId": "16546410"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80419921875
        },
        {
            "corpus_id": "247731685",
            "title": "Block-Based Visual Programming as a Tool for Learning the Concepts of Programming for Novices",
            "text": "Fig. 3 shows this study\"s experimental design, which grouped to intervention and control, namely group A and group B, respectively. Both groups are separated by a dashed line indicating they have different treatments. The intervention or experimental group was treated by implementing the strategy of PjBL using BBVP to learn the concepts of programming. In contrast, the control group had no particular intervention, which means that the students had no distinctive handling and the learning processes were running like usual using the standard method. To find out the initial knowledge of participants, they were given a pretest. In the end, participants were given a posttest to find out the condition between before and after. The project employed in the PjBL settings was making a game in the course\" final according to their creativity. The game project is selected because its features may introduce and reinforce procedural abstraction that is very important in the course of programming [28]. The software used to create the game project is ScratchJr, an online block-based visual programming language that offers an easy-to-implement structure and algorithm of the programs [29]. Before students carried out the final project, they obtained courses on using the software technically for five meetings. They were guided on installing and accessing the software, creating an account, and using the available features in the ScratchJr. Additionally, they were also given a module to accompany learning activities. The module contains five parts: a basic explanation of programming concepts, the introduction of ScratchJr, its features, the step-by-step guide on how to create a game project technically, and project-based instructions. The learning module was also completed by a video, so that they may re-learn afterward.",
            "score": 0.3028248728546346,
            "section_title": "C. Experimental Design",
            "char_start_offset": 9778,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 131
                },
                {
                    "start": 132,
                    "end": 217
                },
                {
                    "start": 218,
                    "end": 354
                },
                {
                    "start": 355,
                    "end": 553
                },
                {
                    "start": 554,
                    "end": 631
                },
                {
                    "start": 632,
                    "end": 730
                },
                {
                    "start": 731,
                    "end": 842
                },
                {
                    "start": 843,
                    "end": 1001
                },
                {
                    "start": 1002,
                    "end": 1189
                },
                {
                    "start": 1190,
                    "end": 1311
                },
                {
                    "start": 1312,
                    "end": 1442
                },
                {
                    "start": 1443,
                    "end": 1520
                },
                {
                    "start": 1521,
                    "end": 1742
                },
                {
                    "start": 1743,
                    "end": 1830
                }
            ],
            "ref_mentions": [
                {
                    "start": 996,
                    "end": 1000,
                    "matchedPaperCorpusId": "221178581"
                },
                {
                    "start": 1184,
                    "end": 1188,
                    "matchedPaperCorpusId": "4012511"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.865234375
        },
        {
            "corpus_id": "271244918",
            "title": "Comparing Visual Metaphors with Textual Code For Learning Basic Computer Science Concepts in Virtual Reality",
            "text": "There have been, on the other hand, examinations of its effectiveness for teaching object-oriented programming (OOP) in particular [12] [13].These studies indicate that completing interactive activities using visual metaphors and analogies, such as the parts of a house for the different subareas of object-oriented programming, can be effective at improving comprehension and confidence regarding these sub-areas.This was found to be especially true for sub-areas associated with particularly low levels of comprehension and confidence before exposure to the visual metaphors in VR, which were targeted in the application design [12].It is noted in one study that similar gains in comprehension and confidence were achieved with traditional text-based methods [13].\n\nThe state of prior work has led the current research toward a study which empirically examines the effectiveness of VR in teaching beginning programming concepts.It is intended that the study will positively contribute toward this specific area where there is the largest lack of similar research compared with other more advanced CS topics.The study will be guided by the following research question.For learners who are new to computer programming, how do VR learning experiences with interactable programming objects compare in effectiveness when textual code is used for the programming objects versus when visual metaphors are used for the programming objects?Measures of effectiveness include change in basic CS knowledge, change in self-efficacy related to basic programming concepts, and productive engagement during the learning activity.",
            "score": 0.30208069061118226,
            "section_title": "VIRTUAL REALITY IN COMPUTER SCIENCE EDUCATION",
            "char_start_offset": 6385,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 141
                },
                {
                    "start": 141,
                    "end": 414
                },
                {
                    "start": 414,
                    "end": 635
                },
                {
                    "start": 635,
                    "end": 766
                },
                {
                    "start": 768,
                    "end": 930
                },
                {
                    "start": 930,
                    "end": 1109
                },
                {
                    "start": 1109,
                    "end": 1169
                },
                {
                    "start": 1169,
                    "end": 1433
                },
                {
                    "start": 1433,
                    "end": 1615
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.30517578125
        },
        {
            "corpus_id": "12326820",
            "title": "Visualising Formula Structures to Support Exploratory Modelling",
            "text": "Graphical representations, such as flowcharts, and pictorial representations of data structures have long been used to support the understanding of programs and their underlying processes (Myers 1986). However, it is of interest to note that in visual computational language the empirical evidence of their compelling and appealing character is limited, as is their educational utility (Sorva, et al. 2013). \n\nPrevious work has proposed ways of presenting and visualizing spreadsheets, see: Saariluoma and Sajaniemi (1991), Igarashi, et al. (1998), Ballinger, et al. (2003) and Burnett, et al. (2001). However these works only consider the wider structure of spreadsheets, and the dependencies between cells. None appear to have addressed the fact that the formulas language is computationally powerful but contracted onto a single line. It is this complexity of language presentation that can complicate its effective use. Our enhanced spreadsheet tool employs a visual language that graphically represents spreadsheet formulae. \n\nA visualisation offers a 'scaffold' of geometric forms, colours and connectors that take advantage of human perceptual ability to recognise patterns and associations -and support \"visual thinking\". We aim to make the relationship and sequence of formulae elements more evident and immediate using such techniques. Examples of how this might reveal itself include: learners recognising when a formula result is not fit for its intended purpose; identifying where an error is in a formula, or; identifying what modifications are necessary to ensure a formula does work. For example, if a cell is computing an unexpected result, the learner will need to closely inspect the formula and essentially 'debug' it. With good visual 'scaffolding', any problem in the formula should be more easily identified.",
            "score": 0.3014970898952687,
            "section_title": "VISUALISATION",
            "char_start_offset": 6899,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 201
                },
                {
                    "start": 202,
                    "end": 407
                },
                {
                    "start": 410,
                    "end": 601
                },
                {
                    "start": 602,
                    "end": 708
                },
                {
                    "start": 709,
                    "end": 837
                },
                {
                    "start": 838,
                    "end": 923
                },
                {
                    "start": 924,
                    "end": 1029
                },
                {
                    "start": 1032,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1345
                },
                {
                    "start": 1346,
                    "end": 1599
                },
                {
                    "start": 1600,
                    "end": 1738
                },
                {
                    "start": 1739,
                    "end": 1831
                }
            ],
            "ref_mentions": [
                {
                    "start": 188,
                    "end": 199,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 386,
                    "end": 406,
                    "matchedPaperCorpusId": "16369862"
                },
                {
                    "start": 491,
                    "end": 521,
                    "matchedPaperCorpusId": "62134455"
                },
                {
                    "start": 521,
                    "end": 546,
                    "matchedPaperCorpusId": "13087114"
                },
                {
                    "start": 546,
                    "end": 573,
                    "matchedPaperCorpusId": "7045329"
                },
                {
                    "start": 578,
                    "end": 600,
                    "matchedPaperCorpusId": "18730312"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.358642578125
        },
        {
            "corpus_id": "1652698",
            "title": "How Logo has Contributed to the Understanding of the Role of Informatics in Education and its Relation to the Learning Process",
            "text": "When the student is programming the computer s/he is engaged in a process of problem solving. By doing so s/he is using concepts and strategies that s/he already has or is searching for new information, processing it and transforming it into knowledge, which in a certain way are all made explicit in the program. The analysis of the programming activity using a language like Logo, more specifically the graphic part of Logo, allows the identification of different actions that happen in terms of the cycle of descriptionexecution-reflection-debugging-description, which the student does and which are important in order to understand how the program is produced: \n\n-Description of problem solution in terms of the programming language. This means using the entire knowledge structure (concepts involved in the problem, strategies to apply these concepts, concepts about the computer, the language, etc.) to represent and describe the steps in the solution of a problem in terms of the programming language; -Execution of this description by the computer. The description of the way the problem is solved in terms of a programming language that can be executed by the computer. In the case of Logo graphics, the Turtle behaves according to each command, presenting on the screen the result in the form of a graphic. The student can look at the figure as it is being built on the screen, and at the final product, reflect on this information; -Reflection on what has been produced by the computer. Reflection on results given by the computer can lead the learner to compare what was achieved with the original intended ideas and to take one of the following alternative actions: nothing, since the problem is considered resolved; or debug1 the description, since the result is different from what was intended; \n\n-Debugging the previous version, producing a new program version. The learner can search for bugs in her/his program, getting more information so to modify the previously defined description. At this moment, the description-execution-reflectiondebugging-description cycle is repeated. \n\nFrom the point of view of the description-execution-reflection-debugging-description cycle, each version of the learner's program can be seen as an explicit expression of her/his reasoning, in terms of a precise and formal language. In this sense, the description here is equivalent to the knowledge representation mentioned before.",
            "score": 0.3010957543757548,
            "section_title": "Logo Programming as a Cycle of Actions",
            "char_start_offset": 11415,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 93
                },
                {
                    "start": 94,
                    "end": 313
                },
                {
                    "start": 314,
                    "end": 664
                },
                {
                    "start": 667,
                    "end": 737
                },
                {
                    "start": 738,
                    "end": 1056
                },
                {
                    "start": 1057,
                    "end": 1178
                },
                {
                    "start": 1179,
                    "end": 1316
                },
                {
                    "start": 1317,
                    "end": 1497
                },
                {
                    "start": 1498,
                    "end": 1810
                },
                {
                    "start": 1813,
                    "end": 1878
                },
                {
                    "start": 1879,
                    "end": 2004
                },
                {
                    "start": 2005,
                    "end": 2097
                },
                {
                    "start": 2100,
                    "end": 2332
                },
                {
                    "start": 2333,
                    "end": 2432
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3310546875
        },
        {
            "corpus_id": "13642734",
            "title": "Rejecting Adaptive Interface",
            "text": "The main idea of user-driven application can be formulated in one fundamental law: user can do anything. User can move, resize, and change any screen element in any way he wants. To receive such a result, something must be done with the screen objects. When I began to work on the algorithm to turn screen objects into movable, there were two obvious requirements: it has to work without problems with any objects and it must be simple. What is really interesting in the proposed algorithm is its tendency for simplicity: for example, the mechanism of declaring movable and resizable a complex plotting area with an unlimited number of scales and related comments is nearly as simple as for a simple rectangle. Even if some of the following examples look like a science fiction to you, you must be aware from the very beginning that all of them are taken from the working application which is available at www.sourceforge.net in the project MoveableGraphics. The application is available together with all its codes! There was a period in the history of programming when code for calculations was intermixed with code for visualization and this was considered normal; later two parts of code were separated and the benefits were high. Up till now both parts continue to be under developers' jurisdiction; it's the time to separate also control over them. The idea of taking the control over visualization from developers and giving it to users looks absolutely heretical to nearly all developers. The prevailing view among developers about users of their programs is short and never publicly expressed \"Users are idiots\". I heard it not once in private professional discussions and every time I laughed because I made simple extrapolation and then the developers in Microsoft must express the same opinion about all those using Visual Studio. (An excellent analogue of a feed chain.) \n\nThe structure of nearly any program can be represented by three main parts: input data preparation, calculations on this data, and the demonstration of results. There are some programs which look like lacking the middle part of this trilogy (take some data from a database and simply show it), but I'll show further on that even such applications fit very well with the ideas of user-driven applications. Now take a list of paper and write down who in the pair developer -user is responsible for each of three stages.",
            "score": 0.3003821980665315,
            "section_title": "What is so new in user-driven applications?",
            "char_start_offset": 18930,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 104
                },
                {
                    "start": 105,
                    "end": 178
                },
                {
                    "start": 179,
                    "end": 252
                },
                {
                    "start": 253,
                    "end": 436
                },
                {
                    "start": 437,
                    "end": 710
                },
                {
                    "start": 711,
                    "end": 958
                },
                {
                    "start": 959,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1234
                },
                {
                    "start": 1235,
                    "end": 1354
                },
                {
                    "start": 1355,
                    "end": 1496
                },
                {
                    "start": 1497,
                    "end": 1621
                },
                {
                    "start": 1622,
                    "end": 1842
                },
                {
                    "start": 1843,
                    "end": 1883
                },
                {
                    "start": 1886,
                    "end": 2046
                },
                {
                    "start": 2047,
                    "end": 2290
                },
                {
                    "start": 2291,
                    "end": 2403
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1514892578125
        },
        {
            "corpus_id": "251713000",
            "title": "CodeToon: Story Ideation, Auto Comic Generation, and Structure Mapping for Code-Driven Storytelling",
            "text": "Moreover, understanding the nature and impact of this approach needs to be further investigated. For instance, what separates CodeToon from other visual programming environments like Scratch is that it can host artistic activities such as drawing. Recent efforts to combine art and programming-known as creative coding-teach and use programming as the primary medium for creating visual artifacts. While CodeToon also allows users to do this to some extent with comic generation, its drawing canvas opens up opportunities for us to potentially explore a different direction-one that does not center around generating art with programming and allows students to learn computational ideas from artistic activities without having to first learn programming. This leads to several questions: What artistic activities can we develop? How can we incorporate them into teaching and learning programming? How can they improve teaching and learning in CS education?",
            "score": 0.3001815675600117,
            "section_title": "Implications & Opportunities",
            "char_start_offset": 48001,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 96
                },
                {
                    "start": 97,
                    "end": 247
                },
                {
                    "start": 248,
                    "end": 397
                },
                {
                    "start": 398,
                    "end": 754
                },
                {
                    "start": 755,
                    "end": 828
                },
                {
                    "start": 829,
                    "end": 896
                },
                {
                    "start": 897,
                    "end": 956
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7724609375
        },
        {
            "corpus_id": "209002439",
            "title": "Use of Scratch for the Teaching of Second Languages",
            "text": "The Scratch programming language. \n\nScratch is a visual programming language created at MIT [1], in order to intuitively arouse and encourage computational thought and increase the development of mental skills. Its main area of application is non-university education. The goal is learning how to program without any previous knowledge, from a constructionist point of view (that is, learning by doing). In this regard, the Scratch programming language is characterized by the fact that it provides the main resources to program available to a typical programming language, with the difference that they are accessed through graphic icons shaped like the pieces of jigsaw, which internally represent a control structure or a data type. \n\nThus, programming teaching is metaphorically explained as the assembly of jigsaws for which the right pieces must be selected and correctly pieced together in order to implement a certain action. In addition, Scratch has a number of visual objects called sprites, various aspects of which, such as their color, size, shape, movements, sounds played, etc. can be configured. In this way, a Scratch program is an animated interaction between one or more sprites which are associated with a behavior or actions to be performed, which are programmed by means of one or more jigsaws representing those actions. One of the main programming resources provided by Scratch is event-based programming [36], which makes it possible to intuitively establish certain behaviors or actions that emerge in interaction depending on whether an event takes place or not. \n\nThe success of this simple programming language is due to several factors [28], mainly the use of typical gaming elements to motivate and facilitate the learning of programming, the possibilities for innovation and creativity offered to create educational resources in the form of animated stories [12], the great capacity for configuration and adaptability (as own or created images, backgrounds, and sounds can be used), and the vast number of available resources to work with Scratch [37], given that the software as well as the programs created are free, and anyone can access the programs created by other people, copy them, reuse them, modify them, etc. Likewise, the project gives users a set of supporting learning materials, such as manuals, videos, FAQs, and support for teachers. Scratch can be used online or installed as a desktop application.",
            "score": 0.30011440463704125,
            "section_title": "3",
            "char_start_offset": 17496,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 33
                },
                {
                    "start": 36,
                    "end": 210
                },
                {
                    "start": 211,
                    "end": 268
                },
                {
                    "start": 269,
                    "end": 403
                },
                {
                    "start": 404,
                    "end": 735
                },
                {
                    "start": 738,
                    "end": 933
                },
                {
                    "start": 934,
                    "end": 1111
                },
                {
                    "start": 1112,
                    "end": 1343
                },
                {
                    "start": 1344,
                    "end": 1589
                },
                {
                    "start": 1592,
                    "end": 2251
                },
                {
                    "start": 2252,
                    "end": 2382
                },
                {
                    "start": 2383,
                    "end": 2448
                }
            ],
            "ref_mentions": [
                {
                    "start": 92,
                    "end": 95,
                    "matchedPaperCorpusId": "13520484"
                },
                {
                    "start": 1429,
                    "end": 1433,
                    "matchedPaperCorpusId": "181536787"
                },
                {
                    "start": 1666,
                    "end": 1670,
                    "matchedPaperCorpusId": "145022149"
                },
                {
                    "start": 2079,
                    "end": 2083,
                    "matchedPaperCorpusId": "30784762"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.72607421875
        },
        {
            "paperId": "7e382526f5129477801a75c992f81ac6d7c727cf",
            "corpusId": 258461009,
            "title": "GPTutor: a ChatGPT-powered programming tool for code explanation",
            "venue": "International Conference on Artificial Intelligence in Education",
            "year": 2023,
            "referenceCount": 10,
            "citationCount": 78,
            "influentialCitationCount": 9,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "http://arxiv.org/pdf/2305.01863",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2305.01863, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2113753556",
                    "name": "Eason Chen"
                },
                {
                    "authorId": "2216357272",
                    "name": "Ray Huang"
                },
                {
                    "authorId": "2214012490",
                    "name": "Hanze Chen"
                },
                {
                    "authorId": "40130996",
                    "name": "Yuen-Hsien Tseng"
                },
                {
                    "authorId": "2145728177",
                    "name": "Liang-Yi Li"
                }
            ],
            "abstract": "Learning new programming skills requires tailored guidance. With the emergence of advanced Natural Language Generation models like the ChatGPT API, there is now a possibility of creating a convenient and personalized tutoring system with AI for computer science education. This paper presents GPTutor, a ChatGPT-powered programming tool, which is a Visual Studio Code extension using the ChatGPT API to provide programming code explanations. By integrating Visual Studio Code API, GPTutor can comprehensively analyze the provided code by referencing the relevant source codes. As a result, GPTutor can use designed prompts to explain the selected code with a pop-up message. GPTutor is now published at the Visual Studio Code Extension Marketplace, and its source code is openly accessible on GitHub. Preliminary evaluation indicates that GPTutor delivers the most concise and accurate explanations compared to vanilla ChatGPT and GitHub Copilot. Moreover, the feedback from students and teachers indicated that GPTutor is user-friendly and can explain given codes satisfactorily. Finally, we discuss possible future research directions for GPTutor. This includes enhancing its performance and personalization via further prompt programming, as well as evaluating the effectiveness of GPTutor with real users.",
            "corpus_id": "258461009",
            "text": "Learning new programming skills requires tailored guidance. With the emergence of advanced Natural Language Generation models like the ChatGPT API, there is now a possibility of creating a convenient and personalized tutoring system with AI for computer science education. This paper presents GPTutor, a ChatGPT-powered programming tool, which is a Visual Studio Code extension using the ChatGPT API to provide programming code explanations. By integrating Visual Studio Code API, GPTutor can comprehensively analyze the provided code by referencing the relevant source codes. As a result, GPTutor can use designed prompts to explain the selected code with a pop-up message. GPTutor is now published at the Visual Studio Code Extension Marketplace, and its source code is openly accessible on GitHub. Preliminary evaluation indicates that GPTutor delivers the most concise and accurate explanations compared to vanilla ChatGPT and GitHub Copilot. Moreover, the feedback from students and teachers indicated that GPTutor is user-friendly and can explain given codes satisfactorily. Finally, we discuss possible future research directions for GPTutor. This includes enhancing its performance and personalization via further prompt programming, as well as evaluating the effectiveness of GPTutor with real users.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.708984375
        },
        {
            "paperId": "fa8bb8ba04432543a65343bd66b4267ccb8d4d89",
            "corpusId": 9995009,
            "title": "Visual Explanation by High-Level Abduction: On Answer-Set Programming Driven Reasoning about Moving Objects",
            "venue": "AAAI Conference on Artificial Intelligence",
            "year": 2017,
            "referenceCount": 36,
            "citationCount": 30,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ojs.aaai.org/index.php/AAAI/article/download/11569/11428",
                "status": "BRONZE",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1712.00840, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2518732",
                    "name": "Jakob Suchan"
                },
                {
                    "authorId": "1796445",
                    "name": "M. Bhatt"
                },
                {
                    "authorId": "2898707",
                    "name": "P. Walega"
                },
                {
                    "authorId": "2650367",
                    "name": "C. Schultz"
                }
            ],
            "abstract": "\n \n We propose a hybrid architecture for systematically computing robust visual explanation(s) encompassing hypothesis formation, belief revision, and default reasoning with video data. The architecture consists of two tightly integrated synergistic components: (1) (functional) answer set programming based abductive reasoning with space-time tracklets as native entities; and (2) a visual processing pipeline for detection based object tracking and motion analysis. We present the formal framework, its general implementation as a (declarative) method in answer set programming, and an example application and evaluation based on two diverse video datasets: the MOTChallenge benchmark developed by the vision community, and a recently developed Movie Dataset.\n \n",
            "corpus_id": "9995009",
            "text": "\n \n We propose a hybrid architecture for systematically computing robust visual explanation(s) encompassing hypothesis formation, belief revision, and default reasoning with video data. The architecture consists of two tightly integrated synergistic components: (1) (functional) answer set programming based abductive reasoning with space-time tracklets as native entities; and (2) a visual processing pipeline for detection based object tracking and motion analysis. We present the formal framework, its general implementation as a (declarative) method in answer set programming, and an example application and evaluation based on two diverse video datasets: the MOTChallenge benchmark developed by the vision community, and a recently developed Movie Dataset.\n \n",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.841796875
        },
        {
            "paperId": "71cb456e2b98b672b6729d7787f060aa4f5757eb",
            "corpusId": 224777808,
            "title": "Question Authoring for Learning Programming Skills based on the Programmed Visual Content Comparison Method",
            "venue": "International Conference on Teaching, Assessment, and Learning for Engineering",
            "year": 2019,
            "referenceCount": 8,
            "citationCount": 1,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/TALE48000.2019.9225958?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/TALE48000.2019.9225958, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2652805",
                    "name": "H. Kiyomitsu"
                },
                {
                    "authorId": "2287751435",
                    "name": "Ha-Thanh Nguyen"
                },
                {
                    "authorId": "2760515",
                    "name": "K. Ohtsuki"
                },
                {
                    "authorId": "2925505",
                    "name": "Dick Martinez Calderon"
                },
                {
                    "authorId": "2055776155",
                    "name": "Shuai Shao"
                },
                {
                    "authorId": "1500661165",
                    "name": "Kento Shigyo"
                }
            ],
            "abstract": "This paper discusses a question authoring function of the Programmed Visual Contents Comparison Method (PVCC). With this method, by comparing two displayed pictures produced by programming samples (a question), a learner must decide which one the programs producing those pictures is the more difficult to build by programming, or if the difficulty is similar for all of them. After the learners answered the sample comparison, the PVCC test system returns the correct answer and detailed explanation of the question to make sure their understanding and improve their skill. A question in the PVCC test is to evaluate and to promote learners\u2019 programming skills related to a specific programming concept. Question for the PVCC test is hard to generate automatically because a programming concept is distributed and implicit in a program, and depends on the structure of arbitrary programs. Therefore, we design and prototype an authoring function to store programming samples, to combine samples and generate a question and to organize the test for the PVCC test system.",
            "corpus_id": "224777808",
            "text": "This paper discusses a question authoring function of the Programmed Visual Contents Comparison Method (PVCC). With this method, by comparing two displayed pictures produced by programming samples (a question), a learner must decide which one the programs producing those pictures is the more difficult to build by programming, or if the difficulty is similar for all of them. After the learners answered the sample comparison, the PVCC test system returns the correct answer and detailed explanation of the question to make sure their understanding and improve their skill. A question in the PVCC test is to evaluate and to promote learners\u2019 programming skills related to a specific programming concept. Question for the PVCC test is hard to generate automatically because a programming concept is distributed and implicit in a program, and depends on the structure of arbitrary programs. Therefore, we design and prototype an authoring function to store programming samples, to combine samples and generate a question and to organize the test for the PVCC test system.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.57080078125
        },
        {
            "paperId": "0c436050172333f097ab99528305fe7dbf647bcc",
            "corpusId": 260854137,
            "title": "A Logic-based Approach to Contrastive Explainability for Neurosymbolic Visual Question Answering",
            "venue": "International Joint Conference on Artificial Intelligence",
            "year": 2023,
            "referenceCount": 37,
            "citationCount": 8,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.ijcai.org/proceedings/2023/0408.pdf",
                "status": "BRONZE",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.24963/ijcai.2023/408?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.24963/ijcai.2023/408, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "72431510",
                    "name": "Thomas Eiter"
                },
                {
                    "authorId": "116145548",
                    "name": "Tobias Geibinger"
                },
                {
                    "authorId": "134514334",
                    "name": "N. Higuera"
                },
                {
                    "authorId": "2953376",
                    "name": "J. Oetsch"
                }
            ],
            "abstract": "Visual Question Answering (VQA) is a well-known problem for which deep-learning is key. This poses a challenge for explaining answers to questions, the more if advanced notions like contrastive explanations (CEs) should be provided. The latter explain why an answer has been reached in contrast to a different one and are attractive as they focus on reasons necessary to flip a query answer. We present a CE framework for VQA that uses a neurosymbolic VQA architecture which disentangles perception from reasoning. Once the reasoning part is provided as logical theory, we use answer-set programming, in which CE generation can be framed as an abduction problem. We validate our approach on the CLEVR dataset, which we extend by more sophisticated questions to further demonstrate the robustness of the modular architecture. While we achieve top performance compared to related approaches, we can also produce CEs for explanation, model debugging, and validation tasks, showing the versatility of the declarative approach to reasoning.",
            "corpus_id": "260854137",
            "text": "Visual Question Answering (VQA) is a well-known problem for which deep-learning is key. This poses a challenge for explaining answers to questions, the more if advanced notions like contrastive explanations (CEs) should be provided. The latter explain why an answer has been reached in contrast to a different one and are attractive as they focus on reasons necessary to flip a query answer. We present a CE framework for VQA that uses a neurosymbolic VQA architecture which disentangles perception from reasoning. Once the reasoning part is provided as logical theory, we use answer-set programming, in which CE generation can be framed as an abduction problem. We validate our approach on the CLEVR dataset, which we extend by more sophisticated questions to further demonstrate the robustness of the modular architecture. While we achieve top performance compared to related approaches, we can also produce CEs for explanation, model debugging, and validation tasks, showing the versatility of the declarative approach to reasoning.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.45556640625
        },
        {
            "paperId": "c91dfdd5d603a86d1d8f9af66cc03bb405a41a3c",
            "corpusId": 250417377,
            "title": "A Neural-Symbolic Approach for Explanation Generation Based on Sub-concept Detection: An Application of Metric Learning for Low-Time-Budget Labeling",
            "venue": "KI - K\u00fcnstliche Intelligenz",
            "year": 2022,
            "referenceCount": 37,
            "citationCount": 2,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://link.springer.com/content/pdf/10.1007/s13218-022-00771-9.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1007/s13218-022-00771-9?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1007/s13218-022-00771-9, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "51209797",
                    "name": "Johannes Rabold"
                }
            ],
            "abstract": "Deep learning methods, although effective in their assigned tasks, are mostly black-boxes with respect to their inner workings. For image classification with CNNs, there exists a variety of visual explanation methods that highlight parts of input images that were relevant for the classification result. But in many domains visual highlighting may not be expressive enough when the classification relies on complex relations within visual concepts. This paper presents an approach to enrich visual explanations with verbal local explanations, emphasizing important relational information. The proposed SymMetric algorithm combines metric learning and inductive logic programming (ILP). Labels given by a human for a small subset of important image parts are first generalized to a neighborhood of similar images using a learned distance metric. The information about labels and their spatial relations is then used to build background knowledge for ILP and ultimately to learn a first-order theory that locally explains the black-box with respect to the given image. The approach is evaluated with the Dogs vs. Cats data set demonstrating the generalization ability of metric learning and with Picasso Faces to illustrate recognition of spatial meaningful constellations of sub-concepts and creation of an expressive explanation.",
            "corpus_id": "250417377",
            "text": "Deep learning methods, although effective in their assigned tasks, are mostly black-boxes with respect to their inner workings. For image classification with CNNs, there exists a variety of visual explanation methods that highlight parts of input images that were relevant for the classification result. But in many domains visual highlighting may not be expressive enough when the classification relies on complex relations within visual concepts. This paper presents an approach to enrich visual explanations with verbal local explanations, emphasizing important relational information. The proposed SymMetric algorithm combines metric learning and inductive logic programming (ILP). Labels given by a human for a small subset of important image parts are first generalized to a neighborhood of similar images using a learned distance metric. The information about labels and their spatial relations is then used to build background knowledge for ILP and ultimately to learn a first-order theory that locally explains the black-box with respect to the given image. The approach is evaluated with the Dogs vs. Cats data set demonstrating the generalization ability of metric learning and with Picasso Faces to illustrate recognition of spatial meaningful constellations of sub-concepts and creation of an expressive explanation.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.429443359375
        },
        {
            "paperId": "658a25a4a0c3298641400f1b7e4e71326e274b0d",
            "corpusId": 248069238,
            "title": "Automated Design of Salient Object Detection Algorithms with Brain Programming",
            "venue": "Applied Sciences",
            "year": 2022,
            "referenceCount": 42,
            "citationCount": 3,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.mdpi.com/2076-3417/12/20/10686/pdf?version=1666620181",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2204.03722, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1721596",
                    "name": "Gustavo Olague"
                },
                {
                    "authorId": "1557562280",
                    "name": "J. Menendez-Clavijo"
                },
                {
                    "authorId": "2125341066",
                    "name": "Matthieu Olague"
                },
                {
                    "authorId": "2061843366",
                    "name": "Arturo Ocampo"
                },
                {
                    "authorId": "1643930067",
                    "name": "Gerardo Ibarra-V\u00e1zquez"
                },
                {
                    "authorId": "1405774413",
                    "name": "R. Ochoa-Montiel"
                },
                {
                    "authorId": "2161967292",
                    "name": "Roberto Pineda"
                }
            ],
            "abstract": "Despite recent improvements in computer vision, artificial visual systems\u2019 design is still daunting since an explanation of visual computing algorithms remains elusive. Salient object detection is one problem that is still open due to the difficulty of understanding the brain\u2019s inner workings. Progress in this research area follows the traditional path of hand-made designs using neuroscience knowledge or, more recently, deep learning, a particular branch of machine learning. Recently, a different approach based on genetic programming appeared to enhance handcrafted techniques following two different strategies. The first method follows the idea of combining previous hand-made methods through genetic programming and fuzzy logic. The second approach improves the inner computational structures of basic hand-made models through artificial evolution. This research proposes expanding the artificial dorsal stream using a recent proposal based on symbolic learning to solve salient object detection problems following the second technique. This approach applies the fusion of visual saliency and image segmentation algorithms as a template. The proposed methodology discovers several critical structures in the template through artificial evolution. We present results on a benchmark designed by experts with outstanding results in an extensive comparison with the state of the art, including classical methods and deep learning approaches to highlight the importance of symbolic learning in visual saliency.",
            "corpus_id": "248069238",
            "text": "Despite recent improvements in computer vision, artificial visual systems\u2019 design is still daunting since an explanation of visual computing algorithms remains elusive. Salient object detection is one problem that is still open due to the difficulty of understanding the brain\u2019s inner workings. Progress in this research area follows the traditional path of hand-made designs using neuroscience knowledge or, more recently, deep learning, a particular branch of machine learning. Recently, a different approach based on genetic programming appeared to enhance handcrafted techniques following two different strategies. The first method follows the idea of combining previous hand-made methods through genetic programming and fuzzy logic. The second approach improves the inner computational structures of basic hand-made models through artificial evolution. This research proposes expanding the artificial dorsal stream using a recent proposal based on symbolic learning to solve salient object detection problems following the second technique. This approach applies the fusion of visual saliency and image segmentation algorithms as a template. The proposed methodology discovers several critical structures in the template through artificial evolution. We present results on a benchmark designed by experts with outstanding results in an extensive comparison with the state of the art, including classical methods and deep learning approaches to highlight the importance of symbolic learning in visual saliency.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.390380859375
        },
        {
            "paperId": "840ad2146a494206af610c211be7ace603396d0e",
            "corpusId": 203737340,
            "title": "Enriching Visual with Verbal Explanations for Relational Concepts - Combining LIME with Aleph",
            "venue": "PKDD/ECML Workshops",
            "year": 2019,
            "referenceCount": 26,
            "citationCount": 57,
            "influentialCitationCount": 5,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1910.01837, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "51209797",
                    "name": "Johannes Rabold"
                },
                {
                    "authorId": "137658876",
                    "name": "Hannah Deininger"
                },
                {
                    "authorId": "1793426",
                    "name": "M. Siebers"
                },
                {
                    "authorId": "1727734",
                    "name": "Ute Schmid"
                }
            ],
            "abstract": "With the increasing number of deep learning applications, there is a growing demand for explanations. Visual explanations provide information about which parts of an image are relevant for a classifier's decision. However, highlighting of image parts (e.g., an eye) cannot capture the relevance of a specific feature value for a class (e.g., that the eye is wide open). Furthermore, highlighting cannot convey whether the classification depends on the mere presence of parts or on a specific spatial relation between them. Consequently, we present an approach that is capable of explaining a classifier's decision in terms of logic rules obtained by the Inductive Logic Programming system Aleph. The examples and the background knowledge needed for Aleph are based on the explanation generation method LIME. We demonstrate our approach with images of a blocksworld domain. First, we show that our approach is capable of identifying a single relation as important explanatory construct. Afterwards, we present the more complex relational concept of towers. Finally, we show how the generated relational rules can be explicitly related with the input image, resulting in richer explanations.",
            "corpus_id": "203737340",
            "text": "With the increasing number of deep learning applications, there is a growing demand for explanations. Visual explanations provide information about which parts of an image are relevant for a classifier's decision. However, highlighting of image parts (e.g., an eye) cannot capture the relevance of a specific feature value for a class (e.g., that the eye is wide open). Furthermore, highlighting cannot convey whether the classification depends on the mere presence of parts or on a specific spatial relation between them. Consequently, we present an approach that is capable of explaining a classifier's decision in terms of logic rules obtained by the Inductive Logic Programming system Aleph. The examples and the background knowledge needed for Aleph are based on the explanation generation method LIME. We demonstrate our approach with images of a blocksworld domain. First, we show that our approach is capable of identifying a single relation as important explanatory construct. Afterwards, we present the more complex relational concept of towers. Finally, we show how the generated relational rules can be explicitly related with the input image, resulting in richer explanations.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.59716796875
        },
        {
            "paperId": "70581a425de60768f99bafd7637c593a3dad6cdb",
            "corpusId": 246363368,
            "title": "The Practice and Exploration of Scratch Programming Instruction in Elementary School Based on Game Design",
            "venue": "2021 IEEE Conference on Telecommunications, Optics and Computer Science (TOCS)",
            "year": 2021,
            "referenceCount": 0,
            "citationCount": 1,
            "influentialCitationCount": 1,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/TOCS53301.2021.9688834?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/TOCS53301.2021.9688834, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2077268904",
                    "name": "Yang Huansong"
                },
                {
                    "authorId": "1693737200",
                    "name": "Wu Jia\u2019en"
                },
                {
                    "authorId": "1965913580",
                    "name": "Shen Mengting"
                }
            ],
            "abstract": "With the proposal of quality-oriented education, Scratch programming teaching in elementary schools is of great importance to the growth and development of students. The visual interface, building block programming, and easy-to-use features of Scratch are suitable for teaching elementary school students, which can also better cultivate students\u2019 analytical problem-solving skills and enhance their logical thinking. However, only a part of schools and students are currently learning this programming, and it is not popular enough yet. Moreover, if the teaching is mainly based on the teacher\u2019s explanation, it will be boring. Therefore, there is a need to explore the teaching based on game design and combine teaching with fun, so that learning can become a more acceptable \u201cgame\u201d for students, making the classroom atmosphere more active and improving the teaching quality of the classroom.",
            "corpus_id": "246363368",
            "text": "With the proposal of quality-oriented education, Scratch programming teaching in elementary schools is of great importance to the growth and development of students. The visual interface, building block programming, and easy-to-use features of Scratch are suitable for teaching elementary school students, which can also better cultivate students\u2019 analytical problem-solving skills and enhance their logical thinking. However, only a part of schools and students are currently learning this programming, and it is not popular enough yet. Moreover, if the teaching is mainly based on the teacher\u2019s explanation, it will be boring. Therefore, there is a need to explore the teaching based on game design and combine teaching with fun, so that learning can become a more acceptable \u201cgame\u201d for students, making the classroom atmosphere more active and improving the teaching quality of the classroom.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.2044677734375
        },
        {
            "paperId": "3cecaadcc0235e98424297e0a8b8cfe353a26d99",
            "corpusId": 229634126,
            "title": "EDUCATIONAL COURSE \"PROGRAMMING OF INTERNET-ORIENTED APPLICATIONS\": FEATURES OF TEACHING",
            "venue": "",
            "year": 2020,
            "referenceCount": 14,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://openedu.kubg.edu.ua/journal/index.php/openedu/article/download/324/336",
                "status": "GOLD",
                "license": "CCBYNCSA",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.28925/2414-0325.2020.9.2?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.28925/2414-0325.2020.9.2, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "151159536",
                    "name": "O. Dushchenko"
                }
            ],
            "abstract": "The use of Internet-oriented applications is constantly growing, but the question arises how to create Internet-oriented applications. The educational course \"Programming of Internet-oriented applications\" is designed to solve this problem. The article describes the subject, purpose and results of the educational course \"Programming of Internet-oriented applications\". The content of the program of the educational course \"Programming of Internet-oriented applications\" is given. The methodical aspects of teaching the course \"Programming of Internet-oriented applications\" are revealed, namely the description of lectures with the description of studying the concepts of the topic, methods and means of teaching (verbal teaching methods (explanation, story, conversation), visual teaching methods (demonstration), methods learning depending on the type of cognitive activity (information-receptive, reproductive, problem, partial-search (heuristic), search (research), inductive, deductive), method of stimulating interest in learning and motivation of learning-cognitive activity (discussion); computer), laboratory practicals with a description of tasks to perform, methods and means of teaching (verbal teaching methods (explanation, story, instruction), visual teaching methods (illustration, demonstration), teaching methods depending on the type of cognitive activity (reproductive), methods of control and self-control on the effectiveness of educational and cognitive activities: methods of oral control (individual recitation, frontal recitation), methods of self-control (personal exploration of errors, self-analysis); textbook, computer), independent work of students, modular control work. It is noted that for most lectures multimedia presentations have been developed, which are freely available on the Internet. A distance course \"Programming of Internet-oriented applications\" has been created as part of distance learning implementation.",
            "corpus_id": "229634126",
            "text": "The use of Internet-oriented applications is constantly growing, but the question arises how to create Internet-oriented applications. The educational course \"Programming of Internet-oriented applications\" is designed to solve this problem. The article describes the subject, purpose and results of the educational course \"Programming of Internet-oriented applications\". The content of the program of the educational course \"Programming of Internet-oriented applications\" is given. The methodical aspects of teaching the course \"Programming of Internet-oriented applications\" are revealed, namely the description of lectures with the description of studying the concepts of the topic, methods and means of teaching (verbal teaching methods (explanation, story, conversation), visual teaching methods (demonstration), methods learning depending on the type of cognitive activity (information-receptive, reproductive, problem, partial-search (heuristic), search (research), inductive, deductive), method of stimulating interest in learning and motivation of learning-cognitive activity (discussion); computer), laboratory practicals with a description of tasks to perform, methods and means of teaching (verbal teaching methods (explanation, story, instruction), visual teaching methods (illustration, demonstration), teaching methods depending on the type of cognitive activity (reproductive), methods of control and self-control on the effectiveness of educational and cognitive activities: methods of oral control (individual recitation, frontal recitation), methods of self-control (personal exploration of errors, self-analysis); textbook, computer), independent work of students, modular control work. It is noted that for most lectures multimedia presentations have been developed, which are freely available on the Internet. A distance course \"Programming of Internet-oriented applications\" has been created as part of distance learning implementation.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.06585693359375
        }
    ],
    "quotes": {
        "cost": 0.177666,
        "quotes": [
            {
                "idx": 0,
                "key": "[186749406 | Dermawan et al. | 2019 | Citations: 2]",
                "snippets": "In Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual Basic",
                        "pdf_hash": "",
                        "start": 305,
                        "end": 624,
                        "sentence_offsets": [
                            {
                                "start": 305,
                                "end": 525
                            },
                            {
                                "start": 526,
                                "end": 624
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "In Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach."
                    }
                ]
            },
            {
                "idx": 1,
                "key": "[19038821 | Sukumar et al. | 2017 | Citations: 0]",
                "snippets": "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax (Myers, 1990)[53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains (Myers, 1990)[41].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "VP concepts",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 514,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 156
                            },
                            {
                                "start": 157,
                                "end": 371
                            },
                            {
                                "start": 372,
                                "end": 514
                            }
                        ],
                        "ref_mentions": [
                            "7335020",
                            "7335020"
                        ],
                        "quote": "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax (Myers, 1990)[53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains (Myers, 1990)[41]."
                    }
                ]
            },
            {
                "idx": 2,
                "key": "[199002134 | Joao et al. | 2019 | Citations: 23]",
                "snippets": "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual and Block-based Programming Environment",
                        "pdf_hash": "",
                        "start": 401,
                        "end": 973,
                        "sentence_offsets": [
                            {
                                "start": 401,
                                "end": 547
                            },
                            {
                                "start": 548,
                                "end": 674
                            },
                            {
                                "start": 675,
                                "end": 679
                            },
                            {
                                "start": 680,
                                "end": 973
                            }
                        ],
                        "ref_mentions": [
                            "7335020"
                        ],
                        "quote": "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs."
                    }
                ]
            },
            {
                "idx": 3,
                "key": "[202566030 | Zikas et al. | 2019 | Citations: 1]",
                "snippets": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities....On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual Programming as an authoring tool",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 477,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 111
                            },
                            {
                                "start": 112,
                                "end": 476
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities"
                    },
                    {
                        "section_title": "Visual Programming as an authoring tool",
                        "pdf_hash": "",
                        "start": 1492,
                        "end": 1774,
                        "sentence_offsets": [
                            {
                                "start": 1492,
                                "end": 1642
                            },
                            {
                                "start": 1643,
                                "end": 1773
                            }
                        ],
                        "ref_mentions": [],
                        "quote": ".On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow."
                    }
                ]
            },
            {
                "idx": 4,
                "key": "[212726996 | Chiu | 2020 | Citations: 40]",
                "snippets": "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming (Denny et al., 2011)- (Denny et al., 2012). Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual programming environment",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 953,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 157
                            },
                            {
                                "start": 158,
                                "end": 329
                            },
                            {
                                "start": 330,
                                "end": 417
                            },
                            {
                                "start": 418,
                                "end": 627
                            },
                            {
                                "start": 628,
                                "end": 766
                            },
                            {
                                "start": 767,
                                "end": 953
                            }
                        ],
                        "ref_mentions": [
                            "33572463",
                            "2965215"
                        ],
                        "quote": "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming (Denny et al., 2011)- (Denny et al., 2012). Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions."
                    }
                ]
            },
            {
                "idx": 5,
                "key": "[221340525 | Alturayeif et al. | 2020 | Citations: 19]",
                "snippets": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "II. BACKGROUND",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 560,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 137
                            },
                            {
                                "start": 138,
                                "end": 339
                            },
                            {
                                "start": 340,
                                "end": 560
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]."
                    }
                ]
            },
            {
                "idx": 6,
                "key": "[221802417 | McDaid et al. | 2020 | Citations: 4]",
                "snippets": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers (Myers, 1990). There are now many visual programming languages (Johnston et al., 2004)11,(Maloney et al., 2010). Many of which are aimed at education or niche domains (Bockermann, 2014)(Ray, 2017)(Andrade, 2015)16,(Gulwani et al., 2015).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[158715 | Andrade | 2015 | Citations: 34]": "Due to hardware limitations at the origin of the video game industry, each new game was generally coded from the ground up. Years later, from the evolution of hardware and the need for quick game development cycles, spawned the concept of game engine. A game engine is a reusable software layer allowing the separation of common game concepts from the game assets (levels, graphics, etc.). This paper surveys fourteen different game engines relevant today, ranging from the industry-level to the newcomer-friendlier ones.",
                    "[30037917 | Ray | 2017 | Citations: 60]": "Visual programming has transformed the art of programming in recent years. Several organizations are in race to develop novel ideas to run visual programming in multiple domains with Internet of Things. IoT, being the most emerging area of computing, needs substantial contribution from the visual programming paradigm for its technological propagation. This paper surveys visual programming languages being served for application development, especially in Internet of Things field. 13 such languages are visited from several popular research-electronic databases (e.g., IEEE Xplore, Science Direct, Springer Link, Google Scholar, Web of Science, and Postscapes) and compared under four key attributes such as programming environment, license, project repository, and platform supports. Grouped into two segments, open source and proprietary platform, these visual languages pertain few crucial challenges that have been elaborated in this literature. The main goal of this paper is to present existing VPLs per their parametric proforma to enable naive developers and researchers in the field of IoT to choose appropriate variant of VPL for particular type of application. It is also worth validating the usability and adaptability of VPLs that is essential for selection of beneficiary in terms of IoT."
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 687,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 89
                            },
                            {
                                "start": 90,
                                "end": 230
                            },
                            {
                                "start": 231,
                                "end": 412
                            },
                            {
                                "start": 415,
                                "end": 555
                            },
                            {
                                "start": 556,
                                "end": 615
                            },
                            {
                                "start": 616,
                                "end": 687
                            }
                        ],
                        "ref_mentions": [
                            "7335020",
                            "5257722",
                            "9744698",
                            "44279097",
                            "30037917",
                            "158715",
                            "425881"
                        ],
                        "quote": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers (Myers, 1990). There are now many visual programming languages (Johnston et al., 2004)11,(Maloney et al., 2010). Many of which are aimed at education or niche domains (Bockermann, 2014)(Ray, 2017)(Andrade, 2015)16,(Gulwani et al., 2015)."
                    }
                ]
            },
            {
                "idx": 7,
                "key": "[225541919 | Falgenti | 2020 | Citations: 2]",
                "snippets": "Visual programming (PV) is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual programming (PV) is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming.",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 8,
                "key": "[231725028 | Kuhail et al. | 2021 | Citations: 39]",
                "snippets": "Visual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13].\n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13].\n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages.",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 9,
                "key": "[236566925 | Aldhlan et al. | 2021 | Citations: 2]",
                "snippets": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI).\n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations.\n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer.\n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc.\n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual programming:",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 848,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 149
                            },
                            {
                                "start": 150,
                                "end": 360
                            },
                            {
                                "start": 363,
                                "end": 692
                            },
                            {
                                "start": 695,
                                "end": 896
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI).\n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations.\n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts"
                    },
                    {
                        "section_title": "Visual programming:",
                        "pdf_hash": "",
                        "start": 697,
                        "end": 1543,
                        "sentence_offsets": [
                            {
                                "start": 695,
                                "end": 896
                            },
                            {
                                "start": 897,
                                "end": 978
                            },
                            {
                                "start": 979,
                                "end": 1158
                            },
                            {
                                "start": 1161,
                                "end": 1286
                            },
                            {
                                "start": 1287,
                                "end": 1305
                            },
                            {
                                "start": 1308,
                                "end": 1490
                            },
                            {
                                "start": 1491,
                                "end": 1701
                            }
                        ],
                        "ref_mentions": [],
                        "quote": ") and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer.\n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc.\n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions."
                    }
                ]
            },
            {
                "idx": 10,
                "key": "[243857547 | Zhu et al. | 2021 | Citations: 6]",
                "snippets": "Visualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Overview of Python-based Visualized Design",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 259,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 259
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result."
                    }
                ]
            },
            {
                "idx": 11,
                "key": "[246022597 | Pongthanisorn et al. | 2022 | Citations: 0]",
                "snippets": "Visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Introduction",
                        "pdf_hash": "",
                        "start": 616,
                        "end": 1069,
                        "sentence_offsets": [
                            {
                                "start": 606,
                                "end": 692
                            },
                            {
                                "start": 693,
                                "end": 801
                            },
                            {
                                "start": 802,
                                "end": 852
                            },
                            {
                                "start": 853,
                                "end": 907
                            },
                            {
                                "start": 908,
                                "end": 1069
                            }
                        ],
                        "ref_mentions": [
                            "7335020"
                        ],
                        "quote": "Visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990)."
                    }
                ]
            },
            {
                "idx": 12,
                "key": "[248510289 | Savidis | 2022 | Citations: 1]",
                "snippets": "The notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990)). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "INTRODUCTION",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 393,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 114
                            },
                            {
                                "start": 115,
                                "end": 280
                            },
                            {
                                "start": 281,
                                "end": 393
                            }
                        ],
                        "ref_mentions": [
                            "7335020"
                        ],
                        "quote": "The notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990)). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming."
                    }
                ]
            },
            {
                "idx": 13,
                "key": "[248524774 | Hirzel | 2022 | Citations: 21]",
                "snippets": "Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Palette Code canvas Stage",
                        "pdf_hash": "",
                        "start": 26,
                        "end": 1044,
                        "sentence_offsets": [
                            {
                                "start": 26,
                                "end": 133
                            },
                            {
                                "start": 134,
                                "end": 265
                            },
                            {
                                "start": 266,
                                "end": 412
                            },
                            {
                                "start": 413,
                                "end": 591
                            },
                            {
                                "start": 592,
                                "end": 895
                            },
                            {
                                "start": 896,
                                "end": 1044
                            }
                        ],
                        "ref_mentions": [
                            "2385464"
                        ],
                        "quote": "Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane."
                    }
                ]
            },
            {
                "idx": 14,
                "key": "[250414169 | Fanchamps et al. | 2022 | Citations: 5]",
                "snippets": "In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- (S\u00e1ez-L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011)(Tsai, 2019).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[8626769 | Moreno et al. | 2011 | Citations: 136]": "In 3 experiments, we examined the effects of using concrete and/or abstract visual problem representations during instruction on students' problem-solving practice, near transfer, problem representations, and learning perceptions. In Experiments 1 and 2, novice students learned about electrical circuit analysis with an instructional program that included worked-out and practice problems represented with abstract (Group A), concrete (Group C), or abstract and concrete diagrams (Group AC), whereby the cover stories were abstract in Group A and concrete in Groups C and AC. Experiment 3 added a 4th condition (C-A) with a concrete cover story and abstract diagrams. Group AC outperformed Groups A and C on problem-solving practice in Experiments 1 and 2 and outperformed Group C on transfer across the 3 experiments; Group AC also outperformed Group C-A in Experiment 3. Further, Group A outperformed Group C on transfer in Experiments 2 and 3 and outperformed Group C-A in Experiment 3. Transfer scores were positively associated with the quality of the diagrams and the number of abstract representations drawn during the transfer test. Data on students' learning perceptions suggest that the advantage of Group AC relies on the combined cognitive support of both representations. Our studies indicate that problem solving is fostered when learners experience concrete visual representations that connect to their prior knowledge and are enabled to use abstract visual representations"
                },
                "metadata": [
                    {
                        "section_title": "Theoretical framework",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 481,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 234
                            },
                            {
                                "start": 235,
                                "end": 481
                            }
                        ],
                        "ref_mentions": [
                            "27633066",
                            "8626769",
                            "92996231"
                        ],
                        "quote": "In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- (S\u00e1ez-L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011)(Tsai, 2019)."
                    }
                ]
            },
            {
                "idx": 15,
                "key": "[256827582 | Wagner et al. | 2023 | Citations: 1]",
                "snippets": "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations.\n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[41867280 | Repenning | 2017 | Citations: 50]": "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                },
                "metadata": [
                    {
                        "section_title": "BACKGROUND ON VISUAL PROGRAMMING",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 612,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 153
                            },
                            {
                                "start": 154,
                                "end": 284
                            },
                            {
                                "start": 287,
                                "end": 359
                            },
                            {
                                "start": 362,
                                "end": 443
                            },
                            {
                                "start": 444,
                                "end": 522
                            },
                            {
                                "start": 523,
                                "end": 613
                            }
                        ],
                        "ref_mentions": [
                            "14591095",
                            "41867280"
                        ],
                        "quote": "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations.\n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour."
                    }
                ]
            },
            {
                "idx": 16,
                "key": "[257145390 | Chen et al. | 2023 | Citations: 5]",
                "snippets": "Visual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation (Zheng et al., 2021). Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan (Xiang et al., 2021).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[235749050 | Zheng et al. | 2021 | Citations: 111]": "In visual reasoning, the achievement of deep learning significantly improved the accuracy of results. Image features are primarily used as input to get answers. However, the image features are too redundant to learn accurate characterizations within a limited complexity and time. While in the process of human reasoning, abstract description of an image is usually to avoid irrelevant details. Inspired by this, a higher-level representation named semantic representation is introduced. In this paper, a detailed visual reasoning model is proposed. This new model contains an image understanding model based on semantic representation, feature extraction and process model refined with watershed and u-distance method, a feature vector learning model using pyramidal pooling and residual network, and a question understanding model combining problem embedding coding method and machine translation decoding method. The feature vector could better represent the whole image instead of overly focused on specific characteristics. The model using semantic representation as input verifies that more accurate results can be obtained by introducing a high-level semantic representation. The result also shows that it is feasible and effective to introduce high-level and abstract forms of knowledge representation into deep learning tasks. This study lays a theoretical and experimental foundation for introducing different levels of knowledge representation into deep learning in the future.",
                    "[237732833 | Xiang et al. | 2021 | Citations: 134]": "The availability of thermodynamic data for geologically relevant phases has made practical the calculation of stable phase relations throughout the mantle and crust of terrestrial planets. GeoPS (http://www.geops.org) is a program designed for this purpose in which both input and output are done through an intuitive graphical user interface. GeoPS provides a wide range of phase equilibrium calculations based on a novel Gibbs energy minimization algorithm. The algorithm provides for exceptionally robust and computationally efficient solution to the phase equilibrium problem by successive alternation between a linear programming step to identify stable phase compositions and a non\u2010linear programming step to refine the compositions estimated during the linear programming. Applications include calculation of various types of phase diagrams and path\u2010dependent phase fractionation. By combining an easy\u2010to\u2010use graphical user interface with a robust and efficient solver, GeoPS makes phase equilibrium modelling accessible to researchers and students with minimal training and provides a powerful tool for understanding natural phase relations and for planning experimental work."
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming Problem-Solving Model.",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 493,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 167
                            },
                            {
                                "start": 168,
                                "end": 338
                            },
                            {
                                "start": 339,
                                "end": 493
                            }
                        ],
                        "ref_mentions": [
                            "235749050",
                            "237732833"
                        ],
                        "quote": "Visual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation (Zheng et al., 2021). Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan (Xiang et al., 2021)."
                    }
                ]
            },
            {
                "idx": 17,
                "key": "[259335765 | DeLozier et al. | 2023 | Citations: 6]",
                "snippets": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018). This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[235383033 | Papadakis | 2021 | Citations: 90]": "Data that shows that young children can learn and acquire Computational Thinking (CT) skills has led governments and policymakers internationally to integrate CT into the curriculum, starting in the earliest grades. Researchers support the idea that this introduction must not solely focus on a problem-solving process skill (CT) but instead provide children with new ways to express themselves, supporting their cognitive, language, and socio-emotional development (Computational Fluency-CF). Coupled with the media and government\u2019s rhetoric and an increasing number of apps offering various programming lessons, puzzles, and challenges, educators have been responsible for introducing young children to CT and CF using touchscreen technology. This paper presents a literature review (N = 21) of empirical studies on applying four coding apps to support young children\u2019s learning of CT and CF. The main conclusion is that all apps positively affect the development of children\u2019s CT skills. None of the apps can ultimately support the development of CF, although ScratchJr, with a \u201csandbox\u201d approach, can better help students express themselves.",
                    "[253196672 | Timur et al. | 2021 | Citations: 6]": "\"Abstract: In this study, it was aimed to examine the pre-service pre-school teachers\u2019 opinions about using block-based coding/Scratch in education. 28 pre-service pre-school teachers were participated studying at a public university in a Marmara province region. Within the scope of the study, pre-service teachers were trained on the block-based coding Scratch program for four weeks. A semi-structured interview form consisting of 12 questions was used to determine the opinions of the participants. The data of the study were analyzed using the descriptive analysis method. As a result of the study, 85.71% of pre-school teacher candidates stated that block-based coding education should start at an early age like a language education, this education is important as a necessity of the technology age and all students should benefit from this education in order to provide an effective education, 14.25% of teacher candidates specified that this education is untimely for younger age levels and should not be given to everyone. In addition, the pre-service teachers stated that the block-based coding/Scratch program training helped them gain new ideas in terms of creating materials, improved their creativity and contributed to design abstract material in addition to concrete ones. Additionally, 46.42% of pre-service teachers stated that block-based coding education should start between the ages of 5-7. In this context, it is recommended to provide coding education both in pre-school and undergraduate education.\"",
                    "[35735491 | Urness et al. | 2011 | Citations: 2]": "In this paper we describe several techniques that have helped increase enrollment in the computer science program from 23 computer science majors in 2008 to 42 computer science majors in 2010 - an increase of 82.6%. We discuss issues related to curriculum, programming assignments, and professor-student interactions that have made the discipline more attractive and manageable to a variety of students within the setting of a small liberal arts college."
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 1016,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 76
                            },
                            {
                                "start": 77,
                                "end": 187
                            },
                            {
                                "start": 188,
                                "end": 278
                            },
                            {
                                "start": 279,
                                "end": 425
                            },
                            {
                                "start": 426,
                                "end": 548
                            },
                            {
                                "start": 549,
                                "end": 696
                            },
                            {
                                "start": 697,
                                "end": 788
                            },
                            {
                                "start": 789,
                                "end": 1016
                            }
                        ],
                        "ref_mentions": [
                            "253196672",
                            "235383033",
                            "10976181",
                            "35735491",
                            "51750550"
                        ],
                        "quote": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018). This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]."
                    }
                ]
            },
            {
                "idx": 18,
                "key": "[269622739 | Sermeno | 2019 | Citations: 0]",
                "snippets": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user's ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "abstract",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 836,
                        "sentence_offsets": [],
                        "ref_mentions": [],
                        "quote": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user's ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks."
                    }
                ]
            },
            {
                "idx": 19,
                "key": "[270427107 | Rybakova et al. | 2024 | Citations: 1]",
                "snippets": "Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2]",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Introdution",
                        "pdf_hash": "",
                        "start": 116,
                        "end": 374,
                        "sentence_offsets": [
                            {
                                "start": 116,
                                "end": 256
                            },
                            {
                                "start": 257,
                                "end": 367
                            },
                            {
                                "start": 368,
                                "end": 559
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2]"
                    }
                ]
            },
            {
                "idx": 20,
                "key": "[273147365 | Kletsko et al. | 2024 | Citations: 0]",
                "snippets": "Visual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming.",
                        "pdf_hash": "",
                        "section_title": "abstract"
                    }
                ]
            },
            {
                "idx": 21,
                "key": "[276961580 | Zhou et al. | 2023 | Citations: 1]",
                "snippets": "Visual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace.\n\nA visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace.\n\nA visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners.",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 22,
                "key": "[277634411 | Gao et al. | 2025 | Citations: 5]",
                "snippets": "Visual Programming (Gupta et al., 2022)(Sur'is et al., 2023) is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code (Lu et al., 2023).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[253734854 | Gupta et al. | 2022 | Citations: 439]": "We present Visprog, a neuro-symbolic approach to solving complex and compositional visual tasks given natural language instructions. Visprog avoids the need for any task-specific training. Instead, it uses the incontext learning ability of large language models to generate python-like modular programs, which are then executed to get both the solution and a comprehensive and interpretable rationale. Each line of the generated program may invoke one of several off-the-shelf computer vision models, image processing subroutines, or python functions to produce intermediate outputs that may be consumed by subsequent parts of the program. We demonstrate the flexibility of VIsPROG on 4 diverse tasks - compositional visual question answering, zero-shot reasoning on image pairs, factual knowledge object tagging, and language-guided image editing. We believe neuro-symbolic approaches like Visprog are an exciting avenue to easily and effectively expand the scope of AI systems to serve the long tail of complex tasks that people may wish to perform.",
                    "[257505358 | Sur'is et al. | 2023 | Citations: 466]": "Answering visual queries is a complex task that requires both visual processing and reasoning. End-to-end models, the dominant approach for this task, do not explicitly differentiate between the two, limiting interpretability and generalization. Learning modular programs presents a promising alternative, but has proven challenging due to the difficulty of learning both the programs and modules simultaneously. We introduce ${\\color{green}{\\text{ViperGPT}}}$, a framework that leverages code-generation models to compose vision-and-language models into subroutines to produce a result for any query. ${\\color{green}{\\text{ViperGPT}}}$ utilizes a provided API to access the available modules, and composes them by generating Python code that is later executed. This simple approach requires no further training, and achieves state-of-the-art results across various complex visual tasks.",
                    "[258212542 | Lu et al. | 2023 | Citations: 324]": "Large language models (LLMs) have achieved remarkable progress in solving various natural language processing tasks due to emergent reasoning abilities. However, LLMs have inherent limitations as they are incapable of accessing up-to-date information (stored on the Web or in task-specific knowledge bases), using external tools, and performing precise mathematical and logical reasoning. In this paper, we present Chameleon, an AI system that mitigates these limitations by augmenting LLMs with plug-and-play modules for compositional reasoning. Chameleon synthesizes programs by composing various tools (e.g., LLMs, off-the-shelf vision models, web search engines, Python functions, and heuristic-based modules) for accomplishing complex reasoning tasks. At the heart of Chameleon is an LLM-based planner that assembles a sequence of tools to execute to generate the final response. We showcase the effectiveness of Chameleon on two multi-modal knowledge-intensive reasoning tasks: ScienceQA and TabMWP. Chameleon, powered by GPT-4, achieves an 86.54% overall accuracy on ScienceQA, improving the best published few-shot result by 11.37%. On TabMWP, GPT-4-powered Chameleon improves the accuracy by 17.0%, lifting the state of the art to 98.78%. Our analysis also shows that the GPT-4-powered planner exhibits more consistent and rational tool selection via inferring potential constraints from instructions, compared to a ChatGPT-powered planner. The project is available at https://chameleon-llm.github.io."
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming as Decision Sequence",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 287,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 129
                            },
                            {
                                "start": 130,
                                "end": 287
                            }
                        ],
                        "ref_mentions": [
                            "253734854",
                            "257505358",
                            "258212542"
                        ],
                        "quote": "Visual Programming (Gupta et al., 2022)(Sur'is et al., 2023) is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code (Lu et al., 2023)."
                    }
                ]
            },
            {
                "idx": 23,
                "key": "[3874016 | Milicchio et al. | 2016 | Citations: 21]",
                "snippets": "In computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71](Shu, 1986)[73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates (Cypher et al., 1993)(Green et al., 1996). VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design (MacLaurin, 2011)[78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[11750514 | Green et al. | 1996 | Citations: 1419]": "Abstract The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good \u2018closeness of match\u2019, but designers need to consider the \u2018viscosity \u2019 (resistance to local change) and the \u2018secondary notation\u2019 (possibility of conveying extra meaning by choice of layout, colour, etc.)."
                },
                "metadata": [
                    {
                        "section_title": "Visual programming",
                        "pdf_hash": "",
                        "start": 180,
                        "end": 1737,
                        "sentence_offsets": [
                            {
                                "start": 180,
                                "end": 360
                            },
                            {
                                "start": 361,
                                "end": 529
                            },
                            {
                                "start": 530,
                                "end": 555
                            },
                            {
                                "start": 556,
                                "end": 647
                            },
                            {
                                "start": 648,
                                "end": 673
                            },
                            {
                                "start": 674,
                                "end": 786
                            },
                            {
                                "start": 787,
                                "end": 929
                            },
                            {
                                "start": 930,
                                "end": 1083
                            },
                            {
                                "start": 1084,
                                "end": 1371
                            },
                            {
                                "start": 1372,
                                "end": 1439
                            },
                            {
                                "start": 1440,
                                "end": 1637
                            },
                            {
                                "start": 1638,
                                "end": 1737
                            }
                        ],
                        "ref_mentions": [
                            "60451974",
                            "106672214",
                            "11750514",
                            "16049286"
                        ],
                        "quote": "In computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71](Shu, 1986)[73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates (Cypher et al., 1993)(Green et al., 1996). VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design (MacLaurin, 2011)[78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required."
                    }
                ]
            },
            {
                "idx": 24,
                "key": "[3949077 | Fayed | 2017 | Citations: 3]",
                "snippets": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "abstract",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 184,
                        "sentence_offsets": [],
                        "ref_mentions": [],
                        "quote": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard."
                    }
                ]
            },
            {
                "idx": 25,
                "key": "[4793447 | Vithana et al. | 2017 | Citations: 0]",
                "snippets": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "WORK DEVELOPED",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 1104,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 155
                            },
                            {
                                "start": 156,
                                "end": 300
                            },
                            {
                                "start": 301,
                                "end": 449
                            },
                            {
                                "start": 450,
                                "end": 617
                            },
                            {
                                "start": 618,
                                "end": 799
                            },
                            {
                                "start": 800,
                                "end": 1104
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components."
                    }
                ]
            },
            {
                "idx": 26,
                "key": "[53282492 | Dias et al. | 2018 | Citations: 14]",
                "snippets": "A Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as:\n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device.\n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual Programming for IoT",
                        "pdf_hash": "",
                        "start": 503,
                        "end": 1104,
                        "sentence_offsets": [
                            {
                                "start": 399,
                                "end": 615
                            },
                            {
                                "start": 618,
                                "end": 748
                            },
                            {
                                "start": 749,
                                "end": 768
                            },
                            {
                                "start": 771,
                                "end": 1013
                            },
                            {
                                "start": 1016,
                                "end": 1205
                            }
                        ],
                        "ref_mentions": [
                            "48762803"
                        ],
                        "quote": "A Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as:\n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device.\n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]."
                    }
                ]
            },
            {
                "idx": 27,
                "key": "[58394 | Hoffmann et al. | 2000 | Citations: 9]",
                "snippets": "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation.",
                        "pdf_hash": "",
                        "section_title": "abstract"
                    }
                ]
            },
            {
                "idx": 28,
                "key": "[60941791 | Plauska et al. | 2014 | Citations: 8]",
                "snippets": "Visual programming is a method to specify a program in a two (or more) dimensional fashion (Myers, 1986), whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification (Lee et al., 2011).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "body",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 953,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 235
                            },
                            {
                                "start": 236,
                                "end": 403
                            },
                            {
                                "start": 404,
                                "end": 673
                            },
                            {
                                "start": 674,
                                "end": 953
                            }
                        ],
                        "ref_mentions": [
                            "12628167",
                            "220866115"
                        ],
                        "quote": "Visual programming is a method to specify a program in a two (or more) dimensional fashion (Myers, 1986), whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification (Lee et al., 2011)."
                    }
                ]
            },
            {
                "idx": 29,
                "key": "[63194770 | Gunawan et al. | 2016 | Citations: 5]",
                "snippets": "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "abstract",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 416,
                        "sentence_offsets": [],
                        "ref_mentions": [],
                        "quote": "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education."
                    }
                ]
            },
            {
                "idx": 30,
                "key": "[68068900 | Bai et al. | 2019 | Citations: 1]",
                "snippets": "In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "abstract",
                        "pdf_hash": "",
                        "start": 1720,
                        "end": 2569,
                        "sentence_offsets": [],
                        "ref_mentions": [],
                        "quote": "In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm."
                    }
                ]
            },
            {
                "idx": 31,
                "key": "[7271567 | Lucanin et al. | 2011 | Citations: 10]",
                "snippets": "In (Burnett et al., 1995) a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[13484911 | Burnett et al. | 1995 | Citations: 154]": "The directness, immediacy, and simplicity of visual programming languages are appealing. The question is, can VPLs be effectively applied to large scale programming problems while retaining these characteristics. In scaling up, the problem is how to expand applicability without sacrificing the goals of better logic expression and understanding. From a size standpoint, scaling up refers to the programmer's ability to apply VPLs in larger programs. Such programs range from those requiring several days' work by a single programmer to programs requiring months of work, large programming teams, and large data structures. From a problem domain standpoint, scaling up refers to suitability for many kinds of problems. These range from visual application domains-such as user interface design or scientific visualization-to general purpose programming in such diverse areas as financial planning, simulations, and real time applications with explicit timing requirements. To illustrate the scaling up problem, we discuss nine major subproblems and describe emerging solutions from existing VPL systems. First, we examine representation issues, including static representation, screen real estate, and documentation. Next, we examine programming language issues-procedural abstraction, interactive visual data abstraction, type checking, persistence, and efficiency. Finally, we look at issues beyond the coding process. >"
                },
                "metadata": [
                    {
                        "section_title": "B. Related work",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 449,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 182
                            },
                            {
                                "start": 183,
                                "end": 223
                            },
                            {
                                "start": 226,
                                "end": 619
                            }
                        ],
                        "ref_mentions": [
                            "13484911"
                        ],
                        "quote": "In (Burnett et al., 1995) a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time"
                    }
                ]
            },
            {
                "idx": 32,
                "key": "[86787308 | Hamzabegovic | 2019 | Citations: 0]",
                "snippets": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun.\n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual programming",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 1614,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 189
                            },
                            {
                                "start": 190,
                                "end": 345
                            },
                            {
                                "start": 346,
                                "end": 493
                            },
                            {
                                "start": 494,
                                "end": 798
                            },
                            {
                                "start": 801,
                                "end": 918
                            },
                            {
                                "start": 919,
                                "end": 1090
                            },
                            {
                                "start": 1091,
                                "end": 1125
                            },
                            {
                                "start": 1126,
                                "end": 1258
                            },
                            {
                                "start": 1259,
                                "end": 1408
                            },
                            {
                                "start": 1409,
                                "end": 1522
                            },
                            {
                                "start": 1523,
                                "end": 1615
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun.\n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages."
                    }
                ]
            }
        ]
    },
    "cluster": {
        "cost": 0.026835,
        "cot": "To explain visual programming effectively, I'll break down this query into several key dimensions:\n\n1. **Introduction/Background**: This section will provide a foundational understanding of what visual programming is and its basic definition. This will be in synthesis format to give users a cohesive introduction to the concept.\n\n2. **Definition and Core Concepts**: This section will synthesize the various formal definitions of visual programming from the literature, explaining what distinguishes it from traditional text-based programming. A synthesis format is appropriate here to present a comprehensive definition.\n\n3. **Types and Categories of Visual Programming**: The quotes mention several different types and classifications of visual programming languages (block-based, node-based, form-based, etc.). This section will be in list format to clearly present these distinct categories.\n\n4. **Advantages of Visual Programming**: Many quotes discuss the benefits visual programming offers, particularly for beginners. A synthesis format is best to explain these interconnected advantages coherently.\n\n5. **Applications and Use Cases**: Several quotes mention where visual programming is commonly used. A list format will help organize these different application domains clearly.\n\n6. **Historical Development**: Some quotes provide historical context about when and how visual programming emerged. A synthesis paragraph will connect these historical points into a coherent timeline.\n\n7. **Technical Implementation**: Several quotes discuss how visual programming systems work technically. This will be in synthesis format to explain the underlying mechanics.\n\nThe quotes provide comprehensive information on all these dimensions, allowing for a complete explanation of visual programming.",
        "plan": {
            "Introduction/Background (synthesis)": [],
            "Definition and Core Concepts (synthesis)": [
                2,
                8,
                9,
                12,
                19,
                23,
                26,
                28,
                32
            ],
            "Types and Categories of Visual Programming (list)": [
                3,
                8,
                13,
                23,
                25,
                27
            ],
            "Advantages of Visual Programming (synthesis)": [
                1,
                4,
                5,
                7,
                11,
                14,
                15,
                16,
                17,
                18,
                20,
                21,
                24,
                29,
                30,
                31
            ],
            "Applications and Use Cases (list)": [
                0,
                1,
                6,
                10,
                21,
                22,
                29
            ],
            "Historical Development (synthesis)": [
                6,
                24
            ],
            "Technical Implementation (synthesis)": [
                13,
                15,
                25,
                27
            ]
        },
        "model": "claude-3-7-sonnet-20250219"
    },
    "summary": {
        "sections": [
            {
                "title": "Introduction/Background",
                "tldr": "Visual programming is a programming approach that uses graphical elements instead of text-based code to create software. It enables users to develop programs by manipulating visual elements on a screen rather than writing traditional text-based code. (LLM Memory)",
                "text": "\nVisual programming represents a paradigm shift from traditional text-based programming, offering an alternative approach to software development that emphasizes graphical representations over written code. Instead of typing lines of text commands, visual programming allows developers to create programs by manipulating visual elements such as blocks, diagrams, icons, and connections through a graphical user interface. This approach aims to make programming more intuitive and accessible, particularly for beginners, domain experts without formal programming training, and visual thinkers. By providing a more concrete representation of program structure and data flow, visual programming environments help users visualize relationships between components and understand program execution in a more tangible way. The visual nature of these environments often reduces syntax errors that are common in text-based programming, as the user is working with pre-defined components that can only be connected in ways that make logical sense. <Model name=\"Anthropic\" version=\"claude-3-7-sonnet-20250219\">",
                "citations": [],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Definition and Core Concepts",
                "tldr": "Visual programming is defined as a programming approach that uses two-dimensional or multi-dimensional graphical elements instead of one-dimensional text for creating programs. Its core concepts include visual representation of program logic, manipulation of graphical objects, and the integration of computer graphics with programming languages. (8 sources)",
                "text": "\nVisual programming is formally defined as \"any system that allows the user to specify a program in a two (or more) dimensional fashion\" <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper> <Paper corpusId=\"248510289\" paperTitle=\"(Savidis, 2022)\" isShortName></Paper>. This multi-dimensional approach stands in contrast to traditional text-based programming, which is considered one-dimensional <Paper corpusId=\"60941791\" paperTitle=\"(Plauska et al., 2014)\" isShortName></Paper>. The fundamental characteristic of visual programming languages (VPLs) is their use of \"meaningful graphic representation and manipulates visual information or supports visual interaction\" in the programming process <Paper corpusId=\"60941791\" paperTitle=\"(Plauska et al., 2014)\" isShortName></Paper>.\n\nVPLs are characterized by programming constructs and rules that are visually depicted <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. These languages allow users to \"create programs by manipulating more graphic elements of the program than text files\" <Paper corpusId=\"86787308\" paperTitle=\"(Hamzabegovic, 2019)\" isShortName></Paper>. The visual nature of these languages uses spatial relationships, multidimensional objects, and temporal dimensions to represent program semantics, making multidimensionality a key differentiator between VPLs and purely textual languages <Paper corpusId=\"86787308\" paperTitle=\"(Hamzabegovic, 2019)\" isShortName></Paper>.\n\nAccording to the Wiley Encyclopedia of Computer Science and Engineering, a Visual Programming Language is one \"in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device\" <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>. These visual elements utilize imagery thinking to provide a more natural approach to programming than textual languages <Paper corpusId=\"60941791\" paperTitle=\"(Plauska et al., 2014)\" isShortName></Paper>.\n\nIt is important to distinguish between visual programming and graphical user interfaces (GUIs). While GUIs help users execute programs via visual menu items, they typically don't allow users to create new programs or combine menu functions. In contrast, visual programming languages have \"the same power as a textual programming language\" when they feature equivalent functional elements, enabling the design and compilation of new algorithms and programs <Paper corpusId=\"3874016\" paperTitle=\"(Milicchio et al., 2016)\" isShortName></Paper>.\n\nVisual programming emerges from the integration of three fields: Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI) <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. It employs various visual elements including \"icons, diagrams, idle sketches, or demonstrations of actions using graphic objects\" <Paper corpusId=\"86787308\" paperTitle=\"(Hamzabegovic, 2019)\" isShortName></Paper> <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. These elements can be categorized into different types, such as Process Icons (denoting accounts) and Object Icons (representing basic or composite objects) <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>.\n\nAn important distinction exists between visual programming and program visualization. In visual programming, graphics are used to create programs, while in program visualization, programs are created using traditional text-based methods and graphics are used to visualize program execution and outputs <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper>. This distinction highlights the primary purpose of visual programming: to enable program creation through direct manipulation of visual elements rather than just visualizing existing code.",
                "citations": [
                    {
                        "id": "(Joao et al., 2019)",
                        "snippets": [
                            "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs."
                        ],
                        "paper": {
                            "corpus_id": 199002134,
                            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
                            "authors": [
                                {
                                    "authorId": "2157028104",
                                    "name": "Piedade Jo\u00e3o"
                                },
                                {
                                    "authorId": "72582337",
                                    "name": "Dorotea Nuno"
                                },
                                {
                                    "authorId": "2157024771",
                                    "name": "Sampaio Ferrentini F\u00e1bio"
                                },
                                {
                                    "authorId": "144370033",
                                    "name": "P. ana"
                                }
                            ],
                            "year": 2019,
                            "venue": "Education sciences",
                            "n_citations": 23
                        },
                        "score": 0.98291015625
                    },
                    {
                        "id": "(Savidis, 2022)",
                        "snippets": [
                            "The notion of visual programming concerns methods to define programs in a multi-dimensional fashion (Myers, 1990)). The latter is not linked to the underlying program representation, but concerns the interactive visual means through which a program is created, refined and managed. Hence, text-based code is considered as one-dimension method and is therefore not treated as visual programming."
                        ],
                        "paper": {
                            "corpus_id": 248510289,
                            "title": "Programming Experience Requirements for Future Visual Development Environments",
                            "authors": [
                                {
                                    "authorId": "1685511",
                                    "name": "Anthony Savidis"
                                }
                            ],
                            "year": 2022,
                            "venue": "International Conference on Computer Supported Education",
                            "n_citations": 1
                        },
                        "score": 0.97265625
                    },
                    {
                        "id": "(Plauska et al., 2014)",
                        "snippets": [
                            "Visual programming is a method to specify a program in a two (or more) dimensional fashion (Myers, 1986), whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification (Lee et al., 2011)."
                        ],
                        "paper": {
                            "corpus_id": 60941791,
                            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
                            "authors": [
                                {
                                    "authorId": "3102760",
                                    "name": "Ignas Plauska"
                                },
                                {
                                    "authorId": "69972564",
                                    "name": "R. Lukas"
                                },
                                {
                                    "authorId": null,
                                    "name": "Robertas Dama\u0161evi\u010dius"
                                }
                            ],
                            "year": 2014,
                            "venue": "",
                            "n_citations": 8
                        },
                        "score": 0.9892578125
                    },
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Visual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13].\n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9912109375
                    },
                    {
                        "id": "(Hamzabegovic, 2019)",
                        "snippets": [
                            "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun.\n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages."
                        ],
                        "paper": {
                            "corpus_id": 86787308,
                            "title": "Development of application software without programming",
                            "authors": [
                                {
                                    "authorId": "30811658",
                                    "name": "J. Hamzabegovi\u0107"
                                }
                            ],
                            "year": 2019,
                            "venue": "IOP Conference Series: Materials Science and Engineering",
                            "n_citations": 0
                        },
                        "score": 0.98486328125
                    },
                    {
                        "id": "(Dias et al., 2018)",
                        "snippets": [
                            "A Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as:\n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device.\n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]."
                        ],
                        "paper": {
                            "corpus_id": 53282492,
                            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                            "authors": [
                                {
                                    "authorId": "145745979",
                                    "name": "Jo\u00e3o Pedro Dias"
                                },
                                {
                                    "authorId": "144027277",
                                    "name": "H. Ferreira"
                                }
                            ],
                            "year": 2018,
                            "venue": "arXiv.org",
                            "n_citations": 14
                        },
                        "score": 0.96337890625
                    },
                    {
                        "id": "(Milicchio et al., 2016)",
                        "snippets": [
                            "In computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71](Shu, 1986)[73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates (Cypher et al., 1993)(Green et al., 1996). VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design (MacLaurin, 2011)[78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required."
                        ],
                        "paper": {
                            "corpus_id": 3874016,
                            "title": "Visual programming for next-generation sequencing data analytics",
                            "authors": [
                                {
                                    "authorId": "2667295",
                                    "name": "F. Milicchio"
                                },
                                {
                                    "authorId": "3381593",
                                    "name": "R. Rose"
                                },
                                {
                                    "authorId": "152441499",
                                    "name": "J. Bian"
                                },
                                {
                                    "authorId": "145545650",
                                    "name": "Jae Min"
                                },
                                {
                                    "authorId": "144270737",
                                    "name": "M. Prosperi"
                                }
                            ],
                            "year": 2016,
                            "venue": "BioData Mining",
                            "n_citations": 21
                        },
                        "score": 0.94580078125
                    },
                    {
                        "id": "(Aldhlan et al., 2021)",
                        "snippets": [
                            "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI).\n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations.\n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts",
                            ") and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer.\n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc.\n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions."
                        ],
                        "paper": {
                            "corpus_id": 236566925,
                            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                            "authors": [
                                {
                                    "authorId": "9207310",
                                    "name": "Kawther A. Aldhlan"
                                },
                                {
                                    "authorId": "2836785",
                                    "name": "Hamad Alreshidi"
                                }
                            ],
                            "year": 2021,
                            "venue": "Indian Journal of Science and Technology",
                            "n_citations": 2
                        },
                        "score": 0.9814453125
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Types and Categories of Visual Programming",
                "tldr": "Visual programming languages can be categorized into several distinct types including block-based, node-based, form-based, diagram-based, and icon-based approaches. Each type uses different visual metaphors and interaction patterns to represent program logic and data flow. (6 sources)",
                "text": "\nVisual programming languages (VPLs) have evolved into several distinct categories, each with unique visual representations and interaction models:\n\n1. **Block-based languages** - These consist of modular blocks representing fundamental programming constructs (if-else statements, loops, etc.) or custom prototypes for more complex functionalities <Paper corpusId=\"202566030\" paperTitle=\"(Zikas et al., 2019)\" isShortName></Paper>. Block-based languages often use an interlocking puzzle piece metaphor, where pieces represent instructions and their interlocking nature shows how data and control flow between them <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>. Scratch is a prominent example of this approach.\n\n2. **Node-based languages** - These represent structures and data flow using logical nodes connected by edges that reflect their relationships. The resulting structure resembles a directed graph that provides users with a visual overview of program and data flow <Paper corpusId=\"202566030\" paperTitle=\"(Zikas et al., 2019)\" isShortName></Paper>. Node-based approaches often use a boxes-and-arrows representation similar to those found in business process modeling notation (BPMN) <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>.\n\n3. **Form-based languages** - These use forms and spreadsheet-like interfaces to define program behavior <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>.\n\n4. **Diagram-based languages** - These use diagrams to represent program logic and behavior. DiaPlan is an example of a visual rule-based language founded on graph transformation as its computational model <Paper corpusId=\"58394\" paperTitle=\"(Hoffmann et al., 2000)\" isShortName></Paper>.\n\n5. **Icon-based languages** - These use icons to represent program elements and actions <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>.\n\nSome visual programming languages are designed with specific domains in mind. For example, command-based models can be developed for modular systems like robot kits, where the visual programming environment issues commands to various connected modules that handle specific tasks <Paper corpusId=\"4793447\" paperTitle=\"(Vithana et al., 2017)\" isShortName></Paper>. Visual programming has been successfully applied in diverse domains including education, multimedia, system simulation and automation, data warehousing, business intelligence, computer-aided design (CAD), and video game development <Paper corpusId=\"3874016\" paperTitle=\"(Milicchio et al., 2016)\" isShortName></Paper>.\n\nDespite the diversity in visual representations, most visual programming environments share common elements, including a code canvas where users can read and write programs, component palettes from which elements can be dragged, and configuration panes for setting properties <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Zikas et al., 2019)",
                        "snippets": [
                            "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities",
                            ".On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow."
                        ],
                        "paper": {
                            "corpus_id": 202566030,
                            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
                            "authors": [
                                {
                                    "authorId": "3419237",
                                    "name": "Paul Zikas"
                                },
                                {
                                    "authorId": "1388001839",
                                    "name": "Nick Lydatakis"
                                },
                                {
                                    "authorId": "19309698",
                                    "name": "Steve Kateros"
                                },
                                {
                                    "authorId": "2896538",
                                    "name": "G. Papagiannakis"
                                }
                            ],
                            "year": 2019,
                            "venue": "arXiv.org",
                            "n_citations": 1
                        },
                        "score": 0.9638671875
                    },
                    {
                        "id": "(Hirzel, 2022)",
                        "snippets": [
                            "Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane."
                        ],
                        "paper": {
                            "corpus_id": 248524774,
                            "title": "Low-Code Programming Models",
                            "authors": [
                                {
                                    "authorId": "1728836",
                                    "name": "Martin Hirzel"
                                }
                            ],
                            "year": 2022,
                            "venue": "Communications of the ACM",
                            "n_citations": 21
                        },
                        "score": 0.98193359375
                    },
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Visual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13].\n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9912109375
                    },
                    {
                        "id": "(Hoffmann et al., 2000)",
                        "snippets": [
                            "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation."
                        ],
                        "paper": {
                            "corpus_id": 58394,
                            "title": "Towards rule-based visual programming of generic visual systems",
                            "authors": [
                                {
                                    "authorId": "38400881",
                                    "name": "Berthold Hoffmann"
                                },
                                {
                                    "authorId": "1731543",
                                    "name": "M. Minas"
                                }
                            ],
                            "year": 2000,
                            "venue": "arXiv.org",
                            "n_citations": 9
                        },
                        "score": 0.94287109375
                    },
                    {
                        "id": "(Vithana et al., 2017)",
                        "snippets": [
                            "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components."
                        ],
                        "paper": {
                            "corpus_id": 4793447,
                            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                            "authors": [
                                {
                                    "authorId": "9346844",
                                    "name": "Yasura Vithana"
                                },
                                {
                                    "authorId": "40894841",
                                    "name": "Hashini Senaratne"
                                }
                            ],
                            "year": 2017,
                            "venue": "British Computer Society Conference on Human-Computer Interaction",
                            "n_citations": 0
                        },
                        "score": 0.97802734375
                    },
                    {
                        "id": "(Milicchio et al., 2016)",
                        "snippets": [
                            "In computer science, a visual programming (VP) language is a medium for implementing computer programs that makes uses of graphical operators and elements rather than textual ones. VP is not a new concept [71](Shu, 1986)[73][74]; it has been envisioned in several ways starting from the early 1960s and has been the object of philosophical debates (Cypher et al., 1993)(Green et al., 1996). VP is different from GUI. A GUI aids users executing programs via visual menu items in contrast to command-line (i.e. terminal) text scripting. In general, GUI menus are premade and users cannot create new programs or combine menu functions within the GUI. Conversely, a VP language has the same power as a textual programming language or a library, if it features the same functional elements (e.g. data structures and methods); therefore, new algorithms and programs can be designed and compiled within a VP, and VP can even be used to implement GUIs. Visual approaches to programming have been explored in diverse environments, including education, multimedia, system simulation and automation, data warehousing, and business intelligence, with probably the most successful example being the computer-aided design (CAD) software industry. Another extremely popular area for VP is video game design (MacLaurin, 2011)[78]. Although in principle VP can be used to create algorithms starting from the lowest hierarchy of programming language elements, in practice, VP is employed for creating applications using libraries. This facilitates developers' work when a large amount of coding (and redundant coding) is required."
                        ],
                        "paper": {
                            "corpus_id": 3874016,
                            "title": "Visual programming for next-generation sequencing data analytics",
                            "authors": [
                                {
                                    "authorId": "2667295",
                                    "name": "F. Milicchio"
                                },
                                {
                                    "authorId": "3381593",
                                    "name": "R. Rose"
                                },
                                {
                                    "authorId": "152441499",
                                    "name": "J. Bian"
                                },
                                {
                                    "authorId": "145545650",
                                    "name": "Jae Min"
                                },
                                {
                                    "authorId": "144270737",
                                    "name": "M. Prosperi"
                                }
                            ],
                            "year": 2016,
                            "venue": "BioData Mining",
                            "n_citations": 21
                        },
                        "score": 0.94580078125
                    }
                ],
                "format": "list",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Advantages of Visual Programming",
                "tldr": "Visual programming offers significant advantages by reducing syntax barriers, increasing program comprehension, and allowing users to focus on logic rather than memorizing programming syntax. It provides immediate visual feedback, enhances accessibility for beginners, and supports exploratory programming through interactive interfaces. (24 sources)",
                "text": "\nVisual programming environments provide numerous benefits that address common challenges in traditional text-based programming. One of the most significant advantages is the reduction of syntax barriers. By using graphical elements instead of text-based code with precise syntax requirements, visual programming eliminates many of the common errors that novice programmers encounter <Paper corpusId=\"212726996\" paperTitle=\"(Chiu, 2020)\" isShortName></Paper>. This allows users to focus on the logical structure and semantics of the program rather than struggling with syntax details <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper> <Paper corpusId=\"68068900\" paperTitle=\"(Bai et al., 2019)\" isShortName></Paper>.\n\nThe visual representation of program elements enhances program comprehension by presenting content in two dimensions, which better aligns with human cognitive processes <Paper corpusId=\"19038821\" paperTitle=\"(Sukumar et al., 2017)\" isShortName></Paper>. This multidimensional approach allows programmers to visualize relationships between program components more naturally, as graphical representations evaluate information in a manner closer to human mental representations of real-world problems <Paper corpusId=\"246022597\" paperTitle=\"(Pongthanisorn et al., 2022)\" isShortName></Paper>.\n\nVisual programming environments assist users in overcoming three key cognitive challenges: syntactic (arranging programming components into well-formed programs), semantic (comprehending program meaning), and pragmatic (understanding program behavior in specific situations) <Paper corpusId=\"256827582\" paperTitle=\"(Wagner et al., 2023)\" isShortName></Paper> <Paper corpusId=\"41867280\" paperTitle=\"(Repenning, 2017)\" isShortName></Paper>. By providing visual cues about how programming elements can be connected, these environments prevent users from creating invalid programs, thus eliminating many common programming errors <Paper corpusId=\"259335765\" paperTitle=\"(DeLozier et al., 2023)\" isShortName></Paper>.\n\nThe drag-and-drop interface common in many visual programming environments makes programming more accessible and less intimidating for beginners <Paper corpusId=\"63194770\" paperTitle=\"(Gunawan et al., 2016)\" isShortName></Paper> <Paper corpusId=\"269622739\" paperTitle=\"(Sermeno, 2019)\" isShortName></Paper>. This approach has proven effective across a wide range of age groups and skill levels, from preschool children to college students <Paper corpusId=\"259335765\" paperTitle=\"(DeLozier et al., 2023)\" isShortName></Paper> <Paper corpusId=\"235383033\" paperTitle=\"(Papadakis, 2021)\" isShortName></Paper> <Paper corpusId=\"253196672\" paperTitle=\"(Timur et al., 2021)\" isShortName></Paper> <Paper corpusId=\"35735491\" paperTitle=\"(Urness et al., 2011)\" isShortName></Paper>.\n\nVisual programming also supports immediate feedback through the on-screen execution of constructed programs, allowing users to quickly verify their solutions and make adjustments <Paper corpusId=\"250414169\" paperTitle=\"(Fanchamps et al., 2022)\" isShortName></Paper> <Paper corpusId=\"8626769\" paperTitle=\"(Moreno et al., 2011)\" isShortName></Paper>. This immediate feedback facilitates exploratory programming and experimentation, accelerating the learning process and making advanced technology more accessible to beginners <Paper corpusId=\"273147365\" paperTitle=\"(Kletsko et al., 2024)\" isShortName></Paper> <Paper corpusId=\"276961580\" paperTitle=\"(Zhou et al., 2023)\" isShortName></Paper>.\n\nAnother key advantage is the effective use of computer display, showing only information that is important to the user at any given time <Paper corpusId=\"7271567\" paperTitle=\"(Lucanin et al., 2011)\" isShortName></Paper> <Paper corpusId=\"13484911\" paperTitle=\"(Burnett et al., 1995)\" isShortName></Paper>. This helps manage screen real estate efficiently and reduces cognitive overload for the programmer.\n\nVisual programming has proven particularly valuable in educational contexts, where it helps students develop computational thinking skills while reducing the intimidation factor associated with traditional programming <Paper corpusId=\"225541919\" paperTitle=\"(Falgenti, 2020)\" isShortName></Paper> <Paper corpusId=\"3949077\" paperTitle=\"(Fayed, 2017)\" isShortName></Paper>. It enables students to learn programming concepts and express their ideas without being hindered by the complexities of syntax <Paper corpusId=\"257145390\" paperTitle=\"(Chen et al., 2023)\" isShortName></Paper> <Paper corpusId=\"235749050\" paperTitle=\"(Zheng et al., 2021)\" isShortName></Paper> <Paper corpusId=\"237732833\" paperTitle=\"(Xiang et al., 2021)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Chiu, 2020)",
                        "snippets": [
                            "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming (Denny et al., 2011)- (Denny et al., 2012). Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions."
                        ],
                        "paper": {
                            "corpus_id": 212726996,
                            "title": "Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning",
                            "authors": [
                                {
                                    "authorId": "2111748",
                                    "name": "Chiung-Fang Chiu"
                                }
                            ],
                            "year": 2020,
                            "venue": "International Journal of Emerging Technologies in Learning (iJET)",
                            "n_citations": 40
                        },
                        "score": 0.96484375
                    },
                    {
                        "id": "(Alturayeif et al., 2020)",
                        "snippets": [
                            "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]."
                        ],
                        "paper": {
                            "corpus_id": 221340525,
                            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                            "authors": [
                                {
                                    "authorId": "2315312012",
                                    "name": "Nora S. Alturayeif"
                                },
                                {
                                    "authorId": "2023398349",
                                    "name": "Nouf Alturaief"
                                },
                                {
                                    "authorId": "2023401654",
                                    "name": "Zainab Alhathloul"
                                }
                            ],
                            "year": 2020,
                            "venue": "International Journal of Advanced Computer Science and Applications",
                            "n_citations": 19
                        },
                        "score": 0.94873046875
                    },
                    {
                        "id": "(Bai et al., 2019)",
                        "snippets": [
                            "In recent years, a lot of visual programming tools came into being, for example, Scratch [3] , Blockly [4] , Snap [5] and so on. By introducing of visual programming tools in computer programming course, the problems mentioned above can be solved effectively. First, for that the core of computational thinking is the ideas rather than the language syntax, by using of visual tools will simplify programming, thus students will focus on the program logic rather than the language syntax, it will help to overcome the fear of programming and cultivate there interesting. Second, visual program help to express the logic of algorithm clearly, thus it helps to train logical thinking through visual programming, lastly, by modeling with visual programming tools, it is easy to execute the algorithm immediately, thus convenient to verify the algorithm."
                        ],
                        "paper": {
                            "corpus_id": 68068900,
                            "title": "Application of Visual Programming in Program Design Course",
                            "authors": [
                                {
                                    "authorId": "2114140303",
                                    "name": "Xiaojun Bai"
                                },
                                {
                                    "authorId": "2801842",
                                    "name": "Baili Liu"
                                }
                            ],
                            "year": 2019,
                            "venue": "DEStech Transactions on Social Science Education and Human Science",
                            "n_citations": 1
                        },
                        "score": 0.96826171875
                    },
                    {
                        "id": "(Sukumar et al., 2017)",
                        "snippets": [
                            "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax (Myers, 1990)[53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains (Myers, 1990)[41]."
                        ],
                        "paper": {
                            "corpus_id": 19038821,
                            "title": "Design Space of Programming Tools on Mobile Touchscreen Devices",
                            "authors": [
                                {
                                    "authorId": "2207677",
                                    "name": "P. Sukumar"
                                },
                                {
                                    "authorId": "1809549",
                                    "name": "Ronald A. Metoyer"
                                }
                            ],
                            "year": 2017,
                            "venue": "arXiv.org",
                            "n_citations": 0
                        },
                        "score": 0.953125
                    },
                    {
                        "id": "(Pongthanisorn et al., 2022)",
                        "snippets": [
                            "Visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990)."
                        ],
                        "paper": {
                            "corpus_id": 246022597,
                            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
                            "authors": [
                                {
                                    "authorId": "2001006030",
                                    "name": "Goragod Pongthanisorn"
                                },
                                {
                                    "authorId": "19305117",
                                    "name": "W. Viriyavit"
                                },
                                {
                                    "authorId": "2844764",
                                    "name": "Thatsanee Charoenporn"
                                },
                                {
                                    "authorId": "1779078",
                                    "name": "Virach Sornlertlamvanich"
                                }
                            ],
                            "year": 2022,
                            "venue": "European-Japanese Conference on Information Modelling and Knowledge Bases",
                            "n_citations": 0
                        },
                        "score": 0.97216796875
                    },
                    {
                        "id": "(Wagner et al., 2023)",
                        "snippets": [
                            "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations.\n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour."
                        ],
                        "paper": {
                            "corpus_id": 256827582,
                            "title": "ELEA - Build your own Evolutionary Algorithm in your Browser",
                            "authors": [
                                {
                                    "authorId": "2194782585",
                                    "name": "Markus Wagner"
                                },
                                {
                                    "authorId": "2205544441",
                                    "name": "Erik Kohlros"
                                },
                                {
                                    "authorId": "2205539993",
                                    "name": "Gerome Quantmeyer"
                                },
                                {
                                    "authorId": "1751539",
                                    "name": "Timo K\u00f6tzing"
                                }
                            ],
                            "year": 2023,
                            "venue": "GECCO Companion",
                            "n_citations": 1
                        },
                        "score": 0.96435546875
                    },
                    {
                        "id": "(Repenning, 2017)",
                        "snippets": [
                            "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                        ],
                        "paper": {
                            "corpus_id": 41867280,
                            "title": "Moving Beyond Syntax: Lessons from 20 Years of Blocks Programing in AgentSheets",
                            "authors": [
                                {
                                    "authorId": "1782080",
                                    "name": "A. Repenning"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Visual Languages and Sentient Systems",
                            "n_citations": 50
                        },
                        "score": 0
                    },
                    {
                        "id": "(DeLozier et al., 2023)",
                        "snippets": [
                            "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018). This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]."
                        ],
                        "paper": {
                            "corpus_id": 259335765,
                            "title": "Using Visual Programming Games to Study Novice Programmers",
                            "authors": [
                                {
                                    "authorId": "39722092",
                                    "name": "Christian DeLozier"
                                },
                                {
                                    "authorId": "38203562",
                                    "name": "James Shey"
                                }
                            ],
                            "year": 2023,
                            "venue": "Int. J. Serious Games",
                            "n_citations": 6
                        },
                        "score": 0.96240234375
                    },
                    {
                        "id": "(Gunawan et al., 2016)",
                        "snippets": [
                            "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education."
                        ],
                        "paper": {
                            "corpus_id": 63194770,
                            "title": "PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI",
                            "authors": [
                                {
                                    "authorId": "1885335036",
                                    "name": "Dedi Gunawan"
                                },
                                {
                                    "authorId": "70024582",
                                    "name": "Fatah Yasin Al Irsyadi"
                                }
                            ],
                            "year": 2016,
                            "venue": "",
                            "n_citations": 5
                        },
                        "score": 0.95068359375
                    },
                    {
                        "id": "(Sermeno, 2019)",
                        "snippets": [
                            "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user's ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks."
                        ],
                        "paper": {
                            "corpus_id": 269622739,
                            "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
                            "authors": [
                                {
                                    "authorId": "2300620753",
                                    "name": "Jason Sermeno"
                                }
                            ],
                            "year": 2019,
                            "venue": "Journal of Innovative Technology Convergence",
                            "n_citations": 0
                        },
                        "score": 0.95263671875
                    },
                    {
                        "id": "(Papadakis, 2021)",
                        "snippets": [
                            "Data that shows that young children can learn and acquire Computational Thinking (CT) skills has led governments and policymakers internationally to integrate CT into the curriculum, starting in the earliest grades. Researchers support the idea that this introduction must not solely focus on a problem-solving process skill (CT) but instead provide children with new ways to express themselves, supporting their cognitive, language, and socio-emotional development (Computational Fluency-CF). Coupled with the media and government\u2019s rhetoric and an increasing number of apps offering various programming lessons, puzzles, and challenges, educators have been responsible for introducing young children to CT and CF using touchscreen technology. This paper presents a literature review (N = 21) of empirical studies on applying four coding apps to support young children\u2019s learning of CT and CF. The main conclusion is that all apps positively affect the development of children\u2019s CT skills. None of the apps can ultimately support the development of CF, although ScratchJr, with a \"sandbox\" approach, can better help students express themselves."
                        ],
                        "paper": {
                            "corpus_id": 235383033,
                            "title": "The Impact of Coding Apps to Support Young Children in Computational Thinking and Computational Fluency. A Literature Review",
                            "authors": [
                                {
                                    "authorId": "31818512",
                                    "name": "Stamatis Papadakis"
                                }
                            ],
                            "year": 2021,
                            "venue": "Frontiers in Education",
                            "n_citations": 90
                        },
                        "score": 0
                    },
                    {
                        "id": "(Timur et al., 2021)",
                        "snippets": [
                            "\"Abstract: In this study, it was aimed to examine the pre-service pre-school teachers\u2019 opinions about using block-based coding/Scratch in education. 28 pre-service pre-school teachers were participated studying at a public university in a Marmara province region. Within the scope of the study, pre-service teachers were trained on the block-based coding Scratch program for four weeks. A semi-structured interview form consisting of 12 questions was used to determine the opinions of the participants. The data of the study were analyzed using the descriptive analysis method. As a result of the study, 85.71% of pre-school teacher candidates stated that block-based coding education should start at an early age like a language education, this education is important as a necessity of the technology age and all students should benefit from this education in order to provide an effective education, 14.25% of teacher candidates specified that this education is untimely for younger age levels and should not be given to everyone. In addition, the pre-service teachers stated that the block-based coding/Scratch program training helped them gain new ideas in terms of creating materials, improved their creativity and contributed to design abstract material in addition to concrete ones. Additionally, 46.42% of pre-service teachers stated that block-based coding education should start between the ages of 5-7. In this context, it is recommended to provide coding education both in pre-school and undergraduate education.\""
                        ],
                        "paper": {
                            "corpus_id": 253196672,
                            "title": "Pre-service pre-school teachers' opinions about using block-based coding/scratch",
                            "authors": [
                                {
                                    "authorId": "2057521942",
                                    "name": "Serkan Timur"
                                },
                                {
                                    "authorId": "70546556",
                                    "name": "Bet\u00fcl Timur"
                                },
                                {
                                    "authorId": "2129327879",
                                    "name": "Elif G\u00fcven\u00e7"
                                },
                                {
                                    "authorId": "2189176196",
                                    "name": "\u0130lknur Us"
                                },
                                {
                                    "authorId": "1712266999",
                                    "name": "Eylem Yal\u00e7\u0131nkaya-\u00d6nder"
                                }
                            ],
                            "year": 2021,
                            "venue": "Acta Didactica Napocensia",
                            "n_citations": 6
                        },
                        "score": 0
                    },
                    {
                        "id": "(Urness et al., 2011)",
                        "snippets": [
                            "In this paper we describe several techniques that have helped increase enrollment in the computer science program from 23 computer science majors in 2008 to 42 computer science majors in 2010 - an increase of 82.6%. We discuss issues related to curriculum, programming assignments, and professor-student interactions that have made the discipline more attractive and manageable to a variety of students within the setting of a small liberal arts college."
                        ],
                        "paper": {
                            "corpus_id": 35735491,
                            "title": "Building a thriving CS program at a small liberal arts college",
                            "authors": [
                                {
                                    "authorId": "2046138",
                                    "name": "T. Urness"
                                },
                                {
                                    "authorId": "3303190",
                                    "name": "E. Manley"
                                }
                            ],
                            "year": 2011,
                            "venue": "Journal of Computing Sciences in Colleges (JCSC; Formerly: Journal of Computing in Small Colleges)",
                            "n_citations": 2
                        },
                        "score": 0
                    },
                    {
                        "id": "(Fanchamps et al., 2022)",
                        "snippets": [
                            "In a visual programming environment, a computer program to solve a computational problem is constructed by manipulating visual programming elements in order to formulate and design a solution to the problem (S\u00e1ez- (S\u00e1ez-L\u00f3pez et al., 2016). Through the on-screen execution of the constructed program, direct visual feedback can be obtained from which the user can anticipate and determine the subsequent interventions by means of problem-solving actions (Moreno et al., 2011)(Tsai, 2019)."
                        ],
                        "paper": {
                            "corpus_id": 250414169,
                            "title": "Effect of SRA-programming on computational thinking through different output modalities",
                            "authors": [
                                {
                                    "authorId": "2103048484",
                                    "name": "Nardie Fanchamps"
                                },
                                {
                                    "authorId": "101239469",
                                    "name": "L.A.M.P. Slangen"
                                },
                                {
                                    "authorId": "143989442",
                                    "name": "M. Specht"
                                },
                                {
                                    "authorId": "102715196",
                                    "name": "P. Hennissen"
                                }
                            ],
                            "year": 2022,
                            "venue": "Journal of Computers in Education",
                            "n_citations": 5
                        },
                        "score": 0.9580078125
                    },
                    {
                        "id": "(Moreno et al., 2011)",
                        "snippets": [
                            "In 3 experiments, we examined the effects of using concrete and/or abstract visual problem representations during instruction on students' problem-solving practice, near transfer, problem representations, and learning perceptions. In Experiments 1 and 2, novice students learned about electrical circuit analysis with an instructional program that included worked-out and practice problems represented with abstract (Group A), concrete (Group C), or abstract and concrete diagrams (Group AC), whereby the cover stories were abstract in Group A and concrete in Groups C and AC. Experiment 3 added a 4th condition (C-A) with a concrete cover story and abstract diagrams. Group AC outperformed Groups A and C on problem-solving practice in Experiments 1 and 2 and outperformed Group C on transfer across the 3 experiments; Group AC also outperformed Group C-A in Experiment 3. Further, Group A outperformed Group C on transfer in Experiments 2 and 3 and outperformed Group C-A in Experiment 3. Transfer scores were positively associated with the quality of the diagrams and the number of abstract representations drawn during the transfer test. Data on students' learning perceptions suggest that the advantage of Group AC relies on the combined cognitive support of both representations. Our studies indicate that problem solving is fostered when learners experience concrete visual representations that connect to their prior knowledge and are enabled to use abstract visual representations"
                        ],
                        "paper": {
                            "corpus_id": 8626769,
                            "title": "Teaching with Concrete and Abstract Visual Representations: Effects on Students' Problem Solving, Problem Representations, and Learning Perceptions.",
                            "authors": [
                                {
                                    "authorId": "144006457",
                                    "name": "R. Moreno"
                                },
                                {
                                    "authorId": "1717551",
                                    "name": "Gamze Ozogul"
                                },
                                {
                                    "authorId": "1740196",
                                    "name": "M. Reisslein"
                                }
                            ],
                            "year": 2011,
                            "venue": "",
                            "n_citations": 136
                        },
                        "score": 0
                    },
                    {
                        "id": "(Kletsko et al., 2024)",
                        "snippets": [
                            "Visual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming."
                        ],
                        "paper": {
                            "corpus_id": 273147365,
                            "title": "Advanced Game Engine Wizardry for Visual Programming Environments",
                            "authors": [
                                {
                                    "authorId": "2326538317",
                                    "name": "Elisabeth Kletsko"
                                },
                                {
                                    "authorId": "2047732442",
                                    "name": "Riemer van Rozen"
                                }
                            ],
                            "year": 2024,
                            "venue": "PAINT@SPLASH",
                            "n_citations": 0
                        },
                        "score": 0.93359375
                    },
                    {
                        "id": "(Zhou et al., 2023)",
                        "snippets": [
                            "Visual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace.\n\nA visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners."
                        ],
                        "paper": {
                            "corpus_id": 276961580,
                            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
                            "authors": [
                                {
                                    "authorId": "2261898099",
                                    "name": "Zhongyi Zhou"
                                },
                                {
                                    "authorId": "2214751677",
                                    "name": "Jing Jin"
                                },
                                {
                                    "authorId": "95798184",
                                    "name": "Vrushank Phadnis"
                                },
                                {
                                    "authorId": "29436685",
                                    "name": "Xiuxiu Yuan"
                                },
                                {
                                    "authorId": "2261902264",
                                    "name": "Jun Jiang"
                                },
                                {
                                    "authorId": "2274943688",
                                    "name": "Xun Qian"
                                },
                                {
                                    "authorId": "2261902483",
                                    "name": "Kristen Wright"
                                },
                                {
                                    "authorId": "2261902982",
                                    "name": "Mark Sherwood"
                                },
                                {
                                    "authorId": "2261904117",
                                    "name": "Jason Mayes"
                                },
                                {
                                    "authorId": "2261943879",
                                    "name": "Jingtao Zhou"
                                },
                                {
                                    "authorId": "2275032507",
                                    "name": "Yiyi Huang"
                                },
                                {
                                    "authorId": "2275017028",
                                    "name": "Zheng Xu"
                                },
                                {
                                    "authorId": "2274975067",
                                    "name": "Yinda Zhang"
                                },
                                {
                                    "authorId": "2274929798",
                                    "name": "Johnny Lee"
                                },
                                {
                                    "authorId": "2292510931",
                                    "name": "Alex Olwal"
                                },
                                {
                                    "authorId": "2274972576",
                                    "name": "David Kim"
                                },
                                {
                                    "authorId": "2214753154",
                                    "name": "Ram Iyengar"
                                },
                                {
                                    "authorId": "2262397661",
                                    "name": "Na Li"
                                },
                                {
                                    "authorId": "2350823722",
                                    "name": "Ruofei Du"
                                }
                            ],
                            "year": 2023,
                            "venue": "International Conference on Human Factors in Computing Systems",
                            "n_citations": 1
                        },
                        "score": 0.9638671875
                    },
                    {
                        "id": "(Lucanin et al., 2011)",
                        "snippets": [
                            "In (Burnett et al., 1995) a general overview of the visual programming strengths and weaknesses is examined with a lot of examples of how certain languages cope with these opportunities and challenges. The two most notable items proposed are: \n\n\u2022 static representation -is a graphical notation used to present a program at rest sufficient to understand the logic \u2022 effective use of computer display -showing only the information important to the user at any given time"
                        ],
                        "paper": {
                            "corpus_id": 7271567,
                            "title": "A visual programming language for drawing and executing flowcharts",
                            "authors": [
                                {
                                    "authorId": "3352207",
                                    "name": "Dra\u017een Lu\u010danin"
                                },
                                {
                                    "authorId": "2754593",
                                    "name": "Ivan Fabek"
                                }
                            ],
                            "year": 2011,
                            "venue": "2011 Proceedings of the 34th International Convention MIPRO",
                            "n_citations": 10
                        },
                        "score": 0.966796875
                    },
                    {
                        "id": "(Burnett et al., 1995)",
                        "snippets": [
                            "The directness, immediacy, and simplicity of visual programming languages are appealing. The question is, can VPLs be effectively applied to large scale programming problems while retaining these characteristics. In scaling up, the problem is how to expand applicability without sacrificing the goals of better logic expression and understanding. From a size standpoint, scaling up refers to the programmer's ability to apply VPLs in larger programs. Such programs range from those requiring several days' work by a single programmer to programs requiring months of work, large programming teams, and large data structures. From a problem domain standpoint, scaling up refers to suitability for many kinds of problems. These range from visual application domains-such as user interface design or scientific visualization-to general purpose programming in such diverse areas as financial planning, simulations, and real time applications with explicit timing requirements. To illustrate the scaling up problem, we discuss nine major subproblems and describe emerging solutions from existing VPL systems. First, we examine representation issues, including static representation, screen real estate, and documentation. Next, we examine programming language issues-procedural abstraction, interactive visual data abstraction, type checking, persistence, and efficiency. Finally, we look at issues beyond the coding process. >"
                        ],
                        "paper": {
                            "corpus_id": 13484911,
                            "title": "Scaling Up Visual Programming Languages",
                            "authors": [
                                {
                                    "authorId": "1737204",
                                    "name": "M. Burnett"
                                },
                                {
                                    "authorId": "28202905",
                                    "name": "M. J. Baker"
                                },
                                {
                                    "authorId": "3104602",
                                    "name": "Carisa Bohus"
                                },
                                {
                                    "authorId": "2059765752",
                                    "name": "Paul Carlson"
                                },
                                {
                                    "authorId": "47569072",
                                    "name": "Sherry Yang"
                                },
                                {
                                    "authorId": "2032553",
                                    "name": "P. V. Zee"
                                }
                            ],
                            "year": 1995,
                            "venue": "Computer",
                            "n_citations": 154
                        },
                        "score": 0
                    },
                    {
                        "id": "(Falgenti, 2020)",
                        "snippets": [
                            "Visual programming (PV) is a tool to facilitate learning programming. The concept of learning to use PV visualizes the work processes of algorithms and programming."
                        ],
                        "paper": {
                            "corpus_id": 225541919,
                            "title": "Studi Komparatif Program Visual Dinamis untuk Pembelajaran Algoritma dan Pemograman Berorientasi Objek",
                            "authors": [
                                {
                                    "authorId": "9178885",
                                    "name": "Kursehi Falgenti"
                                }
                            ],
                            "year": 2020,
                            "venue": "",
                            "n_citations": 2
                        },
                        "score": 0.9658203125
                    },
                    {
                        "id": "(Fayed, 2017)",
                        "snippets": [
                            "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard."
                        ],
                        "paper": {
                            "corpus_id": 3949077,
                            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                            "authors": [
                                {
                                    "authorId": "35131544",
                                    "name": "M. S. Fayed"
                                }
                            ],
                            "year": 2017,
                            "venue": "arXiv.org",
                            "n_citations": 3
                        },
                        "score": 0.9482421875
                    },
                    {
                        "id": "(Chen et al., 2023)",
                        "snippets": [
                            "Visual programming tools lead learners to contact the code language in the way of module splicing, which can make learners accept learning programming psychologically. Its main teaching function is to weaken the writing of programming code, emphasize the application of CT knowledge and methods, and enhance the learner's motivation (Zheng et al., 2021). Visual programming tools can describe and execute problems in real situations in a modular programming language according to the problemsolving plan (Xiang et al., 2021)."
                        ],
                        "paper": {
                            "corpus_id": 257145390,
                            "title": "Computational Thinking Training and Deep Learning Evaluation Model Construction Based on Scratch Modular Programming Course",
                            "authors": [
                                {
                                    "authorId": "2157262938",
                                    "name": "Xiaoli Chen"
                                },
                                {
                                    "authorId": "2209867633",
                                    "name": "XiaoMing Wang"
                                }
                            ],
                            "year": 2023,
                            "venue": "Computational Intelligence and Neuroscience",
                            "n_citations": 5
                        },
                        "score": 0.96044921875
                    },
                    {
                        "id": "(Zheng et al., 2021)",
                        "snippets": [
                            "In visual reasoning, the achievement of deep learning significantly improved the accuracy of results. Image features are primarily used as input to get answers. However, the image features are too redundant to learn accurate characterizations within a limited complexity and time. While in the process of human reasoning, abstract description of an image is usually to avoid irrelevant details. Inspired by this, a higher-level representation named semantic representation is introduced. In this paper, a detailed visual reasoning model is proposed. This new model contains an image understanding model based on semantic representation, feature extraction and process model refined with watershed and u-distance method, a feature vector learning model using pyramidal pooling and residual network, and a question understanding model combining problem embedding coding method and machine translation decoding method. The feature vector could better represent the whole image instead of overly focused on specific characteristics. The model using semantic representation as input verifies that more accurate results can be obtained by introducing a high-level semantic representation. The result also shows that it is feasible and effective to introduce high-level and abstract forms of knowledge representation into deep learning tasks. This study lays a theoretical and experimental foundation for introducing different levels of knowledge representation into deep learning in the future."
                        ],
                        "paper": {
                            "corpus_id": 235749050,
                            "title": "Improving Visual Reasoning Through Semantic Representation",
                            "authors": [
                                {
                                    "authorId": "51452833",
                                    "name": "Wenfeng Zheng"
                                },
                                {
                                    "authorId": "2144226207",
                                    "name": "Xiangjun Liu"
                                },
                                {
                                    "authorId": "2121973028",
                                    "name": "X. Ni"
                                },
                                {
                                    "authorId": "143931711",
                                    "name": "Lirong Yin"
                                },
                                {
                                    "authorId": "143787142",
                                    "name": "Bo Yang"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 111
                        },
                        "score": 0
                    },
                    {
                        "id": "(Xiang et al., 2021)",
                        "snippets": [
                            "The availability of thermodynamic data for geologically relevant phases has made practical the calculation of stable phase relations throughout the mantle and crust of terrestrial planets. GeoPS (http://www.geops.org) is a program designed for this purpose in which both input and output are done through an intuitive graphical user interface. GeoPS provides a wide range of phase equilibrium calculations based on a novel Gibbs energy minimization algorithm. The algorithm provides for exceptionally robust and computationally efficient solution to the phase equilibrium problem by successive alternation between a linear programming step to identify stable phase compositions and a non\u2010linear programming step to refine the compositions estimated during the linear programming. Applications include calculation of various types of phase diagrams and path\u2010dependent phase fractionation. By combining an easy\u2010to\u2010use graphical user interface with a robust and efficient solver, GeoPS makes phase equilibrium modelling accessible to researchers and students with minimal training and provides a powerful tool for understanding natural phase relations and for planning experimental work."
                        ],
                        "paper": {
                            "corpus_id": 237732833,
                            "title": "GeoPS: An interactive visual computing tool for thermodynamic modelling of phase equilibria",
                            "authors": [
                                {
                                    "authorId": "2064888120",
                                    "name": "Hua Xiang"
                                },
                                {
                                    "authorId": "145109359",
                                    "name": "J. Connolly"
                                }
                            ],
                            "year": 2021,
                            "venue": "Journal of Metamorphic Geology",
                            "n_citations": 134
                        },
                        "score": 0
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Applications and Use Cases",
                "tldr": "Visual programming is applied across multiple domains including education, game development, software application development, Internet of Things, and AI task synthesis. Its accessibility makes it particularly valuable for novice programmers and domain experts without coding experience. (12 sources)",
                "text": "\nVisual programming has found applications in diverse fields, leveraging its intuitive approach to programming:\n\n1. **Education and Learning** - Visual programming environments serve as effective tools for teaching programming concepts to children and novice programmers, emphasizing semantics over syntax and promoting program comprehension through two-dimensional representations <Paper corpusId=\"19038821\" paperTitle=\"(Sukumar et al., 2017)\" isShortName></Paper>. These environments have been widely used in educational contexts since the 1980s and 1990s <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>.\n\n2. **Game Development** - Visual programming provides advantages in developing game applications, offering a more accessible approach for students and people without prior coding experience <Paper corpusId=\"63194770\" paperTitle=\"(Gunawan et al., 2016)\" isShortName></Paper>. Game engines have increasingly incorporated visual programming to enable rapid development cycles and separation of game concepts from assets <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper> <Paper corpusId=\"158715\" paperTitle=\"(Andrade, 2015)\" isShortName></Paper>.\n\n3. **Application Development** - In application development, visual programming enables a \"bottom-up\" approach where developers first create a user interface, then configure the properties of interface objects, and finally write code to handle events <Paper corpusId=\"186749406\" paperTitle=\"(Dermawan et al., 2019)\" isShortName></Paper>. This approach follows the principle of \"what you see is what you get,\" allowing developers to see the final result at any time during development <Paper corpusId=\"243857547\" paperTitle=\"(Zhu et al., 2021)\" isShortName></Paper>.\n\n4. **Internet of Things (IoT)** - Visual programming has become essential for IoT application development, with numerous languages developed specifically for this domain. These languages are categorized into open-source and proprietary platforms, each with different programming environments, licensing models, and platform support <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper> <Paper corpusId=\"30037917\" paperTitle=\"(Ray, 2017)\" isShortName></Paper>.\n\n5. **Data Processing and Creative Applications** - Visual programming interfaces with node-graph editors allow users to design data processing pipelines through configuring nodes and connecting them with edges. This approach accelerates experimentation and exploration in creative applications, making advanced technology more accessible to beginners <Paper corpusId=\"276961580\" paperTitle=\"(Zhou et al., 2023)\" isShortName></Paper>.\n\n6. **AI and Computer Vision** - Recent advances in visual programming have enabled the integration of neural symbols or Python modules for AI task synthesis and execution. Systems like Visprog and ViperGPT use code-generation models to compose vision-and-language models into subroutines, allowing for complex visual tasks without task-specific training <Paper corpusId=\"277634411\" paperTitle=\"(Gao et al., 2025)\" isShortName></Paper> <Paper corpusId=\"253734854\" paperTitle=\"(Gupta et al., 2022)\" isShortName></Paper> <Paper corpusId=\"257505358\" paperTitle=\"(Sur'is et al., 2023)\" isShortName></Paper> <Paper corpusId=\"258212542\" paperTitle=\"(Lu et al., 2023)\" isShortName></Paper>.\n\n7. **Specialized Domains** - Beyond the contexts mentioned above, visual programming has found applications in specialized domains where domain experts may have limited programming experience but need to create custom solutions <Paper corpusId=\"19038821\" paperTitle=\"(Sukumar et al., 2017)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Sukumar et al., 2017)",
                        "snippets": [
                            "Visual Programming (VP) languages enable programming by means of interacting with graphical elements, such as blocks, symbols, and arrows, rather than text. They are known, in general, to promote program comprehension by representing content in two-dimensions (text is considered onedimensional) and by emphasizing the underlying semantics rather than the syntax (Myers, 1990)[53]. The contexts where VP is used mostly include learning environments (for both children and novice programmers) and specialized domains (Myers, 1990)[41]."
                        ],
                        "paper": {
                            "corpus_id": 19038821,
                            "title": "Design Space of Programming Tools on Mobile Touchscreen Devices",
                            "authors": [
                                {
                                    "authorId": "2207677",
                                    "name": "P. Sukumar"
                                },
                                {
                                    "authorId": "1809549",
                                    "name": "Ronald A. Metoyer"
                                }
                            ],
                            "year": 2017,
                            "venue": "arXiv.org",
                            "n_citations": 0
                        },
                        "score": 0.953125
                    },
                    {
                        "id": "(McDaid et al., 2020)",
                        "snippets": [
                            "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers (Myers, 1990). There are now many visual programming languages (Johnston et al., 2004)11,(Maloney et al., 2010). Many of which are aimed at education or niche domains (Bockermann, 2014)(Ray, 2017)(Andrade, 2015)16,(Gulwani et al., 2015)."
                        ],
                        "paper": {
                            "corpus_id": 221802417,
                            "title": "A Visual Language for Composable Inductive Programming",
                            "authors": [
                                {
                                    "authorId": "1420120235",
                                    "name": "Edward McDaid"
                                },
                                {
                                    "authorId": "4697495",
                                    "name": "S. McDaid"
                                }
                            ],
                            "year": 2020,
                            "venue": "arXiv.org",
                            "n_citations": 4
                        },
                        "score": 0.9736328125
                    },
                    {
                        "id": "(Gunawan et al., 2016)",
                        "snippets": [
                            "Visual programming is the one programming technique in computer Science which aims to give easy understanding in writing code program. The main users of visual programming are students and people who have no experiences in making computer code and lack of computer programming language.Visual programming gives advantages to develop any kind of application software such as game and application related to education."
                        ],
                        "paper": {
                            "corpus_id": 63194770,
                            "title": "PEMANFAATAN PEMROGRAMAN VISUAL SEBAGAI ALTERNATIF PEMBUATAN MEDIA BELAJAR BERBASIS GAME DAN ANIMASI",
                            "authors": [
                                {
                                    "authorId": "1885335036",
                                    "name": "Dedi Gunawan"
                                },
                                {
                                    "authorId": "70024582",
                                    "name": "Fatah Yasin Al Irsyadi"
                                }
                            ],
                            "year": 2016,
                            "venue": "",
                            "n_citations": 5
                        },
                        "score": 0.95068359375
                    },
                    {
                        "id": "(Andrade, 2015)",
                        "snippets": [
                            "Due to hardware limitations at the origin of the video game industry, each new game was generally coded from the ground up. Years later, from the evolution of hardware and the need for quick game development cycles, spawned the concept of game engine. A game engine is a reusable software layer allowing the separation of common game concepts from the game assets (levels, graphics, etc.). This paper surveys fourteen different game engines relevant today, ranging from the industry-level to the newcomer-friendlier ones."
                        ],
                        "paper": {
                            "corpus_id": 158715,
                            "title": "Game engines: a survey",
                            "authors": [
                                {
                                    "authorId": "146007426",
                                    "name": "A. Andrade"
                                }
                            ],
                            "year": 2015,
                            "venue": "EAI Endorsed Trans. Serious Games",
                            "n_citations": 34
                        },
                        "score": 0
                    },
                    {
                        "id": "(Dermawan et al., 2019)",
                        "snippets": [
                            "In Visual programming, application development starts with the formation of a user interface, then arranges the properties of the objects used in the user interface, and then the program code is written to handle events. The application development phase is known as application development with the Bottom Up approach."
                        ],
                        "paper": {
                            "corpus_id": 186749406,
                            "title": "Microsoft Visual Basic 6.0 Software to Develop Mathematics Teaching Materials",
                            "authors": [
                                {
                                    "authorId": "84008749",
                                    "name": "O. Dermawan"
                                },
                                {
                                    "authorId": "108395174",
                                    "name": "Defriyanto"
                                },
                                {
                                    "authorId": "2145724414",
                                    "name": "Junaidah"
                                },
                                {
                                    "authorId": "2073137966",
                                    "name": "S. M. Ayu"
                                },
                                {
                                    "authorId": "146321436",
                                    "name": "Busmayaril"
                                },
                                {
                                    "authorId": "2248504509",
                                    "name": "Meisuri"
                                },
                                {
                                    "authorId": "2177074572",
                                    "name": "M.J Muhtari"
                                }
                            ],
                            "year": 2019,
                            "venue": "Journal of Physics: Conference Series",
                            "n_citations": 2
                        },
                        "score": 0.982421875
                    },
                    {
                        "id": "(Zhu et al., 2021)",
                        "snippets": [
                            "Visualized programming, also known as visualized program designing, aims at visualizing the programming based on the principle of \"what you see is what you get\", that is, to see the final result at any time, and to synchronize the programming with the result."
                        ],
                        "paper": {
                            "corpus_id": 243857547,
                            "title": "The Design of Parameter Modeling Software Applicable for Turbine Control Systems of Power Units Operated at Deep Shaving States",
                            "authors": [
                                {
                                    "authorId": "46813111",
                                    "name": "L. Zhu"
                                },
                                {
                                    "authorId": "2000943401",
                                    "name": "Paiyou Si"
                                },
                                {
                                    "authorId": "2121296025",
                                    "name": "S. Liu"
                                },
                                {
                                    "authorId": "48927417",
                                    "name": "Chang Xie"
                                },
                                {
                                    "authorId": "2110105326",
                                    "name": "Teng Zhang"
                                },
                                {
                                    "authorId": "3864387",
                                    "name": "Yuou Hu"
                                },
                                {
                                    "authorId": "152424545",
                                    "name": "Xiaozhi Qiu"
                                }
                            ],
                            "year": 2021,
                            "venue": "Journal of Physics: Conference Series",
                            "n_citations": 6
                        },
                        "score": 0.9501953125
                    },
                    {
                        "id": "(Ray, 2017)",
                        "snippets": [
                            "Visual programming has transformed the art of programming in recent years. Several organizations are in race to develop novel ideas to run visual programming in multiple domains with Internet of Things. IoT, being the most emerging area of computing, needs substantial contribution from the visual programming paradigm for its technological propagation. This paper surveys visual programming languages being served for application development, especially in Internet of Things field. 13 such languages are visited from several popular research-electronic databases (e.g., IEEE Xplore, Science Direct, Springer Link, Google Scholar, Web of Science, and Postscapes) and compared under four key attributes such as programming environment, license, project repository, and platform supports. Grouped into two segments, open source and proprietary platform, these visual languages pertain few crucial challenges that have been elaborated in this literature. The main goal of this paper is to present existing VPLs per their parametric proforma to enable naive developers and researchers in the field of IoT to choose appropriate variant of VPL for particular type of application. It is also worth validating the usability and adaptability of VPLs that is essential for selection of beneficiary in terms of IoT."
                        ],
                        "paper": {
                            "corpus_id": 30037917,
                            "title": "A Survey on Visual Programming Languages in Internet of Things",
                            "authors": [
                                {
                                    "authorId": "2352513",
                                    "name": "P. Ray"
                                }
                            ],
                            "year": 2017,
                            "venue": "Scientific Programming",
                            "n_citations": 60
                        },
                        "score": 0
                    },
                    {
                        "id": "(Zhou et al., 2023)",
                        "snippets": [
                            "Visual programming has the potential of providing novice programmers with a low-code experience to build customized processing pipelines. Existing systems typically require users to build pipelines from scratch, implying that novice users are expected to set up and link appropriate nodes from a blank workspace.\n\nA visual programming interface provides users with a node-graph editor to program through interaction with visual elements. As opposed to writing code in a code editor, the node graph allows users to design pipelines by configuring nodes and connecting them with edges in a visual workspace. This alternative user interface approach often accelerates experimentation and exploration in the prototyping phases of creative applications, and can make advanced technology more accessible to beginners."
                        ],
                        "paper": {
                            "corpus_id": 276961580,
                            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
                            "authors": [
                                {
                                    "authorId": "2261898099",
                                    "name": "Zhongyi Zhou"
                                },
                                {
                                    "authorId": "2214751677",
                                    "name": "Jing Jin"
                                },
                                {
                                    "authorId": "95798184",
                                    "name": "Vrushank Phadnis"
                                },
                                {
                                    "authorId": "29436685",
                                    "name": "Xiuxiu Yuan"
                                },
                                {
                                    "authorId": "2261902264",
                                    "name": "Jun Jiang"
                                },
                                {
                                    "authorId": "2274943688",
                                    "name": "Xun Qian"
                                },
                                {
                                    "authorId": "2261902483",
                                    "name": "Kristen Wright"
                                },
                                {
                                    "authorId": "2261902982",
                                    "name": "Mark Sherwood"
                                },
                                {
                                    "authorId": "2261904117",
                                    "name": "Jason Mayes"
                                },
                                {
                                    "authorId": "2261943879",
                                    "name": "Jingtao Zhou"
                                },
                                {
                                    "authorId": "2275032507",
                                    "name": "Yiyi Huang"
                                },
                                {
                                    "authorId": "2275017028",
                                    "name": "Zheng Xu"
                                },
                                {
                                    "authorId": "2274975067",
                                    "name": "Yinda Zhang"
                                },
                                {
                                    "authorId": "2274929798",
                                    "name": "Johnny Lee"
                                },
                                {
                                    "authorId": "2292510931",
                                    "name": "Alex Olwal"
                                },
                                {
                                    "authorId": "2274972576",
                                    "name": "David Kim"
                                },
                                {
                                    "authorId": "2214753154",
                                    "name": "Ram Iyengar"
                                },
                                {
                                    "authorId": "2262397661",
                                    "name": "Na Li"
                                },
                                {
                                    "authorId": "2350823722",
                                    "name": "Ruofei Du"
                                }
                            ],
                            "year": 2023,
                            "venue": "International Conference on Human Factors in Computing Systems",
                            "n_citations": 1
                        },
                        "score": 0.9638671875
                    },
                    {
                        "id": "(Gao et al., 2025)",
                        "snippets": [
                            "Visual Programming (Gupta et al., 2022)(Sur'is et al., 2023) is an emerging field that utilizes neural symbols or Python modules for task synthe-sis and execution. Its advantage lies in the ability to call visual modules through code, with the reasoning logic of the program explicitly presented in the form of code (Lu et al., 2023)."
                        ],
                        "paper": {
                            "corpus_id": 277634411,
                            "title": "Benchmarking Multimodal CoT Reward Model Stepwise by Visual Program",
                            "authors": [
                                {
                                    "authorId": "2211467299",
                                    "name": "Minghe Gao"
                                },
                                {
                                    "authorId": "2354514403",
                                    "name": "Xuqi Liu"
                                },
                                {
                                    "authorId": "2334476426",
                                    "name": "Zhongqi Yue"
                                },
                                {
                                    "authorId": "2331539012",
                                    "name": "Yang Wu"
                                },
                                {
                                    "authorId": "2297146759",
                                    "name": "Shuang Chen"
                                },
                                {
                                    "authorId": "2261788275",
                                    "name": "Juncheng Li"
                                },
                                {
                                    "authorId": "2276402838",
                                    "name": "Siliang Tang"
                                },
                                {
                                    "authorId": "2289700887",
                                    "name": "Fei Wu"
                                },
                                {
                                    "authorId": "2351809900",
                                    "name": "Tat-Seng Chua"
                                },
                                {
                                    "authorId": "2253660817",
                                    "name": "Yueting Zhuang"
                                }
                            ],
                            "year": 2025,
                            "venue": "arXiv.org",
                            "n_citations": 5
                        },
                        "score": 0.953125
                    },
                    {
                        "id": "(Gupta et al., 2022)",
                        "snippets": [
                            "We present Visprog, a neuro-symbolic approach to solving complex and compositional visual tasks given natural language instructions. Visprog avoids the need for any task-specific training. Instead, it uses the incontext learning ability of large language models to generate python-like modular programs, which are then executed to get both the solution and a comprehensive and interpretable rationale. Each line of the generated program may invoke one of several off-the-shelf computer vision models, image processing subroutines, or python functions to produce intermediate outputs that may be consumed by subsequent parts of the program. We demonstrate the flexibility of VIsPROG on 4 diverse tasks - compositional visual question answering, zero-shot reasoning on image pairs, factual knowledge object tagging, and language-guided image editing. We believe neuro-symbolic approaches like Visprog are an exciting avenue to easily and effectively expand the scope of AI systems to serve the long tail of complex tasks that people may wish to perform."
                        ],
                        "paper": {
                            "corpus_id": 253734854,
                            "title": "Visual Programming: Compositional visual reasoning without training",
                            "authors": [
                                {
                                    "authorId": "1911972",
                                    "name": "Tanmay Gupta"
                                },
                                {
                                    "authorId": "2684226",
                                    "name": "Aniruddha Kembhavi"
                                }
                            ],
                            "year": 2022,
                            "venue": "Computer Vision and Pattern Recognition",
                            "n_citations": 439
                        },
                        "score": 0
                    },
                    {
                        "id": "(Sur'is et al., 2023)",
                        "snippets": [
                            "Answering visual queries is a complex task that requires both visual processing and reasoning. End-to-end models, the dominant approach for this task, do not explicitly differentiate between the two, limiting interpretability and generalization. Learning modular programs presents a promising alternative, but has proven challenging due to the difficulty of learning both the programs and modules simultaneously. We introduce ${\\color{green}{\\text{ViperGPT}}}$, a framework that leverages code-generation models to compose vision-and-language models into subroutines to produce a result for any query. ${\\color{green}{\\text{ViperGPT}}}$ utilizes a provided API to access the available modules, and composes them by generating Python code that is later executed. This simple approach requires no further training, and achieves state-of-the-art results across various complex visual tasks."
                        ],
                        "paper": {
                            "corpus_id": 257505358,
                            "title": "ViperGPT: Visual Inference via Python Execution for Reasoning",
                            "authors": [
                                {
                                    "authorId": "35552695",
                                    "name": "D'idac Sur'is"
                                },
                                {
                                    "authorId": "46245898",
                                    "name": "Sachit Menon"
                                },
                                {
                                    "authorId": "1856025",
                                    "name": "Carl Vondrick"
                                }
                            ],
                            "year": 2023,
                            "venue": "IEEE International Conference on Computer Vision",
                            "n_citations": 466
                        },
                        "score": 0
                    },
                    {
                        "id": "(Lu et al., 2023)",
                        "snippets": [
                            "Large language models (LLMs) have achieved remarkable progress in solving various natural language processing tasks due to emergent reasoning abilities. However, LLMs have inherent limitations as they are incapable of accessing up-to-date information (stored on the Web or in task-specific knowledge bases), using external tools, and performing precise mathematical and logical reasoning. In this paper, we present Chameleon, an AI system that mitigates these limitations by augmenting LLMs with plug-and-play modules for compositional reasoning. Chameleon synthesizes programs by composing various tools (e.g., LLMs, off-the-shelf vision models, web search engines, Python functions, and heuristic-based modules) for accomplishing complex reasoning tasks. At the heart of Chameleon is an LLM-based planner that assembles a sequence of tools to execute to generate the final response. We showcase the effectiveness of Chameleon on two multi-modal knowledge-intensive reasoning tasks: ScienceQA and TabMWP. Chameleon, powered by GPT-4, achieves an 86.54% overall accuracy on ScienceQA, improving the best published few-shot result by 11.37%. On TabMWP, GPT-4-powered Chameleon improves the accuracy by 17.0%, lifting the state of the art to 98.78%. Our analysis also shows that the GPT-4-powered planner exhibits more consistent and rational tool selection via inferring potential constraints from instructions, compared to a ChatGPT-powered planner. The project is available at https://chameleon-llm.github.io."
                        ],
                        "paper": {
                            "corpus_id": 258212542,
                            "title": "Chameleon: Plug-and-Play Compositional Reasoning with Large Language Models",
                            "authors": [
                                {
                                    "authorId": "2887562",
                                    "name": "Pan Lu"
                                },
                                {
                                    "authorId": "1780690",
                                    "name": "Baolin Peng"
                                },
                                {
                                    "authorId": "47413820",
                                    "name": "Hao Cheng"
                                },
                                {
                                    "authorId": "1947267",
                                    "name": "Michel Galley"
                                },
                                {
                                    "authorId": "2782886",
                                    "name": "Kai-Wei Chang"
                                },
                                {
                                    "authorId": "39092098",
                                    "name": "Y. Wu"
                                },
                                {
                                    "authorId": "145380991",
                                    "name": "Song-Chun Zhu"
                                },
                                {
                                    "authorId": "48441311",
                                    "name": "Jianfeng Gao"
                                }
                            ],
                            "year": 2023,
                            "venue": "Neural Information Processing Systems",
                            "n_citations": 324
                        },
                        "score": 0
                    }
                ],
                "format": "list",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Historical Development",
                "tldr": "Visual programming has a long history dating back to the 1950s with flowcharts, followed by interactive diagram creation in the 1960s. The field gained significant momentum in the 1980s and 1990s with the advent of graphical workstations and personal computers, leading to widespread development of visual programming languages. (4 sources)",
                "text": "\nThe history of visual programming runs parallel to the development of software itself, with visual representations of programs being present from the early days of computing. In the 1950s, flowcharts were already widely used for program specification and documentation purposes, coinciding with the introduction of high-level programming languages <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>. This early use of visual elements represented the first steps toward more accessible programming paradigms.\n\nA significant advancement came in the 1960s when Sutherland introduced interactive creation of programs as diagrams, representing one of the earliest applications of graphical display and input technologies <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>. This innovation laid the groundwork for future visual programming environments by demonstrating the potential of interactive graphical interfaces for program creation.\n\nThe field of visual programming gained substantial momentum in the 1980s and 1990s, propelled by the widespread introduction of graphical workstations and personal computers <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>. This technological advancement provided the necessary hardware capabilities to support more sophisticated visual programming environments. Since the sixties of the last century, researchers have been developing Visual Programming Languages (VPLs) specifically to address the challenges associated with learning computer programming <Paper corpusId=\"3949077\" paperTitle=\"(Fayed, 2017)\" isShortName></Paper>.\n\nThe proliferation of visual programming languages continued into the modern era, with many languages emerging for educational purposes and specialized domains <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>. As hardware capabilities evolved, visual programming found new applications in areas such as game development, where the concept of game engines emerged to enable quicker development cycles and separation of game concepts from assets <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper> <Paper corpusId=\"158715\" paperTitle=\"(Andrade, 2015)\" isShortName></Paper>. In recent years, the Internet of Things (IoT) has become a significant domain for visual programming, with numerous languages developed specifically for IoT application development <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper> <Paper corpusId=\"30037917\" paperTitle=\"(Ray, 2017)\" isShortName></Paper>.\n\nThroughout its historical development, visual programming has consistently aimed to make programming more accessible and intuitive, evolving from simple flowcharts to sophisticated interactive environments that support complex application development across multiple domains.",
                "citations": [
                    {
                        "id": "(McDaid et al., 2020)",
                        "snippets": [
                            "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers (Myers, 1990). There are now many visual programming languages (Johnston et al., 2004)11,(Maloney et al., 2010). Many of which are aimed at education or niche domains (Bockermann, 2014)(Ray, 2017)(Andrade, 2015)16,(Gulwani et al., 2015)."
                        ],
                        "paper": {
                            "corpus_id": 221802417,
                            "title": "A Visual Language for Composable Inductive Programming",
                            "authors": [
                                {
                                    "authorId": "1420120235",
                                    "name": "Edward McDaid"
                                },
                                {
                                    "authorId": "4697495",
                                    "name": "S. McDaid"
                                }
                            ],
                            "year": 2020,
                            "venue": "arXiv.org",
                            "n_citations": 4
                        },
                        "score": 0.9736328125
                    },
                    {
                        "id": "(Fayed, 2017)",
                        "snippets": [
                            "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard."
                        ],
                        "paper": {
                            "corpus_id": 3949077,
                            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                            "authors": [
                                {
                                    "authorId": "35131544",
                                    "name": "M. S. Fayed"
                                }
                            ],
                            "year": 2017,
                            "venue": "arXiv.org",
                            "n_citations": 3
                        },
                        "score": 0.9482421875
                    },
                    {
                        "id": "(Andrade, 2015)",
                        "snippets": [
                            "Due to hardware limitations at the origin of the video game industry, each new game was generally coded from the ground up. Years later, from the evolution of hardware and the need for quick game development cycles, spawned the concept of game engine. A game engine is a reusable software layer allowing the separation of common game concepts from the game assets (levels, graphics, etc.). This paper surveys fourteen different game engines relevant today, ranging from the industry-level to the newcomer-friendlier ones."
                        ],
                        "paper": {
                            "corpus_id": 158715,
                            "title": "Game engines: a survey",
                            "authors": [
                                {
                                    "authorId": "146007426",
                                    "name": "A. Andrade"
                                }
                            ],
                            "year": 2015,
                            "venue": "EAI Endorsed Trans. Serious Games",
                            "n_citations": 34
                        },
                        "score": 0
                    },
                    {
                        "id": "(Ray, 2017)",
                        "snippets": [
                            "Visual programming has transformed the art of programming in recent years. Several organizations are in race to develop novel ideas to run visual programming in multiple domains with Internet of Things. IoT, being the most emerging area of computing, needs substantial contribution from the visual programming paradigm for its technological propagation. This paper surveys visual programming languages being served for application development, especially in Internet of Things field. 13 such languages are visited from several popular research-electronic databases (e.g., IEEE Xplore, Science Direct, Springer Link, Google Scholar, Web of Science, and Postscapes) and compared under four key attributes such as programming environment, license, project repository, and platform supports. Grouped into two segments, open source and proprietary platform, these visual languages pertain few crucial challenges that have been elaborated in this literature. The main goal of this paper is to present existing VPLs per their parametric proforma to enable naive developers and researchers in the field of IoT to choose appropriate variant of VPL for particular type of application. It is also worth validating the usability and adaptability of VPLs that is essential for selection of beneficiary in terms of IoT."
                        ],
                        "paper": {
                            "corpus_id": 30037917,
                            "title": "A Survey on Visual Programming Languages in Internet of Things",
                            "authors": [
                                {
                                    "authorId": "2352513",
                                    "name": "P. Ray"
                                }
                            ],
                            "year": 2017,
                            "venue": "Scientific Programming",
                            "n_citations": 60
                        },
                        "score": 0
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Technical Implementation",
                "tldr": "Visual programming systems are typically built around a code canvas where users can read and write programs by manipulating graphical elements. The implementation varies based on the visual representation chosen, with common architectures including boxes-and-arrows, interlocking puzzle pieces, and command-based models. (5 sources)",
                "text": "\nVisual programming environments, despite their diversity in visual representations, share common architectural components. At the center of most visual programming systems (VPS) is a code canvas where users can both read and write programs through direct manipulation of graphical elements <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>. This canvas is complemented by a component palette from which users can drag elements onto the canvas and a configuration pane where these elements can be customized <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>.\n\nThe technical implementation of visual programming languages often follows one of several established paradigms. In the boxes-and-arrows approach, similar to Business Process Modeling Notation (BPMN), boxes represent program entities or instructions while arrows depict the relationships or data flow between them <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper> <Paper corpusId=\"256827582\" paperTitle=\"(Wagner et al., 2023)\" isShortName></Paper>. Alternatively, interlocking puzzle pieces, as exemplified by Scratch, use the physical metaphor of puzzle pieces fitting together to represent how instructions connect and how data flows between them <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>.\n\nSome visual programming systems employ a command-based model designed for distributed processing. This approach is particularly suited for modular systems like robot kits, where the visual programming environment coordinates tasks performed by connected modules. In this implementation, the central controlling entity issues commands to various modules that handle specific tasks independently, with some tasks simply executing and others returning results for decision-making <Paper corpusId=\"4793447\" paperTitle=\"(Vithana et al., 2017)\" isShortName></Paper>.\n\nMore specialized implementations exist for particular domains. DiaPlan, for example, is a visual rule-based language founded on graph transformation as its computational model, specifically designed for programming visual systems <Paper corpusId=\"58394\" paperTitle=\"(Hoffmann et al., 2000)\" isShortName></Paper>.\n\nThe design of visual programming systems aims to assist users in overcoming three key cognitive challenges: syntactic (creating well-formed programs), semantic (understanding program meaning), and pragmatic (comprehending program behavior in specific contexts) <Paper corpusId=\"256827582\" paperTitle=\"(Wagner et al., 2023)\" isShortName></Paper> <Paper corpusId=\"41867280\" paperTitle=\"(Repenning, 2017)\" isShortName></Paper>. By providing visual cues about how programming elements can be connected, these implementations help prevent users from creating invalid programs, thereby eliminating many common programming errors <Paper corpusId=\"256827582\" paperTitle=\"(Wagner et al., 2023)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Hirzel, 2022)",
                        "snippets": [
                            "Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane."
                        ],
                        "paper": {
                            "corpus_id": 248524774,
                            "title": "Low-Code Programming Models",
                            "authors": [
                                {
                                    "authorId": "1728836",
                                    "name": "Martin Hirzel"
                                }
                            ],
                            "year": 2022,
                            "venue": "Communications of the ACM",
                            "n_citations": 21
                        },
                        "score": 0.98193359375
                    },
                    {
                        "id": "(Wagner et al., 2023)",
                        "snippets": [
                            "A visual programming system (VPS) [8] allows users to create programs by manipulating program elements graphically rather than specifying them textually. In a VPS, a user creates a program by arranging \"boxes and arrows\", where boxes represent entities and arrows represent relations.\n\nA VPS can assist programmers to overcome three cognitive challenges [6]: \n\n\u2022 Syntactic: arranging programming language components into well-formed programs. \u2022 Semantic: assisting users with the comprehension of the meaning of programs. \u2022 Pragmatic: bringing a program into a specific situation and understanding its behaviour."
                        ],
                        "paper": {
                            "corpus_id": 256827582,
                            "title": "ELEA - Build your own Evolutionary Algorithm in your Browser",
                            "authors": [
                                {
                                    "authorId": "2194782585",
                                    "name": "Markus Wagner"
                                },
                                {
                                    "authorId": "2205544441",
                                    "name": "Erik Kohlros"
                                },
                                {
                                    "authorId": "2205539993",
                                    "name": "Gerome Quantmeyer"
                                },
                                {
                                    "authorId": "1751539",
                                    "name": "Timo K\u00f6tzing"
                                }
                            ],
                            "year": 2023,
                            "venue": "GECCO Companion",
                            "n_citations": 1
                        },
                        "score": 0.96435546875
                    },
                    {
                        "id": "(Vithana et al., 2017)",
                        "snippets": [
                            "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components."
                        ],
                        "paper": {
                            "corpus_id": 4793447,
                            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                            "authors": [
                                {
                                    "authorId": "9346844",
                                    "name": "Yasura Vithana"
                                },
                                {
                                    "authorId": "40894841",
                                    "name": "Hashini Senaratne"
                                }
                            ],
                            "year": 2017,
                            "venue": "British Computer Society Conference on Human-Computer Interaction",
                            "n_citations": 0
                        },
                        "score": 0.97802734375
                    },
                    {
                        "id": "(Hoffmann et al., 2000)",
                        "snippets": [
                            "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation."
                        ],
                        "paper": {
                            "corpus_id": 58394,
                            "title": "Towards rule-based visual programming of generic visual systems",
                            "authors": [
                                {
                                    "authorId": "38400881",
                                    "name": "Berthold Hoffmann"
                                },
                                {
                                    "authorId": "1731543",
                                    "name": "M. Minas"
                                }
                            ],
                            "year": 2000,
                            "venue": "arXiv.org",
                            "n_citations": 9
                        },
                        "score": 0.94287109375
                    },
                    {
                        "id": "(Repenning, 2017)",
                        "snippets": [
                            "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                        ],
                        "paper": {
                            "corpus_id": 41867280,
                            "title": "Moving Beyond Syntax: Lessons from 20 Years of Blocks Programing in AgentSheets",
                            "authors": [
                                {
                                    "authorId": "1782080",
                                    "name": "A. Repenning"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Visual Languages and Sentient Systems",
                            "n_citations": 50
                        },
                        "score": 0
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            }
        ],
        "cost": 0.162345
    }
}
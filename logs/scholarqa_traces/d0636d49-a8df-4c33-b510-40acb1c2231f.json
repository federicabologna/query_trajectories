{
    "query": "What are the main categories of visual programming languages, such as block-based, node-based, or diagram-based, and how do they differ?",
    "user_id": "lib_user",
    "task_id": "d0636d49-a8df-4c33-b510-40acb1c2231f",
    "timestamp": "2025-06-23T23:40:32.203118",
    "n_retrieval": 256,
    "n_retrieved": 272,
    "n_candidates": 39,
    "n_rerank": 50,
    "opt_in": true,
    "total_cost": 0.461028,
    "decomposed_query": {
        "rewritten_query": "Main categories of visual programming languages such as block-based, node-based, or diagram-based, and how they differ.",
        "keyword_query": "visual programming languages block-based node-based diagram-based differences categories",
        "search_filters": {
            "fieldsOfStudy": "Computer Science"
        },
        "cost": 0.009834,
        "model": "claude-3-7-sonnet-20250219"
    },
    "candidates": [
        {
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "venue": "IEEE Access",
            "year": 2021,
            "reference_count": 107,
            "citation_count": 39,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ieeexplore.ieee.org/ielx7/6287639/9312710/09320477.pdf",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/ACCESS.2021.3051043?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/ACCESS.2021.3051043, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1980707",
                    "name": "M. Kuhail"
                },
                {
                    "authorId": "153238394",
                    "name": "Shahbano Farooq"
                },
                {
                    "authorId": "3083161",
                    "name": "R. Hammad"
                },
                {
                    "authorId": "8357681",
                    "name": "Mohammed Bahja"
                }
            ],
            "abstract": "Recently many researches have explored the potential of visual programming in robotics, the Internet of Things (IoT), and education. However, there is a lack of studies that analyze the recent evidence-based visual programming approaches that are applied in several domains. This study presents a systematic review to understand, compare, and reflect on recent visual programming approaches using twelve dimensions: visual programming classification, interaction style, target users, domain, platform, empirical evaluation type, test participants\u2019 type, number of test participants, test participants\u2019 programming skills, evaluation methods, evaluation measures, and accessibility of visual programming tools. The results show that most of the selected articles discussed tools that target IoT and education, while other fields such as data science, robotics are emerging. Further, most tools use abstractions to hide implementation details and use similar interaction styles. The predominant platforms for the tools are web and mobile, while desktop-based tools are on the decline. Only a few tools were evaluated with a formal experiment, whilst the remaining ones were evaluated with evaluation studies or informal feedback. Most tools were evaluated with students with little to no programming skills. There is a lack of emphasis on usability principles in the design stage of the tools. Additionally, only one of the tools was evaluated for expressiveness. Other areas for exploration include supporting end users throughout the life cycle of applications created with the tools, studying the impact of tutorials on improving learnability, and exploring the potential of machine learning to improve debugging solutions developed with visual programming.",
            "corpus_id": 231725028,
            "sentences": [
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Visual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:",
                    "score": 0.5885909639403195,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 5284,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 71
                        },
                        {
                            "start": 72,
                            "end": 301
                        },
                        {
                            "start": 302,
                            "end": 507
                        },
                        {
                            "start": 510,
                            "end": 698
                        },
                        {
                            "start": 699,
                            "end": 818
                        },
                        {
                            "start": 821,
                            "end": 975
                        },
                        {
                            "start": 976,
                            "end": 1057
                        },
                        {
                            "start": 1058,
                            "end": 1159
                        },
                        {
                            "start": 1160,
                            "end": 1372
                        },
                        {
                            "start": 1373,
                            "end": 1484
                        },
                        {
                            "start": 1487,
                            "end": 1693
                        },
                        {
                            "start": 1694,
                            "end": 1855
                        },
                        {
                            "start": 1856,
                            "end": 2042
                        },
                        {
                            "start": 2043,
                            "end": 2138
                        },
                        {
                            "start": 2141,
                            "end": 2181
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 502,
                            "end": 506,
                            "matchedPaperCorpusId": "15687689"
                        },
                        {
                            "start": 694,
                            "end": 697,
                            "matchedPaperCorpusId": "8272806"
                        },
                        {
                            "start": 813,
                            "end": 817,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 903,
                            "end": 906,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1182,
                            "end": 1185,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1531,
                            "end": 1534,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1557,
                            "end": 1560,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1787,
                            "end": 1790,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1795,
                            "end": 1798,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 1926,
                            "end": 1929,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1993,
                            "end": 1996,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 2038,
                            "end": 2041,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 2089,
                            "end": 2092,
                            "matchedPaperCorpusId": "7335020"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9921875
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "We define the VPL categories as follows: \n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users. \n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons. Recently iconic languages have been used to enable end users without programming experience to create applications based on triggers and actions. For instance, end users may specify an alert to be sent to them when the indoor temperature is less than 40 \u2022 F. More examples can be found in [16]- [18], and [94]. \n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications. The textual form-based paradigm utilizes a declarative approach to programming, that is based on a dependency-driven, direct-manipulation model [20]. Users of form-based languages create or configure cells, and define formulas for those cells [21]. These formulas reference values contained in other cells and use them in calculations. Whenever a cell's formula is defined, the underlying evaluation engine calculates the cell's value, recalculates the values of cells that reference recalculated cells, and displays new results on the screen. \n\nDiagrams have been utilized as communication and thinking tools across many domains [22]- [24].",
                    "score": 0.5363550918564606,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 7425,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 40
                        },
                        {
                            "start": 43,
                            "end": 185
                        },
                        {
                            "start": 186,
                            "end": 237
                        },
                        {
                            "start": 238,
                            "end": 389
                        },
                        {
                            "start": 390,
                            "end": 527
                        },
                        {
                            "start": 530,
                            "end": 647
                        },
                        {
                            "start": 648,
                            "end": 730
                        },
                        {
                            "start": 731,
                            "end": 882
                        },
                        {
                            "start": 883,
                            "end": 960
                        },
                        {
                            "start": 961,
                            "end": 1023
                        },
                        {
                            "start": 1024,
                            "end": 1169
                        },
                        {
                            "start": 1170,
                            "end": 1282
                        },
                        {
                            "start": 1283,
                            "end": 1334
                        },
                        {
                            "start": 1337,
                            "end": 1519
                        },
                        {
                            "start": 1520,
                            "end": 1613
                        },
                        {
                            "start": 1614,
                            "end": 1763
                        },
                        {
                            "start": 1764,
                            "end": 1862
                        },
                        {
                            "start": 1863,
                            "end": 1949
                        },
                        {
                            "start": 1950,
                            "end": 2157
                        },
                        {
                            "start": 2160,
                            "end": 2255
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 433,
                            "end": 437,
                            "matchedPaperCorpusId": "275570079"
                        },
                        {
                            "start": 642,
                            "end": 646,
                            "matchedPaperCorpusId": "12476837"
                        },
                        {
                            "start": 654,
                            "end": 658,
                            "matchedPaperCorpusId": "207116116"
                        },
                        {
                            "start": 1313,
                            "end": 1317,
                            "matchedPaperCorpusId": "42867257"
                        },
                        {
                            "start": 1319,
                            "end": 1323,
                            "matchedPaperCorpusId": "39706110"
                        },
                        {
                            "start": 1514,
                            "end": 1518,
                            "matchedPaperCorpusId": "31262336"
                        },
                        {
                            "start": 1758,
                            "end": 1762,
                            "matchedPaperCorpusId": "16926659"
                        },
                        {
                            "start": 1857,
                            "end": 1861,
                            "matchedPaperCorpusId": "14879345"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97607421875
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Diagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.",
                    "score": 0.658097668151179,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 9585,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 95
                        },
                        {
                            "start": 96,
                            "end": 307
                        },
                        {
                            "start": 308,
                            "end": 374
                        },
                        {
                            "start": 375,
                            "end": 469
                        },
                        {
                            "start": 470,
                            "end": 642
                        },
                        {
                            "start": 645,
                            "end": 750
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 84,
                            "end": 88,
                            "matchedPaperCorpusId": "74221"
                        },
                        {
                            "start": 90,
                            "end": 94,
                            "matchedPaperCorpusId": "143658620"
                        },
                        {
                            "start": 637,
                            "end": 641,
                            "matchedPaperCorpusId": "19780225"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.97509765625
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.",
                    "score": 0.49137877811584296,
                    "section_title": "1) FORM-BASED TOOLS",
                    "char_start_offset": 28883,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 216
                        },
                        {
                            "start": 217,
                            "end": 404
                        },
                        {
                            "start": 405,
                            "end": 478
                        },
                        {
                            "start": 481,
                            "end": 576
                        },
                        {
                            "start": 577,
                            "end": 735
                        },
                        {
                            "start": 736,
                            "end": 790
                        },
                        {
                            "start": 791,
                            "end": 901
                        },
                        {
                            "start": 902,
                            "end": 978
                        },
                        {
                            "start": 981,
                            "end": 1046
                        },
                        {
                            "start": 1047,
                            "end": 1144
                        },
                        {
                            "start": 1145,
                            "end": 1179
                        },
                        {
                            "start": 1180,
                            "end": 1238
                        },
                        {
                            "start": 1239,
                            "end": 1434
                        },
                        {
                            "start": 1437,
                            "end": 1551
                        },
                        {
                            "start": 1552,
                            "end": 1676
                        },
                        {
                            "start": 1677,
                            "end": 1817
                        },
                        {
                            "start": 1818,
                            "end": 1927
                        },
                        {
                            "start": 1928,
                            "end": 2071
                        },
                        {
                            "start": 2074,
                            "end": 2242
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 239,
                            "end": 243,
                            "matchedPaperCorpusId": "146808112"
                        },
                        {
                            "start": 338,
                            "end": 342,
                            "matchedPaperCorpusId": "218969033"
                        },
                        {
                            "start": 508,
                            "end": 512,
                            "matchedPaperCorpusId": "146808112"
                        },
                        {
                            "start": 1041,
                            "end": 1045,
                            "matchedPaperCorpusId": "218969033"
                        },
                        {
                            "start": 1452,
                            "end": 1456,
                            "matchedPaperCorpusId": "67453782"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.95947265625
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Only a handful of studies reviewed visual programming related research. The studies reviewed how visual programming tools were used in specific domains such as IoT, robotics, and education. \n\nAs an example, the authors in [8] surveyed 16 visual programming environments allowing end users to create applications involving robots with social capabilities. Only one article out of the 16 articles was published in a journal. The study shows that recent tools are adopting component-based software engineering approaches, but the tools need to be evaluated with real end users as opposed to university students, and should be validated in a real setting as opposed to a laboratory. The study mainly focused on the analysis and challenges specific to robotics-related approaches such as scripting-based, rule-based systems, state-based and behavior-based systems. \n\nAnother example of a domain-specific visual programming review study is the study in [10]. The author surveyed 13 articles that use visual programming to support the creation of IoT-based applications. The vast majority of the articles were conference articles. The study reported that VPLs make it easy for end users to visualize the programming logic and eliminate the burden of handling syntactical errors. However, significant time is spent on creating small-scale IoT applications with visual programming. The study focused on IoT-specific attributes such as the hardware platform (e.g. Raspberry Pi, Arduino) and overlooked the broad VPL classifications (e.g. diagrammatic, iconic, block-based). \n\nA recent study conducted a systematic literature review to examine the role of visual and textual programming languages in helping students learn how to program [30]. The study reported that the choice of textual programming language is not a crucial one as languages are alike. However, the use of visual programming to introduce students to programming concepts is of utility as long as it is within a short time frame. \n\nTo sum up, all the aforementioned review studies are domain specific, and as such do not provide a generic view of VPL approaches applied in multiple domains beyond the domains of education, IoT and robotics. \n\nOur study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains.",
                    "score": 0.3673892989192877,
                    "section_title": "B. VISUAL PROGRAMMING REVIEW STUDIES",
                    "char_start_offset": 15847,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 71
                        },
                        {
                            "start": 72,
                            "end": 189
                        },
                        {
                            "start": 192,
                            "end": 354
                        },
                        {
                            "start": 355,
                            "end": 422
                        },
                        {
                            "start": 423,
                            "end": 678
                        },
                        {
                            "start": 679,
                            "end": 859
                        },
                        {
                            "start": 862,
                            "end": 952
                        },
                        {
                            "start": 953,
                            "end": 1063
                        },
                        {
                            "start": 1064,
                            "end": 1123
                        },
                        {
                            "start": 1124,
                            "end": 1271
                        },
                        {
                            "start": 1272,
                            "end": 1372
                        },
                        {
                            "start": 1373,
                            "end": 1453
                        },
                        {
                            "start": 1454,
                            "end": 1527
                        },
                        {
                            "start": 1528,
                            "end": 1563
                        },
                        {
                            "start": 1566,
                            "end": 1732
                        },
                        {
                            "start": 1733,
                            "end": 1844
                        },
                        {
                            "start": 1845,
                            "end": 1987
                        },
                        {
                            "start": 1990,
                            "end": 2198
                        },
                        {
                            "start": 2201,
                            "end": 2522
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 222,
                            "end": 225,
                            "matchedPaperCorpusId": "219455753"
                        },
                        {
                            "start": 947,
                            "end": 951,
                            "matchedPaperCorpusId": "30037917"
                        },
                        {
                            "start": 1727,
                            "end": 1731,
                            "matchedPaperCorpusId": "4039308"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.90380859375
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "To answer the first research question, we analyzed the selected articles against the five research question dimensions discussed in the subsequent subsections. Furthermore, we used examples from some of the selected articles to shed light on details of interest. \n\nA. RQ1-D1: VPL CLASSIFICATION 43.3% (13) of the articles used a block-based approach, while 40% (12) of the selected articles used a diagram-based approach. 13.3% (4) of the selected articles used a form-based approach, whereas only 6.6% (2) articles used an icon-based approach (Figure 4). Despite the differences of the approaches, all the tools use high-level abstractions to simplify the process of creating a program and hide implementation details. The abstractions are often represented as visual components that end users can drag and drop. The abstractions allow end users to incorporate into their applications: functions [32], [51], web services [43] or software modules [41]. Abstractions are used to increase tool accessibility though this may be at the cost of expressiveness as the abstractions are often designed to operate in a restricted way. Another common theme is the use of color to represent data flowing between components [51], [60].",
                    "score": 0.37594480507987044,
                    "section_title": "VI. FIRST RESEARCH QUESTION DIMENSIONS",
                    "char_start_offset": 25531,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 159
                        },
                        {
                            "start": 160,
                            "end": 262
                        },
                        {
                            "start": 265,
                            "end": 421
                        },
                        {
                            "start": 422,
                            "end": 555
                        },
                        {
                            "start": 556,
                            "end": 719
                        },
                        {
                            "start": 720,
                            "end": 813
                        },
                        {
                            "start": 814,
                            "end": 952
                        },
                        {
                            "start": 953,
                            "end": 1125
                        },
                        {
                            "start": 1126,
                            "end": 1223
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 897,
                            "end": 901,
                            "matchedPaperCorpusId": "66914713"
                        },
                        {
                            "start": 903,
                            "end": 907,
                            "matchedPaperCorpusId": "26243684"
                        },
                        {
                            "start": 922,
                            "end": 926,
                            "matchedPaperCorpusId": "195785412"
                        },
                        {
                            "start": 947,
                            "end": 951,
                            "matchedPaperCorpusId": "146808112"
                        },
                        {
                            "start": 1212,
                            "end": 1216,
                            "matchedPaperCorpusId": "26243684"
                        },
                        {
                            "start": 1218,
                            "end": 1222,
                            "matchedPaperCorpusId": "7388219"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9013671875
                },
                {
                    "corpus_id": "231725028",
                    "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                    "text": "Figure 7 shows the target domain of the selected articles. All the surveyed tools are domain specific, and not meant to be used for multiple purposes. 23.3% (7) of the tools presented in the selected articles fit in the category of IoT. Some of these tools allow end users to utilize the resources of their personal phones such as [32] and [51]. Others enable the usage of sensors deployed in cities such as [43] or sensors used in variety of contexts such as smart homes or available for medical staff to monitor patients' health [60]. While tools built for IoT applications use different VPL approaches (form-based, diagram-based, and block-based), a common theme among the tools is allowing end users to access services such as sensors and phone resources by means of visual abstractions. For instance, the tool presented in [46] shows various types of sensors (such as motion and presence sensors) as visual blocks. End users can define logic that is related to the the states of such sensors. As a simple example, end users may specify a welcoming message upon switching on a certain light. \n\n23.3% (7) of the tools are intended to be used in an educational setting. Some of these tools such as [38] and [39] are utilized for teaching basic programming principles such as loops and conditionals, whereas the tool in [44] aims at teaching data science concepts to non-programmers, and the tool in [45] is intended for teaching computing and engineering concepts and for programming robots. \n\nApart from one tool [45], all the tools built for educational applications used a block-based approach. The block-based educational tools use similar visual blocks to represent programming constructs such as variable setting, control flow, and conditionals. The tools aimed at teaching a specific topic in computer science such as parallel programming represent related concepts (e.g. parallel blocks, message passing, events) visually. For instance, the concept of events is represented by a ''When'' visual block in [37] and [49]. \n\nThe tool explained in [45] uses a diagram-based approach to programming education. For instance, a while loop is represented by a sequence of connected boxes. Each box represents a command, e.g. setting a variable.",
                    "score": 0.33216997179715685,
                    "section_title": "D. RQ1-D4: DOMAIN",
                    "char_start_offset": 37365,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 58
                        },
                        {
                            "start": 59,
                            "end": 150
                        },
                        {
                            "start": 151,
                            "end": 236
                        },
                        {
                            "start": 237,
                            "end": 345
                        },
                        {
                            "start": 346,
                            "end": 536
                        },
                        {
                            "start": 537,
                            "end": 791
                        },
                        {
                            "start": 792,
                            "end": 919
                        },
                        {
                            "start": 920,
                            "end": 997
                        },
                        {
                            "start": 998,
                            "end": 1095
                        },
                        {
                            "start": 1098,
                            "end": 1171
                        },
                        {
                            "start": 1172,
                            "end": 1493
                        },
                        {
                            "start": 1496,
                            "end": 1599
                        },
                        {
                            "start": 1600,
                            "end": 1753
                        },
                        {
                            "start": 1754,
                            "end": 1880
                        },
                        {
                            "start": 1881,
                            "end": 1932
                        },
                        {
                            "start": 1933,
                            "end": 2028
                        },
                        {
                            "start": 2031,
                            "end": 2113
                        },
                        {
                            "start": 2114,
                            "end": 2189
                        },
                        {
                            "start": 2190,
                            "end": 2225
                        },
                        {
                            "start": 2226,
                            "end": 2245
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 157,
                            "end": 160,
                            "matchedPaperCorpusId": "195856963"
                        },
                        {
                            "start": 331,
                            "end": 335,
                            "matchedPaperCorpusId": "66914713"
                        },
                        {
                            "start": 340,
                            "end": 344,
                            "matchedPaperCorpusId": "26243684"
                        },
                        {
                            "start": 408,
                            "end": 412,
                            "matchedPaperCorpusId": "195785412"
                        },
                        {
                            "start": 531,
                            "end": 535,
                            "matchedPaperCorpusId": "7388219"
                        },
                        {
                            "start": 828,
                            "end": 832,
                            "matchedPaperCorpusId": "222210810"
                        },
                        {
                            "start": 1104,
                            "end": 1107,
                            "matchedPaperCorpusId": "195856963"
                        },
                        {
                            "start": 1200,
                            "end": 1204,
                            "matchedPaperCorpusId": "211104795"
                        },
                        {
                            "start": 1209,
                            "end": 1213,
                            "matchedPaperCorpusId": "211206448"
                        },
                        {
                            "start": 1321,
                            "end": 1325,
                            "matchedPaperCorpusId": "53080670"
                        },
                        {
                            "start": 1401,
                            "end": 1405,
                            "matchedPaperCorpusId": "67453782"
                        },
                        {
                            "start": 1516,
                            "end": 1520,
                            "matchedPaperCorpusId": "67453782"
                        },
                        {
                            "start": 2014,
                            "end": 2018,
                            "matchedPaperCorpusId": "16591367"
                        },
                        {
                            "start": 2023,
                            "end": 2027,
                            "matchedPaperCorpusId": "44165140"
                        },
                        {
                            "start": 2053,
                            "end": 2057,
                            "matchedPaperCorpusId": "67453782"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.88916015625
                }
            ],
            "relevance_judgement": 0.9921875,
            "relevance_judgment_input_expanded": "# Title: Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review\n# Venue: IEEE Access\n# Authors: M. Kuhail, Shahbano Farooq, R. Hammad, Mohammed Bahja\n## Abstract\nRecently many researches have explored the potential of visual programming in robotics, the Internet of Things (IoT), and education. However, there is a lack of studies that analyze the recent evidence-based visual programming approaches that are applied in several domains. This study presents a systematic review to understand, compare, and reflect on recent visual programming approaches using twelve dimensions: visual programming classification, interaction style, target users, domain, platform, empirical evaluation type, test participants\u2019 type, number of test participants, test participants\u2019 programming skills, evaluation methods, evaluation measures, and accessibility of visual programming tools. The results show that most of the selected articles discussed tools that target IoT and education, while other fields such as data science, robotics are emerging. Further, most tools use abstractions to hide implementation details and use similar interaction styles. The predominant platforms for the tools are web and mobile, while desktop-based tools are on the decline. Only a few tools were evaluated with a formal experiment, whilst the remaining ones were evaluated with evaluation studies or informal feedback. Most tools were evaluated with students with little to no programming skills. There is a lack of emphasis on usability principles in the design stage of the tools. Additionally, only one of the tools was evaluated for expressiveness. Other areas for exploration include supporting end users throughout the life cycle of applications created with the tools, studying the impact of tutorials on improving learnability, and exploring the potential of machine learning to improve debugging solutions developed with visual programming.\n## II. BACKGROUND\nVisual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:\n...\nWe define the VPL categories as follows: \n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users. \n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons. Recently iconic languages have been used to enable end users without programming experience to create applications based on triggers and actions. For instance, end users may specify an alert to be sent to them when the indoor temperature is less than 40 \u2022 F. More examples can be found in [16]- [18], and [94]. \n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications. The textual form-based paradigm utilizes a declarative approach to programming, that is based on a dependency-driven, direct-manipulation model [20]. Users of form-based languages create or configure cells, and define formulas for those cells [21]. These formulas reference values contained in other cells and use them in calculations. Whenever a cell's formula is defined, the underlying evaluation engine calculates the cell's value, recalculates the values of cells that reference recalculated cells, and displays new results on the screen. \n\nDiagrams have been utilized as communication and thinking tools across many domains [22]- [24].\n...\nDiagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.\n\n## B. VISUAL PROGRAMMING REVIEW STUDIES\nOnly a handful of studies reviewed visual programming related research. The studies reviewed how visual programming tools were used in specific domains such as IoT, robotics, and education. \n\nAs an example, the authors in [8] surveyed 16 visual programming environments allowing end users to create applications involving robots with social capabilities. Only one article out of the 16 articles was published in a journal. The study shows that recent tools are adopting component-based software engineering approaches, but the tools need to be evaluated with real end users as opposed to university students, and should be validated in a real setting as opposed to a laboratory. The study mainly focused on the analysis and challenges specific to robotics-related approaches such as scripting-based, rule-based systems, state-based and behavior-based systems. \n\nAnother example of a domain-specific visual programming review study is the study in [10]. The author surveyed 13 articles that use visual programming to support the creation of IoT-based applications. The vast majority of the articles were conference articles. The study reported that VPLs make it easy for end users to visualize the programming logic and eliminate the burden of handling syntactical errors. However, significant time is spent on creating small-scale IoT applications with visual programming. The study focused on IoT-specific attributes such as the hardware platform (e.g. Raspberry Pi, Arduino) and overlooked the broad VPL classifications (e.g. diagrammatic, iconic, block-based). \n\nA recent study conducted a systematic literature review to examine the role of visual and textual programming languages in helping students learn how to program [30]. The study reported that the choice of textual programming language is not a crucial one as languages are alike. However, the use of visual programming to introduce students to programming concepts is of utility as long as it is within a short time frame. \n\nTo sum up, all the aforementioned review studies are domain specific, and as such do not provide a generic view of VPL approaches applied in multiple domains beyond the domains of education, IoT and robotics. \n\nOur study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains.\n\n## VI. FIRST RESEARCH QUESTION DIMENSIONS\nTo answer the first research question, we analyzed the selected articles against the five research question dimensions discussed in the subsequent subsections. Furthermore, we used examples from some of the selected articles to shed light on details of interest. \n\nA. RQ1-D1: VPL CLASSIFICATION 43.3% (13) of the articles used a block-based approach, while 40% (12) of the selected articles used a diagram-based approach. 13.3% (4) of the selected articles used a form-based approach, whereas only 6.6% (2) articles used an icon-based approach (Figure 4). Despite the differences of the approaches, all the tools use high-level abstractions to simplify the process of creating a program and hide implementation details. The abstractions are often represented as visual components that end users can drag and drop. The abstractions allow end users to incorporate into their applications: functions [32], [51], web services [43] or software modules [41]. Abstractions are used to increase tool accessibility though this may be at the cost of expressiveness as the abstractions are often designed to operate in a restricted way. Another common theme is the use of color to represent data flowing between components [51], [60].\n\n## 1) FORM-BASED TOOLS\n2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.\n\n## D. RQ1-D4: DOMAIN\nFigure 7 shows the target domain of the selected articles. All the surveyed tools are domain specific, and not meant to be used for multiple purposes. 23.3% (7) of the tools presented in the selected articles fit in the category of IoT. Some of these tools allow end users to utilize the resources of their personal phones such as [32] and [51]. Others enable the usage of sensors deployed in cities such as [43] or sensors used in variety of contexts such as smart homes or available for medical staff to monitor patients' health [60]. While tools built for IoT applications use different VPL approaches (form-based, diagram-based, and block-based), a common theme among the tools is allowing end users to access services such as sensors and phone resources by means of visual abstractions. For instance, the tool presented in [46] shows various types of sensors (such as motion and presence sensors) as visual blocks. End users can define logic that is related to the the states of such sensors. As a simple example, end users may specify a welcoming message upon switching on a certain light. \n\n23.3% (7) of the tools are intended to be used in an educational setting. Some of these tools such as [38] and [39] are utilized for teaching basic programming principles such as loops and conditionals, whereas the tool in [44] aims at teaching data science concepts to non-programmers, and the tool in [45] is intended for teaching computing and engineering concepts and for programming robots. \n\nApart from one tool [45], all the tools built for educational applications used a block-based approach. The block-based educational tools use similar visual blocks to represent programming constructs such as variable setting, control flow, and conditionals. The tools aimed at teaching a specific topic in computer science such as parallel programming represent related concepts (e.g. parallel blocks, message passing, events) visually. For instance, the concept of events is represented by a ''When'' visual block in [37] and [49]. \n\nThe tool explained in [45] uses a diagram-based approach to programming education. For instance, a while loop is represented by a sequence of connected boxes. Each box represents a command, e.g. setting a variable.",
            "reference_string": "[231725028 | Kuhail et al. | 2021 | Citations: 39]"
        },
        {
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "venue": "arXiv.org",
            "year": 2018,
            "reference_count": 105,
            "citation_count": 14,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1811.04159, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "145745979",
                    "name": "Jo\u00e3o Pedro Dias"
                },
                {
                    "authorId": "144027277",
                    "name": "H. Ferreira"
                }
            ],
            "abstract": "Software has a longstanding association with a state of crisis considering its success rate. The explosion of Internet-connected devices, Internet-of-Things, adds to the complexity of software systems. The particular characteristics of these systems, such as being large-scale and its heterogeneity, pose increasingly new challenges. In this paper, we first briefly introduce the IoT paradigm and the current state of art of software development. Then, we delve into the particularities of developing software for IoT systems and systems of systems, given an overview of what are the current methodologies and tools for design, develop and test such systems. The findings are discussed, revealing open issues and research directions, and reveal that the nowadays IoT software development practices are still lagging behind of what are the current best practices.",
            "corpus_id": 53282492,
            "sentences": [
                {
                    "corpus_id": "53282492",
                    "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                    "text": "As such, nowadays, the five categories more used to characterize VPLs are the following: \n\n\u2022 Purely Visual Languages: Languages that totally rely on visual techniques throughout the programming process and the program is compiled directly from its visual representation. In this case, the language is never translated into an interim text-based language. \n\n\u2022 Hybrid Systems (Textual/Visual): Languages that can be either created visually and then translated into an underlying high-level textual language or involve the use of graphical elements in an otherwise textual language. \n\n\u2022 Programming-by-Example systems: In these systems, the paradigm of programming-by-demonstration is followed and the user is allowed to create and manipulate visual objects in order to teach the system how to perform tasks. \n\n\u2022 Constraint-oriented Systems: Languages that are designed to act in a constraint scenario or environments, such as simulation design or graphical user interfaces development. \n\n\u2022 Form-based systems: Languages that take advantage of any spreadsheet metaphor. \n\nIt is important to note that these categories are by no means mutually exclusive. Indeed, many languages can be placed in more than one category. \n\nCharacterizing IoT VPLs and their Development Environments. A typical development lifecycle for the IoT is similar to the development of any other system, plus some particularities inherent to the IoT ecosystem. However, since IoT is still in its early stages of development, its development mechanisms and tools are still lagging behind on the best practices and lessons learned from the Software Engineering community in the past decades. Such earliness of development is noticed in the lack of Integrated Development Environments with proper mechanisms of debugging and testing [Dias et al. 2018]. \n\nIn spite of the novelty of the IoT, several Visual Programming Languages appeared (altogether with their supporting tools and development environments). And, similarly to any other programming language, there is an array of aspects that have impact when it comes to picking the Visual Programming system to use, beyond the language itself, but the features it provides and others aspects such as the openness, extensibility, community support, thus, we see that the traditional characterization approaches do not cover all the details of these systems. \n\nIn the following paragraphs we propose a set of guidelines for characterizing these languages and their development environments, enumerating the aspects that must be taken into account.",
                    "score": 0.3398914003638871,
                    "section_title": "Control-flow.",
                    "char_start_offset": 54856,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 88
                        },
                        {
                            "start": 91,
                            "end": 270
                        },
                        {
                            "start": 271,
                            "end": 354
                        },
                        {
                            "start": 357,
                            "end": 579
                        },
                        {
                            "start": 582,
                            "end": 805
                        },
                        {
                            "start": 808,
                            "end": 983
                        },
                        {
                            "start": 986,
                            "end": 1066
                        },
                        {
                            "start": 1069,
                            "end": 1150
                        },
                        {
                            "start": 1151,
                            "end": 1214
                        },
                        {
                            "start": 1217,
                            "end": 1276
                        },
                        {
                            "start": 1277,
                            "end": 1428
                        },
                        {
                            "start": 1429,
                            "end": 1657
                        },
                        {
                            "start": 1658,
                            "end": 1817
                        },
                        {
                            "start": 1820,
                            "end": 1972
                        },
                        {
                            "start": 1973,
                            "end": 2372
                        },
                        {
                            "start": 2375,
                            "end": 2561
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 1798,
                            "end": 1816,
                            "matchedPaperCorpusId": "49895548"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.98974609375
                },
                {
                    "corpus_id": "53282492",
                    "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                    "text": "Brunett et al. [Burnett and Baker 1994] were one of the first to define a list of eleven main paradigms present in VPL that include the traditional paradigms in programming but also others. Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).",
                    "score": 0.31069681289542206,
                    "section_title": "Visual Metaphors.",
                    "char_start_offset": 48894,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 189
                        },
                        {
                            "start": 190,
                            "end": 515
                        },
                        {
                            "start": 516,
                            "end": 552
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 15,
                            "end": 39,
                            "matchedPaperCorpusId": "1426814"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9140625
                },
                {
                    "corpus_id": "53282492",
                    "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                    "text": "We can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\nManuscript submitted to ACM \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms.",
                    "score": 0.3855168034465497,
                    "section_title": "Paradigms.",
                    "char_start_offset": 49461,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 168
                        },
                        {
                            "start": 171,
                            "end": 198
                        },
                        {
                            "start": 201,
                            "end": 272
                        },
                        {
                            "start": 273,
                            "end": 458
                        },
                        {
                            "start": 461,
                            "end": 591
                        },
                        {
                            "start": 592,
                            "end": 706
                        },
                        {
                            "start": 709,
                            "end": 879
                        },
                        {
                            "start": 880,
                            "end": 942
                        },
                        {
                            "start": 945,
                            "end": 1144
                        },
                        {
                            "start": 1145,
                            "end": 1290
                        },
                        {
                            "start": 1293,
                            "end": 1387
                        },
                        {
                            "start": 1388,
                            "end": 1481
                        },
                        {
                            "start": 1482,
                            "end": 1605
                        },
                        {
                            "start": 1606,
                            "end": 1719
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 114,
                            "end": 138,
                            "matchedPaperCorpusId": "1426814"
                        },
                        {
                            "start": 156,
                            "end": 167,
                            "matchedPaperCorpusId": "48762803"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9013671875
                }
            ],
            "relevance_judgement": 0.98974609375,
            "relevance_judgment_input_expanded": "# Title: State of the Software Development Life-Cycle for the Internet-of-Things\n# Venue: arXiv.org\n# Authors: Jo\u00e3o Pedro Dias, H. Ferreira\n## Abstract\nSoftware has a longstanding association with a state of crisis considering its success rate. The explosion of Internet-connected devices, Internet-of-Things, adds to the complexity of software systems. The particular characteristics of these systems, such as being large-scale and its heterogeneity, pose increasingly new challenges. In this paper, we first briefly introduce the IoT paradigm and the current state of art of software development. Then, we delve into the particularities of developing software for IoT systems and systems of systems, given an overview of what are the current methodologies and tools for design, develop and test such systems. The findings are discussed, revealing open issues and research directions, and reveal that the nowadays IoT software development practices are still lagging behind of what are the current best practices.\n## Visual Metaphors.\nBrunett et al. [Burnett and Baker 1994] were one of the first to define a list of eleven main paradigms present in VPL that include the traditional paradigms in programming but also others. Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\n## Paradigms.\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\nManuscript submitted to ACM \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms.\n\n## Control-flow.\nAs such, nowadays, the five categories more used to characterize VPLs are the following: \n\n\u2022 Purely Visual Languages: Languages that totally rely on visual techniques throughout the programming process and the program is compiled directly from its visual representation. In this case, the language is never translated into an interim text-based language. \n\n\u2022 Hybrid Systems (Textual/Visual): Languages that can be either created visually and then translated into an underlying high-level textual language or involve the use of graphical elements in an otherwise textual language. \n\n\u2022 Programming-by-Example systems: In these systems, the paradigm of programming-by-demonstration is followed and the user is allowed to create and manipulate visual objects in order to teach the system how to perform tasks. \n\n\u2022 Constraint-oriented Systems: Languages that are designed to act in a constraint scenario or environments, such as simulation design or graphical user interfaces development. \n\n\u2022 Form-based systems: Languages that take advantage of any spreadsheet metaphor. \n\nIt is important to note that these categories are by no means mutually exclusive. Indeed, many languages can be placed in more than one category. \n\nCharacterizing IoT VPLs and their Development Environments. A typical development lifecycle for the IoT is similar to the development of any other system, plus some particularities inherent to the IoT ecosystem. However, since IoT is still in its early stages of development, its development mechanisms and tools are still lagging behind on the best practices and lessons learned from the Software Engineering community in the past decades. Such earliness of development is noticed in the lack of Integrated Development Environments with proper mechanisms of debugging and testing [Dias et al. 2018]. \n\nIn spite of the novelty of the IoT, several Visual Programming Languages appeared (altogether with their supporting tools and development environments). And, similarly to any other programming language, there is an array of aspects that have impact when it comes to picking the Visual Programming system to use, beyond the language itself, but the features it provides and others aspects such as the openness, extensibility, community support, thus, we see that the traditional characterization approaches do not cover all the details of these systems. \n\nIn the following paragraphs we propose a set of guidelines for characterizing these languages and their development environments, enumerating the aspects that must be taken into account.",
            "reference_string": "[53282492 | Dias et al. | 2018 | Citations: 14]"
        },
        {
            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
            "venue": "arXiv.org",
            "year": 2019,
            "reference_count": 32,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1909.05719, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3419237",
                    "name": "Paul Zikas"
                },
                {
                    "authorId": "1388001839",
                    "name": "Nick Lydatakis"
                },
                {
                    "authorId": "19309698",
                    "name": "Steve Kateros"
                },
                {
                    "authorId": "2896538",
                    "name": "G. Papagiannakis"
                }
            ],
            "abstract": "Virtual reality (VR) has re-emerged as a low-cost, highly accessible consumer product, and training on simulators is rapidly becoming standard in many industrial sectors. Combined with the continued advancements in VR technology, the interest in platforms that generate immersive experiences has increased. However, the available systems are either focusing on gaming context, featuring limited capabilities (embedded editors in game engines) or they support only content creation of virtual environments without any rapid prototyping and modification. In this project we propose Scenior, an innovative coding-free, visual scripting platform to replicate gamified training scenarios through Rapid Prototyping via newly defined VR software design patterns. We implemented and compared three authoring tools: a) Prototyped scripting, b) Visual Scripting and c) VR Editor for rapid reconstruction of VR training scenarios. Our Visual Scripting module is capable generating training applications utilizing a node-based scripting system whereas the VR Editor gives the user/developer the ability to customize and populate new VR training scenarios directly from within the virtual environment. We also introduce Action Prototypes, a new software design pattern suitable to replicate behavioural tasks for VR experiences. In a addition, we present the scenegraph architecture as the main model to represent training scenarios on a modular, dynamic and highly adaptive acyclic graph based on a structured educational curriculum.",
            "corpus_id": 202566030,
            "sentences": [
                {
                    "corpus_id": "202566030",
                    "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
                    "text": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
                    "score": 0.5404214175905946,
                    "section_title": "Visual Programming as an authoring tool",
                    "char_start_offset": 7334,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 111
                        },
                        {
                            "start": 112,
                            "end": 476
                        },
                        {
                            "start": 477,
                            "end": 649
                        },
                        {
                            "start": 650,
                            "end": 932
                        },
                        {
                            "start": 933,
                            "end": 1110
                        },
                        {
                            "start": 1111,
                            "end": 1240
                        },
                        {
                            "start": 1241,
                            "end": 1489
                        },
                        {
                            "start": 1492,
                            "end": 1642
                        },
                        {
                            "start": 1643,
                            "end": 1773
                        },
                        {
                            "start": 1774,
                            "end": 1930
                        },
                        {
                            "start": 1931,
                            "end": 2110
                        },
                        {
                            "start": 2111,
                            "end": 2297
                        },
                        {
                            "start": 2298,
                            "end": 2387
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 699,
                            "end": 703,
                            "matchedPaperCorpusId": "2701916"
                        },
                        {
                            "start": 971,
                            "end": 975,
                            "matchedPaperCorpusId": "54120970"
                        },
                        {
                            "start": 1294,
                            "end": 1298,
                            "matchedPaperCorpusId": "9744698"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9775390625
                }
            ],
            "relevance_judgement": 0.9775390625,
            "relevance_judgment_input_expanded": "# Title: Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns\n# Venue: arXiv.org\n# Authors: Paul Zikas, Nick Lydatakis, Steve Kateros, G. Papagiannakis\n## Abstract\nVirtual reality (VR) has re-emerged as a low-cost, highly accessible consumer product, and training on simulators is rapidly becoming standard in many industrial sectors. Combined with the continued advancements in VR technology, the interest in platforms that generate immersive experiences has increased. However, the available systems are either focusing on gaming context, featuring limited capabilities (embedded editors in game engines) or they support only content creation of virtual environments without any rapid prototyping and modification. In this project we propose Scenior, an innovative coding-free, visual scripting platform to replicate gamified training scenarios through Rapid Prototyping via newly defined VR software design patterns. We implemented and compared three authoring tools: a) Prototyped scripting, b) Visual Scripting and c) VR Editor for rapid reconstruction of VR training scenarios. Our Visual Scripting module is capable generating training applications utilizing a node-based scripting system whereas the VR Editor gives the user/developer the ability to customize and populate new VR training scenarios directly from within the virtual environment. We also introduce Action Prototypes, a new software design pattern suitable to replicate behavioural tasks for VR experiences. In a addition, we present the scenegraph architecture as the main model to represent training scenarios on a modular, dynamic and highly adaptive acyclic graph based on a structured educational curriculum.\n## Visual Programming as an authoring tool\nVisual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
            "reference_string": "[202566030 | Zikas et al. | 2019 | Citations: 1]"
        },
        {
            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
            "venue": "Universal Access in the Information Society",
            "year": 2022,
            "reference_count": 46,
            "citation_count": 3,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://link.springer.com/content/pdf/10.1007/s10209-022-00934-3.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://pmc.ncbi.nlm.nih.gov/articles/PMC9583062, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1411449483",
                    "name": "Rub\u00e9n Baena-P\u00e9rez"
                },
                {
                    "authorId": "1409150721",
                    "name": "Iv\u00e1n Ruiz-Rube"
                },
                {
                    "authorId": "32483651",
                    "name": "Jos\u00e9 Miguel Mota"
                },
                {
                    "authorId": "49031811",
                    "name": "Anke Berns"
                },
                {
                    "authorId": "144050001",
                    "name": "Antonio Balderas"
                }
            ],
            "abstract": "The COVID-19 pandemic has led to face-to-face activities being developed in a virtual format that often offers a poor experience in areas such as education. Virtual Learning Environments have improved in recent years thanks to new technologies such as Virtual Reality or Chatbots. However, creating Virtual Learning Environments requires advanced programming knowledge, so this work is aimed to enable teachers to create these new environments easily. This work presents a set of extensions for App Inventor that facilitate the authoring of mobile learning apps that use Chatbots in a Virtual Reality environment, while simultaneously monitoring of student activity. This proposal is based on integrating block-based languages and Business Process Model and Notation diagrams. The developed extensions were successfully implemented in an educational app called Let\u2019s date!. A quantitative analysis of the use of these extensions in App Inventor was also carried out, resulting in a significant reduction in the number of blocks required. The proposed contribution has demonstrated its validity in creating virtual learning environments through visual programming and modelling, reducing development complexity.",
            "corpus_id": 253043422,
            "sentences": [
                {
                    "corpus_id": "253043422",
                    "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
                    "text": "The development of software solutions involves a considerable effort for those users who are not experts, limiting access to the use of the latest technological innovations. To solve this problem, in recent years, EUD has recently experienced a renewed interest, providing the necessary tools for non-expert users to develop their software solutions through adapted languages [11]. \n\nProgramming with VPLs does not require knowledge of textual programming syntax and provides a more visually stimulating environment, having a direct impact on user motivation [13]. Such languages are commonly used in educational settings for promoting students' development of computational thinking [14]. The suitability of block-based environments for novice programmers has already been demonstrated in different studies. Broll et al. [15] propose a web development environment based on Snap! that adds distributed programming capabilities. Kyfonidis et al. [16] present a block-based programming environment focused on learning the C language. Finally, Rao et al. [17] propose a visual programming environment for education in data science. \n\nVPLs can be classified into two categories: imperative languages and flow-based languages [18]. With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others [19].",
                    "score": 0.4140161618448794,
                    "section_title": "Visual programming languages",
                    "char_start_offset": 5567,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 173
                        },
                        {
                            "start": 174,
                            "end": 381
                        },
                        {
                            "start": 384,
                            "end": 564
                        },
                        {
                            "start": 565,
                            "end": 689
                        },
                        {
                            "start": 690,
                            "end": 808
                        },
                        {
                            "start": 809,
                            "end": 927
                        },
                        {
                            "start": 928,
                            "end": 1031
                        },
                        {
                            "start": 1032,
                            "end": 1128
                        },
                        {
                            "start": 1131,
                            "end": 1226
                        },
                        {
                            "start": 1227,
                            "end": 1365
                        },
                        {
                            "start": 1366,
                            "end": 1432
                        },
                        {
                            "start": 1433,
                            "end": 1516
                        },
                        {
                            "start": 1517,
                            "end": 1682
                        },
                        {
                            "start": 1683,
                            "end": 1871
                        },
                        {
                            "start": 1872,
                            "end": 1992
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 376,
                            "end": 380,
                            "matchedPaperCorpusId": "67770007"
                        },
                        {
                            "start": 559,
                            "end": 563,
                            "matchedPaperCorpusId": "219455753"
                        },
                        {
                            "start": 684,
                            "end": 688,
                            "matchedPaperCorpusId": "202252904"
                        },
                        {
                            "start": 822,
                            "end": 826,
                            "matchedPaperCorpusId": "44165140"
                        },
                        {
                            "start": 945,
                            "end": 949,
                            "matchedPaperCorpusId": "35843064"
                        },
                        {
                            "start": 1052,
                            "end": 1056,
                            "matchedPaperCorpusId": "53080670"
                        },
                        {
                            "start": 1221,
                            "end": 1225,
                            "matchedPaperCorpusId": "20439639"
                        },
                        {
                            "start": 1987,
                            "end": 1991,
                            "matchedPaperCorpusId": "6927128"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.958984375
                }
            ],
            "relevance_judgement": 0.958984375,
            "relevance_judgment_input_expanded": "# Title: Visual authoring of virtual reality conversational scenarios for e-learning\n# Venue: Universal Access in the Information Society\n# Authors: Rub\u00e9n Baena-P\u00e9rez, Iv\u00e1n Ruiz-Rube, Jos\u00e9 Miguel Mota, Anke Berns, Antonio Balderas\n## Abstract\nThe COVID-19 pandemic has led to face-to-face activities being developed in a virtual format that often offers a poor experience in areas such as education. Virtual Learning Environments have improved in recent years thanks to new technologies such as Virtual Reality or Chatbots. However, creating Virtual Learning Environments requires advanced programming knowledge, so this work is aimed to enable teachers to create these new environments easily. This work presents a set of extensions for App Inventor that facilitate the authoring of mobile learning apps that use Chatbots in a Virtual Reality environment, while simultaneously monitoring of student activity. This proposal is based on integrating block-based languages and Business Process Model and Notation diagrams. The developed extensions were successfully implemented in an educational app called Let\u2019s date!. A quantitative analysis of the use of these extensions in App Inventor was also carried out, resulting in a significant reduction in the number of blocks required. The proposed contribution has demonstrated its validity in creating virtual learning environments through visual programming and modelling, reducing development complexity.\n## Visual programming languages\nThe development of software solutions involves a considerable effort for those users who are not experts, limiting access to the use of the latest technological innovations. To solve this problem, in recent years, EUD has recently experienced a renewed interest, providing the necessary tools for non-expert users to develop their software solutions through adapted languages [11]. \n\nProgramming with VPLs does not require knowledge of textual programming syntax and provides a more visually stimulating environment, having a direct impact on user motivation [13]. Such languages are commonly used in educational settings for promoting students' development of computational thinking [14]. The suitability of block-based environments for novice programmers has already been demonstrated in different studies. Broll et al. [15] propose a web development environment based on Snap! that adds distributed programming capabilities. Kyfonidis et al. [16] present a block-based programming environment focused on learning the C language. Finally, Rao et al. [17] propose a visual programming environment for education in data science. \n\nVPLs can be classified into two categories: imperative languages and flow-based languages [18]. With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others [19].",
            "reference_string": "[253043422 | Baena-Perez et al. | 2022 | Citations: 3]"
        },
        {
            "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
            "venue": "International Conference on Human Factors in Computing Systems",
            "year": 2023,
            "reference_count": 51,
            "citation_count": 18,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3613904.3641920",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2310.08574, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2106412318",
                    "name": "David Chuan-En Lin"
                },
                {
                    "authorId": "3111790",
                    "name": "Nikolas Martelaro"
                }
            ],
            "abstract": "Recent advancements in AI foundation models have made it possible for them to be utilized off-the-shelf for creative tasks, including ideating design concepts or generating visual prototypes. However, integrating these models into the creative process can be challenging as they often exist as standalone applications tailored to specific tasks. To address this challenge, we introduce Jigsaw, a prototype system that employs puzzle pieces as metaphors to represent foundation models. Jigsaw allows designers to combine different foundation model capabilities across various modalities by assembling compatible puzzle pieces. To inform the design of Jigsaw, we interviewed ten designers and distilled design goals. In a user study, we showed that Jigsaw enhanced designers\u2019 understanding of available foundation model capabilities, provided guidance on combining capabilities across different modalities and tasks, and served as a canvas to support design exploration, prototyping, and documentation.",
            "corpus_id": 269747039,
            "sentences": [
                {
                    "corpus_id": "269747039",
                    "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
                    "text": "Visual programming interfaces (VPIs) have been extensively studied as tools to aid users in designing and implementing systems through graphical elements rather than text-based code [31].A key benefit of VPIs is their lower entry barrier for novice programmers [45].There are primarily two main paradigms for VPIs.The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph.Pioneering work in this area includes Prograph [17] and LabVIEW [27].The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together.Notable works in this area include Scratch [35] and Blockly [19].Many commercial creative applications have adopted VPIs, including game engines such as Unity [11], CAD tools such as Grasshopper [9], and multimedia development tools such as Max/MSP [12].\n\nVPI concepts have been applied to machine learning applications.For example, Teachable Machine [15] uses a visual interface to help students learn to train a machine learning model.ML Blocks [46] assists developers in training, evaluating, and exporting machine learning model architectures.Very recently, researchers in both academia and industry have worked on VPIs that support the creation of AI workflows through the combination of pre-trained models.Several works have investigated node-based interfaces for building Large Language Model (LLM) pipelines, including PromptChainer [48], FlowiseAI [2], and Langflow [3].Most closely related to our work are Rapsai by Du et al. [18] and ComfyUI [1].Both tools provide a node-based interface for machine learning researchers and enthusiasts to build multimedia machine learning pipelines.These tools are catered more toward users with at least some background knowledge in AI programming, giving users the flexibility to customize the tools through programming at the expense of exposing more technical elements to the user.\n\nOur work builds upon prior and concurrent VPI tools and research.However, we made several design choices for our tool to help better support non-technical designers (Table 1).First, our tool leverages a block-based VPI paradigm, which has been shown to be effective in supporting novice programming learners [35].",
                    "score": 0.38701659705408087,
                    "section_title": "Visual Programming Interfaces",
                    "char_start_offset": 6517,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 187
                        },
                        {
                            "start": 187,
                            "end": 266
                        },
                        {
                            "start": 266,
                            "end": 314
                        },
                        {
                            "start": 314,
                            "end": 455
                        },
                        {
                            "start": 455,
                            "end": 524
                        },
                        {
                            "start": 524,
                            "end": 666
                        },
                        {
                            "start": 666,
                            "end": 731
                        },
                        {
                            "start": 731,
                            "end": 920
                        },
                        {
                            "start": 922,
                            "end": 986
                        },
                        {
                            "start": 986,
                            "end": 1103
                        },
                        {
                            "start": 1103,
                            "end": 1213
                        },
                        {
                            "start": 1213,
                            "end": 1378
                        },
                        {
                            "start": 1378,
                            "end": 1545
                        },
                        {
                            "start": 1545,
                            "end": 1623
                        },
                        {
                            "start": 1623,
                            "end": 1761
                        },
                        {
                            "start": 1761,
                            "end": 1997
                        },
                        {
                            "start": 1999,
                            "end": 2064
                        },
                        {
                            "start": 2064,
                            "end": 2174
                        },
                        {
                            "start": 2174,
                            "end": 2312
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 182,
                            "end": 186,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 261,
                            "end": 265,
                            "matchedPaperCorpusId": "18983760"
                        },
                        {
                            "start": 502,
                            "end": 506,
                            "matchedPaperCorpusId": "9693598"
                        },
                        {
                            "start": 1017,
                            "end": 1021,
                            "matchedPaperCorpusId": "218482766"
                        },
                        {
                            "start": 1113,
                            "end": 1117,
                            "matchedPaperCorpusId": "251662411"
                        },
                        {
                            "start": 1507,
                            "end": 1511,
                            "matchedPaperCorpusId": "247447133"
                        },
                        {
                            "start": 1602,
                            "end": 1606,
                            "matchedPaperCorpusId": "258216977"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.95263671875
                }
            ],
            "relevance_judgement": 0.95263671875,
            "relevance_judgment_input_expanded": "# Title: Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models\n# Venue: International Conference on Human Factors in Computing Systems\n# Authors: David Chuan-En Lin, Nikolas Martelaro\n## Abstract\nRecent advancements in AI foundation models have made it possible for them to be utilized off-the-shelf for creative tasks, including ideating design concepts or generating visual prototypes. However, integrating these models into the creative process can be challenging as they often exist as standalone applications tailored to specific tasks. To address this challenge, we introduce Jigsaw, a prototype system that employs puzzle pieces as metaphors to represent foundation models. Jigsaw allows designers to combine different foundation model capabilities across various modalities by assembling compatible puzzle pieces. To inform the design of Jigsaw, we interviewed ten designers and distilled design goals. In a user study, we showed that Jigsaw enhanced designers\u2019 understanding of available foundation model capabilities, provided guidance on combining capabilities across different modalities and tasks, and served as a canvas to support design exploration, prototyping, and documentation.\n## Visual Programming Interfaces\nVisual programming interfaces (VPIs) have been extensively studied as tools to aid users in designing and implementing systems through graphical elements rather than text-based code [31].A key benefit of VPIs is their lower entry barrier for novice programmers [45].There are primarily two main paradigms for VPIs.The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph.Pioneering work in this area includes Prograph [17] and LabVIEW [27].The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together.Notable works in this area include Scratch [35] and Blockly [19].Many commercial creative applications have adopted VPIs, including game engines such as Unity [11], CAD tools such as Grasshopper [9], and multimedia development tools such as Max/MSP [12].\n\nVPI concepts have been applied to machine learning applications.For example, Teachable Machine [15] uses a visual interface to help students learn to train a machine learning model.ML Blocks [46] assists developers in training, evaluating, and exporting machine learning model architectures.Very recently, researchers in both academia and industry have worked on VPIs that support the creation of AI workflows through the combination of pre-trained models.Several works have investigated node-based interfaces for building Large Language Model (LLM) pipelines, including PromptChainer [48], FlowiseAI [2], and Langflow [3].Most closely related to our work are Rapsai by Du et al. [18] and ComfyUI [1].Both tools provide a node-based interface for machine learning researchers and enthusiasts to build multimedia machine learning pipelines.These tools are catered more toward users with at least some background knowledge in AI programming, giving users the flexibility to customize the tools through programming at the expense of exposing more technical elements to the user.\n\nOur work builds upon prior and concurrent VPI tools and research.However, we made several design choices for our tool to help better support non-technical designers (Table 1).First, our tool leverages a block-based VPI paradigm, which has been shown to be effective in supporting novice programming learners [35].",
            "reference_string": "[269747039 | Lin et al. | 2023 | Citations: 18]"
        },
        {
            "title": "Positional Control in Node-Based Programming",
            "venue": "CHI Extended Abstracts",
            "year": 2023,
            "reference_count": 48,
            "citation_count": 4,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1145/3544549.3585878",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3544549.3585878?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3544549.3585878, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2061281840",
                    "name": "Peiling Jiang"
                }
            ],
            "abstract": "Visual programming languages enable novices to code with a lowered barrier. These languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires. We propose integrating these two approaches by utilizing positional control in node-based programming to visualize and allow manipulation of both the execution order and data flow. A grid system organizes blocks and determines their sequence. Effect block is introduced, which controls other blocks within its effective range through positional constraints. As relocating blocks is easier than wiring that targets tiny inlets and outlets, we aim to shorten the feedback loop time and encourage exploration. We present b5, a web-based novel visual interface for creative coding, to demonstrate and evaluate this design.",
            "corpus_id": 258217657,
            "sentences": [],
            "relevance_judgement": 0.94921875,
            "relevance_judgment_input_expanded": "# Title: Positional Control in Node-Based Programming\n# Venue: CHI Extended Abstracts\n# Authors: Peiling Jiang\n## Abstract\nVisual programming languages enable novices to code with a lowered barrier. These languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires. We propose integrating these two approaches by utilizing positional control in node-based programming to visualize and allow manipulation of both the execution order and data flow. A grid system organizes blocks and determines their sequence. Effect block is introduced, which controls other blocks within its effective range through positional constraints. As relocating blocks is easier than wiring that targets tiny inlets and outlets, we aim to shorten the feedback loop time and encourage exploration. We present b5, a web-based novel visual interface for creative coding, to demonstrate and evaluate this design.\n",
            "reference_string": "[258217657 | Jiang | 2023 | Citations: 4]"
        },
        {
            "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
            "venue": "Journal of Systems and Software",
            "year": 2022,
            "reference_count": 46,
            "citation_count": 3,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1016/j.jss.2022.111547",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1016/j.jss.2022.111547?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1016/j.jss.2022.111547, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1412106655",
                    "name": "Christoph Mayr-Dorn"
                },
                {
                    "authorId": "39590163",
                    "name": "M. Winterer"
                },
                {
                    "authorId": "153704508",
                    "name": "Christian Salomon"
                },
                {
                    "authorId": "2120343508",
                    "name": "Doris Hohensinger"
                },
                {
                    "authorId": "1730456",
                    "name": "Harald F\u00fcrschu\u00df"
                }
            ],
            "abstract": null,
            "corpus_id": 253049931,
            "sentences": [
                {
                    "corpus_id": "253049931",
                    "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
                    "text": "A block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled. \n\nModern block-based programming editors offer support for drag-and-drop of blocks and for snapping matching blocks together. Individual blocks can be picked from a palette and inserted into a program by dropping them on another block where it will snap in place if the dents/nobs of the blocks match. This feature helps to intuitively explain coding concepts and to facilitate access to programming for novice users. According to Bau et al. (2017), block-based programming languages are advantageous over conventional textual languages with respect to learnability due to the following reasons: \n\n\u2022 Programming languages usually require learning the programming vocabulary. However, blocks rely on recognition -not on recall, since blocks can be picked from palettes and need not be remembered. Additionally, the listing of all block types helps the user to become familiar with language elements and to maintain an overview of system components. \n\n\u2022 Programming causes a high cognitive load, in particular for new users. This is reduced because block-based programs typically are structured into smaller and easily recognizable pieces. \n\n\u2022 In contrast to conventional programming approaches, syntax errors can be avoided in block-based programming. The related environment prevents the user from connecting mismatching blocks when assembling elements to programs. \n\nOne example block-based language environment is Blockly. Specifically, it is an open-source JavaScript library for building block-based programming editors for the web, mainly developed by Google. 1 Blockly defines the general graphical syntax and provides some basic language blocks out of the box.",
                    "score": 0.3721991141151649,
                    "section_title": "Block-based programming languages",
                    "char_start_offset": 3116,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 76
                        },
                        {
                            "start": 77,
                            "end": 253
                        },
                        {
                            "start": 254,
                            "end": 378
                        },
                        {
                            "start": 379,
                            "end": 511
                        },
                        {
                            "start": 512,
                            "end": 737
                        },
                        {
                            "start": 738,
                            "end": 884
                        },
                        {
                            "start": 887,
                            "end": 1010
                        },
                        {
                            "start": 1011,
                            "end": 1186
                        },
                        {
                            "start": 1187,
                            "end": 1302
                        },
                        {
                            "start": 1303,
                            "end": 1480
                        },
                        {
                            "start": 1483,
                            "end": 1559
                        },
                        {
                            "start": 1560,
                            "end": 1680
                        },
                        {
                            "start": 1681,
                            "end": 1832
                        },
                        {
                            "start": 1835,
                            "end": 1907
                        },
                        {
                            "start": 1908,
                            "end": 2022
                        },
                        {
                            "start": 2025,
                            "end": 2135
                        },
                        {
                            "start": 2136,
                            "end": 2250
                        },
                        {
                            "start": 2253,
                            "end": 2309
                        },
                        {
                            "start": 2310,
                            "end": 2552
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94677734375
                }
            ],
            "relevance_judgement": 0.94677734375,
            "relevance_judgment_input_expanded": "# Title: Assessing industrial end-user programming of robotic production cells: A controlled experiment\n# Venue: Journal of Systems and Software\n# Authors: Christoph Mayr-Dorn, M. Winterer, Christian Salomon, Doris Hohensinger, Harald F\u00fcrschu\u00df\n## Abstract\nNone\n## Block-based programming languages\nA block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled. \n\nModern block-based programming editors offer support for drag-and-drop of blocks and for snapping matching blocks together. Individual blocks can be picked from a palette and inserted into a program by dropping them on another block where it will snap in place if the dents/nobs of the blocks match. This feature helps to intuitively explain coding concepts and to facilitate access to programming for novice users. According to Bau et al. (2017), block-based programming languages are advantageous over conventional textual languages with respect to learnability due to the following reasons: \n\n\u2022 Programming languages usually require learning the programming vocabulary. However, blocks rely on recognition -not on recall, since blocks can be picked from palettes and need not be remembered. Additionally, the listing of all block types helps the user to become familiar with language elements and to maintain an overview of system components. \n\n\u2022 Programming causes a high cognitive load, in particular for new users. This is reduced because block-based programs typically are structured into smaller and easily recognizable pieces. \n\n\u2022 In contrast to conventional programming approaches, syntax errors can be avoided in block-based programming. The related environment prevents the user from connecting mismatching blocks when assembling elements to programs. \n\nOne example block-based language environment is Blockly. Specifically, it is an open-source JavaScript library for building block-based programming editors for the web, mainly developed by Google. 1 Blockly defines the general graphical syntax and provides some basic language blocks out of the box.",
            "reference_string": "[253049931 | Mayr-Dorn et al. | 2022 | Citations: 3]"
        },
        {
            "title": "Collaborative Coding in a Robotic Visual Language",
            "venue": "International Conference on Computer Supported Education",
            "year": 2021,
            "reference_count": 14,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5220/0010455501510156",
                "status": "HYBRID",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5220/0010455501510156?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5220/0010455501510156, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2106215024",
                    "name": "Farah Yasser Dawoud"
                },
                {
                    "authorId": "143859112",
                    "name": "A. Adel"
                },
                {
                    "authorId": "2730794",
                    "name": "Nada Sharaf"
                }
            ],
            "abstract": ": This paper presents a platform, that is a block-based visual programming environment. Students can collab-oratively interact using a \ufb02exible and versatile de\ufb01nition of visual programming code and interface created using Google Blockly, JavaScript, and Firebase. The web application is designed to allow students to program the Lego Mindstorms EV3. An experiment was conducted to investigate the effect of real-time collaboration on students working on the block-based visual programming web application.",
            "corpus_id": 235234208,
            "sentences": [
                {
                    "corpus_id": "235234208",
                    "title": "Collaborative Coding in a Robotic Visual Language",
                    "text": "Visual Programming reduces the need to write lond textual programs. Program thus have multiple dimensions not only the text (Burnett and McIntyre, 1995). The idea is that with visual constructs, it could have a better learning curve and be more appealing. \n\nFor example, with a robotic visual programming language, users can program the robot without writing a textual code and without significant knowledge of any programming language. Examples include Make Block1 and Open Roberta2 for programming different hardware systems using blocks. \n\nVisual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990).",
                    "score": 0.31815208617474316,
                    "section_title": "VISUAL PROGRAMMING",
                    "char_start_offset": 2075,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 67
                        },
                        {
                            "start": 68,
                            "end": 153
                        },
                        {
                            "start": 154,
                            "end": 255
                        },
                        {
                            "start": 258,
                            "end": 436
                        },
                        {
                            "start": 437,
                            "end": 540
                        },
                        {
                            "start": 543,
                            "end": 682
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 124,
                            "end": 152,
                            "matchedPaperCorpusId": "14994189"
                        },
                        {
                            "start": 668,
                            "end": 681,
                            "matchedPaperCorpusId": "7335020"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94482421875
                },
                {
                    "corpus_id": "235234208",
                    "title": "Collaborative Coding in a Robotic Visual Language",
                    "text": "Block-based languages are a class of visual programming languages where the code constrcuts are blocks that should be connected to each other. \n\nIn this case, the programmer has to drag the needed blocks and drop them in the editor and connect them together shown in Figure 1. Blocks usually contain visual hints that eliminate the possibility of having wrong connections or programs.",
                    "score": 0.4439982908604859,
                    "section_title": "Block-based Programming",
                    "char_start_offset": 2785,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 142
                        },
                        {
                            "start": 145,
                            "end": 276
                        },
                        {
                            "start": 277,
                            "end": 384
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9404296875
                }
            ],
            "relevance_judgement": 0.94482421875,
            "relevance_judgment_input_expanded": "# Title: Collaborative Coding in a Robotic Visual Language\n# Venue: International Conference on Computer Supported Education\n# Authors: Farah Yasser Dawoud, A. Adel, Nada Sharaf\n## Abstract\n: This paper presents a platform, that is a block-based visual programming environment. Students can collab-oratively interact using a \ufb02exible and versatile de\ufb01nition of visual programming code and interface created using Google Blockly, JavaScript, and Firebase. The web application is designed to allow students to program the Lego Mindstorms EV3. An experiment was conducted to investigate the effect of real-time collaboration on students working on the block-based visual programming web application.\n## VISUAL PROGRAMMING\nVisual Programming reduces the need to write lond textual programs. Program thus have multiple dimensions not only the text (Burnett and McIntyre, 1995). The idea is that with visual constructs, it could have a better learning curve and be more appealing. \n\nFor example, with a robotic visual programming language, users can program the robot without writing a textual code and without significant knowledge of any programming language. Examples include Make Block1 and Open Roberta2 for programming different hardware systems using blocks. \n\nVisual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990).\n\n## Block-based Programming\nBlock-based languages are a class of visual programming languages where the code constrcuts are blocks that should be connected to each other. \n\nIn this case, the programmer has to drag the needed blocks and drop them in the editor and connect them together shown in Figure 1. Blocks usually contain visual hints that eliminate the possibility of having wrong connections or programs.",
            "reference_string": "[235234208 | Dawoud et al. | 2021 | Citations: 1]"
        },
        {
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "venue": "Education sciences",
            "year": 2019,
            "reference_count": 50,
            "citation_count": 23,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.mdpi.com/2227-7102/9/3/181/pdf?version=1563177761",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3390/EDUCSCI9030181?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3390/EDUCSCI9030181, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2157028104",
                    "name": "Piedade Jo\u00e3o"
                },
                {
                    "authorId": "72582337",
                    "name": "Dorotea Nuno"
                },
                {
                    "authorId": "2157024771",
                    "name": "Sampaio Ferrentini F\u00e1bio"
                },
                {
                    "authorId": "144370033",
                    "name": "P. ana"
                }
            ],
            "abstract": "In the last few years, it has been pointed out that teaching programming is a strong strategy to develop pupils\u2019 competences in computational thinking (CT). In the Portuguese context, the curriculum changes in 2018 made programming and CT compulsory for every pupil in primary and secondary education. Nowadays, there is an information and communication technology (ICT) subject, taught by a computer science teacher in each school grade. In Portugal, to become a computer science teacher in primary and secondary education, it is compulsory to have a master\u2019s degree in computer science education. This article reports on a pedagogical activity developed with student-teachers of a Master in Teaching Informatics at the University of Lisbon. Within the activities of the master\u2019s program, we developed a cross-analysis of the core characteristics of 26 block-based and visual programming applications (apps) used to teach computational thinking and programming in school classes. In order to organize the analysis, a framework with several dimensions was developed and used by student-teachers to register the characteristics of each app. The product of this work is a comparative matrix mapping the core characteristics of each of the 26 apps that student-teachers used to select the most appropriate one for teaching programming and computational thinking according to each grade, age group and other characteristics.",
            "corpus_id": 199002134,
            "sentences": [
                {
                    "corpus_id": "199002134",
                    "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
                    "text": "The visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
                    "score": 0.4746908767174216,
                    "section_title": "Visual and Block-based Programming Environment",
                    "char_start_offset": 12132,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 218
                        },
                        {
                            "start": 219,
                            "end": 398
                        },
                        {
                            "start": 401,
                            "end": 547
                        },
                        {
                            "start": 548,
                            "end": 674
                        },
                        {
                            "start": 675,
                            "end": 679
                        },
                        {
                            "start": 680,
                            "end": 973
                        },
                        {
                            "start": 974,
                            "end": 1205
                        },
                        {
                            "start": 1208,
                            "end": 1409
                        },
                        {
                            "start": 1410,
                            "end": 1624
                        },
                        {
                            "start": 1625,
                            "end": 1871
                        },
                        {
                            "start": 1874,
                            "end": 2034
                        },
                        {
                            "start": 2035,
                            "end": 2150
                        },
                        {
                            "start": 2153,
                            "end": 2335
                        },
                        {
                            "start": 2336,
                            "end": 2430
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 394,
                            "end": 397,
                            "matchedPaperCorpusId": "17459721"
                        },
                        {
                            "start": 416,
                            "end": 420,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1404,
                            "end": 1408,
                            "matchedPaperCorpusId": "59528289"
                        },
                        {
                            "start": 1619,
                            "end": 1623,
                            "matchedPaperCorpusId": "11994747"
                        },
                        {
                            "start": 1866,
                            "end": 1870,
                            "matchedPaperCorpusId": "51750550"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94384765625
                }
            ],
            "relevance_judgement": 0.94384765625,
            "relevance_judgment_input_expanded": "# Title: A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers\n# Venue: Education sciences\n# Authors: Piedade Jo\u00e3o, Dorotea Nuno, Sampaio Ferrentini F\u00e1bio, P. ana\n## Abstract\nIn the last few years, it has been pointed out that teaching programming is a strong strategy to develop pupils\u2019 competences in computational thinking (CT). In the Portuguese context, the curriculum changes in 2018 made programming and CT compulsory for every pupil in primary and secondary education. Nowadays, there is an information and communication technology (ICT) subject, taught by a computer science teacher in each school grade. In Portugal, to become a computer science teacher in primary and secondary education, it is compulsory to have a master\u2019s degree in computer science education. This article reports on a pedagogical activity developed with student-teachers of a Master in Teaching Informatics at the University of Lisbon. Within the activities of the master\u2019s program, we developed a cross-analysis of the core characteristics of 26 block-based and visual programming applications (apps) used to teach computational thinking and programming in school classes. In order to organize the analysis, a framework with several dimensions was developed and used by student-teachers to register the characteristics of each app. The product of this work is a comparative matrix mapping the core characteristics of each of the 26 apps that student-teachers used to select the most appropriate one for teaching programming and computational thinking according to each grade, age group and other characteristics.\n## Visual and Block-based Programming Environment\nThe visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
            "reference_string": "[199002134 | Joao et al. | 2019 | Citations: 23]"
        },
        {
            "title": "Low-Code Programming Models",
            "venue": "Communications of the ACM",
            "year": 2022,
            "reference_count": 46,
            "citation_count": 21,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3587691",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2205.02282, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1728836",
                    "name": "Martin Hirzel"
                }
            ],
            "abstract": "Low-code has the potential to empower more people to automate tasks by creating computer programs.",
            "corpus_id": 248524774,
            "sentences": [
                {
                    "corpus_id": "248524774",
                    "title": "Low-Code Programming Models",
                    "text": "Config. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
                    "score": 0.4141396568232528,
                    "section_title": "Palette Code canvas Stage",
                    "char_start_offset": 13328,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 7
                        },
                        {
                            "start": 8,
                            "end": 25
                        },
                        {
                            "start": 26,
                            "end": 133
                        },
                        {
                            "start": 134,
                            "end": 265
                        },
                        {
                            "start": 266,
                            "end": 412
                        },
                        {
                            "start": 413,
                            "end": 591
                        },
                        {
                            "start": 592,
                            "end": 895
                        },
                        {
                            "start": 896,
                            "end": 1044
                        },
                        {
                            "start": 1045,
                            "end": 1164
                        },
                        {
                            "start": 1165,
                            "end": 1233
                        },
                        {
                            "start": 1234,
                            "end": 1346
                        },
                        {
                            "start": 1347,
                            "end": 1462
                        },
                        {
                            "start": 1465,
                            "end": 1504
                        },
                        {
                            "start": 1505,
                            "end": 1690
                        },
                        {
                            "start": 1691,
                            "end": 1832
                        },
                        {
                            "start": 1833,
                            "end": 1983
                        },
                        {
                            "start": 1986,
                            "end": 2176
                        },
                        {
                            "start": 2177,
                            "end": 2289
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 355,
                            "end": 359,
                            "matchedPaperCorpusId": "2385464"
                        },
                        {
                            "start": 1929,
                            "end": 1933,
                            "matchedPaperCorpusId": "16189588"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9423828125
                }
            ],
            "relevance_judgement": 0.9423828125,
            "relevance_judgment_input_expanded": "# Title: Low-Code Programming Models\n# Venue: Communications of the ACM\n# Authors: Martin Hirzel\n## Abstract\nLow-code has the potential to empower more people to automate tasks by creating computer programs.\n## Palette Code canvas Stage\nConfig. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
            "reference_string": "[248524774 | Hirzel | 2022 | Citations: 21]"
        },
        {
            "title": "A Visual Language for Composable Inductive Programming",
            "venue": "arXiv.org",
            "year": 2020,
            "reference_count": 21,
            "citation_count": 4,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2009.08700, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1420120235",
                    "name": "Edward McDaid"
                },
                {
                    "authorId": "4697495",
                    "name": "S. McDaid"
                }
            ],
            "abstract": "We present Zoea Visual which is a visual programming language based on the Zoea composable inductive programming language. Zoea Visual allows users to create software directly from a specification that resembles a set of functional test cases. Programming with Zoea Visual involves the definition of a data flow model of test case inputs, optional intermediate values, and outputs. Data elements are represented visually and can be combined to create structures of any complexity. Data flows between elements provide additional information that allows the Zoea compiler to generate larger programs in less time. This paper includes an overview of the language. The benefits of the approach and some possible future enhancements are also discussed.",
            "corpus_id": 221802417,
            "sentences": [
                {
                    "corpus_id": "221802417",
                    "title": "A Visual Language for Composable Inductive Programming",
                    "text": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
                    "score": 0.37955109953353117,
                    "section_title": "Visual Programming",
                    "char_start_offset": 2695,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 89
                        },
                        {
                            "start": 90,
                            "end": 230
                        },
                        {
                            "start": 231,
                            "end": 412
                        },
                        {
                            "start": 415,
                            "end": 555
                        },
                        {
                            "start": 556,
                            "end": 615
                        },
                        {
                            "start": 616,
                            "end": 687
                        },
                        {
                            "start": 690,
                            "end": 798
                        },
                        {
                            "start": 799,
                            "end": 887
                        },
                        {
                            "start": 890,
                            "end": 927
                        },
                        {
                            "start": 930,
                            "end": 973
                        },
                        {
                            "start": 976,
                            "end": 1015
                        },
                        {
                            "start": 1018,
                            "end": 1160
                        },
                        {
                            "start": 1161,
                            "end": 1305
                        },
                        {
                            "start": 1308,
                            "end": 1523
                        },
                        {
                            "start": 1524,
                            "end": 1590
                        },
                        {
                            "start": 1591,
                            "end": 1734
                        },
                        {
                            "start": 1735,
                            "end": 1837
                        },
                        {
                            "start": 1838,
                            "end": 1959
                        },
                        {
                            "start": 1962,
                            "end": 2039
                        },
                        {
                            "start": 2040,
                            "end": 2257
                        },
                        {
                            "start": 2258,
                            "end": 2322
                        },
                        {
                            "start": 2325,
                            "end": 2433
                        },
                        {
                            "start": 2434,
                            "end": 2625
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 551,
                            "end": 554,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 604,
                            "end": 608,
                            "matchedPaperCorpusId": "5257722"
                        },
                        {
                            "start": 611,
                            "end": 614,
                            "matchedPaperCorpusId": "9744698"
                        },
                        {
                            "start": 670,
                            "end": 674,
                            "matchedPaperCorpusId": "44279097"
                        },
                        {
                            "start": 674,
                            "end": 677,
                            "matchedPaperCorpusId": "30037917"
                        },
                        {
                            "start": 677,
                            "end": 680,
                            "matchedPaperCorpusId": "158715"
                        },
                        {
                            "start": 683,
                            "end": 686,
                            "matchedPaperCorpusId": "425881"
                        },
                        {
                            "start": 793,
                            "end": 797,
                            "matchedPaperCorpusId": "561505"
                        },
                        {
                            "start": 2105,
                            "end": 2109,
                            "matchedPaperCorpusId": "30404857"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94140625
                }
            ],
            "relevance_judgement": 0.94140625,
            "relevance_judgment_input_expanded": "# Title: A Visual Language for Composable Inductive Programming\n# Venue: arXiv.org\n# Authors: Edward McDaid, S. McDaid\n## Abstract\nWe present Zoea Visual which is a visual programming language based on the Zoea composable inductive programming language. Zoea Visual allows users to create software directly from a specification that resembles a set of functional test cases. Programming with Zoea Visual involves the definition of a data flow model of test case inputs, optional intermediate values, and outputs. Data elements are represented visually and can be combined to create structures of any complexity. Data flows between elements provide additional information that allows the Zoea compiler to generate larger programs in less time. This paper includes an overview of the language. The benefits of the approach and some possible future enhancements are also discussed.\n## Visual Programming\nVisual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
            "reference_string": "[221802417 | McDaid et al. | 2020 | Citations: 4]"
        },
        {
            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
            "venue": "British Computer Society Conference on Human-Computer Interaction",
            "year": 2017,
            "reference_count": 20,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.scienceopen.com/document_file/12bbb28c-64da-4374-bf9d-9fde41f35fd6/ScienceOpen/001_Vithana.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.14236/ewic/HCI2017.26?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.14236/ewic/HCI2017.26, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "9346844",
                    "name": "Yasura Vithana"
                },
                {
                    "authorId": "40894841",
                    "name": "Hashini Senaratne"
                }
            ],
            "abstract": "This paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.",
            "corpus_id": 4793447,
            "sentences": [
                {
                    "corpus_id": "4793447",
                    "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                    "text": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
                    "score": 0.43162795378826974,
                    "section_title": "WORK DEVELOPED",
                    "char_start_offset": 5574,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 155
                        },
                        {
                            "start": 156,
                            "end": 300
                        },
                        {
                            "start": 301,
                            "end": 449
                        },
                        {
                            "start": 450,
                            "end": 617
                        },
                        {
                            "start": 618,
                            "end": 799
                        },
                        {
                            "start": 800,
                            "end": 1104
                        },
                        {
                            "start": 1105,
                            "end": 1213
                        },
                        {
                            "start": 1214,
                            "end": 1426
                        },
                        {
                            "start": 1427,
                            "end": 1477
                        },
                        {
                            "start": 1478,
                            "end": 1540
                        },
                        {
                            "start": 1541,
                            "end": 1650
                        },
                        {
                            "start": 1651,
                            "end": 1810
                        },
                        {
                            "start": 1811,
                            "end": 1850
                        },
                        {
                            "start": 1851,
                            "end": 1936
                        },
                        {
                            "start": 1937,
                            "end": 2045
                        },
                        {
                            "start": 2046,
                            "end": 2161
                        },
                        {
                            "start": 2162,
                            "end": 2230
                        },
                        {
                            "start": 2231,
                            "end": 2370
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.94091796875
                }
            ],
            "relevance_judgement": 0.94091796875,
            "relevance_judgment_input_expanded": "# Title: Extensible Visual Programming Model for Modular Systems Targeting Novices\n# Venue: British Computer Society Conference on Human-Computer Interaction\n# Authors: Yasura Vithana, Hashini Senaratne\n## Abstract\nThis paper presents a visual programming model with its entire flow starting from the visual program creation to the execution of the program on the target system. The introduced visual programming model is developed targeting modular hardware systems where the module specific execution of tasks is offloaded to the respective module. This model can be used on systems like robot kits and other module based programmable systems where modules have self-sufficient processing power, specially targeting STEM education. The nature of the target system and the message passing model of task execution have given this model the qualities like simplicity and extensibility. The generated executable consists of instructions that can be executed by the interpreter-like execution engine that resides in the central processing unit of the target system. This also gives the ability to directly execute instructions on the system without going through the traditional program translation process.\n## WORK DEVELOPED\nThe visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
            "reference_string": "[4793447 | Vithana et al. | 2017 | Citations: 0]"
        },
        {
            "title": "Guided Optimization for Image Processing Pipelines",
            "venue": "IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments",
            "year": 2021,
            "reference_count": 37,
            "citation_count": 9,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://arxiv.org/pdf/2107.12567",
                "status": "GREEN",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/2107.12567, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2134665163",
                    "name": "Yuka Ikarashi"
                },
                {
                    "authorId": "1401885963",
                    "name": "Jonathan Ragan-Kelley"
                },
                {
                    "authorId": "33439074",
                    "name": "Tsukasa Fukusato"
                },
                {
                    "authorId": "153049675",
                    "name": "Jun Kato"
                },
                {
                    "authorId": "1717356",
                    "name": "T. Igarashi"
                }
            ],
            "abstract": "Writing high-performance image processing code is challenging and labor-intensive. To address this, we propose a programming support method called \u201cguided optimization.\u201d Guided optimization provides programmers a set of valid optimization options and interactive feedback about their current choices, which enables them to comprehend and efficiently optimize image processing code without the time-consuming trial-and-error process of traditional text editors. We implemented a proof-of-concept system, Roly-poly, which integrates guided optimization, program visualization, and schedule cost estimation to support the comprehension and development of efficient image processing code. We conducted a user study with novice Halide programmers and confirmed that Roly-poly and its guided optimization was informative, increased productivity, and resulted in higher-performing schedules in less time.",
            "corpus_id": 236447670,
            "sentences": [
                {
                    "corpus_id": "236447670",
                    "title": "Guided Optimization for Image Processing Pipelines",
                    "text": "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes [31]. Alice [32] and Scratch [33] are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks. Weintrop and Wilensky found that block-based programming tools were easier to use for high school students than text-based alternatives [34]. \n\nInspired by the prior work on VPLs, Roly-poly offers an interactive block-like visualization of the execution of the image processing pipeline. Compared with manual text-based scheduling, we narrow users' freedom by only providing a set of choices. However, our design choices are that using visual constraints in Roly-poly will help users focus only on essential ideas, not on syntactical mistakes. Also, some VPLs assign colors to categories based on their functionalities (e.g., control blocks and operators blocks). This inspired Roly-poly to assign distinguished colors to different functions.",
                    "score": 0.3544289123930477,
                    "section_title": "E. Visual Programming Language",
                    "char_start_offset": 15457,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 115
                        },
                        {
                            "start": 116,
                            "end": 198
                        },
                        {
                            "start": 199,
                            "end": 349
                        },
                        {
                            "start": 350,
                            "end": 491
                        },
                        {
                            "start": 494,
                            "end": 637
                        },
                        {
                            "start": 638,
                            "end": 742
                        },
                        {
                            "start": 743,
                            "end": 893
                        },
                        {
                            "start": 894,
                            "end": 1013
                        },
                        {
                            "start": 1014,
                            "end": 1092
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 193,
                            "end": 197,
                            "matchedPaperCorpusId": "34589974"
                        },
                        {
                            "start": 205,
                            "end": 209,
                            "matchedPaperCorpusId": "62491646"
                        },
                        {
                            "start": 222,
                            "end": 226,
                            "matchedPaperCorpusId": "273180521"
                        },
                        {
                            "start": 486,
                            "end": 490,
                            "matchedPaperCorpusId": "207226901"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9375
                }
            ],
            "relevance_judgement": 0.9375,
            "relevance_judgment_input_expanded": "# Title: Guided Optimization for Image Processing Pipelines\n# Venue: IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments\n# Authors: Yuka Ikarashi, Jonathan Ragan-Kelley, Tsukasa Fukusato, Jun Kato, T. Igarashi\n## Abstract\nWriting high-performance image processing code is challenging and labor-intensive. To address this, we propose a programming support method called \u201cguided optimization.\u201d Guided optimization provides programmers a set of valid optimization options and interactive feedback about their current choices, which enables them to comprehend and efficiently optimize image processing code without the time-consuming trial-and-error process of traditional text editors. We implemented a proof-of-concept system, Roly-poly, which integrates guided optimization, program visualization, and schedule cost estimation to support the comprehension and development of efficient image processing code. We conducted a user study with novice Halide programmers and confirmed that Roly-poly and its guided optimization was informative, increased productivity, and resulted in higher-performing schedules in less time.\n## E. Visual Programming Language\nVisual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes [31]. Alice [32] and Scratch [33] are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks. Weintrop and Wilensky found that block-based programming tools were easier to use for high school students than text-based alternatives [34]. \n\nInspired by the prior work on VPLs, Roly-poly offers an interactive block-like visualization of the execution of the image processing pipeline. Compared with manual text-based scheduling, we narrow users' freedom by only providing a set of choices. However, our design choices are that using visual constraints in Roly-poly will help users focus only on essential ideas, not on syntactical mistakes. Also, some VPLs assign colors to categories based on their functionalities (e.g., control blocks and operators blocks). This inspired Roly-poly to assign distinguished colors to different functions.",
            "reference_string": "[236447670 | Ikarashi et al. | 2021 | Citations: 9]"
        },
        {
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "venue": "Indian Journal of Science and Technology",
            "year": 2021,
            "reference_count": 32,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.17485/ijst/v14i17.431",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.17485/IJST/V14I17.431?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.17485/IJST/V14I17.431, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "9207310",
                    "name": "Kawther A. Aldhlan"
                },
                {
                    "authorId": "2836785",
                    "name": "Hamad Alreshidi"
                }
            ],
            "abstract": "Objectives: To employ the Scratch program for designing electronic educational games in raising technological awareness and visual programing skills to deal with electronic fatal games for first-grade secondary students in Hail- Saudi Arabia. Method: To achieve the goal, the researchers utilize the experimental methods by using one of the educational games programs (Scratch) to develop technological awareness of electronic games for first-grade secondary school students in Hail, Saudi Arabia. Whereas, the research problem was explained in the high number of suicides among adolescents due to the use of fatal games. Besides, an observation method was used where a scale of technological awareness values and a visual programming skills card were prepared to be acquired by students through the program. An exploratory sample of (38) students in the first grade of Ha\u2019il secondary school was selected. The experimental group consisted of a random sample of (48) students in the first grade of Al-Mas secondary school. The research tools were applied before and after the experimental group to determine the significance of the differences. Findings: The results clearly show that there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the technological awareness scale in favor of the research group in the post-measurement and there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the scorecard for the skill performance in visual programming for the research group in the post-measurement. Application: The research concludes with the importance of employing electronic educational games and the interaction between the values of technological awareness and visual programming to deal with electronic fatal games for first-grade secondary students in Ha\u2019il- Saudi Arabia. \nKeywords: Educational E-Games; Technological Awareness; Visual Programming; Fatal Games; Scratch program",
            "corpus_id": 236566925,
            "sentences": [
                {
                    "corpus_id": "236566925",
                    "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                    "text": "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23) .3 The Third Axis: Fatal electronic games: \n\nThrough this axis, the researchers reviewed the concept of fatal games, some fatal games that have recently spread and become popular (Blue Whale, Mariam), in addition to some early warning signs of the seriousness of fatal electronic games.",
                    "score": 0.47108735754461806,
                    "section_title": "Some visual programming languages:",
                    "char_start_offset": 30409,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 79
                        },
                        {
                            "start": 82,
                            "end": 265
                        },
                        {
                            "start": 266,
                            "end": 591
                        },
                        {
                            "start": 594,
                            "end": 769
                        },
                        {
                            "start": 770,
                            "end": 901
                        },
                        {
                            "start": 902,
                            "end": 1111
                        },
                        {
                            "start": 1112,
                            "end": 1337
                        },
                        {
                            "start": 1338,
                            "end": 1340
                        },
                        {
                            "start": 1341,
                            "end": 1380
                        },
                        {
                            "start": 1383,
                            "end": 1624
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.935546875
                },
                {
                    "corpus_id": "236566925",
                    "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                    "text": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
                    "score": 0.3721991141151649,
                    "section_title": "Visual programming:",
                    "char_start_offset": 28669,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 149
                        },
                        {
                            "start": 150,
                            "end": 360
                        },
                        {
                            "start": 363,
                            "end": 692
                        },
                        {
                            "start": 695,
                            "end": 896
                        },
                        {
                            "start": 897,
                            "end": 978
                        },
                        {
                            "start": 979,
                            "end": 1158
                        },
                        {
                            "start": 1161,
                            "end": 1286
                        },
                        {
                            "start": 1287,
                            "end": 1305
                        },
                        {
                            "start": 1308,
                            "end": 1490
                        },
                        {
                            "start": 1491,
                            "end": 1701
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.87841796875
                }
            ],
            "relevance_judgement": 0.935546875,
            "relevance_judgment_input_expanded": "# Title: Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games\n# Venue: Indian Journal of Science and Technology\n# Authors: Kawther A. Aldhlan, Hamad Alreshidi\n## Abstract\nObjectives: To employ the Scratch program for designing electronic educational games in raising technological awareness and visual programing skills to deal with electronic fatal games for first-grade secondary students in Hail- Saudi Arabia. Method: To achieve the goal, the researchers utilize the experimental methods by using one of the educational games programs (Scratch) to develop technological awareness of electronic games for first-grade secondary school students in Hail, Saudi Arabia. Whereas, the research problem was explained in the high number of suicides among adolescents due to the use of fatal games. Besides, an observation method was used where a scale of technological awareness values and a visual programming skills card were prepared to be acquired by students through the program. An exploratory sample of (38) students in the first grade of Ha\u2019il secondary school was selected. The experimental group consisted of a random sample of (48) students in the first grade of Al-Mas secondary school. The research tools were applied before and after the experimental group to determine the significance of the differences. Findings: The results clearly show that there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the technological awareness scale in favor of the research group in the post-measurement and there is a statistically significant difference at the level of (0,01) between the average scores of the research sample students in the post and pre-measurement of the scorecard for the skill performance in visual programming for the research group in the post-measurement. Application: The research concludes with the importance of employing electronic educational games and the interaction between the values of technological awareness and visual programming to deal with electronic fatal games for first-grade secondary students in Ha\u2019il- Saudi Arabia. \nKeywords: Educational E-Games; Technological Awareness; Visual Programming; Fatal Games; Scratch program\n## Visual programming:\nVisual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.\n\n## Some visual programming languages:\nVisual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23) .3 The Third Axis: Fatal electronic games: \n\nThrough this axis, the researchers reviewed the concept of fatal games, some fatal games that have recently spread and become popular (Blue Whale, Mariam), in addition to some early warning signs of the seriousness of fatal electronic games.",
            "reference_string": "[236566925 | Aldhlan et al. | 2021 | Citations: 2]"
        },
        {
            "title": "DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology",
            "venue": "",
            "year": 2020,
            "reference_count": 32,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.36227/techrxiv.13176365.v1",
                "status": "GREEN",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.36227/techrxiv.13176365?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.36227/techrxiv.13176365, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2007576185",
                    "name": "Joseph Willrich Lutalo"
                },
                {
                    "authorId": "2041303630",
                    "name": "Odongo Steven Eyobu"
                },
                {
                    "authorId": "1774407",
                    "name": "Benjamin Kanagwa"
                }
            ],
            "abstract": "The need to improve or build new software systems to solve new and old business challenges is a persistent challenge inthe software consumer and development industry, yet costly. To minimize these costs, the construction method should be designed with the following qualities in mind; software portability, extensibility, and simplicity. To achieve these qualities, this paper proposes the Dynamic Nuchwezi Architecture Platform (DNAP), which is a new software construction and extension technology. DNAP offers avisual programming paradigm with a capability of generating production-ready business automation software for both mobile and web. It also offers a simple mechanism for the extension of existing softwares using embeddable components. To evaluate and justify DNAP, eight Software Operating Environment (SOE) metrics have been developed and together with the SOE model, are used to contrastDNAP against four alternative software construction technologies namely; Android Platform, .NET Framework, Java SE Platform and Python. The performance evaluation results show that DNAP offers an average of 33% reduction in software construction complexity and an 11% enhancement in language efficiency when compared to alternative technologies.",
            "corpus_id": 238126162,
            "sentences": [
                {
                    "corpus_id": "238126162",
                    "title": "DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology",
                    "text": "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts. \n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13]. \n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages. These are special and different from the traditional programming which employs numeric opcodes and parameters in bare-metal coding. Traditional programming came up with higher level languages that abstract away the low-level instruction set via human-readable alpha-numeric textual syntax. Another approach is block programming which makes coding feel less like a technical undertaking and more like an artistic endeavor. \n\nThe most famous block programming technologies include Snap [3]. Snap originated from Berkeley, and was inspired by an earlier block programming environment called Scratch [2]. Both offer browser-based environments for coding and running applications -which run using standard web technologies such as JavaScript, HTML and CSS. However, they make it unnecessary to know about the underlying implementation details, and nor does one need to explicitly write any JavaScript or HTML while using these environments -except perhaps, for the expert engineer needing to develop new blocks or extend the environment itself [14]. \n\nIt should be noted that the use of drag-and-drop interfaces in programs like Microsoft Visual Studio to design and specify the look and behavior of traditional Windows Forms (WF) applications or modern XAML powered Windows Presentation Foundation (WPF) applications, does not entirely eliminate the need to code business logic and the application's event handling instructions in text, away from the visual interface.",
                    "score": 0.3665447550339148,
                    "section_title": "Programming Complexity: Visual Programming Interfaces and Languages Simplifying Software Construction",
                    "char_start_offset": 9711,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 190
                        },
                        {
                            "start": 191,
                            "end": 335
                        },
                        {
                            "start": 336,
                            "end": 554
                        },
                        {
                            "start": 557,
                            "end": 636
                        },
                        {
                            "start": 637,
                            "end": 916
                        },
                        {
                            "start": 919,
                            "end": 1022
                        },
                        {
                            "start": 1023,
                            "end": 1154
                        },
                        {
                            "start": 1155,
                            "end": 1312
                        },
                        {
                            "start": 1313,
                            "end": 1444
                        },
                        {
                            "start": 1447,
                            "end": 1511
                        },
                        {
                            "start": 1512,
                            "end": 1623
                        },
                        {
                            "start": 1624,
                            "end": 1774
                        },
                        {
                            "start": 1775,
                            "end": 2067
                        },
                        {
                            "start": 2070,
                            "end": 2487
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 330,
                            "end": 334,
                            "matchedPaperCorpusId": "4039308"
                        },
                        {
                            "start": 631,
                            "end": 635,
                            "matchedPaperCorpusId": "4039308"
                        },
                        {
                            "start": 911,
                            "end": 915,
                            "matchedPaperCorpusId": "17653432"
                        },
                        {
                            "start": 1507,
                            "end": 1510,
                            "matchedPaperCorpusId": "220755838"
                        },
                        {
                            "start": 2062,
                            "end": 2066,
                            "matchedPaperCorpusId": "17452915"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.931640625
                }
            ],
            "relevance_judgement": 0.931640625,
            "relevance_judgment_input_expanded": "# Title: DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology\n# Venue: \n# Authors: Joseph Willrich Lutalo, Odongo Steven Eyobu, Benjamin Kanagwa\n## Abstract\nThe need to improve or build new software systems to solve new and old business challenges is a persistent challenge inthe software consumer and development industry, yet costly. To minimize these costs, the construction method should be designed with the following qualities in mind; software portability, extensibility, and simplicity. To achieve these qualities, this paper proposes the Dynamic Nuchwezi Architecture Platform (DNAP), which is a new software construction and extension technology. DNAP offers avisual programming paradigm with a capability of generating production-ready business automation software for both mobile and web. It also offers a simple mechanism for the extension of existing softwares using embeddable components. To evaluate and justify DNAP, eight Software Operating Environment (SOE) metrics have been developed and together with the SOE model, are used to contrastDNAP against four alternative software construction technologies namely; Android Platform, .NET Framework, Java SE Platform and Python. The performance evaluation results show that DNAP offers an average of 33% reduction in software construction complexity and an 11% enhancement in language efficiency when compared to alternative technologies.\n## Programming Complexity: Visual Programming Interfaces and Languages Simplifying Software Construction\nWhen it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts. \n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13]. \n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages. These are special and different from the traditional programming which employs numeric opcodes and parameters in bare-metal coding. Traditional programming came up with higher level languages that abstract away the low-level instruction set via human-readable alpha-numeric textual syntax. Another approach is block programming which makes coding feel less like a technical undertaking and more like an artistic endeavor. \n\nThe most famous block programming technologies include Snap [3]. Snap originated from Berkeley, and was inspired by an earlier block programming environment called Scratch [2]. Both offer browser-based environments for coding and running applications -which run using standard web technologies such as JavaScript, HTML and CSS. However, they make it unnecessary to know about the underlying implementation details, and nor does one need to explicitly write any JavaScript or HTML while using these environments -except perhaps, for the expert engineer needing to develop new blocks or extend the environment itself [14]. \n\nIt should be noted that the use of drag-and-drop interfaces in programs like Microsoft Visual Studio to design and specify the look and behavior of traditional Windows Forms (WF) applications or modern XAML powered Windows Presentation Foundation (WPF) applications, does not entirely eliminate the need to code business logic and the application's event handling instructions in text, away from the visual interface.",
            "reference_string": "[238126162 | Lutalo et al. | 2020 | Citations: 0]"
        },
        {
            "title": "Development of application software without programming",
            "venue": "IOP Conference Series: Materials Science and Engineering",
            "year": 2019,
            "reference_count": 18,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1088/1757-899x/477/1/012058",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1088/1757-899X/477/1/012058?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1088/1757-899X/477/1/012058, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "30811658",
                    "name": "J. Hamzabegovi\u0107"
                }
            ],
            "abstract": "End-user programming is an increasingly popular discipline of software engineering. In order to design a development environment that allows programming by non-programmers, it is desirable to understand their mental model. Most languages designed for end-users are based on visual interaction techniques such as programming with graphically presented rules and agents. Visual techniques allow direct manipulation in the environment in such a way that users grasp and pull visual components to match the application, as well as to select specific actions on certain events. Due to its omnipresence in operating systems, desktop and mobile applications, direct manipulation is an interaction technique which non-programmers are familiar with, and therefore highly desirable in application development environments by end-users or non-programmers. In this paper we present a review of the features and the functionality of the development environment that would allow the end-users logopedists to develop their therapeutic software without writing programming code and without any programming knowledge.",
            "corpus_id": 86787308,
            "sentences": [
                {
                    "corpus_id": "86787308",
                    "title": "Development of application software without programming",
                    "text": "Visual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
                    "score": 0.4394783042499773,
                    "section_title": "Visual programming and parametrization",
                    "char_start_offset": 15443,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 218
                        },
                        {
                            "start": 219,
                            "end": 380
                        },
                        {
                            "start": 381,
                            "end": 518
                        },
                        {
                            "start": 519,
                            "end": 748
                        },
                        {
                            "start": 749,
                            "end": 1062
                        },
                        {
                            "start": 1063,
                            "end": 1185
                        },
                        {
                            "start": 1188,
                            "end": 1338
                        },
                        {
                            "start": 1339,
                            "end": 1609
                        },
                        {
                            "start": 1610,
                            "end": 1847
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.92333984375
                },
                {
                    "corpus_id": "86787308",
                    "title": "Development of application software without programming",
                    "text": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.",
                    "score": 0.33092007672030155,
                    "section_title": "Visual programming",
                    "char_start_offset": 13785,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 189
                        },
                        {
                            "start": 190,
                            "end": 345
                        },
                        {
                            "start": 346,
                            "end": 493
                        },
                        {
                            "start": 494,
                            "end": 798
                        },
                        {
                            "start": 801,
                            "end": 918
                        },
                        {
                            "start": 919,
                            "end": 1090
                        },
                        {
                            "start": 1091,
                            "end": 1125
                        },
                        {
                            "start": 1126,
                            "end": 1258
                        },
                        {
                            "start": 1259,
                            "end": 1408
                        },
                        {
                            "start": 1409,
                            "end": 1522
                        },
                        {
                            "start": 1523,
                            "end": 1615
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.89453125
                }
            ],
            "relevance_judgement": 0.92333984375,
            "relevance_judgment_input_expanded": "# Title: Development of application software without programming\n# Venue: IOP Conference Series: Materials Science and Engineering\n# Authors: J. Hamzabegovi\u0107\n## Abstract\nEnd-user programming is an increasingly popular discipline of software engineering. In order to design a development environment that allows programming by non-programmers, it is desirable to understand their mental model. Most languages designed for end-users are based on visual interaction techniques such as programming with graphically presented rules and agents. Visual techniques allow direct manipulation in the environment in such a way that users grasp and pull visual components to match the application, as well as to select specific actions on certain events. Due to its omnipresence in operating systems, desktop and mobile applications, direct manipulation is an interaction technique which non-programmers are familiar with, and therefore highly desirable in application development environments by end-users or non-programmers. In this paper we present a review of the features and the functionality of the development environment that would allow the end-users logopedists to develop their therapeutic software without writing programming code and without any programming knowledge.\n## Visual programming\nIn computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.\n\n## Visual programming and parametrization\nVisual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
            "reference_string": "[86787308 | Hamzabegovic | 2019 | Citations: 0]"
        },
        {
            "title": "Case Study: Design Strategies for Enabling Visual Application Blocks of Bluetooth Library",
            "venue": "IEEE Access",
            "year": 2022,
            "reference_count": 65,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ieeexplore.ieee.org/ielx7/6287639/6514899/09775105.pdf",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/ACCESS.2022.3175316?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/ACCESS.2022.3175316, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2118213172",
                    "name": "Tai-Liang Chen"
                },
                {
                    "authorId": "2165513468",
                    "name": "I-An Su"
                },
                {
                    "authorId": "2166337197",
                    "name": "Jenq-Kuen Lee"
                }
            ],
            "abstract": "Block-based tools can make it easier for beginners to learn programming by arranging blocks. Their block concept and extensible characteristics make block-based designs suitable for introductory programming. However, block-based tools are easy to use but difficult to extend to include the complicated applications of vendor libraries or domain-specific libraries. This paper proposes a solution to block design strategies that enable designers to redefine and design domain-specific libraries to generate visual application blocks. This research uses the Bluetooth library as a case study and constructs the BlocklyTooth integrated development environment (IDE) using the Google Blockly tool. A feasibility evaluation of this study produced the following findings: (1) for the strategies, the usability of the usability metric for user experience (UMUX) and the practicality of the customized theme received satisfactory responses; and (2) for the IDE, the usability of UMUX and the value implication of the customized theme received positive reviews. In addition, the experiment on resource impact revealed that the strategies are effective in improving resource utilization, in which the quantity of code is reduced by 70.2% and 89% in terms of the block count and lines of code, respectively, and the system memory is reduced by 51.8% in terms of the dynamic code size. The results indicate that the proposed solution can be a design reference guideline for block-based tools and can effectively abstract the complex Bluetooth library into blocks.",
            "corpus_id": 248845951,
            "sentences": [
                {
                    "corpus_id": "248845951",
                    "title": "Case Study: Design Strategies for Enabling Visual Application Blocks of Bluetooth Library",
                    "text": "Block-based programming is a visual expression of VPLs that uses block-stack behavior to construct program content. The Scratch language developed in 2003 is a good example; it is currently one of the most widely used VPLs in children's learning software and has been used in the development of many learning programs and applications [27]- [35]. Another representative block-based tool is Blockly (shown in Fig. 1), which is a web-based VPL editor with imperative programming and is an open-source approach proposed by Google in 2012. Its block mode can be converted into an actual programming language mode (red box 1 in Fig. 1). It is different from the Scratch language in that it can support the design or extension of self-defined module blocks for programming languages or domain-specific development environments. The block design modules contain eight basic syntax categories (red box 2 in Fig. 1), which allow users to stack the block contents of applications. Blockly is used extensively in the development of training programs and applications [7], [36]- [44].",
                    "score": 0.3835890472241386,
                    "section_title": "II. RELATED WORK",
                    "char_start_offset": 6898,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 115
                        },
                        {
                            "start": 116,
                            "end": 346
                        },
                        {
                            "start": 347,
                            "end": 535
                        },
                        {
                            "start": 536,
                            "end": 631
                        },
                        {
                            "start": 632,
                            "end": 821
                        },
                        {
                            "start": 822,
                            "end": 970
                        },
                        {
                            "start": 971,
                            "end": 1072
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 335,
                            "end": 339,
                            "matchedPaperCorpusId": "12050846"
                        },
                        {
                            "start": 341,
                            "end": 345,
                            "matchedPaperCorpusId": "242076483"
                        },
                        {
                            "start": 1056,
                            "end": 1059,
                            "matchedPaperCorpusId": "29919218"
                        },
                        {
                            "start": 1061,
                            "end": 1065,
                            "matchedPaperCorpusId": "2805973"
                        },
                        {
                            "start": 1067,
                            "end": 1071,
                            "matchedPaperCorpusId": "246681322"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.92236328125
                }
            ],
            "relevance_judgement": 0.92236328125,
            "relevance_judgment_input_expanded": "# Title: Case Study: Design Strategies for Enabling Visual Application Blocks of Bluetooth Library\n# Venue: IEEE Access\n# Authors: Tai-Liang Chen, I-An Su, Jenq-Kuen Lee\n## Abstract\nBlock-based tools can make it easier for beginners to learn programming by arranging blocks. Their block concept and extensible characteristics make block-based designs suitable for introductory programming. However, block-based tools are easy to use but difficult to extend to include the complicated applications of vendor libraries or domain-specific libraries. This paper proposes a solution to block design strategies that enable designers to redefine and design domain-specific libraries to generate visual application blocks. This research uses the Bluetooth library as a case study and constructs the BlocklyTooth integrated development environment (IDE) using the Google Blockly tool. A feasibility evaluation of this study produced the following findings: (1) for the strategies, the usability of the usability metric for user experience (UMUX) and the practicality of the customized theme received satisfactory responses; and (2) for the IDE, the usability of UMUX and the value implication of the customized theme received positive reviews. In addition, the experiment on resource impact revealed that the strategies are effective in improving resource utilization, in which the quantity of code is reduced by 70.2% and 89% in terms of the block count and lines of code, respectively, and the system memory is reduced by 51.8% in terms of the dynamic code size. The results indicate that the proposed solution can be a design reference guideline for block-based tools and can effectively abstract the complex Bluetooth library into blocks.\n## II. RELATED WORK\nBlock-based programming is a visual expression of VPLs that uses block-stack behavior to construct program content. The Scratch language developed in 2003 is a good example; it is currently one of the most widely used VPLs in children's learning software and has been used in the development of many learning programs and applications [27]- [35]. Another representative block-based tool is Blockly (shown in Fig. 1), which is a web-based VPL editor with imperative programming and is an open-source approach proposed by Google in 2012. Its block mode can be converted into an actual programming language mode (red box 1 in Fig. 1). It is different from the Scratch language in that it can support the design or extension of self-defined module blocks for programming languages or domain-specific development environments. The block design modules contain eight basic syntax categories (red box 2 in Fig. 1), which allow users to stack the block contents of applications. Blockly is used extensively in the development of training programs and applications [7], [36]- [44].",
            "reference_string": "[248845951 | Chen et al. | 2022 | Citations: 2]"
        },
        {
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "venue": "TEM Journal",
            "year": 2021,
            "reference_count": 10,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "http://www.temjournal.com/content/102/TEMJournalMay2021_981_986.pdf",
                "status": "GOLD",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.18421/TEM102-63?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.18421/TEM102-63, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2666781",
                    "name": "R. Daskalov"
                },
                {
                    "authorId": "94696738",
                    "name": "G. Pashev"
                },
                {
                    "authorId": "2299512",
                    "name": "Silvia N. Gaftandzhieva"
                }
            ],
            "abstract": "The paper presents an approach to learning and an environment for working with a hybrid visual - text programming language with a special emphasis on the training for future programmers at an early stage. An overview of other visual programming environments and languages is made and the advantages of the hybrid visual - text approach offered in this article are highlighted. Emphasis is placed on the practical implementation of a proprietary environment for the development of sample programs in the author's hybrid visual programming language. An example of the use of the environment is presented and perspectives for its development are formulated.",
            "corpus_id": 236336244,
            "sentences": [
                {
                    "corpus_id": "236336244",
                    "title": "Hybrid Visual Programming Language Environment for Programming Training",
                    "text": "In computer science, a visual programming language (VPL) is any programming language that lets users create programs by manipulating program elements graphically rather than by specifying them textually [1]. A VPL allows programming with visual expressions, spatial arrangements of text and graphic symbols, used either as syntax elements or secondary notation. \n\nMany VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations. \n\nVPLs are not something new. Initially, the idea behind their development was to awake the passion for programming in children from an early age. For this reason, Feurzeig, Seymour and Cynthia Solomon designed the programming language Logo in 1967 [3]. Logo is famous for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on a screen or with a small robot termed a turtle. Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding. Although Scratch is for beginners in programming, it is not as simple as functionality language. Other known VPLs for Scratch for Android are: Ardublock, GraspIO, ReactiveBlocks and AT&T Flow Designer. \n\nEach of these VPLs is built on a text-based programming language (such as ActionScript, JavaScript, C #, Java, etc.), which the user does not need to know to compile a program from the blocks of the VPL. \n\nMost VPLs are considered to be mainly for children's education or use by non-specialists. No approach is specially adapted to the initial training of future programmers. Weintrop and Wilensky [6] review earliest found study for Hybrid Visual Programming Languages as mentioned in [7], which also reviews several other attempts for Hybrid approach, such as [8] and [9]. These Hybrid approaches, however, are very bound to specific well-known text programming languages and do not provide more language independent approaches.",
                    "score": 0.311939090775342,
                    "section_title": "Introduction",
                    "char_start_offset": 15,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 207
                        },
                        {
                            "start": 208,
                            "end": 361
                        },
                        {
                            "start": 364,
                            "end": 544
                        },
                        {
                            "start": 547,
                            "end": 574
                        },
                        {
                            "start": 575,
                            "end": 691
                        },
                        {
                            "start": 692,
                            "end": 798
                        },
                        {
                            "start": 799,
                            "end": 980
                        },
                        {
                            "start": 981,
                            "end": 1017
                        },
                        {
                            "start": 1018,
                            "end": 1036
                        },
                        {
                            "start": 1037,
                            "end": 1148
                        },
                        {
                            "start": 1149,
                            "end": 1245
                        },
                        {
                            "start": 1246,
                            "end": 1350
                        },
                        {
                            "start": 1353,
                            "end": 1556
                        },
                        {
                            "start": 1559,
                            "end": 1648
                        },
                        {
                            "start": 1649,
                            "end": 1728
                        },
                        {
                            "start": 1729,
                            "end": 1927
                        },
                        {
                            "start": 1928,
                            "end": 2083
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.92236328125
                }
            ],
            "relevance_judgement": 0.92236328125,
            "relevance_judgment_input_expanded": "# Title: Hybrid Visual Programming Language Environment for Programming Training\n# Venue: TEM Journal\n# Authors: R. Daskalov, G. Pashev, Silvia N. Gaftandzhieva\n## Abstract\nThe paper presents an approach to learning and an environment for working with a hybrid visual - text programming language with a special emphasis on the training for future programmers at an early stage. An overview of other visual programming environments and languages is made and the advantages of the hybrid visual - text approach offered in this article are highlighted. Emphasis is placed on the practical implementation of a proprietary environment for the development of sample programs in the author's hybrid visual programming language. An example of the use of the environment is presented and perspectives for its development are formulated.\n## Introduction\nIn computer science, a visual programming language (VPL) is any programming language that lets users create programs by manipulating program elements graphically rather than by specifying them textually [1]. A VPL allows programming with visual expressions, spatial arrangements of text and graphic symbols, used either as syntax elements or secondary notation. \n\nMany VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations. \n\nVPLs are not something new. Initially, the idea behind their development was to awake the passion for programming in children from an early age. For this reason, Feurzeig, Seymour and Cynthia Solomon designed the programming language Logo in 1967 [3]. Logo is famous for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on a screen or with a small robot termed a turtle. Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding. Although Scratch is for beginners in programming, it is not as simple as functionality language. Other known VPLs for Scratch for Android are: Ardublock, GraspIO, ReactiveBlocks and AT&T Flow Designer. \n\nEach of these VPLs is built on a text-based programming language (such as ActionScript, JavaScript, C #, Java, etc.), which the user does not need to know to compile a program from the blocks of the VPL. \n\nMost VPLs are considered to be mainly for children's education or use by non-specialists. No approach is specially adapted to the initial training of future programmers. Weintrop and Wilensky [6] review earliest found study for Hybrid Visual Programming Languages as mentioned in [7], which also reviews several other attempts for Hybrid approach, such as [8] and [9]. These Hybrid approaches, however, are very bound to specific well-known text programming languages and do not provide more language independent approaches.",
            "reference_string": "[236336244 | Daskalov et al. | 2021 | Citations: 2]"
        },
        {
            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
            "venue": "International Journal of Advanced Computer Science and Applications",
            "year": 2020,
            "reference_count": 17,
            "citation_count": 19,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "http://thesai.org/Downloads/Volume11No7/Paper_77-DeepScratch_Scratch_Programming_Language.pdf",
                "status": "GOLD",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.14569/ijacsa.2020.0110777?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.14569/ijacsa.2020.0110777, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2315312012",
                    "name": "Nora S. Alturayeif"
                },
                {
                    "authorId": "2023398349",
                    "name": "Nouf Alturaief"
                },
                {
                    "authorId": "2023401654",
                    "name": "Zainab Alhathloul"
                }
            ],
            "abstract": "Visual programming languages make programming more accessible for novices, which open more opportunities to innovate and develop problem-solving skills. Besides, deep learning is one of the trending computer science fields that has a profound impact on our daily life, and it is important that young people are aware of how our world works. In this study, we partially attribute the difficulties novices face in building deep learning models to the used programming language. This paper presents DeepScratch, a new programming language extension to Scratch that provides powerful language elements to facilitate building and learning about deep learning models. We present the implementation process of DeepScratch, and explain the syntactical definition and the lexical definition of the extended vocabulary. DeepScratch provides two options to implement deep learning models: training a neural network based on built-in datasets and using pre-trained deep learning models. The two options are provided to serve different age groups and educational levels. The preliminary evaluation shows the usability and the effectiveness of this extension as a tool for kids to learn about deep learning.",
            "corpus_id": 221340525,
            "sentences": [
                {
                    "corpus_id": "221340525",
                    "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                    "text": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
                    "score": 0.46064432315507237,
                    "section_title": "II. BACKGROUND",
                    "char_start_offset": 3910,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 137
                        },
                        {
                            "start": 138,
                            "end": 339
                        },
                        {
                            "start": 340,
                            "end": 560
                        },
                        {
                            "start": 563,
                            "end": 678
                        },
                        {
                            "start": 679,
                            "end": 808
                        },
                        {
                            "start": 809,
                            "end": 894
                        },
                        {
                            "start": 895,
                            "end": 1013
                        },
                        {
                            "start": 1016,
                            "end": 1138
                        },
                        {
                            "start": 1139,
                            "end": 1256
                        },
                        {
                            "start": 1257,
                            "end": 1350
                        },
                        {
                            "start": 1351,
                            "end": 1424
                        },
                        {
                            "start": 1425,
                            "end": 1532
                        },
                        {
                            "start": 1533,
                            "end": 1662
                        },
                        {
                            "start": 1663,
                            "end": 1789
                        },
                        {
                            "start": 1790,
                            "end": 1925
                        },
                        {
                            "start": 1926,
                            "end": 2013
                        },
                        {
                            "start": 2014,
                            "end": 2152
                        },
                        {
                            "start": 2153,
                            "end": 2370
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 674,
                            "end": 677,
                            "matchedPaperCorpusId": "11994747"
                        },
                        {
                            "start": 890,
                            "end": 893,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1009,
                            "end": 1012,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1785,
                            "end": 1788,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 1803,
                            "end": 1806,
                            "matchedPaperCorpusId": "41867280"
                        },
                        {
                            "start": 2148,
                            "end": 2151,
                            "matchedPaperCorpusId": "17452915"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9208984375
                }
            ],
            "relevance_judgement": 0.9208984375,
            "relevance_judgment_input_expanded": "# Title: DeepScratch: Scratch Programming Language Extension for Deep Learning Education\n# Venue: International Journal of Advanced Computer Science and Applications\n# Authors: Nora S. Alturayeif, Nouf Alturaief, Zainab Alhathloul\n## Abstract\nVisual programming languages make programming more accessible for novices, which open more opportunities to innovate and develop problem-solving skills. Besides, deep learning is one of the trending computer science fields that has a profound impact on our daily life, and it is important that young people are aware of how our world works. In this study, we partially attribute the difficulties novices face in building deep learning models to the used programming language. This paper presents DeepScratch, a new programming language extension to Scratch that provides powerful language elements to facilitate building and learning about deep learning models. We present the implementation process of DeepScratch, and explain the syntactical definition and the lexical definition of the extended vocabulary. DeepScratch provides two options to implement deep learning models: training a neural network based on built-in datasets and using pre-trained deep learning models. The two options are provided to serve different age groups and educational levels. The preliminary evaluation shows the usability and the effectiveness of this extension as a tool for kids to learn about deep learning.\n## II. BACKGROUND\nVisual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
            "reference_string": "[221340525 | Alturayeif et al. | 2020 | Citations: 19]"
        },
        {
            "title": "Comparison of flow-based versus block-based programming for naive programmers",
            "venue": "",
            "year": 0,
            "reference_count": 0,
            "citation_count": 2,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://rshare.library.torontomu.ca/articles/thesis/Comparison_of_flow-based_versus_block-based_programming_for_naive_programmers/14652246/2/files/28134006.pdf",
                "status": "GREEN",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.32920/ryerson.14652246?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.32920/ryerson.14652246, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2071526509",
                    "name": "Kruti Dave"
                }
            ],
            "abstract": "There is general agreement that most people should have some programming ability, whether\nto investigate the vast amount of data around them or for professional purposes. Visual\nProgramming Languages comprise two broad categories: Flow-based, functional programming\nor Block-based, imperative programming. However, there has been a lack of empirical studies\nin the visual programming domain to evaluate the relative benefits of the two categories. This\nresearch provides an empirical study to analyze the effects of the comparison between Flowbased\nand Block-based paradigm, to determine which of the two representations is easier for\nnon-programmers or novice programmers. Each user is given a random, simple problem to\nprogram in a random environment. Both of the environments, Flow-based and Block-based\nare designed to be as similar as possible to make the comparison useful. The results indicate\nthat Flow and Block are equivalent environments for non-programmers or novice programmers\nin terms of usability and effectiveness.",
            "corpus_id": 242281246,
            "sentences": [],
            "relevance_judgement": 0.92041015625,
            "relevance_judgment_input_expanded": "# Title: Comparison of flow-based versus block-based programming for naive programmers\n# Venue: \n# Authors: Kruti Dave\n## Abstract\nThere is general agreement that most people should have some programming ability, whether\nto investigate the vast amount of data around them or for professional purposes. Visual\nProgramming Languages comprise two broad categories: Flow-based, functional programming\nor Block-based, imperative programming. However, there has been a lack of empirical studies\nin the visual programming domain to evaluate the relative benefits of the two categories. This\nresearch provides an empirical study to analyze the effects of the comparison between Flowbased\nand Block-based paradigm, to determine which of the two representations is easier for\nnon-programmers or novice programmers. Each user is given a random, simple problem to\nprogram in a random environment. Both of the environments, Flow-based and Block-based\nare designed to be as similar as possible to make the comparison useful. The results indicate\nthat Flow and Block are equivalent environments for non-programmers or novice programmers\nin terms of usability and effectiveness.\n",
            "reference_string": "[242281246 | Dave | 0 | Citations: 2]"
        },
        {
            "title": "Towards rule-based visual programming of generic visual systems",
            "venue": "arXiv.org",
            "year": 2000,
            "reference_count": 33,
            "citation_count": 9,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/cs/0010016, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "38400881",
                    "name": "Berthold Hoffmann"
                },
                {
                    "authorId": "1731543",
                    "name": "M. Minas"
                }
            ],
            "abstract": "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation. The language supports object-oriented programming since its graphs are hierarchically structured. Typing allows the shape of these graphs to be specified recursively in order to increase program security. Thanks to its genericity, DiaPlan allows to implement systems that represent and manipulate data in arbitrary diagram notations. The environment for the language exploits the diagram editor generator DiaGen for providing genericity, and for implementing its user interface and type checker.",
            "corpus_id": 58394,
            "sentences": [
                {
                    "corpus_id": "58394",
                    "title": "Towards rule-based visual programming of generic visual systems",
                    "text": "As this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
                    "score": 0.33748140519510234,
                    "section_title": "Genericity",
                    "char_start_offset": 20066,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 129
                        },
                        {
                            "start": 130,
                            "end": 290
                        },
                        {
                            "start": 291,
                            "end": 447
                        },
                        {
                            "start": 448,
                            "end": 580
                        },
                        {
                            "start": 581,
                            "end": 731
                        },
                        {
                            "start": 732,
                            "end": 912
                        },
                        {
                            "start": 913,
                            "end": 1045
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 950,
                            "end": 954,
                            "matchedPaperCorpusId": "43464074"
                        },
                        {
                            "start": 1040,
                            "end": 1044,
                            "matchedPaperCorpusId": "8161155"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.91943359375
                }
            ],
            "relevance_judgement": 0.91943359375,
            "relevance_judgment_input_expanded": "# Title: Towards rule-based visual programming of generic visual systems\n# Venue: arXiv.org\n# Authors: Berthold Hoffmann, M. Minas\n## Abstract\nThis paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation. The language supports object-oriented programming since its graphs are hierarchically structured. Typing allows the shape of these graphs to be specified recursively in order to increase program security. Thanks to its genericity, DiaPlan allows to implement systems that represent and manipulate data in arbitrary diagram notations. The environment for the language exploits the diagram editor generator DiaGen for providing genericity, and for implementing its user interface and type checker.\n## Genericity\nAs this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
            "reference_string": "[58394 | Hoffmann et al. | 2000 | Citations: 9]"
        },
        {
            "title": "Abstraction Level Taxonomy of Programming Language Frameworks",
            "venue": "arXiv.org",
            "year": 2013,
            "reference_count": 44,
            "citation_count": 9,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://arxiv.org/pdf/1311.3293",
                "status": "GREEN",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1311.3293, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2145585",
                    "name": "Brijender Kahanwal"
                }
            ],
            "abstract": "The main purpose of this article is to describe the taxonomy of computer languages according to the levels of abstraction. There exists so many computer languages because of so many reasons like the evolution of better computer languages over the time; the socio-economic factors as the proprietary interests, commercial advantages; expressive power; ease of use of novice; orientation toward special purposes; orientation toward special hardware; and diverse ideas about most suitability. Moreover, the important common properties of most of these languages are discussed here. No programming language is designed in a vacuity, but it solves some specific kinds of problems. There is a different framework for each problem and best suitable framework for each problem. A single framework is not best for all types of problems. So, it is important to select vigilantly the frameworks supported by the language. The five generation of the computer programming languages are explored in this paper to some extent.",
            "corpus_id": 20991852,
            "sentences": [
                {
                    "corpus_id": "20991852",
                    "title": "Abstraction Level Taxonomy of Programming Language Frameworks",
                    "text": "Visual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages. Some of the programming languages which use this concept are Visual Basic (VB), Visual Java, and Visual C++ etc.",
                    "score": 0.3685763966626367,
                    "section_title": "e)",
                    "char_start_offset": 21367,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 98
                        },
                        {
                            "start": 99,
                            "end": 299
                        },
                        {
                            "start": 300,
                            "end": 434
                        },
                        {
                            "start": 435,
                            "end": 580
                        },
                        {
                            "start": 581,
                            "end": 674
                        },
                        {
                            "start": 675,
                            "end": 737
                        },
                        {
                            "start": 738,
                            "end": 850
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.91845703125
                }
            ],
            "relevance_judgement": 0.91845703125,
            "relevance_judgment_input_expanded": "# Title: Abstraction Level Taxonomy of Programming Language Frameworks\n# Venue: arXiv.org\n# Authors: Brijender Kahanwal\n## Abstract\nThe main purpose of this article is to describe the taxonomy of computer languages according to the levels of abstraction. There exists so many computer languages because of so many reasons like the evolution of better computer languages over the time; the socio-economic factors as the proprietary interests, commercial advantages; expressive power; ease of use of novice; orientation toward special purposes; orientation toward special hardware; and diverse ideas about most suitability. Moreover, the important common properties of most of these languages are discussed here. No programming language is designed in a vacuity, but it solves some specific kinds of problems. There is a different framework for each problem and best suitable framework for each problem. A single framework is not best for all types of problems. So, it is important to select vigilantly the frameworks supported by the language. The five generation of the computer programming languages are explored in this paper to some extent.\n## e)\nVisual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages. Some of the programming languages which use this concept are Visual Basic (VB), Visual Java, and Visual C++ etc.",
            "reference_string": "[20991852 | Kahanwal | 2013 | Citations: 9]"
        },
        {
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "venue": "Int. J. Serious Games",
            "year": 2023,
            "reference_count": 42,
            "citation_count": 6,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://journal.seriousgamessociety.org/index.php/IJSG/article/download/577/498",
                "status": "GOLD",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.17083/ijsg.v10i2.577?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.17083/ijsg.v10i2.577, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "39722092",
                    "name": "Christian DeLozier"
                },
                {
                    "authorId": "38203562",
                    "name": "James Shey"
                }
            ],
            "abstract": "Enabling programmers to write correct and efficient parallel code remains an important challenge, and the prevalence of on-chip accelerators exacerbates this challenge. Novice programmers, especially those in disciplines outside of Computer Science and Computer Engineering, need to be able to write code that exploits parallelism and heterogeneity, but the frameworks for writing parallel and heterogeneous programs expect expert knowledge and experience. More effort must be put into understanding how novice programmers solve parallel problems. Unfortunately, novice programmers are difficult to study because they are, by definition, novices. We have designed a visual programming language and game-based framework for studying how novice programmers solve parallel problems. This tool was used to conduct an initial study on 95 undergraduate students with little to no prior programming experience. 71% of all volunteer participants completed the study in 48 minutes on average. This study demonstrated that novice programmers could solve parallel problems, and this framework can be used to conduct more thorough studies of how novice programmers approach parallel code.",
            "corpus_id": 259335765,
            "sentences": [
                {
                    "corpus_id": "259335765",
                    "title": "Using Visual Programming Games to Study Novice Programmers",
                    "text": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
                    "score": 0.44662867939248974,
                    "section_title": "Visual Programming",
                    "char_start_offset": 4631,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 76
                        },
                        {
                            "start": 77,
                            "end": 187
                        },
                        {
                            "start": 188,
                            "end": 278
                        },
                        {
                            "start": 279,
                            "end": 425
                        },
                        {
                            "start": 426,
                            "end": 548
                        },
                        {
                            "start": 549,
                            "end": 696
                        },
                        {
                            "start": 697,
                            "end": 788
                        },
                        {
                            "start": 789,
                            "end": 1016
                        },
                        {
                            "start": 1019,
                            "end": 1094
                        },
                        {
                            "start": 1095,
                            "end": 1231
                        },
                        {
                            "start": 1232,
                            "end": 1323
                        },
                        {
                            "start": 1324,
                            "end": 1441
                        },
                        {
                            "start": 1442,
                            "end": 1583
                        },
                        {
                            "start": 1584,
                            "end": 1737
                        },
                        {
                            "start": 1738,
                            "end": 1796
                        },
                        {
                            "start": 1797,
                            "end": 1816
                        },
                        {
                            "start": 1817,
                            "end": 1926
                        },
                        {
                            "start": 1927,
                            "end": 2022
                        },
                        {
                            "start": 2023,
                            "end": 2189
                        },
                        {
                            "start": 2190,
                            "end": 2356
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 145,
                            "end": 148,
                            "matchedPaperCorpusId": "253196672"
                        },
                        {
                            "start": 148,
                            "end": 150,
                            "matchedPaperCorpusId": "235383033"
                        },
                        {
                            "start": 167,
                            "end": 170,
                            "matchedPaperCorpusId": "10976181"
                        },
                        {
                            "start": 183,
                            "end": 186,
                            "matchedPaperCorpusId": "35735491"
                        },
                        {
                            "start": 783,
                            "end": 787,
                            "matchedPaperCorpusId": "51750550"
                        },
                        {
                            "start": 1089,
                            "end": 1093,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1226,
                            "end": 1230,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1436,
                            "end": 1440,
                            "matchedPaperCorpusId": "198986538"
                        },
                        {
                            "start": 1578,
                            "end": 1582,
                            "matchedPaperCorpusId": "199002134"
                        },
                        {
                            "start": 1820,
                            "end": 1823,
                            "matchedPaperCorpusId": "253196672"
                        },
                        {
                            "start": 2045,
                            "end": 2049,
                            "matchedPaperCorpusId": "239681487"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.91162109375
                }
            ],
            "relevance_judgement": 0.91162109375,
            "relevance_judgment_input_expanded": "# Title: Using Visual Programming Games to Study Novice Programmers\n# Venue: Int. J. Serious Games\n# Authors: Christian DeLozier, James Shey\n## Abstract\nEnabling programmers to write correct and efficient parallel code remains an important challenge, and the prevalence of on-chip accelerators exacerbates this challenge. Novice programmers, especially those in disciplines outside of Computer Science and Computer Engineering, need to be able to write code that exploits parallelism and heterogeneity, but the frameworks for writing parallel and heterogeneous programs expect expert knowledge and experience. More effort must be put into understanding how novice programmers solve parallel problems. Unfortunately, novice programmers are difficult to study because they are, by definition, novices. We have designed a visual programming language and game-based framework for studying how novice programmers solve parallel problems. This tool was used to conduct an initial study on 95 undergraduate students with little to no prior programming experience. 71% of all volunteer participants completed the study in 48 minutes on average. This study demonstrated that novice programmers could solve parallel problems, and this framework can be used to conduct more thorough studies of how novice programmers approach parallel code.\n## Visual Programming\nVisual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
            "reference_string": "[259335765 | DeLozier et al. | 2023 | Citations: 6]"
        },
        {
            "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
            "venue": "Journal of Innovative Technology Convergence",
            "year": 2019,
            "reference_count": 0,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://jitc.innotcs.org/index.php/jitc/article/download/8/7",
                "status": "HYBRID",
                "license": "CCBYNC",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.69478/jitc2019v1n1a06?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.69478/jitc2019v1n1a06, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2300620753",
                    "name": "Jason Sermeno"
                }
            ],
            "abstract": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
            "corpus_id": 269622739,
            "sentences": [
                {
                    "corpus_id": "269622739",
                    "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
                    "text": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
                    "score": 0.3544289123930477,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9111328125
                }
            ],
            "relevance_judgement": 0.9111328125,
            "relevance_judgment_input_expanded": "# Title: Graphical Block Structured Programming: A Visual Programming Paradigm\n# Venue: Journal of Innovative Technology Convergence\n# Authors: Jason Sermeno\n## Abstract\nThis paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.\n",
            "reference_string": "[269622739 | Sermeno | 2019 | Citations: 0]"
        },
        {
            "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
            "venue": "PLoS ONE",
            "year": 2024,
            "reference_count": 31,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0299456&type=printable",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://pmc.ncbi.nlm.nih.gov/articles/PMC10919872, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "100971028",
                    "name": "Pavel Kodytek"
                },
                {
                    "authorId": "1910708525",
                    "name": "Alexandra Bodzas"
                },
                {
                    "authorId": "2290253497",
                    "name": "Jan Zidek"
                }
            ],
            "abstract": "Continual technological advances associated with the recent automation revolution have tremendously increased the impact of computer technology in the industry. Software development and testing are time-consuming processes, and the current market faces a lack of specialized experts. Introducing automation to this field could, therefore, improve software engineers\u2019 common workflow and decrease the time to market. Even though many code-generating algorithms have been proposed in textual-based programming languages, to the best of the authors\u2019 knowledge, none of the studies deals with the implementation of such algorithms in graphical programming environments, especially LabVIEW. Due to this fact, the main goal of this study is to conduct a proof-of-concept for a requirement-based automated code-developing system within the graphical programming environment LabVIEW. The proposed framework was evaluated on four basic benchmark problems, encompassing a string model, a numeric model, a boolean model and a mixed-type problem model, which covers fundamental programming scenarios. In all tested cases, the algorithm demonstrated an ability to create satisfying functional and errorless solutions that met all user-defined requirements. Even though the generated programs were burdened with redundant objects and were much more complex compared to programmer-developed codes, this fact has no effect on the code\u2019s execution speed or accuracy. Based on the achieved results, we can conclude that this pilot study not only proved the feasibility and viability of the proposed concept, but also showed promising results in solving linear and binary programming tasks. Furthermore, the results revealed that with further research, this poorly explored field could become a powerful tool not only for application developers but also for non-programmers and low-skilled users.",
            "corpus_id": 268272915,
            "sentences": [
                {
                    "corpus_id": "268272915",
                    "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
                    "text": "Graphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements. Since graphical programming does not require a strong understanding of the language and its syntax, these languages are often designed to make programming more intuitive and accessible to non-programmers. \n\nAutomated code development in LabVIEW or any other graphical programming environment is inspired by reversing a standard software development model. This engineering design process can be perceived as a methodical series of steps that allow programmers to create functional products and processes [1]. This process can be highly repetitive, and certain stages often require multiple iterations before proceeding to the next step. Since requirements-based testing and validation, also known as test-driven development, is a common and essential part of software development [2] and a standard procedure for programmers who must verify the code's functionality, by reversing this process, we can automatically generate code instead of developing programs or unit testing frameworks. In this reverse scenario, we can automatically create programs based on the predefined input requirements, and by backpropagating the input-output differences, we can modify the generated code until all requirements are satisfied. By transforming this task into a fully automated process, we can therefore fundamentally reshape the development principles for basic programs, and instead of employing human experts for code development and test report validation, we can utilize computers to generate programs and evaluate test reports. \n\nAutomated code generation in textual-based environments has been used in the software industry for decades [3], and especially in recent years, many novel program generation approaches have been proposed and evaluated on common benchmark problems [4]. These approaches to code generation employ various techniques, including artificial intelligence, machine learning, or genetic evolution methods, to repair or generate efficient and error-free codes. A significant research direction in this field involves the use of machine learning, especially neural network models.",
                    "score": 0.38114380565842604,
                    "section_title": "Introduction",
                    "char_start_offset": 15,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 227
                        },
                        {
                            "start": 228,
                            "end": 507
                        },
                        {
                            "start": 508,
                            "end": 712
                        },
                        {
                            "start": 715,
                            "end": 863
                        },
                        {
                            "start": 864,
                            "end": 1016
                        },
                        {
                            "start": 1017,
                            "end": 1144
                        },
                        {
                            "start": 1145,
                            "end": 1495
                        },
                        {
                            "start": 1496,
                            "end": 1726
                        },
                        {
                            "start": 1727,
                            "end": 2031
                        },
                        {
                            "start": 2034,
                            "end": 2285
                        },
                        {
                            "start": 2286,
                            "end": 2485
                        },
                        {
                            "start": 2486,
                            "end": 2604
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 1012,
                            "end": 1015,
                            "matchedPaperCorpusId": "225556207"
                        },
                        {
                            "start": 1288,
                            "end": 1291,
                            "matchedPaperCorpusId": "220647375"
                        },
                        {
                            "start": 2141,
                            "end": 2144,
                            "matchedPaperCorpusId": "3111613"
                        },
                        {
                            "start": 2281,
                            "end": 2284,
                            "matchedPaperCorpusId": "257038678"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9091796875
                }
            ],
            "relevance_judgement": 0.9091796875,
            "relevance_judgment_input_expanded": "# Title: Automated code development based on genetic programming in graphical programming language: A pilot study\n# Venue: PLoS ONE\n# Authors: Pavel Kodytek, Alexandra Bodzas, Jan Zidek\n## Abstract\nContinual technological advances associated with the recent automation revolution have tremendously increased the impact of computer technology in the industry. Software development and testing are time-consuming processes, and the current market faces a lack of specialized experts. Introducing automation to this field could, therefore, improve software engineers\u2019 common workflow and decrease the time to market. Even though many code-generating algorithms have been proposed in textual-based programming languages, to the best of the authors\u2019 knowledge, none of the studies deals with the implementation of such algorithms in graphical programming environments, especially LabVIEW. Due to this fact, the main goal of this study is to conduct a proof-of-concept for a requirement-based automated code-developing system within the graphical programming environment LabVIEW. The proposed framework was evaluated on four basic benchmark problems, encompassing a string model, a numeric model, a boolean model and a mixed-type problem model, which covers fundamental programming scenarios. In all tested cases, the algorithm demonstrated an ability to create satisfying functional and errorless solutions that met all user-defined requirements. Even though the generated programs were burdened with redundant objects and were much more complex compared to programmer-developed codes, this fact has no effect on the code\u2019s execution speed or accuracy. Based on the achieved results, we can conclude that this pilot study not only proved the feasibility and viability of the proposed concept, but also showed promising results in solving linear and binary programming tasks. Furthermore, the results revealed that with further research, this poorly explored field could become a powerful tool not only for application developers but also for non-programmers and low-skilled users.\n## Introduction\nGraphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements. Since graphical programming does not require a strong understanding of the language and its syntax, these languages are often designed to make programming more intuitive and accessible to non-programmers. \n\nAutomated code development in LabVIEW or any other graphical programming environment is inspired by reversing a standard software development model. This engineering design process can be perceived as a methodical series of steps that allow programmers to create functional products and processes [1]. This process can be highly repetitive, and certain stages often require multiple iterations before proceeding to the next step. Since requirements-based testing and validation, also known as test-driven development, is a common and essential part of software development [2] and a standard procedure for programmers who must verify the code's functionality, by reversing this process, we can automatically generate code instead of developing programs or unit testing frameworks. In this reverse scenario, we can automatically create programs based on the predefined input requirements, and by backpropagating the input-output differences, we can modify the generated code until all requirements are satisfied. By transforming this task into a fully automated process, we can therefore fundamentally reshape the development principles for basic programs, and instead of employing human experts for code development and test report validation, we can utilize computers to generate programs and evaluate test reports. \n\nAutomated code generation in textual-based environments has been used in the software industry for decades [3], and especially in recent years, many novel program generation approaches have been proposed and evaluated on common benchmark problems [4]. These approaches to code generation employ various techniques, including artificial intelligence, machine learning, or genetic evolution methods, to repair or generate efficient and error-free codes. A significant research direction in this field involves the use of machine learning, especially neural network models.",
            "reference_string": "[268272915 | Kodytek et al. | 2024 | Citations: 1]"
        },
        {
            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
            "venue": "European-Japanese Conference on Information Modelling and Knowledge Bases",
            "year": 2022,
            "reference_count": 15,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://ebooks.iospress.nl/pdf/doi/10.3233/FAIA210477",
                "status": "HYBRID",
                "license": "CCBYNC",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3233/faia210477?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3233/faia210477, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2001006030",
                    "name": "Goragod Pongthanisorn"
                },
                {
                    "authorId": "19305117",
                    "name": "W. Viriyavit"
                },
                {
                    "authorId": "2844764",
                    "name": "Thatsanee Charoenporn"
                },
                {
                    "authorId": "1779078",
                    "name": "Virach Sornlertlamvanich"
                }
            ],
            "abstract": "Computer programming is popularized in 21st century education in terms of allowing intensive logical thinking for students. Artificial Intelligent and robotic field is considered to be the most attractive for programming today. However, for the first-time learners and novice programmers, they may encounter a difficulty in understanding the text-based style programming language with its special syntax, sematic, libraries, and the structure of the program itself. In this work, we proposed a visual programming environment for artificial intelligent and robotic application using Google Blockly. The development framework is a web application which is capable of using Google Blockly to create a program and translate the result of visual programming style to conventional text-based programming. This allows almost instant programming capability for learners of programming in such a complex system.",
            "corpus_id": 246022597,
            "sentences": [
                {
                    "corpus_id": "246022597",
                    "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
                    "text": "Not only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
                    "score": 0.3793446774400553,
                    "section_title": "Introduction",
                    "char_start_offset": 4515,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 108
                        },
                        {
                            "start": 109,
                            "end": 366
                        },
                        {
                            "start": 367,
                            "end": 542
                        },
                        {
                            "start": 543,
                            "end": 603
                        },
                        {
                            "start": 606,
                            "end": 692
                        },
                        {
                            "start": 693,
                            "end": 801
                        },
                        {
                            "start": 802,
                            "end": 852
                        },
                        {
                            "start": 853,
                            "end": 907
                        },
                        {
                            "start": 908,
                            "end": 1069
                        },
                        {
                            "start": 1070,
                            "end": 1273
                        },
                        {
                            "start": 1274,
                            "end": 1566
                        },
                        {
                            "start": 1567,
                            "end": 1688
                        },
                        {
                            "start": 1689,
                            "end": 1823
                        },
                        {
                            "start": 1824,
                            "end": 1900
                        },
                        {
                            "start": 1901,
                            "end": 2156
                        },
                        {
                            "start": 2157,
                            "end": 2205
                        },
                        {
                            "start": 2206,
                            "end": 2277
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 1065,
                            "end": 1068,
                            "matchedPaperCorpusId": "7335020"
                        },
                        {
                            "start": 1901,
                            "end": 1905,
                            "matchedPaperCorpusId": "15999236"
                        },
                        {
                            "start": 1908,
                            "end": 1911,
                            "matchedPaperCorpusId": "35216497"
                        },
                        {
                            "start": 1911,
                            "end": 1914,
                            "matchedPaperCorpusId": "221243933"
                        },
                        {
                            "start": 1914,
                            "end": 1917,
                            "matchedPaperCorpusId": "31119847"
                        },
                        {
                            "start": 2166,
                            "end": 2170,
                            "matchedPaperCorpusId": "15999236"
                        },
                        {
                            "start": 2173,
                            "end": 2176,
                            "matchedPaperCorpusId": "35216497"
                        },
                        {
                            "start": 2176,
                            "end": 2179,
                            "matchedPaperCorpusId": "221243933"
                        },
                        {
                            "start": 2179,
                            "end": 2182,
                            "matchedPaperCorpusId": "31119847"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.90771484375
                }
            ],
            "relevance_judgement": 0.90771484375,
            "relevance_judgment_input_expanded": "# Title: Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework\n# Venue: European-Japanese Conference on Information Modelling and Knowledge Bases\n# Authors: Goragod Pongthanisorn, W. Viriyavit, Thatsanee Charoenporn, Virach Sornlertlamvanich\n## Abstract\nComputer programming is popularized in 21st century education in terms of allowing intensive logical thinking for students. Artificial Intelligent and robotic field is considered to be the most attractive for programming today. However, for the first-time learners and novice programmers, they may encounter a difficulty in understanding the text-based style programming language with its special syntax, sematic, libraries, and the structure of the program itself. In this work, we proposed a visual programming environment for artificial intelligent and robotic application using Google Blockly. The development framework is a web application which is capable of using Google Blockly to create a program and translate the result of visual programming style to conventional text-based programming. This allows almost instant programming capability for learners of programming in such a complex system.\n## Introduction\nNot only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
            "reference_string": "[246022597 | Pongthanisorn et al. | 2022 | Citations: 0]"
        },
        {
            "title": "ALLI/O Diagram: An Action-based Visual Programming Language for Embedded System",
            "venue": "IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments",
            "year": 2024,
            "reference_count": 25,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/VL/HCC60511.2024.00031?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/VL/HCC60511.2024.00031, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2297972654",
                    "name": "Nuntipat Narkthong"
                },
                {
                    "authorId": "18086059",
                    "name": "C. Jariyavajee"
                },
                {
                    "authorId": "2326245511",
                    "name": "Xiaolin Xu"
                }
            ],
            "abstract": "This paper introduces ALLI/O Diagram, an action-based visual programming language for embedded system programming used by the ALLI/O IDE. We illustrate the practicality of ALLI/O Diagram with various design examples and evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs. These results demonstrate that our proposed ALLI/O Diagram is the most compact, expressive, and portable across different hardware models. We open source the ALLI/O Diagram and all example programs at https://allio.build.",
            "corpus_id": 273376382,
            "sentences": [],
            "relevance_judgement": 0.90478515625,
            "relevance_judgment_input_expanded": "# Title: ALLI/O Diagram: An Action-based Visual Programming Language for Embedded System\n# Venue: IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments\n# Authors: Nuntipat Narkthong, C. Jariyavajee, Xiaolin Xu\n## Abstract\nThis paper introduces ALLI/O Diagram, an action-based visual programming language for embedded system programming used by the ALLI/O IDE. We illustrate the practicality of ALLI/O Diagram with various design examples and evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs. These results demonstrate that our proposed ALLI/O Diagram is the most compact, expressive, and portable across different hardware models. We open source the ALLI/O Diagram and all example programs at https://allio.build.\n",
            "reference_string": "[273376382 | Narkthong et al. | 2024 | Citations: 0]"
        },
        {
            "title": "VAPE-3D: A 3D Visual Avatar-based Programming Environment",
            "venue": "Computer Science Education Research Conference",
            "year": 2022,
            "reference_count": 8,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3569173.3569181?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3569173.3569181, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2218649267",
                    "name": "Wouter Brinksma"
                },
                {
                    "authorId": "2219317025",
                    "name": "Berber Bouma"
                }
            ],
            "abstract": "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well. Often, the visualization of creating programs with these tools is different from executing them. We present the design and prototype of a 3D Visual Avatar-based Programming Environment (VAPE-3D) in the form of a visual programming language with a syntonic Avatar as its central component, and a unified visualization to edit and execute a program.",
            "corpus_id": 258990742,
            "sentences": [],
            "relevance_judgement": 0.90478515625,
            "relevance_judgment_input_expanded": "# Title: VAPE-3D: A 3D Visual Avatar-based Programming Environment\n# Venue: Computer Science Education Research Conference\n# Authors: Wouter Brinksma, Berber Bouma\n## Abstract\nVisual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well. Often, the visualization of creating programs with these tools is different from executing them. We present the design and prototype of a 3D Visual Avatar-based Programming Environment (VAPE-3D) in the form of a visual programming language with a syntonic Avatar as its central component, and a unified visualization to edit and execute a program.\n",
            "reference_string": "[258990742 | Brinksma et al. | 2022 | Citations: 0]"
        },
        {
            "title": "Robots and Their Applications",
            "venue": "",
            "year": 2018,
            "reference_count": 8,
            "citation_count": 96,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://link.springer.com/content/pdf/10.1007%2F978-3-319-62533-1_1.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1007/978-3-319-62533-1_1?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1007/978-3-319-62533-1_1, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1398913278",
                    "name": "M. Ben-Ari"
                },
                {
                    "authorId": "1727799",
                    "name": "F. Mondada"
                }
            ],
            "abstract": "This chapter starts with an overview and classification of robots: industrial robots, autonomous mobile robots, humanoid robots and educational robots. A specification is given of a generic educational robot used throughout the book: a small mobile robot with differential drive and horizontal and ground proximity sensors. A pseudocode is defined so that algorithms can be presented in a platform-independent manner. The chapter concludes with a detailed overview of the contents of the book.",
            "corpus_id": 64771513,
            "sentences": [
                {
                    "corpus_id": "64771513",
                    "title": "Robots and Their Applications",
                    "text": "Every educational robotics system includes a software development environment. The programming language can be a version of a standard programming language like Java or Python. Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes.",
                    "score": 0.3749681041156981,
                    "section_title": "Software Development Environments",
                    "char_start_offset": 13160,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 78
                        },
                        {
                            "start": 79,
                            "end": 176
                        },
                        {
                            "start": 177,
                            "end": 298
                        },
                        {
                            "start": 301,
                            "end": 411
                        },
                        {
                            "start": 412,
                            "end": 518
                        },
                        {
                            "start": 519,
                            "end": 656
                        },
                        {
                            "start": 659,
                            "end": 730
                        },
                        {
                            "start": 731,
                            "end": 858
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9033203125
                }
            ],
            "relevance_judgement": 0.9033203125,
            "relevance_judgment_input_expanded": "# Title: Robots and Their Applications\n# Venue: \n# Authors: M. Ben-Ari, F. Mondada\n## Abstract\nThis chapter starts with an overview and classification of robots: industrial robots, autonomous mobile robots, humanoid robots and educational robots. A specification is given of a generic educational robot used throughout the book: a small mobile robot with differential drive and horizontal and ground proximity sensors. A pseudocode is defined so that algorithms can be presented in a platform-independent manner. The chapter concludes with a detailed overview of the contents of the book.\n## Software Development Environments\nEvery educational robotics system includes a software development environment. The programming language can be a version of a standard programming language like Java or Python. Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes.",
            "reference_string": "[64771513 | Ben-Ari et al. | 2018 | Citations: 96]"
        },
        {
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "venue": "",
            "year": 2014,
            "reference_count": 10,
            "citation_count": 8,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5755/j01.eee.20.1.6169",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5755/J01.EEE.20.1.6169?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5755/J01.EEE.20.1.6169, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3102760",
                    "name": "Ignas Plauska"
                },
                {
                    "authorId": "69972564",
                    "name": "R. Lukas"
                },
                {
                    "authorId": null,
                    "name": "Robertas Dama\u0161evi\u010dius"
                }
            ],
            "abstract": "Visual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169",
            "corpus_id": 60941791,
            "sentences": [
                {
                    "corpus_id": "60941791",
                    "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
                    "text": "Visual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
                    "score": 0.3213007535264759,
                    "section_title": "body",
                    "char_start_offset": 1,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 235
                        },
                        {
                            "start": 236,
                            "end": 403
                        },
                        {
                            "start": 404,
                            "end": 673
                        },
                        {
                            "start": 674,
                            "end": 953
                        },
                        {
                            "start": 956,
                            "end": 1988
                        },
                        {
                            "start": 1991,
                            "end": 2095
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 91,
                            "end": 94,
                            "matchedPaperCorpusId": "12628167"
                        },
                        {
                            "start": 949,
                            "end": 952,
                            "matchedPaperCorpusId": "220866115"
                        },
                        {
                            "start": 1011,
                            "end": 1014,
                            "matchedPaperCorpusId": "11750514"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.9033203125
                }
            ],
            "relevance_judgement": 0.9033203125,
            "relevance_judgment_input_expanded": "# Title: Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching\n# Venue: \n# Authors: Ignas Plauska, R. Lukas, Robertas Dama\u0161evi\u010dius\n## Abstract\nVisual programming languages provide a more natural approach to specifying software/hardware systems with complex behaviour such as robots. They are especially important in education because they do not require formal knowledge of programming language syntax and are attractive to users. We present an analysis and comparison of two visual programming environments, Lego NXT-G and Microsoft Visual Programming Language, based on the cognitive and usability requirements, evaluate their application in robotics-based Computer Science education, identify main problems and propose solutions for using visual programming languages in the Internet-of-Things domain. DOI: http://dx.doi.org/10.5755/j01.eee.20.1.6169\n## body\nVisual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
            "reference_string": "[60941791 | Plauska et al. | 2014 | Citations: 8]"
        },
        {
            "title": "A survey on the design space of end-user-oriented languages for specifying robotic missions",
            "venue": "Journal of Software and Systems Modeling",
            "year": 2021,
            "reference_count": 121,
            "citation_count": 15,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://link.springer.com/content/pdf/10.1007/s10270-020-00854-x.pdf",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1007/s10270-020-00854-x?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1007/s10270-020-00854-x, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "23203814",
                    "name": "Swaib Dragule"
                },
                {
                    "authorId": "39565422",
                    "name": "T. Berger"
                },
                {
                    "authorId": "144341567",
                    "name": "C. Menghi"
                },
                {
                    "authorId": "2909166",
                    "name": "Patrizio Pelliccione"
                }
            ],
            "abstract": "Mobile robots are becoming increasingly important in society. Fulfilling complex missions in different contexts and environments, robots are promising instruments to support our everyday live. As such, the task of defining the robot\u2019s mission is moving from professional developers and roboticists to the end-users. However, with the current state-of-the-art, defining missions is non-trivial and typically requires dedicated programming skills. Since end-users usually lack such skills, many commercial robots are nowadays equipped with environments and domain-specific languages tailored for end-users. As such, the software support for defining missions is becoming an increasingly relevant criterion when buying or choosing robots. Improving these environments and languages for specifying missions toward simplicity and flexibility is crucial. To this end, we need to improve our empirical understanding of the current state-of-the-art of such languages and their environments. In this paper, we contribute in this direction. We present a survey of 30 mission specification environments for mobile robots that come with a visual and end-user-oriented language. We explore the design space of these languages and their environments, identify their concepts, and organize them as features in a feature model. We believe that our results are valuable to practitioners and researchers designing the next generation of mission specification languages in the vibrant domain of mobile robots.",
            "corpus_id": 232029733,
            "sentences": [
                {
                    "corpus_id": "232029733",
                    "title": "A survey on the design space of end-user-oriented languages for specifying robotic missions",
                    "text": "Block-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45].\n\nThe majority, that is, 23 out of our 30 environments offer a block-based syntax. Most of these environments are used for teaching, as shown in Table 2. There is some attempt to use these languages for industrial use. 2 The syntaxes of these block-based languages are typically implemented using the popular open-source libraries Blockly [17,88] and Scratch [51]. Specifically, Blockly is developed by Google for creating visual notations, where each block represents a programming concept. The library can be extended to define new blocks, support functions, and procedures. Blockly allows access to the parse tree and offers a code-generation framework to generate code in the target (general-purpose) language [87]. Scratch is similar to Blockly, but developed by the MIT media laboratory [51]. The library can be extended to add custom, end-user-oriented blocks.",
                    "score": 0.37534345840243005,
                    "section_title": "Environments with block-based languages",
                    "char_start_offset": 15063,
                    "sentence_offsets": [],
                    "ref_mentions": [
                        {
                            "start": 812,
                            "end": 815,
                            "matchedPaperCorpusId": "2701916"
                        },
                        {
                            "start": 1183,
                            "end": 1187,
                            "matchedPaperCorpusId": "6808751"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.90234375
                }
            ],
            "relevance_judgement": 0.90234375,
            "relevance_judgment_input_expanded": "# Title: A survey on the design space of end-user-oriented languages for specifying robotic missions\n# Venue: Journal of Software and Systems Modeling\n# Authors: Swaib Dragule, T. Berger, C. Menghi, Patrizio Pelliccione\n## Abstract\nMobile robots are becoming increasingly important in society. Fulfilling complex missions in different contexts and environments, robots are promising instruments to support our everyday live. As such, the task of defining the robot\u2019s mission is moving from professional developers and roboticists to the end-users. However, with the current state-of-the-art, defining missions is non-trivial and typically requires dedicated programming skills. Since end-users usually lack such skills, many commercial robots are nowadays equipped with environments and domain-specific languages tailored for end-users. As such, the software support for defining missions is becoming an increasingly relevant criterion when buying or choosing robots. Improving these environments and languages for specifying missions toward simplicity and flexibility is crucial. To this end, we need to improve our empirical understanding of the current state-of-the-art of such languages and their environments. In this paper, we contribute in this direction. We present a survey of 30 mission specification environments for mobile robots that come with a visual and end-user-oriented language. We explore the design space of these languages and their environments, identify their concepts, and organize them as features in a feature model. We believe that our results are valuable to practitioners and researchers designing the next generation of mission specification languages in the vibrant domain of mobile robots.\n## Environments with block-based languages\nBlock-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45].\n\nThe majority, that is, 23 out of our 30 environments offer a block-based syntax. Most of these environments are used for teaching, as shown in Table 2. There is some attempt to use these languages for industrial use. 2 The syntaxes of these block-based languages are typically implemented using the popular open-source libraries Blockly [17,88] and Scratch [51]. Specifically, Blockly is developed by Google for creating visual notations, where each block represents a programming concept. The library can be extended to define new blocks, support functions, and procedures. Blockly allows access to the parse tree and offers a code-generation framework to generate code in the target (general-purpose) language [87]. Scratch is similar to Blockly, but developed by the MIT media laboratory [51]. The library can be extended to add custom, end-user-oriented blocks.",
            "reference_string": "[232029733 | Dragule et al. | 2021 | Citations: 15]"
        },
        {
            "title": "DSCBlocks: An Open-Source Platform for Learning Embedded Systems Based on Algorithm Visualizations and Digital Signal Controllers",
            "venue": "Electronics",
            "year": 2019,
            "reference_count": 41,
            "citation_count": 7,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.mdpi.com/2079-9292/8/2/228/pdf?version=1550489529",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.3390/ELECTRONICS8020228?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.3390/ELECTRONICS8020228, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "102148671",
                    "name": "Jonathan \u00c1lvarez Ariza"
                }
            ],
            "abstract": "DSCBlocks is an open-source platform in hardware and software developed in JavaFX, which is focused on learning embedded systems through Digital Signal Controllers (DSCs). These devices are employed in industrial and educational sectors due to their robustness, number of peripherals, processing speed, scalability and versatility. The platform uses graphical blocks designed in Google\u2019s tool Blockly that can be used to build different Algorithm Visualizations (AVs). Afterwards, the algorithms are converted in real-time to C language, according to the specifications of the compiler for the DSCs (XC16) and they can be downloaded in one of the two models of development board for the dsPIC 33FJ128GP804 and dsPIC 33FJ128MC802. The main aim of the platform is to provide a flexible environment, drawing on the educational advantages of the AVs with different aspects concerning the embedded systems, such as declaration of variables and functions, configuration of ports and peripherals, handling of Real-Time Operating System (RTOS), interrupts, among others, that are employed in several fields such as robotics, control, instrumentation, etc. In addition, some experiments that were designed in the platform are presented in the manuscript. The educational methodology and the assessment provided by the students (n = 30) suggest that the platform is suitable and reliable to learn concepts relating to embedded systems.",
            "corpus_id": 116768063,
            "sentences": [
                {
                    "corpus_id": "116768063",
                    "title": "DSCBlocks: An Open-Source Platform for Learning Embedded Systems Based on Algorithm Visualizations and Digital Signal Controllers",
                    "text": "Integrating a database for course management. \n\nPasternak et al. [17] discussed creating visual languages with Blockly. Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations. In addition, every VPL has grammar and vocabulary that define the behavior of the language that has been created. In any case, the authors marked out some reflection points that could give a horizon for the design of VPLs with Blockly:",
                    "score": 0.3244780451268607,
                    "section_title": "\u2022",
                    "char_start_offset": 8536,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 45
                        },
                        {
                            "start": 48,
                            "end": 119
                        },
                        {
                            "start": 120,
                            "end": 322
                        },
                        {
                            "start": 323,
                            "end": 436
                        },
                        {
                            "start": 437,
                            "end": 558
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 65,
                            "end": 69,
                            "matchedPaperCorpusId": "2701916"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.896484375
                }
            ],
            "relevance_judgement": 0.896484375,
            "relevance_judgment_input_expanded": "# Title: DSCBlocks: An Open-Source Platform for Learning Embedded Systems Based on Algorithm Visualizations and Digital Signal Controllers\n# Venue: Electronics\n# Authors: Jonathan \u00c1lvarez Ariza\n## Abstract\nDSCBlocks is an open-source platform in hardware and software developed in JavaFX, which is focused on learning embedded systems through Digital Signal Controllers (DSCs). These devices are employed in industrial and educational sectors due to their robustness, number of peripherals, processing speed, scalability and versatility. The platform uses graphical blocks designed in Google\u2019s tool Blockly that can be used to build different Algorithm Visualizations (AVs). Afterwards, the algorithms are converted in real-time to C language, according to the specifications of the compiler for the DSCs (XC16) and they can be downloaded in one of the two models of development board for the dsPIC 33FJ128GP804 and dsPIC 33FJ128MC802. The main aim of the platform is to provide a flexible environment, drawing on the educational advantages of the AVs with different aspects concerning the embedded systems, such as declaration of variables and functions, configuration of ports and peripherals, handling of Real-Time Operating System (RTOS), interrupts, among others, that are employed in several fields such as robotics, control, instrumentation, etc. In addition, some experiments that were designed in the platform are presented in the manuscript. The educational methodology and the assessment provided by the students (n = 30) suggest that the platform is suitable and reliable to learn concepts relating to embedded systems.\n## \u2022\nIntegrating a database for course management. \n\nPasternak et al. [17] discussed creating visual languages with Blockly. Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations. In addition, every VPL has grammar and vocabulary that define the behavior of the language that has been created. In any case, the authors marked out some reflection points that could give a horizon for the design of VPLs with Blockly:",
            "reference_string": "[116768063 | Ariza | 2019 | Citations: 7]"
        },
        {
            "title": "Mosaicode and the visual programming of Web Application for Music and Multimedia",
            "venue": "",
            "year": 2018,
            "reference_count": 35,
            "citation_count": 7,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.revistas.ufg.br/musica/article/download/53577/25697",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5216/MH.V18I1.53577?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5216/MH.V18I1.53577, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2116792",
                    "name": "F. Schiavoni"
                },
                {
                    "authorId": "29793059",
                    "name": "L. Goncalves"
                },
                {
                    "authorId": "72875756",
                    "name": "Jos\u00e9 Mauro da Silva Sandy"
                }
            ],
            "abstract": "The development of audio application demands a high knowledge about this application domain, traditional program - ming logic and programming languages. It is possible to use a Visual Programming Language to ease the application development, including experimentations and creative exploration of the language. In this paper we present a Visual Programming Environment to create Web Audio applications, called Mosaicode. Different from other audio creation platforms that use a visual approach, our environment is a source code generator based on code snippets to create complete applications.",
            "corpus_id": 67344764,
            "sentences": [
                {
                    "corpus_id": "67344764",
                    "title": "Mosaicode and the visual programming of Web Application for Music and Multimedia",
                    "text": "Mosaicode (SCHIAVONI; GON\u00c7ALVES, 2017a) is a Graphical programming environment to create Visual Programming Languages, normally based on a specific domain, like a DSL. Initially developed as a Computer Vision Programming Environment to generate C code to OpenCV library, Mosaicode has been expanded to other programming languages and domains such as Python and Image Processing. The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator. Every single block and connection defines code fragments and add code Snippets of the application final code. The application code also depends on a code template that defines how the code snippets will be merged into the final application. Once a diagram is completed, it is possible to generate the application source code and run it. Figure 4 presents a generated source code. The tool has an interface and a plugin manager that allows the creation of new components for the environment, like Blocks, Ports and Code Templates, so the tool can be extended, allowing the generation of source code to different programming languages and specific domains. The creation of new blocks for code generation consists of a Python class extending the BlockModel class. The BlockModel class offers three sets of properties that must be specialized for that the new block to behave properly. The first set, called Definition, consists of determining an identifier of the block, the language, the framework it will compose and its source information.",
                    "score": 0.45924067623495074,
                    "section_title": "About the Mosaicode",
                    "char_start_offset": 10595,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 167
                        },
                        {
                            "start": 168,
                            "end": 378
                        },
                        {
                            "start": 379,
                            "end": 466
                        },
                        {
                            "start": 467,
                            "end": 546
                        },
                        {
                            "start": 547,
                            "end": 655
                        },
                        {
                            "start": 656,
                            "end": 825
                        },
                        {
                            "start": 826,
                            "end": 914
                        },
                        {
                            "start": 915,
                            "end": 1016
                        },
                        {
                            "start": 1017,
                            "end": 1107
                        },
                        {
                            "start": 1108,
                            "end": 1191
                        },
                        {
                            "start": 1192,
                            "end": 1337
                        },
                        {
                            "start": 1338,
                            "end": 1447
                        },
                        {
                            "start": 1448,
                            "end": 1578
                        },
                        {
                            "start": 1579,
                            "end": 1674
                        },
                        {
                            "start": 1675,
                            "end": 1717
                        },
                        {
                            "start": 1718,
                            "end": 1992
                        },
                        {
                            "start": 1993,
                            "end": 2098
                        },
                        {
                            "start": 2099,
                            "end": 2219
                        },
                        {
                            "start": 2220,
                            "end": 2377
                        }
                    ],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.89306640625
                }
            ],
            "relevance_judgement": 0.89306640625,
            "relevance_judgment_input_expanded": "# Title: Mosaicode and the visual programming of Web Application for Music and Multimedia\n# Venue: \n# Authors: F. Schiavoni, L. Goncalves, Jos\u00e9 Mauro da Silva Sandy\n## Abstract\nThe development of audio application demands a high knowledge about this application domain, traditional program - ming logic and programming languages. It is possible to use a Visual Programming Language to ease the application development, including experimentations and creative exploration of the language. In this paper we present a Visual Programming Environment to create Web Audio applications, called Mosaicode. Different from other audio creation platforms that use a visual approach, our environment is a source code generator based on code snippets to create complete applications.\n## About the Mosaicode\nMosaicode (SCHIAVONI; GON\u00c7ALVES, 2017a) is a Graphical programming environment to create Visual Programming Languages, normally based on a specific domain, like a DSL. Initially developed as a Computer Vision Programming Environment to generate C code to OpenCV library, Mosaicode has been expanded to other programming languages and domains such as Python and Image Processing. The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator. Every single block and connection defines code fragments and add code Snippets of the application final code. The application code also depends on a code template that defines how the code snippets will be merged into the final application. Once a diagram is completed, it is possible to generate the application source code and run it. Figure 4 presents a generated source code. The tool has an interface and a plugin manager that allows the creation of new components for the environment, like Blocks, Ports and Code Templates, so the tool can be extended, allowing the generation of source code to different programming languages and specific domains. The creation of new blocks for code generation consists of a Python class extending the BlockModel class. The BlockModel class offers three sets of properties that must be specialized for that the new block to behave properly. The first set, called Definition, consists of determining an identifier of the block, the language, the framework it will compose and its source information.",
            "reference_string": "[67344764 | Schiavoni et al. | 2018 | Citations: 7]"
        },
        {
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "venue": "International Conference on Computer Supported Education",
            "year": 2022,
            "reference_count": 23,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5220/0011082500003182",
                "status": "HYBRID",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5220/0011082500003182?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5220/0011082500003182, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1685511",
                    "name": "Anthony Savidis"
                }
            ],
            "abstract": ": Visual programming is widely adopted for teaching purposes, considered as an appropriate starting base before introducing learners to typical programming languages. However, the progress in such tools is very slow and limited compared to standard programming environments. Moreover, there is no systematic classification regarding the most important requirements to improve the support of visual programming tasks. In this context, we introduce programming experience as the context-specific notion of user-experience for the programming domain. Then, we identify three groups of requirements relating to language, interaction and tools, and elaborate with specific requirements per group. In this analysis, we study related examples from current tools in various domains, while we propose scenarios inspired from source-based programming environments.",
            "corpus_id": 248510289,
            "sentences": [
                {
                    "corpus_id": "248510289",
                    "title": "Programming Experience Requirements for Future Visual Development Environments",
                    "text": "The visual programming system should rely on an explicit underlying theoretically-oriented language paradigm, sometimes carefully chosen combinations of paradigms such as: imperative, object-oriented, event-driven, flow-based, batch processing, functional programming, message passing, constrained systems, etc. \n\nClearly, it is crucial to document and explain the primary reason a specific paradigm is chosen for the target learner audience and domain (if one or some are explicit targeted), setting an anticipated learning curve and engineering criteria like: ease-of-use, intuitive deployment, rapid development, error prevention, engineering scalability, proximity to a real language that learners might have to use, etc. \n\nOnce the paradigm is selected, designers may optionally expose ideas and techniques regarding the way the primary programming elements of the paradigm may be mapped to visual counterparts, and the reason such a mapping is considered appropriate and consistent. In certain cases, when visual designs aim for specific purposes or tasks, even if the underlying language paradigm is of general purpose, it has to be explicitly stated and justified. \n\nExamples: The most common programming language paradigm is the imperative, with variables, assignments, statements and expressions, and the flow-based, blending functional characteristics with event-oriented elements. In particular, Scratch offers blocks reflecting a purely imperative paradigm, while Lego Mindstorms Ev3 (Vallance et al., 2009) provides elements with an imperative look, but a genuine functional style. Business Process Modelling and Notation (BPMN, Ko et al., 2009) is a domain-specific visual language that adopts the flow-based programming paradigm (FBP, Morrisson, 1994). The roots of FBP are in controlflow and stream processing, while it borrows elements from functional composition, batch processing and event-driven systems. \n\nIn general, we refer to such cases as visual syntactic illusions when the graphical language conveys an underlying paradigm but with a frontend that mimics alternative more familiar paradigms. \n\nTouch Develop by Microsoft (Ball et al., 2016) combined the imperative programming style with typical object-based elements (not including any class definition or inheritance features), while offering the syntactic illusion of message-passing regarding method invocations.",
                    "score": 0.33748140519510234,
                    "section_title": "Explicit Language Paradigm",
                    "char_start_offset": 3495,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 311
                        },
                        {
                            "start": 314,
                            "end": 725
                        },
                        {
                            "start": 728,
                            "end": 988
                        },
                        {
                            "start": 989,
                            "end": 1172
                        },
                        {
                            "start": 1175,
                            "end": 1392
                        },
                        {
                            "start": 1393,
                            "end": 1595
                        },
                        {
                            "start": 1596,
                            "end": 1768
                        },
                        {
                            "start": 1769,
                            "end": 1925
                        },
                        {
                            "start": 1928,
                            "end": 2120
                        },
                        {
                            "start": 2123,
                            "end": 2395
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 1497,
                            "end": 1520,
                            "matchedPaperCorpusId": "208013563"
                        },
                        {
                            "start": 1643,
                            "end": 1658,
                            "matchedPaperCorpusId": "9504064"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.8916015625
                }
            ],
            "relevance_judgement": 0.8916015625,
            "relevance_judgment_input_expanded": "# Title: Programming Experience Requirements for Future Visual Development Environments\n# Venue: International Conference on Computer Supported Education\n# Authors: Anthony Savidis\n## Abstract\n: Visual programming is widely adopted for teaching purposes, considered as an appropriate starting base before introducing learners to typical programming languages. However, the progress in such tools is very slow and limited compared to standard programming environments. Moreover, there is no systematic classification regarding the most important requirements to improve the support of visual programming tasks. In this context, we introduce programming experience as the context-specific notion of user-experience for the programming domain. Then, we identify three groups of requirements relating to language, interaction and tools, and elaborate with specific requirements per group. In this analysis, we study related examples from current tools in various domains, while we propose scenarios inspired from source-based programming environments.\n## Explicit Language Paradigm\nThe visual programming system should rely on an explicit underlying theoretically-oriented language paradigm, sometimes carefully chosen combinations of paradigms such as: imperative, object-oriented, event-driven, flow-based, batch processing, functional programming, message passing, constrained systems, etc. \n\nClearly, it is crucial to document and explain the primary reason a specific paradigm is chosen for the target learner audience and domain (if one or some are explicit targeted), setting an anticipated learning curve and engineering criteria like: ease-of-use, intuitive deployment, rapid development, error prevention, engineering scalability, proximity to a real language that learners might have to use, etc. \n\nOnce the paradigm is selected, designers may optionally expose ideas and techniques regarding the way the primary programming elements of the paradigm may be mapped to visual counterparts, and the reason such a mapping is considered appropriate and consistent. In certain cases, when visual designs aim for specific purposes or tasks, even if the underlying language paradigm is of general purpose, it has to be explicitly stated and justified. \n\nExamples: The most common programming language paradigm is the imperative, with variables, assignments, statements and expressions, and the flow-based, blending functional characteristics with event-oriented elements. In particular, Scratch offers blocks reflecting a purely imperative paradigm, while Lego Mindstorms Ev3 (Vallance et al., 2009) provides elements with an imperative look, but a genuine functional style. Business Process Modelling and Notation (BPMN, Ko et al., 2009) is a domain-specific visual language that adopts the flow-based programming paradigm (FBP, Morrisson, 1994). The roots of FBP are in controlflow and stream processing, while it borrows elements from functional composition, batch processing and event-driven systems. \n\nIn general, we refer to such cases as visual syntactic illusions when the graphical language conveys an underlying paradigm but with a frontend that mimics alternative more familiar paradigms. \n\nTouch Develop by Microsoft (Ball et al., 2016) combined the imperative programming style with typical object-based elements (not including any class definition or inheritance features), while offering the syntactic illusion of message-passing regarding method invocations.",
            "reference_string": "[248510289 | Savidis | 2022 | Citations: 1]"
        },
        {
            "title": "Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers",
            "venue": "SIGPLAN symposium on New ideas, new paradigms, and reflections on programming and software",
            "year": 2023,
            "reference_count": 47,
            "citation_count": 4,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3622758.3622893",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3622758.3622893?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3622758.3622893, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2260344112",
                    "name": "Assaf Avishahar-Zeira"
                },
                {
                    "authorId": "2260344780",
                    "name": "David H. Lorenz"
                }
            ],
            "abstract": "By 2030 for each filled position in Software Engineering, two positions would remain unfilled. This already apparent loss of productivity has the software industry scrambling to fill the missing positions with citizen developers---technical people with little or no programming skills---who would be using No-Code platforms to program various software solutions in specific domains. However, currently available platforms have fairly limited abstractions, lacking the flexibility of a general purpose programming language. To break the No-Code abstraction barrier, a very simple yet expressive general purpose No-Code programming language might provide citizen developers with an alternative to domain-specific No-Code platforms. Unfortunately, these requirements seem contradictory. Making a language very simple and specific might render it crippled, thus limited to a certain domain of problems. Conversely, making a language very expressive and general, might render it too complicated for citizen developers. In this work we argue that a multi-paradigm minimalist approach can bridge the gap between simplicity and expressiveness by including only abstractions considered intuitive to citizens. As a concrete proof-of-concept, we present a general purpose programming language designed for citizen developers that is on the one hand very powerful and on the other hand very simple. In fact, this language is so simple that the entire development is accomplished by flowcharts using mouse actions only, without typing a single line of code, thus demonstrating a general purpose No-Code programming language candidate for citizen developers.",
            "corpus_id": 264306865,
            "sentences": [
                {
                    "corpus_id": "264306865",
                    "title": "Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers",
                    "text": "No-Code programming is a special case of Low-Code (visual) programming [13]. Low-Code requires minimal but some programming skills, targeting professionals that lack expertise in a speci c domain, whereas No-Code requires technical skills but no programming skills, targeting end-users who are citizens. \n\nBoth No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code. \n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code. With Kogi [37], a tool for deriving Blockly code from a simpli ed context-free grammar of a given language [36], a block-based coding visual environment can be generated for many languages. However, not every block-based coding visual environment necessarily provides a No-Code programming experience for citizen developers, because the graphical abstractions do not necessarily hide the complexity of the underlying language. \n\nToo distinguishes itself from traditional visual languages in its intent and purpose. The intention of Low-Code platforms is often to reduce coding e ort in order to enable rapid development. In comparison, the intention of Too is to empower citizen developers. Most No-Code and Low-Code platforms are special purpose, targeting a speci c domain, such as No-Code AI (e.g., Obviously.AI) 10 or Low-Code Machine Learning (e.g., AutoML).11 They enable \"domain citizens\" to reap the bene ts of the domain without deep knowledge of that domain. In comparison, Too is general purpose. \n\nOne of the main goals of Too is to make programming accessible for citizens. Although Too provides an ecosystem to create complete software solutions, it would be bene cial to have interfaces to other languages. This would enable integration with modules developed by professional programmers in di erent programming languages.",
                    "score": 0.37547402264727736,
                    "section_title": "Discussion and Related Work",
                    "char_start_offset": 53870,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 76
                        },
                        {
                            "start": 77,
                            "end": 303
                        },
                        {
                            "start": 306,
                            "end": 462
                        },
                        {
                            "start": 463,
                            "end": 524
                        },
                        {
                            "start": 527,
                            "end": 699
                        },
                        {
                            "start": 700,
                            "end": 820
                        },
                        {
                            "start": 821,
                            "end": 991
                        },
                        {
                            "start": 992,
                            "end": 1181
                        },
                        {
                            "start": 1182,
                            "end": 1418
                        },
                        {
                            "start": 1421,
                            "end": 1506
                        },
                        {
                            "start": 1507,
                            "end": 1612
                        },
                        {
                            "start": 1613,
                            "end": 1682
                        },
                        {
                            "start": 1683,
                            "end": 1857
                        },
                        {
                            "start": 1858,
                            "end": 1960
                        },
                        {
                            "start": 1961,
                            "end": 1999
                        },
                        {
                            "start": 2002,
                            "end": 2078
                        },
                        {
                            "start": 2079,
                            "end": 2213
                        },
                        {
                            "start": 2214,
                            "end": 2329
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 556,
                            "end": 560,
                            "matchedPaperCorpusId": "9744698"
                        },
                        {
                            "start": 694,
                            "end": 698,
                            "matchedPaperCorpusId": "27376867"
                        },
                        {
                            "start": 846,
                            "end": 850,
                            "matchedPaperCorpusId": "2701916"
                        },
                        {
                            "start": 1002,
                            "end": 1006,
                            "matchedPaperCorpusId": "227154812"
                        },
                        {
                            "start": 1099,
                            "end": 1103,
                            "matchedPaperCorpusId": "243867310"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.88671875
                }
            ],
            "relevance_judgement": 0.88671875,
            "relevance_judgment_input_expanded": "# Title: Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers\n# Venue: SIGPLAN symposium on New ideas, new paradigms, and reflections on programming and software\n# Authors: Assaf Avishahar-Zeira, David H. Lorenz\n## Abstract\nBy 2030 for each filled position in Software Engineering, two positions would remain unfilled. This already apparent loss of productivity has the software industry scrambling to fill the missing positions with citizen developers---technical people with little or no programming skills---who would be using No-Code platforms to program various software solutions in specific domains. However, currently available platforms have fairly limited abstractions, lacking the flexibility of a general purpose programming language. To break the No-Code abstraction barrier, a very simple yet expressive general purpose No-Code programming language might provide citizen developers with an alternative to domain-specific No-Code platforms. Unfortunately, these requirements seem contradictory. Making a language very simple and specific might render it crippled, thus limited to a certain domain of problems. Conversely, making a language very expressive and general, might render it too complicated for citizen developers. In this work we argue that a multi-paradigm minimalist approach can bridge the gap between simplicity and expressiveness by including only abstractions considered intuitive to citizens. As a concrete proof-of-concept, we present a general purpose programming language designed for citizen developers that is on the one hand very powerful and on the other hand very simple. In fact, this language is so simple that the entire development is accomplished by flowcharts using mouse actions only, without typing a single line of code, thus demonstrating a general purpose No-Code programming language candidate for citizen developers.\n## Discussion and Related Work\nNo-Code programming is a special case of Low-Code (visual) programming [13]. Low-Code requires minimal but some programming skills, targeting professionals that lack expertise in a speci c domain, whereas No-Code requires technical skills but no programming skills, targeting end-users who are citizens. \n\nBoth No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code. \n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code. With Kogi [37], a tool for deriving Blockly code from a simpli ed context-free grammar of a given language [36], a block-based coding visual environment can be generated for many languages. However, not every block-based coding visual environment necessarily provides a No-Code programming experience for citizen developers, because the graphical abstractions do not necessarily hide the complexity of the underlying language. \n\nToo distinguishes itself from traditional visual languages in its intent and purpose. The intention of Low-Code platforms is often to reduce coding e ort in order to enable rapid development. In comparison, the intention of Too is to empower citizen developers. Most No-Code and Low-Code platforms are special purpose, targeting a speci c domain, such as No-Code AI (e.g., Obviously.AI) 10 or Low-Code Machine Learning (e.g., AutoML).11 They enable \"domain citizens\" to reap the bene ts of the domain without deep knowledge of that domain. In comparison, Too is general purpose. \n\nOne of the main goals of Too is to make programming accessible for citizens. Although Too provides an ecosystem to create complete software solutions, it would be bene cial to have interfaces to other languages. This would enable integration with modules developed by professional programmers in di erent programming languages.",
            "reference_string": "[264306865 | Avishahar-Zeira et al. | 2023 | Citations: 4]"
        },
        {
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "venue": "arXiv.org",
            "year": 2017,
            "reference_count": 72,
            "citation_count": 3,
            "influential_citation_count": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://arxiv.org/abs/1712.10281, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "35131544",
                    "name": "M. S. Fayed"
                }
            ],
            "abstract": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
            "corpus_id": 3949077,
            "sentences": [
                {
                    "corpus_id": "3949077",
                    "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
                    "text": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
                    "score": 0.3276843530888929,
                    "section_title": "abstract",
                    "char_start_offset": 0,
                    "sentence_offsets": [],
                    "ref_mentions": [],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.87744140625
                }
            ],
            "relevance_judgement": 0.87744140625,
            "relevance_judgment_input_expanded": "# Title: General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications\n# Venue: arXiv.org\n# Authors: M. S. Fayed\n## Abstract\nLearning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.\n",
            "reference_string": "[3949077 | Fayed | 2017 | Citations: 3]"
        },
        {
            "title": "Tiny Thing Blocks: Integrating Everyday Objects into IoT Context",
            "venue": "Brazilian Symposium on Computing System Engineering",
            "year": 2019,
            "reference_count": 9,
            "citation_count": 1,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.5753/sbesc_estendido.2019.8648",
                "status": "HYBRID",
                "license": "CCBYNC",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.5753/sbesc_estendido.2019.8648?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.5753/sbesc_estendido.2019.8648, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2139606017",
                    "name": "Lucas Amorim"
                },
                {
                    "authorId": "2072163215",
                    "name": "Raimundo S. Barreto"
                },
                {
                    "authorId": "2062047530",
                    "name": "M\u00e1rcio Alencar"
                }
            ],
            "abstract": "The evolution of smart things technologies caused the growth in the popularity of concepts such as smart homes and industry 4.0. The Internet of Things (IoT) is the paradigm that encompasses and give a base for these topics. The development of devices that are used in this paradigm requires knowledge of subjects such as programming, embedded cyber-physical systems, web protocols, networking and others. This paper proposes a method to make it easier for people who do not have this knowledge to create smart IoT devices. To achieve this goal, we decide to create a visual language based on blocks that automatically generate code to Internet of Things devices. This language gives support to design the behavior of devices, which is represented by a model of a finite state machine. This model is generated using the tool Graphviz, which is a graph generator. We created a compiler for this language using the compiler generator Coco/r. The compiler translates the block code into the C language which is one of the programming language recognised by the Arduino IDE. We advocate that this process is more intuitive than the normal development process. after conducting tests with users, the first evaluation about this method is that it can be useful for people who understand the base concepts of it. However, there is just a few data about tests, turning it into a not definitive conclusion.",
            "corpus_id": 209056321,
            "sentences": [
                {
                    "corpus_id": "209056321",
                    "title": "Tiny Thing Blocks: Integrating Everyday Objects into IoT Context",
                    "text": "The result of the previous steps is a new language based on the Graphviz format. Like any other language, this one has a curve of learning and requires of its user knowledge about programming languages. So, we decided to create a more accessible approach to develop using this language. This method is a visual language that represents the structures using blocks. According to S. Chang and M. Erwing, a visual programming language (VLP) is one language that allows the users to develop programs using graphic elements in the place of specifying them textually. To built this language we used the library Blockly, which allowed us to create a visual language based on blocks [4], [6]. \n\nThe Tiny Thing Blocks is an open-source tool that allows the user to develop code for the Tiny Thing module without programming with a text editor. Each block was designed to represent the syntax of one structure of the new language. \n\nThe blocks represent declarations of nodes in the model, but not all of these nodes are one part of the final code. Some of the declarations of a block are used only to create the FSM. These declarations are responsible for representing the transition between states. \n\nFigure 13 and Figure 14 show the declarations of state transitions, which is the base of creating an FSM. However, Figura 13. example of transition for actuators devices Figura 14. Example of transition for sensors devices this model is the expected behavior of the device, and the tool does not cover the code for functions. In Section VI, we talk more about changes that would happen at the features of this tool. \n\nThere are four categories to categorize the blocks, and each one is a cluster of blocks that are directly linked. \n\n\u2022 The first category is the \"device\"it is the two blocks responsible for starting and finishing the model. \n\nFigura 15. Device blocks \n\nThe second is the \"pin's blocks\"category. This one encapsulates the declaration of which pins will the device use. \n\nFigura 16. Pin's blocks \n\n\u2022 The third category is the \"state's blocks\". This category encapsulates the blocks which declare the states which the device use, the blocks of transition between states in the case of the device is an actuator and the declaration of the initial state for the model.",
                    "score": 0.44697767811167344,
                    "section_title": "C. Visual programming language",
                    "char_start_offset": 12454,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 80
                        },
                        {
                            "start": 81,
                            "end": 202
                        },
                        {
                            "start": 203,
                            "end": 286
                        },
                        {
                            "start": 287,
                            "end": 364
                        },
                        {
                            "start": 365,
                            "end": 561
                        },
                        {
                            "start": 562,
                            "end": 684
                        },
                        {
                            "start": 687,
                            "end": 834
                        },
                        {
                            "start": 835,
                            "end": 920
                        },
                        {
                            "start": 923,
                            "end": 1038
                        },
                        {
                            "start": 1039,
                            "end": 1107
                        },
                        {
                            "start": 1108,
                            "end": 1190
                        },
                        {
                            "start": 1193,
                            "end": 1298
                        },
                        {
                            "start": 1299,
                            "end": 1518
                        },
                        {
                            "start": 1519,
                            "end": 1608
                        },
                        {
                            "start": 1611,
                            "end": 1724
                        },
                        {
                            "start": 1727,
                            "end": 1833
                        },
                        {
                            "start": 1836,
                            "end": 1846
                        },
                        {
                            "start": 1847,
                            "end": 1860
                        },
                        {
                            "start": 1863,
                            "end": 1904
                        },
                        {
                            "start": 1905,
                            "end": 1977
                        },
                        {
                            "start": 1980,
                            "end": 1990
                        },
                        {
                            "start": 1991,
                            "end": 2003
                        },
                        {
                            "start": 2006,
                            "end": 2051
                        },
                        {
                            "start": 2052,
                            "end": 2273
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 680,
                            "end": 683,
                            "matchedPaperCorpusId": "10570737"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.876953125
                }
            ],
            "relevance_judgement": 0.876953125,
            "relevance_judgment_input_expanded": "# Title: Tiny Thing Blocks: Integrating Everyday Objects into IoT Context\n# Venue: Brazilian Symposium on Computing System Engineering\n# Authors: Lucas Amorim, Raimundo S. Barreto, M\u00e1rcio Alencar\n## Abstract\nThe evolution of smart things technologies caused the growth in the popularity of concepts such as smart homes and industry 4.0. The Internet of Things (IoT) is the paradigm that encompasses and give a base for these topics. The development of devices that are used in this paradigm requires knowledge of subjects such as programming, embedded cyber-physical systems, web protocols, networking and others. This paper proposes a method to make it easier for people who do not have this knowledge to create smart IoT devices. To achieve this goal, we decide to create a visual language based on blocks that automatically generate code to Internet of Things devices. This language gives support to design the behavior of devices, which is represented by a model of a finite state machine. This model is generated using the tool Graphviz, which is a graph generator. We created a compiler for this language using the compiler generator Coco/r. The compiler translates the block code into the C language which is one of the programming language recognised by the Arduino IDE. We advocate that this process is more intuitive than the normal development process. after conducting tests with users, the first evaluation about this method is that it can be useful for people who understand the base concepts of it. However, there is just a few data about tests, turning it into a not definitive conclusion.\n## C. Visual programming language\nThe result of the previous steps is a new language based on the Graphviz format. Like any other language, this one has a curve of learning and requires of its user knowledge about programming languages. So, we decided to create a more accessible approach to develop using this language. This method is a visual language that represents the structures using blocks. According to S. Chang and M. Erwing, a visual programming language (VLP) is one language that allows the users to develop programs using graphic elements in the place of specifying them textually. To built this language we used the library Blockly, which allowed us to create a visual language based on blocks [4], [6]. \n\nThe Tiny Thing Blocks is an open-source tool that allows the user to develop code for the Tiny Thing module without programming with a text editor. Each block was designed to represent the syntax of one structure of the new language. \n\nThe blocks represent declarations of nodes in the model, but not all of these nodes are one part of the final code. Some of the declarations of a block are used only to create the FSM. These declarations are responsible for representing the transition between states. \n\nFigure 13 and Figure 14 show the declarations of state transitions, which is the base of creating an FSM. However, Figura 13. example of transition for actuators devices Figura 14. Example of transition for sensors devices this model is the expected behavior of the device, and the tool does not cover the code for functions. In Section VI, we talk more about changes that would happen at the features of this tool. \n\nThere are four categories to categorize the blocks, and each one is a cluster of blocks that are directly linked. \n\n\u2022 The first category is the \"device\"it is the two blocks responsible for starting and finishing the model. \n\nFigura 15. Device blocks \n\nThe second is the \"pin's blocks\"category. This one encapsulates the declaration of which pins will the device use. \n\nFigura 16. Pin's blocks \n\n\u2022 The third category is the \"state's blocks\". This category encapsulates the blocks which declare the states which the device use, the blocks of transition between states in the case of the device is an actuator and the declaration of the initial state for the model.",
            "reference_string": "[209056321 | Amorim et al. | 2019 | Citations: 1]"
        },
        {
            "title": "ECCE Toolkit: Prototyping Sensor-Based Interaction",
            "venue": "Italian National Conference on Sensors",
            "year": 2017,
            "reference_count": 42,
            "citation_count": 9,
            "influential_citation_count": 2,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.mdpi.com/1424-8220/17/3/438/pdf?version=1487847983",
                "status": "GOLD",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://pmc.ncbi.nlm.nih.gov/articles/PMC5375724, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "145582592",
                    "name": "Andrea Bellucci"
                },
                {
                    "authorId": "1708076",
                    "name": "I. Aedo"
                },
                {
                    "authorId": "145429731",
                    "name": "P. D\u00edaz"
                }
            ],
            "abstract": "Building and exploring physical user interfaces requires high technical skills and hours of specialized work. The behavior of multiple devices with heterogeneous input/output channels and connectivity has to be programmed in a context where not only the software interface matters, but also the hardware components are critical (e.g., sensors and actuators). Prototyping physical interaction is hindered by the challenges of: (1) programming interactions among physical sensors/actuators and digital interfaces; (2) implementing functionality for different platforms in different programming languages; and (3) building custom electronic-incorporated objects. We present ECCE (Entities, Components, Couplings and Ecosystems), a toolkit for non-programmers that copes with these issues by abstracting from low-level implementations, thus lowering the complexity of prototyping small-scale, sensor-based physical interfaces to support the design process. A user evaluation provides insights and use cases of the kind of applications that can be developed with the toolkit.",
            "corpus_id": 15820022,
            "sentences": [
                {
                    "corpus_id": "15820022",
                    "title": "ECCE Toolkit: Prototyping Sensor-Based Interaction",
                    "text": "As reported by Lieberman et al. [24], techniques to support end users in the programming task include: scripting languages, domain-specific languages, programming-by-demonstration, tailoring, configurability, visual languages and natural programming environments. Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification [25] and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming [24] (p. 3). d.tools [26] is one of the first attempts to introduce End-User Programming (EUP) techniques for authoring ubiquitous interaction. It supports visual programming via a visual state chart editor. The system was later extended by Exemplar [11], which exploits the programming-by-demonstration technique to enable interaction via sensor data. iStuff mobile [27] is built on top of iStuff [21] and it provides a software architecture and visual language to prototype interactions between physical objects, enhanced with sensors and actuators, and mobile devices. The project pushes forward the vision of interweaved devices, but no information is provided about (i) the implementation effort required to program cross-device interactions; (ii) how the system bridges communication among heterogeneous devices; or (iii) how the system could be extended to include new devices. Other environments have embraced visual programming for prototyping physical interaction. For instance, Scratch4Arduino [28] exploits the Scratch visual environment and visual syntax [29] to program the Arduino hardware through the composition of logical blocks on the screen. However, Scratch4Arduino is meant for educational purposes and to ease the transition to a classical textual programming language, thus it does not provide support for building complex device ecosystems. More advanced tools for this task are Node-RED [30] and MIT App Inventor [31]. Node-RED implements a visual data-flow language to interweave smart things. It provides high configurability and extensibility and it is powered by crowd-based development that enables people to reuse code created by others.",
                    "score": 0.3130935495611387,
                    "section_title": "End-User Programming for Ubiquitous Interaction",
                    "char_start_offset": 93200,
                    "sentence_offsets": [
                        {
                            "start": 0,
                            "end": 263
                        },
                        {
                            "start": 264,
                            "end": 598
                        },
                        {
                            "start": 599,
                            "end": 602
                        },
                        {
                            "start": 603,
                            "end": 733
                        },
                        {
                            "start": 734,
                            "end": 797
                        },
                        {
                            "start": 798,
                            "end": 942
                        },
                        {
                            "start": 943,
                            "end": 1161
                        },
                        {
                            "start": 1162,
                            "end": 1474
                        },
                        {
                            "start": 1475,
                            "end": 1564
                        },
                        {
                            "start": 1565,
                            "end": 1751
                        },
                        {
                            "start": 1752,
                            "end": 1955
                        },
                        {
                            "start": 1956,
                            "end": 2034
                        },
                        {
                            "start": 2035,
                            "end": 2110
                        },
                        {
                            "start": 2111,
                            "end": 2259
                        }
                    ],
                    "ref_mentions": [
                        {
                            "start": 32,
                            "end": 36,
                            "matchedPaperCorpusId": "15559793"
                        },
                        {
                            "start": 425,
                            "end": 429,
                            "matchedPaperCorpusId": "12628167"
                        },
                        {
                            "start": 590,
                            "end": 594,
                            "matchedPaperCorpusId": "15559793"
                        },
                        {
                            "start": 611,
                            "end": 615,
                            "matchedPaperCorpusId": "3004251"
                        },
                        {
                            "start": 840,
                            "end": 844,
                            "matchedPaperCorpusId": "6092270"
                        },
                        {
                            "start": 957,
                            "end": 961,
                            "matchedPaperCorpusId": "1532919"
                        },
                        {
                            "start": 988,
                            "end": 992,
                            "matchedPaperCorpusId": "16903963"
                        },
                        {
                            "start": 1595,
                            "end": 1599,
                            "matchedPaperCorpusId": "10384172"
                        }
                    ],
                    "pdf_hash": "",
                    "stype": "vespa",
                    "rerank_score": 0.87548828125
                }
            ],
            "relevance_judgement": 0.87548828125,
            "relevance_judgment_input_expanded": "# Title: ECCE Toolkit: Prototyping Sensor-Based Interaction\n# Venue: Italian National Conference on Sensors\n# Authors: Andrea Bellucci, I. Aedo, P. D\u00edaz\n## Abstract\nBuilding and exploring physical user interfaces requires high technical skills and hours of specialized work. The behavior of multiple devices with heterogeneous input/output channels and connectivity has to be programmed in a context where not only the software interface matters, but also the hardware components are critical (e.g., sensors and actuators). Prototyping physical interaction is hindered by the challenges of: (1) programming interactions among physical sensors/actuators and digital interfaces; (2) implementing functionality for different platforms in different programming languages; and (3) building custom electronic-incorporated objects. We present ECCE (Entities, Components, Couplings and Ecosystems), a toolkit for non-programmers that copes with these issues by abstracting from low-level implementations, thus lowering the complexity of prototyping small-scale, sensor-based physical interfaces to support the design process. A user evaluation provides insights and use cases of the kind of applications that can be developed with the toolkit.\n## End-User Programming for Ubiquitous Interaction\nAs reported by Lieberman et al. [24], techniques to support end users in the programming task include: scripting languages, domain-specific languages, programming-by-demonstration, tailoring, configurability, visual languages and natural programming environments. Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification [25] and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming [24] (p. 3). d.tools [26] is one of the first attempts to introduce End-User Programming (EUP) techniques for authoring ubiquitous interaction. It supports visual programming via a visual state chart editor. The system was later extended by Exemplar [11], which exploits the programming-by-demonstration technique to enable interaction via sensor data. iStuff mobile [27] is built on top of iStuff [21] and it provides a software architecture and visual language to prototype interactions between physical objects, enhanced with sensors and actuators, and mobile devices. The project pushes forward the vision of interweaved devices, but no information is provided about (i) the implementation effort required to program cross-device interactions; (ii) how the system bridges communication among heterogeneous devices; or (iii) how the system could be extended to include new devices. Other environments have embraced visual programming for prototyping physical interaction. For instance, Scratch4Arduino [28] exploits the Scratch visual environment and visual syntax [29] to program the Arduino hardware through the composition of logical blocks on the screen. However, Scratch4Arduino is meant for educational purposes and to ease the transition to a classical textual programming language, thus it does not provide support for building complex device ecosystems. More advanced tools for this task are Node-RED [30] and MIT App Inventor [31]. Node-RED implements a visual data-flow language to interweave smart things. It provides high configurability and extensibility and it is powered by crowd-based development that enables people to reuse code created by others.",
            "reference_string": "[15820022 | Bellucci et al. | 2017 | Citations: 9]"
        },
        {
            "title": "A Visual Programming Environment for Describing Complex Big Data Functions",
            "venue": "International Conferences on Information Science and System",
            "year": 2023,
            "reference_count": 10,
            "citation_count": 0,
            "influential_citation_count": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3625156.3625166",
                "status": "BRONZE",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3625156.3625166?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3625156.3625166, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2173313968",
                    "name": "Andreas Karabetian"
                },
                {
                    "authorId": "3403940",
                    "name": "Athanasios Kiourtis"
                },
                {
                    "authorId": "3404011",
                    "name": "Argyro Mavrogiorgou"
                },
                {
                    "authorId": "1681006",
                    "name": "D. Kyriazis"
                }
            ],
            "abstract": "The rapid advancement of technology and the increasing reliance on computer systems have elevated the significance of programming skills in various domains. Traditional programming techniques, primarily text-based languages, have been the backbone of software development for decades. However, these techniques often require a steep learning curve, limiting their accessibility to individuals without technical backgrounds. To address this issue, Visual Programming Environments (VPEs) have emerged as a powerful alternative, offering intuitive interfaces, consisting of graphical components such as buttons, icons or moving elements. The simple visual layout of these building blocks makes programming more accessible to non-technical users, and enables them to understand, design, and explain complex big data pipelines. While VPE's offer significant benefits, they are not without their limitations. Firstly, these environments may impose constraints on the flexibility and expressiveness of programming constructs, limiting advanced programming techniques that require fine-grained control over complex algorithms. Additionally, the graphical nature of VPE's may result in less efficient coding practices, as users might prioritize visual aesthetics over performance optimization. It is also of great importance that these services can be containerized, in order to be easily deployed and scaled, when talking about big data scenario's requirements. In this study, a VPE named Pipeline Modeler is implemented, capable of translating visual graph representations into operations, which can be then executed in big data scenarios, such as analytics pipelines and flow management on finance datasets. With the use of node blocks, one can create a graph to declare a complex mathematical flow or a pipeline of linked operations that need to be executed on a given set of data. After proper evaluation and experimentation, it is identified that this service is ideal for multiple big data and microservices scenarios, considering pipeline management cases, and that is why the Pipeline Modeler can be a great solution in the pursuit of inclusive and efficient software development and data management.",
            "corpus_id": 265369698,
            "sentences": [],
            "relevance_judgement": 0.87353515625,
            "relevance_judgment_input_expanded": "# Title: A Visual Programming Environment for Describing Complex Big Data Functions\n# Venue: International Conferences on Information Science and System\n# Authors: Andreas Karabetian, Athanasios Kiourtis, Argyro Mavrogiorgou, D. Kyriazis\n## Abstract\nThe rapid advancement of technology and the increasing reliance on computer systems have elevated the significance of programming skills in various domains. Traditional programming techniques, primarily text-based languages, have been the backbone of software development for decades. However, these techniques often require a steep learning curve, limiting their accessibility to individuals without technical backgrounds. To address this issue, Visual Programming Environments (VPEs) have emerged as a powerful alternative, offering intuitive interfaces, consisting of graphical components such as buttons, icons or moving elements. The simple visual layout of these building blocks makes programming more accessible to non-technical users, and enables them to understand, design, and explain complex big data pipelines. While VPE's offer significant benefits, they are not without their limitations. Firstly, these environments may impose constraints on the flexibility and expressiveness of programming constructs, limiting advanced programming techniques that require fine-grained control over complex algorithms. Additionally, the graphical nature of VPE's may result in less efficient coding practices, as users might prioritize visual aesthetics over performance optimization. It is also of great importance that these services can be containerized, in order to be easily deployed and scaled, when talking about big data scenario's requirements. In this study, a VPE named Pipeline Modeler is implemented, capable of translating visual graph representations into operations, which can be then executed in big data scenarios, such as analytics pipelines and flow management on finance datasets. With the use of node blocks, one can create a graph to declare a complex mathematical flow or a pipeline of linked operations that need to be executed on a given set of data. After proper evaluation and experimentation, it is identified that this service is ideal for multiple big data and microservices scenarios, considering pipeline management cases, and that is why the Pipeline Modeler can be a great solution in the pursuit of inclusive and efficient software development and data management.\n",
            "reference_string": "[265369698 | Karabetian et al. | 2023 | Citations: 0]"
        }
    ],
    "retrieved": [
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Diagrams have been utilized as communication and thinking tools across many domains [22]- [24]. Diagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program. For example, flowcharts use connectedness and directionality to represent how a piece of information is related to one another, and how it flows from one to the other [25]. \n\nThis study will classify several visual programming tools according to the aforementioned VPL categories.",
            "score": 0.658097668151179,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 9585,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 95
                },
                {
                    "start": 96,
                    "end": 307
                },
                {
                    "start": 308,
                    "end": 374
                },
                {
                    "start": 375,
                    "end": 469
                },
                {
                    "start": 470,
                    "end": 642
                },
                {
                    "start": 645,
                    "end": 750
                }
            ],
            "ref_mentions": [
                {
                    "start": 84,
                    "end": 88,
                    "matchedPaperCorpusId": "74221"
                },
                {
                    "start": 90,
                    "end": 94,
                    "matchedPaperCorpusId": "143658620"
                },
                {
                    "start": 637,
                    "end": 641,
                    "matchedPaperCorpusId": "19780225"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97509765625
        },
        {
            "corpus_id": "62105198",
            "title": "Graphic and Functional Algorithms of Sequence of Tenses in English Grammar for the Effective Education And Automated Systems of Text Synthesis and Editing",
            "text": "In addition to the visual (graphic) languages of communication, there are visual programming languages, in which the relationships between objects, actions, and their sequences are involved in the description processes, together with the objects on an equal footing (Johnston, 2004, p. 7). Visual programming languages appeared in the 20th century as an adjunct to the visualization of conventional programming languages. In 1984, Jaron Lanier published an article about a visual programming language (Jaron Lanier, http://www.well.com/user/jaron), which was followed by the birth of several visual programming languages, such as: \u2022 \u00abDragon (Friendly Russian algorithmic language that provides visibility)\u00bb used in the rocket and space technology, which can be attributed to the language of diagrams or flowcharts (Zenkin, 1991, pp. 96-113); \u2022 The basic elements of the language are states (shown by rectangles), which perform certain actions and transitions from state to state (lines). \n\nFor each transition, a logical condition for the transition to the next step is assigned; \u2022 \u00abLD (Ladder Diagram)\u00bb -a graphic language for programming ladder diagrams (Parr, 2007, p. 34); \u2022 \u00abFBD (Function Block Diagram)\u00bb -graphic language to describe the functional block diagrams (Petrov, 2004, pp. 19-21, 48-64); \u2022 \u00abCFC (Continuous Flow Chart)\u00bb -graphic language created for the design of control systems with continuous technological processes; \u2022 \u00abLabVIEW\u00bb -a graphic language for programming working with non-PC devices (http://www.labview. ru/, 2015); \u2022 \u00abVisSim\u00bb -a graphic language for modeling dynamic systems and designing systems based on models with built-in microprocessors (Darnell, 1996, p. 14); \u2022 \u00abScratch\u00bb -a visual object-oriented educational environment for students (Super Scratch Programming Adventure! Learn to Program, 2012, pp. 5-160);",
            "score": 0.6472008367228593,
            "section_title": "Visual Programming Languages",
            "char_start_offset": 3904,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 289
                },
                {
                    "start": 290,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 548
                },
                {
                    "start": 549,
                    "end": 987
                },
                {
                    "start": 990,
                    "end": 1533
                },
                {
                    "start": 1534,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1838
                },
                {
                    "start": 1839,
                    "end": 1846
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8203125
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Visual programming is a subset of the end-user development field (EUD). Other subsets of EUD include End-user programming (EUP), which mainly focuses on enabling end users to create their own programs [12], while EUD tackles the entire software life cycle including maintainability, and extensibility. End-user Software Engineering (EUSE) is another related research area which focuses on the quality attributes of the software developed by end users including reusability, security, and verifiability [77]. \n\nVisual programming refers to approaches and methods that use two-dimensional graphical elements to allow nonprogrammer end-users to create, extend, and customize software applications [9]. Visual programming languages (VPLs) are described by programming constructs and rules which are visually depicted [13]. \n\nThere are two widely known taxonomies for visual programming languages: (1) Myers [1] classified visual programming languages by specification techniques. Certain categories in Myers' classification can be generalized into one category. As an example, data-flow graphs, directed graphs, and flowcharts can be considered diagrammatic VPLs. (2) Burnett and Baker [2], on the other hand, listed three broad subcategories under ''visual representations'' namely: diagrammatic languages, iconic languages, and languages based on static pictorial sequences. This classification, while highly useful, does not list the form-based VPLs mentioned in Myers' classification. \n\nCombining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1]. Further, we filtered out the subcategories in [1] which apply to textual programming languages. \n\nWe define the VPL categories as follows:",
            "score": 0.5885909639403195,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 5284,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 71
                },
                {
                    "start": 72,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 507
                },
                {
                    "start": 510,
                    "end": 698
                },
                {
                    "start": 699,
                    "end": 818
                },
                {
                    "start": 821,
                    "end": 975
                },
                {
                    "start": 976,
                    "end": 1057
                },
                {
                    "start": 1058,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1372
                },
                {
                    "start": 1373,
                    "end": 1484
                },
                {
                    "start": 1487,
                    "end": 1693
                },
                {
                    "start": 1694,
                    "end": 1855
                },
                {
                    "start": 1856,
                    "end": 2042
                },
                {
                    "start": 2043,
                    "end": 2138
                },
                {
                    "start": 2141,
                    "end": 2181
                }
            ],
            "ref_mentions": [
                {
                    "start": 502,
                    "end": 506,
                    "matchedPaperCorpusId": "15687689"
                },
                {
                    "start": 694,
                    "end": 697,
                    "matchedPaperCorpusId": "8272806"
                },
                {
                    "start": 813,
                    "end": 817,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 903,
                    "end": 906,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1182,
                    "end": 1185,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1531,
                    "end": 1534,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1557,
                    "end": 1560,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1787,
                    "end": 1790,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1795,
                    "end": 1798,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1926,
                    "end": 1929,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1993,
                    "end": 1996,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 2038,
                    "end": 2041,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 2089,
                    "end": 2092,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9921875
        },
        {
            "corpus_id": "202566030",
            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
            "text": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities. OpenBlocks [27] proposes an extendable framework that enables application developers to build their own graphical block programming systems by specifying a single XML file. Google's online visual scripting platform Blocky [24] uses interlocking, graphical blocks to represent code concepts like variables, logical expressions, loops, and other basic programming patterns to export blocks to many programming languages like JavaScript, Python, PHP and Lua. Another approach from MIT is StarLogo [17], a client-based modeling and simulation software which facilitates the generation and understanding of simulations of complex systems. StarLogo utilize 3D graphics, sounds and a block based interface to facilitate as a programming tool for educational video games. Finally, another interesting approach is the Scratch [18] visual programming language and environment, which primarily targets ages 8 to 16 offering an authoring tool to support self-directed learning through tinkering and collaboration with peers. \n\nOn the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow. GRaIL [8] was one of the first systems that featured a visual scripting method for the creation of computer instructions based on cognitive visual patterns. It was used to make sophisticated programs that can be compiled and run at full speed, or stepped through with a debugging interpreter that can run the program at variable speeds. More recently, [16] published three case studies on Visual programming for building information modeling (BIM) utilizing Dynamo, an pen source graphical programming framework for design. a lightweight tool with an intuitive user interface for commissioning of IP-enabled WSNs.",
            "score": 0.5404214175905946,
            "section_title": "Visual Programming as an authoring tool",
            "char_start_offset": 7334,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 111
                },
                {
                    "start": 112,
                    "end": 476
                },
                {
                    "start": 477,
                    "end": 649
                },
                {
                    "start": 650,
                    "end": 932
                },
                {
                    "start": 933,
                    "end": 1110
                },
                {
                    "start": 1111,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1489
                },
                {
                    "start": 1492,
                    "end": 1642
                },
                {
                    "start": 1643,
                    "end": 1773
                },
                {
                    "start": 1774,
                    "end": 1930
                },
                {
                    "start": 1931,
                    "end": 2110
                },
                {
                    "start": 2111,
                    "end": 2297
                },
                {
                    "start": 2298,
                    "end": 2387
                }
            ],
            "ref_mentions": [
                {
                    "start": 699,
                    "end": 703,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 971,
                    "end": 975,
                    "matchedPaperCorpusId": "54120970"
                },
                {
                    "start": 1294,
                    "end": 1298,
                    "matchedPaperCorpusId": "9744698"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9775390625
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "We define the VPL categories as follows: \n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users. \n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons. Recently iconic languages have been used to enable end users without programming experience to create applications based on triggers and actions. For instance, end users may specify an alert to be sent to them when the indoor temperature is less than 40 \u2022 F. More examples can be found in [16]- [18], and [94]. \n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications. The textual form-based paradigm utilizes a declarative approach to programming, that is based on a dependency-driven, direct-manipulation model [20]. Users of form-based languages create or configure cells, and define formulas for those cells [21]. These formulas reference values contained in other cells and use them in calculations. Whenever a cell's formula is defined, the underlying evaluation engine calculates the cell's value, recalculates the values of cells that reference recalculated cells, and displays new results on the screen. \n\nDiagrams have been utilized as communication and thinking tools across many domains [22]- [24].",
            "score": 0.5363550918564606,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 7425,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 40
                },
                {
                    "start": 43,
                    "end": 185
                },
                {
                    "start": 186,
                    "end": 237
                },
                {
                    "start": 238,
                    "end": 389
                },
                {
                    "start": 390,
                    "end": 527
                },
                {
                    "start": 530,
                    "end": 647
                },
                {
                    "start": 648,
                    "end": 730
                },
                {
                    "start": 731,
                    "end": 882
                },
                {
                    "start": 883,
                    "end": 960
                },
                {
                    "start": 961,
                    "end": 1023
                },
                {
                    "start": 1024,
                    "end": 1169
                },
                {
                    "start": 1170,
                    "end": 1282
                },
                {
                    "start": 1283,
                    "end": 1334
                },
                {
                    "start": 1337,
                    "end": 1519
                },
                {
                    "start": 1520,
                    "end": 1613
                },
                {
                    "start": 1614,
                    "end": 1763
                },
                {
                    "start": 1764,
                    "end": 1862
                },
                {
                    "start": 1863,
                    "end": 1949
                },
                {
                    "start": 1950,
                    "end": 2157
                },
                {
                    "start": 2160,
                    "end": 2255
                }
            ],
            "ref_mentions": [
                {
                    "start": 433,
                    "end": 437,
                    "matchedPaperCorpusId": "275570079"
                },
                {
                    "start": 642,
                    "end": 646,
                    "matchedPaperCorpusId": "12476837"
                },
                {
                    "start": 654,
                    "end": 658,
                    "matchedPaperCorpusId": "207116116"
                },
                {
                    "start": 1313,
                    "end": 1317,
                    "matchedPaperCorpusId": "42867257"
                },
                {
                    "start": 1319,
                    "end": 1323,
                    "matchedPaperCorpusId": "39706110"
                },
                {
                    "start": 1514,
                    "end": 1518,
                    "matchedPaperCorpusId": "31262336"
                },
                {
                    "start": 1758,
                    "end": 1762,
                    "matchedPaperCorpusId": "16926659"
                },
                {
                    "start": 1857,
                    "end": 1861,
                    "matchedPaperCorpusId": "14879345"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.97607421875
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "2) DIAGRAM-BASED TOOLS Tools using the diagram-based approach empower users to construct a program by connecting together visual components where the output of a component serves as a data input to another component. In some tools such as [41], the visual components may represent data sets and algorithms, whereas in other tools such as [42], the visual components simply represent graphical components. Further, the user can configure these services by setting its properties. \n\nAs an example, the tool in [41] uses a diagram-based approach to building deep learning models. End users drag and drop layers (available on the left menu), configure their properties, and connect them to build a deep neural network without writing code. The layers include data sets and activation functions. The tool provides initial default configuration of the parameters of each layer which the end user can change. Further, the tool displays error messages and suggestions on the right side. \n\nAnother example of a diagram-based approach is described in [42]. End users design 3D interactive graphics by dragging and dropping blocks to the tool environment. Each block represents a 3D object. The end-user can connect the objects together using lines. Further, the end user can specify interactivity by graphically configuring an object to do some logic (e.g. when the user taps an object, another object can show up or a sound segment is played). \n\nThe article in [45] uses a diagram-based approach to allow the development of IoT and robotics-based applications. The tool uses Microsoft Visual Programming Language (MVPL) which provides a graphical dataflow-based programming model [95]. The program allows concurrent development as it uses the metaphor of multiple workers on an assembly line, who perform tasks as jobs arrive. The article presents an example of building an application of a robot navigating through a maze autonomously. The application is entirely built with blocks such as variables, data items, and conditionals that are connected visually to show the dataflow. \n\n3) BLOCK-BASED TOOLS Tools using the block-based approach allow users to construct a program by combining together visual blocks that fit together like a jigsaw puzzle.",
            "score": 0.49137877811584296,
            "section_title": "1) FORM-BASED TOOLS",
            "char_start_offset": 28883,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 216
                },
                {
                    "start": 217,
                    "end": 404
                },
                {
                    "start": 405,
                    "end": 478
                },
                {
                    "start": 481,
                    "end": 576
                },
                {
                    "start": 577,
                    "end": 735
                },
                {
                    "start": 736,
                    "end": 790
                },
                {
                    "start": 791,
                    "end": 901
                },
                {
                    "start": 902,
                    "end": 978
                },
                {
                    "start": 981,
                    "end": 1046
                },
                {
                    "start": 1047,
                    "end": 1144
                },
                {
                    "start": 1145,
                    "end": 1179
                },
                {
                    "start": 1180,
                    "end": 1238
                },
                {
                    "start": 1239,
                    "end": 1434
                },
                {
                    "start": 1437,
                    "end": 1551
                },
                {
                    "start": 1552,
                    "end": 1676
                },
                {
                    "start": 1677,
                    "end": 1817
                },
                {
                    "start": 1818,
                    "end": 1927
                },
                {
                    "start": 1928,
                    "end": 2071
                },
                {
                    "start": 2074,
                    "end": 2242
                }
            ],
            "ref_mentions": [
                {
                    "start": 239,
                    "end": 243,
                    "matchedPaperCorpusId": "146808112"
                },
                {
                    "start": 338,
                    "end": 342,
                    "matchedPaperCorpusId": "218969033"
                },
                {
                    "start": 508,
                    "end": 512,
                    "matchedPaperCorpusId": "146808112"
                },
                {
                    "start": 1041,
                    "end": 1045,
                    "matchedPaperCorpusId": "218969033"
                },
                {
                    "start": 1452,
                    "end": 1456,
                    "matchedPaperCorpusId": "67453782"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.95947265625
        },
        {
            "corpus_id": "12337509",
            "title": "Exploiting XPG for Visual Languages: Definition, Analysis and Development",
            "text": "The importance of graphical notations in human-computer interaction and human-human communication, and the decreasing cost of hardware technologies and graphics software have caused the development of a large number of visual languages in many different application fields [4,10,14]. In particular, visual modeling languages are largely used in the software engineering field since they allow designers to provide suitable models of the system at different levels of abstraction.\n\nOne of the main question in the visual languages research field is how to specify visual languages. Informally, a visual language can be seen as a set of diagrams which represent the valid sentences for the language and each diagram is a collection of visual symbols arranged in the Cartesian plane.\n\nDuring the last years formal methods are achieving increasing importance in the context of visual languages. Indeed, much effort is presently put to develop formal techniques for specifying, designing and implementing visual languages [3,10,15,16,20]. Several of such methods are grammar-based, even if, other different approaches have been investigated in the last years, such as logic-based [12] and algebraic approaches [22]. The literature offers several grammatical formalisms for the specification of visual languages, which differ one from another under several aspects [10,15,16,20].\n\nIn this paper we focus our attention on the approach of Extended Positional Grammars which represent a direct extension of context-free string grammars where more general relations other than concatenation are allowed. Indeed, the idea behind the definition of such formalism has been to exploit the well-established theoretical background and techniques developed for string languages in the field of visual languages. The paper highlights the expressive power of the formalism which turns out to be able to describe complex visual languages and at same time to stress the benefits that can be derived from providing a specification of a language in terms of the XPG model. In particular, we show how the use of context-free style productions can simplify the development of complex visual languages allowing us to effectively adopt an incremental approach. On the defined language several tasks can be easily performed such as customization and modifications as well as the maintenance and the debug. Moreover, syntax-directed translations can be carried out based on the syntactic structure, which is the output of the syntactic analysis process, in order to verify properties of visual sentences.",
            "score": 0.4808570682732731,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 273,
                    "end": 276,
                    "matchedPaperCorpusId": "60085966"
                },
                {
                    "start": 276,
                    "end": 279,
                    "matchedPaperCorpusId": "14994189"
                },
                {
                    "start": 1017,
                    "end": 1020,
                    "matchedPaperCorpusId": "18340461"
                },
                {
                    "start": 1020,
                    "end": 1023,
                    "matchedPaperCorpusId": "14994189"
                },
                {
                    "start": 1026,
                    "end": 1029,
                    "matchedPaperCorpusId": "12792951"
                },
                {
                    "start": 1029,
                    "end": 1032,
                    "matchedPaperCorpusId": "17252216"
                },
                {
                    "start": 1175,
                    "end": 1179,
                    "matchedPaperCorpusId": "206874431"
                },
                {
                    "start": 1205,
                    "end": 1209,
                    "matchedPaperCorpusId": "11930938"
                },
                {
                    "start": 1359,
                    "end": 1363,
                    "matchedPaperCorpusId": "14994189"
                },
                {
                    "start": 1366,
                    "end": 1369,
                    "matchedPaperCorpusId": "12792951"
                },
                {
                    "start": 1369,
                    "end": 1372,
                    "matchedPaperCorpusId": "17252216"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78515625
        },
        {
            "corpus_id": "199002134",
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "text": "The visual programming environment (VPE) and block-based programming environment have been referred in many research studies as important tools to learn programming and to solve many problems taught in primary schools. In fact, visual programming with blocks is a great support in introducing programming and saves pupils from the difficulties of traditionally complex text-based languages [27,36]. \n\nIn 1990, Myers [37] defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program [29]. In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming [38]. Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together [39]. \n\nThe most popular of these environments used in early programming education is Scratch, but there many others available like App Inventor, Alice, and PencilCode. While these VPEs differ in many aspects and characteristics, they have similar programming principles and purposes. \n\nThis kind of programming environment is recognized by different researchers as an interesting way to preventing errors and reducing the cognitive overload to novice programmers [40]. Most common syntax errors found in text-based languages are avoided or they cannot occur [41].",
            "score": 0.4746908767174216,
            "section_title": "Visual and Block-based Programming Environment",
            "char_start_offset": 12132,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 218
                },
                {
                    "start": 219,
                    "end": 398
                },
                {
                    "start": 401,
                    "end": 547
                },
                {
                    "start": 548,
                    "end": 674
                },
                {
                    "start": 675,
                    "end": 679
                },
                {
                    "start": 680,
                    "end": 973
                },
                {
                    "start": 974,
                    "end": 1205
                },
                {
                    "start": 1208,
                    "end": 1409
                },
                {
                    "start": 1410,
                    "end": 1624
                },
                {
                    "start": 1625,
                    "end": 1871
                },
                {
                    "start": 1874,
                    "end": 2034
                },
                {
                    "start": 2035,
                    "end": 2150
                },
                {
                    "start": 2153,
                    "end": 2335
                },
                {
                    "start": 2336,
                    "end": 2430
                }
            ],
            "ref_mentions": [
                {
                    "start": 394,
                    "end": 397,
                    "matchedPaperCorpusId": "17459721"
                },
                {
                    "start": 416,
                    "end": 420,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1404,
                    "end": 1408,
                    "matchedPaperCorpusId": "59528289"
                },
                {
                    "start": 1619,
                    "end": 1623,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 1866,
                    "end": 1870,
                    "matchedPaperCorpusId": "51750550"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94384765625
        },
        {
            "corpus_id": "236566925",
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "text": "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23) .3 The Third Axis: Fatal electronic games: \n\nThrough this axis, the researchers reviewed the concept of fatal games, some fatal games that have recently spread and become popular (Blue Whale, Mariam), in addition to some early warning signs of the seriousness of fatal electronic games.",
            "score": 0.47108735754461806,
            "section_title": "Some visual programming languages:",
            "char_start_offset": 30409,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 79
                },
                {
                    "start": 82,
                    "end": 265
                },
                {
                    "start": 266,
                    "end": 591
                },
                {
                    "start": 594,
                    "end": 769
                },
                {
                    "start": 770,
                    "end": 901
                },
                {
                    "start": 902,
                    "end": 1111
                },
                {
                    "start": 1112,
                    "end": 1337
                },
                {
                    "start": 1338,
                    "end": 1340
                },
                {
                    "start": 1341,
                    "end": 1380
                },
                {
                    "start": 1383,
                    "end": 1624
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.935546875
        },
        {
            "corpus_id": "221340525",
            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
            "text": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text. These languages can potentially allow young people to acquire the computational concepts more easily by reducing unnecessary syntax and facilitating the use of dragging and snapping the command blocks. With such features, these frameworks can help reduce the cognitive load on novices by allowing them to focus on the logic and structures of a program rather than worrying about the syntax and the mechanism of coding [3]. \n\nThere is a rich history of different visual programming tools designed for novices comprehensively surveyed in [4]. AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language [6]. Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch [6]. \n\nScratch was created by MIT Media Lab's Lifelong Kindergarten Group in collaboration with Yasmin Kafai's group at UCLA [7]. The main idea for Scratch was inspired by LEGO bricks, as Scratch research team worked closely with LEGO company [8]. Scratch grammar was converted to a programming blocks which represent the bricks in the LEGO. To create a program, users need to simply tinker the blocks together [8]. Thereafter, in the third version of Scratch, they collaborated with Blockly, a project developed by Google. Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets [6]. According to [6], Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language. Fig. 1 demonstrates how a Python code block looks like in Scratch programming language. In 2015, Scratch team presented the scratch extension system to enable programmers to innovate on the language itself by extending it [2]. In addition, \"enabling learners with a diverse set of interests to engage in programming with Scratch by opening up a number of previously unavailable pathways, through new domain-specific programming primitives\" [2].",
            "score": 0.46064432315507237,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 3910,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 137
                },
                {
                    "start": 138,
                    "end": 339
                },
                {
                    "start": 340,
                    "end": 560
                },
                {
                    "start": 563,
                    "end": 678
                },
                {
                    "start": 679,
                    "end": 808
                },
                {
                    "start": 809,
                    "end": 894
                },
                {
                    "start": 895,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1138
                },
                {
                    "start": 1139,
                    "end": 1256
                },
                {
                    "start": 1257,
                    "end": 1350
                },
                {
                    "start": 1351,
                    "end": 1424
                },
                {
                    "start": 1425,
                    "end": 1532
                },
                {
                    "start": 1533,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1789
                },
                {
                    "start": 1790,
                    "end": 1925
                },
                {
                    "start": 1926,
                    "end": 2013
                },
                {
                    "start": 2014,
                    "end": 2152
                },
                {
                    "start": 2153,
                    "end": 2370
                }
            ],
            "ref_mentions": [
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 890,
                    "end": 893,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1009,
                    "end": 1012,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1785,
                    "end": 1788,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 1803,
                    "end": 1806,
                    "matchedPaperCorpusId": "41867280"
                },
                {
                    "start": 2148,
                    "end": 2151,
                    "matchedPaperCorpusId": "17452915"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9208984375
        },
        {
            "corpus_id": "67344764",
            "title": "Mosaicode and the visual programming of Web Application for Music and Multimedia",
            "text": "Mosaicode (SCHIAVONI; GON\u00c7ALVES, 2017a) is a Graphical programming environment to create Visual Programming Languages, normally based on a specific domain, like a DSL. Initially developed as a Computer Vision Programming Environment to generate C code to OpenCV library, Mosaicode has been expanded to other programming languages and domains such as Python and Image Processing. The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator. Every single block and connection defines code fragments and add code Snippets of the application final code. The application code also depends on a code template that defines how the code snippets will be merged into the final application. Once a diagram is completed, it is possible to generate the application source code and run it. Figure 4 presents a generated source code. The tool has an interface and a plugin manager that allows the creation of new components for the environment, like Blocks, Ports and Code Templates, so the tool can be extended, allowing the generation of source code to different programming languages and specific domains. The creation of new blocks for code generation consists of a Python class extending the BlockModel class. The BlockModel class offers three sets of properties that must be specialized for that the new block to behave properly. The first set, called Definition, consists of determining an identifier of the block, the language, the framework it will compose and its source information.",
            "score": 0.45924067623495074,
            "section_title": "About the Mosaicode",
            "char_start_offset": 10595,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 167
                },
                {
                    "start": 168,
                    "end": 378
                },
                {
                    "start": 379,
                    "end": 466
                },
                {
                    "start": 467,
                    "end": 546
                },
                {
                    "start": 547,
                    "end": 655
                },
                {
                    "start": 656,
                    "end": 825
                },
                {
                    "start": 826,
                    "end": 914
                },
                {
                    "start": 915,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1107
                },
                {
                    "start": 1108,
                    "end": 1191
                },
                {
                    "start": 1192,
                    "end": 1337
                },
                {
                    "start": 1338,
                    "end": 1447
                },
                {
                    "start": 1448,
                    "end": 1578
                },
                {
                    "start": 1579,
                    "end": 1674
                },
                {
                    "start": 1675,
                    "end": 1717
                },
                {
                    "start": 1718,
                    "end": 1992
                },
                {
                    "start": 1993,
                    "end": 2098
                },
                {
                    "start": 2099,
                    "end": 2219
                },
                {
                    "start": 2220,
                    "end": 2377
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89306640625
        },
        {
            "corpus_id": "58394",
            "title": "Towards rule-based visual programming of generic visual systems",
            "text": "Many data structures can be represented by graphs, and the theory of graph transformation [22] provides a profound computational model for rule-based programming with graphs. As graphs are inherently visual, and have been used as an abstract model for visual representations [2,9,14], graph transformation could become widely accepted as a paradigm of rule-based visual programming. \n\nHowever, existing programming languages based on graph transformation, such as PROGRES [23] or LUDWIG 2 [18], have not been as successful as one could expect. We believe that this has two major reasons: \n\n\u2022 The structuring of graphs as nested graph objects, and thus object-oriented programming are not supported. \u2022 It is not possible to customize the \"standard\" graph notation to the visual notation of particular application domains. However, some approaches to these problems exist for visual environments which are not based on graphs: Object-oriented programming languages have been developed in the visual programming community [3], notably Prograph [5]. Furthermore, there are visual language tools which allow to use domain-specific visual representations, e.g., CALYPSO, a tool for visually defining data structures of programs [28]. However, we are not aware of any language or tool that allows to visually specify and generate visual language environments which then use domain-specific visual representations. \n\nThis paper is about DIAPLAN, a visual, rule-based programming language and environment for implementing visual languages, which offers just these features. The DIAPLAN programming environment consists of \u2022 a visual programming language which supports graph typing and structuring as well as object-oriented programming for specifying graph transformations. These rules specify the behavior of the generated visual language. \u2022 a tool for specifying how graphs are represented by domain-specific diagrams in the generated visual language and how the user can interact with these diagrams. This makes DIAPLAN a generic environment. The paper is organized as follows: Section 2 describes graph transformation, the computational model of the language. Concepts for programming are illustrated in Section 3, and typing is discussed in Section 4. A complete example of a DIAPLAN program for solving graph coloring problems is discussed in Section 5. Section 6 recalls how graphs can be visualized in arbitrary diagram notations. Genericity of the language is based on this feature.",
            "score": 0.4587781235239201,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 174
                },
                {
                    "start": 175,
                    "end": 382
                },
                {
                    "start": 385,
                    "end": 543
                },
                {
                    "start": 544,
                    "end": 587
                },
                {
                    "start": 590,
                    "end": 698
                },
                {
                    "start": 699,
                    "end": 820
                },
                {
                    "start": 821,
                    "end": 1045
                },
                {
                    "start": 1046,
                    "end": 1227
                },
                {
                    "start": 1228,
                    "end": 1406
                },
                {
                    "start": 1409,
                    "end": 1564
                },
                {
                    "start": 1565,
                    "end": 1765
                },
                {
                    "start": 1766,
                    "end": 1832
                },
                {
                    "start": 1833,
                    "end": 1995
                },
                {
                    "start": 1996,
                    "end": 2037
                },
                {
                    "start": 2038,
                    "end": 2155
                },
                {
                    "start": 2156,
                    "end": 2430
                },
                {
                    "start": 2431,
                    "end": 2483
                }
            ],
            "ref_mentions": [
                {
                    "start": 90,
                    "end": 94,
                    "matchedPaperCorpusId": "5238889"
                },
                {
                    "start": 275,
                    "end": 278,
                    "matchedPaperCorpusId": "5985096"
                },
                {
                    "start": 278,
                    "end": 280,
                    "matchedPaperCorpusId": "17004705"
                },
                {
                    "start": 280,
                    "end": 283,
                    "matchedPaperCorpusId": "7041014"
                },
                {
                    "start": 489,
                    "end": 493,
                    "matchedPaperCorpusId": "26536164"
                },
                {
                    "start": 1222,
                    "end": 1226,
                    "matchedPaperCorpusId": "14621382"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83935546875
        },
        {
            "corpus_id": "39606061",
            "title": "Measuring an Impact of Block-Based Language in Introductory Programming",
            "text": "The body of introductory programming is not to develop an understanding of the grammar of particular programming languages, but it should develop the problem-solving skills with computing that is called \"computational thinking\" [1]. The similar concept has been proposed by the United Nations Educational, Scientific and Cultural Organization (UNESCO), as \"designing a task-oriented algorithm\" [2]. Both statements include common sense. One is to focus on the thinking and creation of algorithms. Another is that computing is not only dependent upon the use of actual computers, but logical modeling for the required problem-solving. \n\nA use of visual language, especially \"building-block approach\" [3] is the most popular way to form the learning environment for the purpose of education. Many block-based languages for education have been proposed over more than two decades, and yet developers continue by trial and error to improve the language using modern software technology. The first workshop specifically blockbased language focused was held in the last year (Blocks and Beyond in Visual Languages and Human-Centric Computing (VL/HCC 2015) [4]). The workshop was able to collect a remarkable number of submissions, the participants discussed the design of the next generation of block-based language, including the topic of how to design the tools as a bridge to text-based language (e.g. [5,6]). \n\nHowever, as the workshop stated \"Despite their popularity, there has been remarkably little research on the usability, effectiveness, or generalizability of affordances from these environments\" [4], there is little research which provides evidence showing advantages of block-based language. Practitioners using visual programming languages believe that the visual programming approach is an effective way in developing computational thinking because learners can focus on their problem-solving tasks [7]. The block-based language should be used as scaffolding to text-based language. However, the belief is not verified, and the percentage of degree is not clear yet. \n\nHence, we tried learning data analysis with fine grain logs recorded by students' development environment. We conducted the introductory education using the tools we developed, where the learners can switch their language between visual-block language (Block) and one for a text-based language (Java) by bidirectional translation technology.",
            "score": 0.45101123844901714,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 232
                },
                {
                    "start": 233,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 436
                },
                {
                    "start": 437,
                    "end": 496
                },
                {
                    "start": 497,
                    "end": 633
                },
                {
                    "start": 636,
                    "end": 789
                },
                {
                    "start": 790,
                    "end": 982
                },
                {
                    "start": 983,
                    "end": 1155
                },
                {
                    "start": 1156,
                    "end": 1398
                },
                {
                    "start": 1399,
                    "end": 1406
                },
                {
                    "start": 1409,
                    "end": 1700
                },
                {
                    "start": 1701,
                    "end": 1914
                },
                {
                    "start": 1915,
                    "end": 1993
                },
                {
                    "start": 1994,
                    "end": 2077
                },
                {
                    "start": 2080,
                    "end": 2186
                },
                {
                    "start": 2187,
                    "end": 2421
                }
            ],
            "ref_mentions": [
                {
                    "start": 228,
                    "end": 231,
                    "matchedPaperCorpusId": "41391768"
                },
                {
                    "start": 1399,
                    "end": 1402,
                    "matchedPaperCorpusId": "40151963"
                },
                {
                    "start": 1402,
                    "end": 1404,
                    "matchedPaperCorpusId": "10876307"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.69970703125
        },
        {
            "corpus_id": "235641449",
            "title": "Matters of Neural Network Repository Designing for Analyzing and Predicting of Spatial Processes",
            "text": "When developing visual programming languages, drawing of graphs is used as the main approach, that is, in the form of a set of vertices (nodes) connected by arcs (edges). Unlike the textual form of notation, in which objects (symbols and words) form a sequence, and each object is associated only with the left and right \"neighbors\", the graph form allows you to visually depict more complex relationships, since in it each object can be connected to several others objects. In this sense, the text form is one-dimensional, while the graph form is twodimensional. The ability to vary the geometric dimensions, shape and color of vertices, the appearance and thickness of arcs, change the relative position of the vertices without changing the topology of the graph significantly increases the expressive capabilities of the graph form of the program algorithm. \n\nThe creation of a visual (figurative) style of software development is the main motive for the development of graphsymbolic programming (GSP) technology. GSP technology is a technology for designing and coding algorithms and models based on a graphical way of representing programs, with the goal of fully or partially automating the design, coding and testing of software. This programming technology adheres to two fundamental principles: a) visual, graphical form of presentation of program algorithms and other components of their specifications; b) the principle of structured procedural programming. The implementation of this concept is excellent for solving the problem of visual programming of neural networks. Visual programming increases the clarity of the presented codes, significantly reduces the number of errors made at the design and coding stage of programs, and thereby speeds up the development process and increases the reliability of codes of developed programs. Together with the use of the block approach, visual programming methods will not only speed up development due to simple graphical interchangeability of logical blocks, but also provide simple portability of such programs. An application programming interface (API) based on the REST architectural pattern provides a unified interaction with the system for programmatic data exchange, including deep model export, editing, structured data retrieval, and other use cases. \n\nThe main directions for the further use of the expected results: \n\n1) Implementation of intelligent systems for forecasting the development of natural and man-made emergency processes based on new technologies of integration, intellectual analysis and dissemination of large geospatial data into the activities of industrial enterprises and executive authorities of the region.",
            "score": 0.44726912808580827,
            "section_title": "C. Development of Interfaces for Interacting with the Repository",
            "char_start_offset": 17906,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 170
                },
                {
                    "start": 171,
                    "end": 474
                },
                {
                    "start": 475,
                    "end": 563
                },
                {
                    "start": 564,
                    "end": 860
                },
                {
                    "start": 863,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1236
                },
                {
                    "start": 1237,
                    "end": 1468
                },
                {
                    "start": 1469,
                    "end": 1582
                },
                {
                    "start": 1583,
                    "end": 1847
                },
                {
                    "start": 1848,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2318
                },
                {
                    "start": 2321,
                    "end": 2385
                },
                {
                    "start": 2388,
                    "end": 2698
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85546875
        },
        {
            "corpus_id": "209056321",
            "title": "Tiny Thing Blocks: Integrating Everyday Objects into IoT Context",
            "text": "The result of the previous steps is a new language based on the Graphviz format. Like any other language, this one has a curve of learning and requires of its user knowledge about programming languages. So, we decided to create a more accessible approach to develop using this language. This method is a visual language that represents the structures using blocks. According to S. Chang and M. Erwing, a visual programming language (VLP) is one language that allows the users to develop programs using graphic elements in the place of specifying them textually. To built this language we used the library Blockly, which allowed us to create a visual language based on blocks [4], [6]. \n\nThe Tiny Thing Blocks is an open-source tool that allows the user to develop code for the Tiny Thing module without programming with a text editor. Each block was designed to represent the syntax of one structure of the new language. \n\nThe blocks represent declarations of nodes in the model, but not all of these nodes are one part of the final code. Some of the declarations of a block are used only to create the FSM. These declarations are responsible for representing the transition between states. \n\nFigure 13 and Figure 14 show the declarations of state transitions, which is the base of creating an FSM. However, Figura 13. example of transition for actuators devices Figura 14. Example of transition for sensors devices this model is the expected behavior of the device, and the tool does not cover the code for functions. In Section VI, we talk more about changes that would happen at the features of this tool. \n\nThere are four categories to categorize the blocks, and each one is a cluster of blocks that are directly linked. \n\n\u2022 The first category is the \"device\"it is the two blocks responsible for starting and finishing the model. \n\nFigura 15. Device blocks \n\nThe second is the \"pin's blocks\"category. This one encapsulates the declaration of which pins will the device use. \n\nFigura 16. Pin's blocks \n\n\u2022 The third category is the \"state's blocks\". This category encapsulates the blocks which declare the states which the device use, the blocks of transition between states in the case of the device is an actuator and the declaration of the initial state for the model.",
            "score": 0.44697767811167344,
            "section_title": "C. Visual programming language",
            "char_start_offset": 12454,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 80
                },
                {
                    "start": 81,
                    "end": 202
                },
                {
                    "start": 203,
                    "end": 286
                },
                {
                    "start": 287,
                    "end": 364
                },
                {
                    "start": 365,
                    "end": 561
                },
                {
                    "start": 562,
                    "end": 684
                },
                {
                    "start": 687,
                    "end": 834
                },
                {
                    "start": 835,
                    "end": 920
                },
                {
                    "start": 923,
                    "end": 1038
                },
                {
                    "start": 1039,
                    "end": 1107
                },
                {
                    "start": 1108,
                    "end": 1190
                },
                {
                    "start": 1193,
                    "end": 1298
                },
                {
                    "start": 1299,
                    "end": 1518
                },
                {
                    "start": 1519,
                    "end": 1608
                },
                {
                    "start": 1611,
                    "end": 1724
                },
                {
                    "start": 1727,
                    "end": 1833
                },
                {
                    "start": 1836,
                    "end": 1846
                },
                {
                    "start": 1847,
                    "end": 1860
                },
                {
                    "start": 1863,
                    "end": 1904
                },
                {
                    "start": 1905,
                    "end": 1977
                },
                {
                    "start": 1980,
                    "end": 1990
                },
                {
                    "start": 1991,
                    "end": 2003
                },
                {
                    "start": 2006,
                    "end": 2051
                },
                {
                    "start": 2052,
                    "end": 2273
                }
            ],
            "ref_mentions": [
                {
                    "start": 680,
                    "end": 683,
                    "matchedPaperCorpusId": "10570737"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.876953125
        },
        {
            "corpus_id": "259335765",
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "text": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool [6,7], to high school [8], to college [9]. The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors [12]. This ease of use often hides the fact that many of these languages still support sophisticated programming constructs to include complex data structures, file handling, arrays, mouse and keyboard inputs, and parallel code [13]. \n\nProgramming requires computational, algorithmic, and logical thinking [14]. Solving a problem then requires problem identification, understanding syntax, semantics, and com plexity of a programming language [14]. Visual programming languages have the ability to introduce these topics to a wide audience. These languages have been available since the 1990s with LogoBlocks, but were limited in scope and availability [15]. Over the past decade, the field of introductory programming languages has proliferated with many different visual programming languages [14]. This explosion of options and the ease of use of the languages have fostered an environment where younger children can be introduced to programming [13]. There are many options, but popular ones include code.org, Scratch, and Alice. In [6], Scratch was introduced to preschool educators and evaluated basic computational and logical thinking. All educators saw the direct benefits and 85.7% said it should be taught to preschool students. Continuing this idea, [16] concludes that the early introduction of computational and logical thinking into the kindergarten curriculum helps with cognitive thinking. Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities.",
            "score": 0.44662867939248974,
            "section_title": "Visual Programming",
            "char_start_offset": 4631,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 76
                },
                {
                    "start": 77,
                    "end": 187
                },
                {
                    "start": 188,
                    "end": 278
                },
                {
                    "start": 279,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 548
                },
                {
                    "start": 549,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 788
                },
                {
                    "start": 789,
                    "end": 1016
                },
                {
                    "start": 1019,
                    "end": 1094
                },
                {
                    "start": 1095,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1323
                },
                {
                    "start": 1324,
                    "end": 1441
                },
                {
                    "start": 1442,
                    "end": 1583
                },
                {
                    "start": 1584,
                    "end": 1737
                },
                {
                    "start": 1738,
                    "end": 1796
                },
                {
                    "start": 1797,
                    "end": 1816
                },
                {
                    "start": 1817,
                    "end": 1926
                },
                {
                    "start": 1927,
                    "end": 2022
                },
                {
                    "start": 2023,
                    "end": 2189
                },
                {
                    "start": 2190,
                    "end": 2356
                }
            ],
            "ref_mentions": [
                {
                    "start": 145,
                    "end": 148,
                    "matchedPaperCorpusId": "253196672"
                },
                {
                    "start": 148,
                    "end": 150,
                    "matchedPaperCorpusId": "235383033"
                },
                {
                    "start": 167,
                    "end": 170,
                    "matchedPaperCorpusId": "10976181"
                },
                {
                    "start": 183,
                    "end": 186,
                    "matchedPaperCorpusId": "35735491"
                },
                {
                    "start": 783,
                    "end": 787,
                    "matchedPaperCorpusId": "51750550"
                },
                {
                    "start": 1089,
                    "end": 1093,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1226,
                    "end": 1230,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1436,
                    "end": 1440,
                    "matchedPaperCorpusId": "198986538"
                },
                {
                    "start": 1578,
                    "end": 1582,
                    "matchedPaperCorpusId": "199002134"
                },
                {
                    "start": 1820,
                    "end": 1823,
                    "matchedPaperCorpusId": "253196672"
                },
                {
                    "start": 2045,
                    "end": 2049,
                    "matchedPaperCorpusId": "239681487"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91162109375
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "Diagrams and other graphical logic and/or model representations have been playing a role in software development since the appearance of the modern digital computers in the 1940s. In the beginning, the diagrams were paper-based aids, used to design and understand the software structure, but then, interest appeared in the direct use of diagrams as a solution to improve software development tools. This led to the appearing of visual software project management tools, visual editors for graphical interface creation, visual tools for software modeling and engineering, and visual programming languages [Cox 2007]. \n\nA Visual Programming Language (VPL) can be defined, as described in the Wiley Encyclopedia of Computer Science and Engineering [S. K. Chang 2002], as: \n\nA language in which significant parts of the structure of a program are represented in a pictorial notation, which may include icons, connecting lines indicating relationships, motion, color, texture, shading, or any other non-textual device. \n\nAs such, visual programming makes use of an extensive set of icons and diagrams to convey information and to allow multi-modal communication and interaction between humans and computers [S. K. Chang 2002]. \n\nVPLs have been explored and used in several domains, including, but not limited to, educational activities (e.g. learning to program), multimedia, video game development, system design and development, simulations, automation, data warehousing and business analytics [ Ray 2017]. \n\nAlthough several domains of applications already take advantage of the use of VPLs, the emerging field of Internetof-Things (IoT) is still lingering far behind other sectors. \n\nVisual Programming Languages are commonly used with the intent of abstracting low-level concepts and details into a more high-level logic, through the use of visual metaphors [Barricelli and Valtolina 2015;Thomas and Barry 2003]. The application of domain-specific visual programming languages to solve the need of abstraction from the low-level and heterogeneous devices that usually make a part in the IoT connected world can already be observed. We can consider, as an example, how graphical-based programming languages are already widely used for programming low-level devices such as Programmed Logic Controllers (PLCs) in high-production manufacturing systems [Younis and Frey 2003]. \n\nThe goal of this section is to review the landscape of visual programming environments (viz.",
            "score": 0.4462610459287506,
            "section_title": "Visual Programming for IoT",
            "char_start_offset": 44329,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 179
                },
                {
                    "start": 180,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 615
                },
                {
                    "start": 618,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 768
                },
                {
                    "start": 771,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1205
                },
                {
                    "start": 1206,
                    "end": 1221
                },
                {
                    "start": 1224,
                    "end": 1336
                },
                {
                    "start": 1337,
                    "end": 1503
                },
                {
                    "start": 1506,
                    "end": 1680
                },
                {
                    "start": 1683,
                    "end": 1912
                },
                {
                    "start": 1913,
                    "end": 2131
                },
                {
                    "start": 2132,
                    "end": 2372
                },
                {
                    "start": 2375,
                    "end": 2467
                }
            ],
            "ref_mentions": [
                {
                    "start": 752,
                    "end": 763,
                    "matchedPaperCorpusId": "48762803"
                },
                {
                    "start": 1209,
                    "end": 1220,
                    "matchedPaperCorpusId": "48762803"
                },
                {
                    "start": 1493,
                    "end": 1502,
                    "matchedPaperCorpusId": "30037917"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8720703125
        },
        {
            "corpus_id": "235234208",
            "title": "Collaborative Coding in a Robotic Visual Language",
            "text": "Block-based languages are a class of visual programming languages where the code constrcuts are blocks that should be connected to each other. \n\nIn this case, the programmer has to drag the needed blocks and drop them in the editor and connect them together shown in Figure 1. Blocks usually contain visual hints that eliminate the possibility of having wrong connections or programs.",
            "score": 0.4439982908604859,
            "section_title": "Block-based Programming",
            "char_start_offset": 2785,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 142
                },
                {
                    "start": 145,
                    "end": 276
                },
                {
                    "start": 277,
                    "end": 384
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9404296875
        },
        {
            "corpus_id": "86787308",
            "title": "Development of application software without programming",
            "text": "Visual programming and parameterization tools allow the creation of a program logic by stacking and linking visual elements and their spatial layout instead of writing textual commands of the programming language [12]. Semantic and syntax rules, as well as textual programming languages, are still used, but the language elements in this case are represented by graphical symbols. Although these are tools for developing applications without programming, they still need to be familiar with the programming principles. With the \"right\" visual programming tools there is no need to write program commands or other texts, except in cases where it is necessary to designate program elements (variables, labels, blocks, etc.) for transparency purposes. Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools. Typical representatives of the graphical editing tool for the user interface are MS Visual Studio and MS Expression Blend. \n\nThe basic advantage of the visual programming language is that it requires little initial knowledge in order to be able to start efficiently using it. This is because all the elements of the programming language, its semantics and syntax are visually represented, and the use of context dependencies dynamically narrows the choice of elements that can be used and in this way the user facilitates the programming process. All tools in this group are, in fact, software tools, and of the classic programming tools they differ only in that programming is not carried out by writing textual commands of the programming language, but by stacking graphic elements.",
            "score": 0.4394783042499773,
            "section_title": "Visual programming and parametrization",
            "char_start_offset": 15443,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 218
                },
                {
                    "start": 219,
                    "end": 380
                },
                {
                    "start": 381,
                    "end": 518
                },
                {
                    "start": 519,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 1062
                },
                {
                    "start": 1063,
                    "end": 1185
                },
                {
                    "start": 1188,
                    "end": 1338
                },
                {
                    "start": 1339,
                    "end": 1609
                },
                {
                    "start": 1610,
                    "end": 1847
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92333984375
        },
        {
            "corpus_id": "4793447",
            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
            "text": "The visual programming language in topic is a command based model and the processing of each of the command is expected to be done in a distributed manner. Since this model was developed targeting modular systems like robot kits, the main motive was to coordinate tasks done by the connected modules. These tasks can be standalone tasks which can be simply started and ignored and some other tasks in which the results are passed to decision making. For example, in the context of a robot kit, there can be a task which makes the robot turn right and also a task to measure the distance to an obstacle using a sensor. The visual programming model is developed to program the central controlling entity that can control all the other connected modules by issuing commands and analysing their results. The important point here is that due to this configuration, the output of the visual programming environment can be made extremely simple and uniform as the native executions of the tasks are offloaded to various modules which are built with all the necessary algorithms and other programming components. The visual programming model that we introduce requires the target system to have the above characteristics. This visual programming environment contains a library of programming blocks and an editor area which is used to place and order the dragged and dropped programming blocks in order to create the intended program. These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks. These blocks were sufficient for the intended task of the original work, but the same concepts can be extended to other blocks as required.",
            "score": 0.43162795378826974,
            "section_title": "WORK DEVELOPED",
            "char_start_offset": 5574,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 155
                },
                {
                    "start": 156,
                    "end": 300
                },
                {
                    "start": 301,
                    "end": 449
                },
                {
                    "start": 450,
                    "end": 617
                },
                {
                    "start": 618,
                    "end": 799
                },
                {
                    "start": 800,
                    "end": 1104
                },
                {
                    "start": 1105,
                    "end": 1213
                },
                {
                    "start": 1214,
                    "end": 1426
                },
                {
                    "start": 1427,
                    "end": 1477
                },
                {
                    "start": 1478,
                    "end": 1540
                },
                {
                    "start": 1541,
                    "end": 1650
                },
                {
                    "start": 1651,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1850
                },
                {
                    "start": 1851,
                    "end": 1936
                },
                {
                    "start": 1937,
                    "end": 2045
                },
                {
                    "start": 2046,
                    "end": 2161
                },
                {
                    "start": 2162,
                    "end": 2230
                },
                {
                    "start": 2231,
                    "end": 2370
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94091796875
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "Visual languages adopted for learning purposes become stepping stones to acquire more advanced skills and further exploit the expressive power of a real language. Essentially, visual languages are blankets which hide or abstract the underlying complexity of the real language and its detailed programming model. However, this does not imply that the syntax and semantics of the backend language should not be transferred in the visual frontend. Completely separating those two, not only makes the transition to the real language harder, but may reduce the chances to educationally deliver fundamental concepts that are only present within the original language syntax and semantics. In particular, visual syntax concerns all geometric and graphical rules applying to visual program composition that also map directly to the grammatical elements of the underlying language. \n\nAs mentioned earlier, due to syntactic illusions, this mapping need not be very precise. However, it is crucial that the visual language is delivered in a way that its visual syntax and the corresponding semantics are explicitly and naturally mapped, linking unambiguously to backend language semantics. Elements like recursion, repetition, nesting and scoping should be appropriately represented by corresponding visual structures. \n\nExamples: Spreadsheets are treated as visual programming systems with their backend relying on grid formulas and constraints. Theoretically, formulas reflect a functional style that users directly deploy over a visual grid, with interactive facilities to refer to grid cells, individually or collectively, via pick or group selection. The syntax and semantics of the underlying language are completely visible, implying spreadsheets are less visual languages and more scripting systems on grid elements. Scratch (Maloney et al., 2010) adopts a concise visual syntax, with encoding of elements and placeholders (as outlined under Figure 4) that maps directly to the text language. However, there is a simplification and potential information loss, since sub-categories of expressions and statements all map to just a single syntactic visual symbol. An increasingly popular visual system is Node-RED (Open JS Foundation, 2022), adopting the flow-based paradigm that hides the underlying details of event-driven programming via consumerproducer chains. As a result, the syntax of event blocks is hidden, while event management is semantically treated as data flows. But still to introduce new custom nodes, one should directly program them in JavaScript.",
            "score": 0.4296219487285012,
            "section_title": "Visible Syntax and Semantics",
            "char_start_offset": 6190,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 162
                },
                {
                    "start": 163,
                    "end": 311
                },
                {
                    "start": 312,
                    "end": 444
                },
                {
                    "start": 445,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 872
                },
                {
                    "start": 875,
                    "end": 963
                },
                {
                    "start": 964,
                    "end": 1178
                },
                {
                    "start": 1179,
                    "end": 1307
                },
                {
                    "start": 1310,
                    "end": 1435
                },
                {
                    "start": 1436,
                    "end": 1644
                },
                {
                    "start": 1645,
                    "end": 1813
                },
                {
                    "start": 1814,
                    "end": 1989
                },
                {
                    "start": 1990,
                    "end": 2157
                },
                {
                    "start": 2158,
                    "end": 2359
                },
                {
                    "start": 2360,
                    "end": 2472
                },
                {
                    "start": 2473,
                    "end": 2561
                }
            ],
            "ref_mentions": [
                {
                    "start": 1822,
                    "end": 1844,
                    "matchedPaperCorpusId": "9744698"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8701171875
        },
        {
            "corpus_id": "6455062",
            "title": "Visual Representation of 3D Language Constructs Specified by Generic Depictions",
            "text": "Alternatively, the third dimension can be used to focus on specific classes of interest in class diagrams [GRR99]. Some further systems in context of visual programming make use of threedimensionality. Alice [KP07] is a 3D programming environment that employs a story telling metaphor and teaches children to learn fundamental programming concepts by programming the behavior of 3D objects, e.g., people or animals. This system's effectiveness has been proven by various user studies. Another programming environment that uses three-dimensional objects is AgentCubes [IRW09], the successor of AgentSheets, which allows children to create interactive 3D games. The key challenges of AgentCubes are intuitive mechanisms to create 3D objects incrementally, including subsequent programming and animation aspects. \n\nThe above mentioned 3D languages and programming environments consist of objects with different 3D shapes. Some languages-as molecular models, ToneCraft, or Petri Nets-use relatively simple shapes like cubes, spheres, or cylinders. But the 3D scenes composed with Alice or AgentCubes consist of more complex shapes, visualizing real world objects such as people, buildings, or cars. There is an additional challenging task: Because of the fact that language constructs can be nested inside each other, their depiction needs mechanisms to adopt the size of interior constructs. \n\nOur approach relies on a tool that makes the development of 3D language editors as simple as possible. The development of a language specific implementation is justified, only if the effort is appropriately small. Therefore, effective generator systems are useful. We are developing the generator framework DEViL3D (Development Environment for Visual Languages in 3D) that accomplishes this task. One central part of developing visual languages (either two-or three-dimensional) is the definition of the visual appearance of language constructs. For such a task, DEViL3D provides a 3D editor to specify generic depictions for language constructs. They may consist of a large set of three-dimensional geometric shapes and their parameters specify where substructures are embedded, and how the graphic adapts to space requirements of nested constructs. \n\nFigure 1: A language construct before and after stretch. \n\nFigure 1 shows an exemplary language construct consisting of a blue box and a green sphere.",
            "score": 0.4232317057543027,
            "section_title": "Introduction",
            "char_start_offset": 2172,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 114
                },
                {
                    "start": 115,
                    "end": 201
                },
                {
                    "start": 202,
                    "end": 415
                },
                {
                    "start": 416,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 659
                },
                {
                    "start": 660,
                    "end": 809
                },
                {
                    "start": 812,
                    "end": 918
                },
                {
                    "start": 919,
                    "end": 1043
                },
                {
                    "start": 1044,
                    "end": 1194
                },
                {
                    "start": 1195,
                    "end": 1388
                },
                {
                    "start": 1391,
                    "end": 1493
                },
                {
                    "start": 1494,
                    "end": 1604
                },
                {
                    "start": 1605,
                    "end": 1655
                },
                {
                    "start": 1656,
                    "end": 1787
                },
                {
                    "start": 1788,
                    "end": 1936
                },
                {
                    "start": 1937,
                    "end": 2037
                },
                {
                    "start": 2038,
                    "end": 2241
                },
                {
                    "start": 2244,
                    "end": 2300
                },
                {
                    "start": 2303,
                    "end": 2394
                }
            ],
            "ref_mentions": [
                {
                    "start": 208,
                    "end": 214,
                    "matchedPaperCorpusId": "207163504"
                },
                {
                    "start": 567,
                    "end": 574,
                    "matchedPaperCorpusId": "9523126"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.693359375
        },
        {
            "corpus_id": "231785967",
            "title": "Hybrid Java: The creation of a Hybrid Programming Environment",
            "text": "\u2022 Some students found that more time was required to complete a program in a blocksbased environment as opposed to a text-based environment. \u2022 The students recounted how text-based languages often require less lines of code to be written in comparison to the number of blocks needed in a blocks-based language. \u2022 The lack of authenticity held by blocks-based programming languages in the sense that the blocks-based language was not similar enough to traditional text-based languages to effectively educate others in the ways of computer programming. \n\nSome efforts have been undertaken by researchers to bridge this gap in the past. One large area of focus has been the creation of text-based programming environments with some visual cues or elements. For example, K\u00f6lling, Quig, Patterson, & Rosenberg have developed the BlueJ programming system (2003) and K\u00f6lling has developed the Greenfoot programming environment (2010). Both environments seek to solve a particular problem. BlueJ is presented as a learning tool to aid with the difficulty of teaching object-oriented programming to novice programmers. Greenfoot has similar goals but targets itself at younger students and uses topics such as game development to help teach the concepts. Both tools aim to fill this educational gap, but neither are marketed as complete solutions, with the assumption that students will still migrate to a text-based language afterwards. \n\nA pertinent question that could be asked here is \"Is there a tool with a more longitudinal focus, or one which can be used interchangeably with a text-based language?\". With the ever changing landscape of literature in the area of FPL, and with some of it often being contradictory, the authors undertook a systematic literature review to examine the prevalence of visual and textual programming languages in education, with the aim of determining the best FPL approaches (Noone & Mooney, 2018). This review centred around two research questions: \n\n\u2022 Are there any benefits of learning a visual programming language over a traditional text-based language? \u2022 Does the choice of First Programming Language make a difference? What languages are the best ones to teach? \n\nA very quick summary of the results of this study would be to say that visual programming languages are extremely beneficial when taught to the \"right age group\". The study also further pointed to the existence of this \"educational gap\" around the ages of 14-17 where neither language type is ideal.",
            "score": 0.4225880012063582,
            "section_title": "Motivation and Background",
            "char_start_offset": 5616,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 140
                },
                {
                    "start": 141,
                    "end": 310
                },
                {
                    "start": 311,
                    "end": 550
                },
                {
                    "start": 553,
                    "end": 633
                },
                {
                    "start": 634,
                    "end": 753
                },
                {
                    "start": 754,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 981
                },
                {
                    "start": 982,
                    "end": 1109
                },
                {
                    "start": 1110,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1428
                },
                {
                    "start": 1431,
                    "end": 1599
                },
                {
                    "start": 1600,
                    "end": 1926
                },
                {
                    "start": 1927,
                    "end": 1977
                },
                {
                    "start": 1980,
                    "end": 2086
                },
                {
                    "start": 2087,
                    "end": 2153
                },
                {
                    "start": 2154,
                    "end": 2196
                },
                {
                    "start": 2199,
                    "end": 2361
                },
                {
                    "start": 2362,
                    "end": 2498
                }
            ],
            "ref_mentions": [
                {
                    "start": 1903,
                    "end": 1925,
                    "matchedPaperCorpusId": "4039308"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.60205078125
        },
        {
            "corpus_id": "231785967",
            "title": "Hybrid Java: The creation of a Hybrid Programming Environment",
            "text": "There have been numerous studies (Boshernitsan & Downes, 2004;Kiper, Howard, & Ames, 1997;S\u00e1ez-L\u00f3pez, Rom\u00e1n-Gonz\u00e1lez, & V\u00e1zquez-Cano, 2016;Weintrop & Wilensky, 2015;Whitley, 1997) undertaken to evaluate the benefits and disadvantages related to teaching programming using visual programming languages. One such study (Weintrop & Wilensky, 2015) was devised to determine if a visual blocks-based programming language would be fitting as a first programming language for students to learn. The study was focused around high school students and answered three main questions: \n\n\u2022 Is a block-based language considered easy? If so, why? \n\n\u2022 What are the differences between blocks-based and text-based languages? \n\n\u2022 What could be considered as weaknesses within blocks-based languages? \n\nThe results found that over half of the student participants surveyed found the block-based language Snap! easier to use than the text-based language Java. The reasons given for the increased ease-of-use included: \n\n\u2022 \"The lack of obscure punctuation\". \n\n\u2022 The provision of \"graphical cues\" given by the shape of the blocks, assisting the user in determining how to use them. \u2022 The \"act of dragging-and-dropping\" the blocks resulting in less errors than the traditional typing of commands. \n\nPerhaps the strongest advantage of a visual programming language to emerge from this study is the \"browsability\" of its commands as reported by (Weintrop & Wilensky, 2015). By having an easily accessible list of commands that are available to the user, the complexity of a language is reduced. This is something that text-based programming languages tend not to have, apart from libraries for more complicated elements. \n\nAlthough the block-based language was seen as easier to use than the traditional text-based language, weaknesses were also identified, including: \n\n\u2022 The limitation attached to programs that can be created, which prohibits the creation of more complex programs, a fact also discussed by Preidel et. al (2017). \u2022 Some students found that more time was required to complete a program in a blocksbased environment as opposed to a text-based environment.",
            "score": 0.42111595838574856,
            "section_title": "Motivation and Background",
            "char_start_offset": 3608,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 487
                },
                {
                    "start": 488,
                    "end": 572
                },
                {
                    "start": 575,
                    "end": 619
                },
                {
                    "start": 620,
                    "end": 631
                },
                {
                    "start": 634,
                    "end": 707
                },
                {
                    "start": 710,
                    "end": 781
                },
                {
                    "start": 784,
                    "end": 939
                },
                {
                    "start": 940,
                    "end": 997
                },
                {
                    "start": 1000,
                    "end": 1036
                },
                {
                    "start": 1039,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1273
                },
                {
                    "start": 1276,
                    "end": 1448
                },
                {
                    "start": 1449,
                    "end": 1569
                },
                {
                    "start": 1570,
                    "end": 1695
                },
                {
                    "start": 1698,
                    "end": 1843
                },
                {
                    "start": 1846,
                    "end": 2007
                },
                {
                    "start": 2008,
                    "end": 2148
                }
            ],
            "ref_mentions": [
                {
                    "start": 90,
                    "end": 139,
                    "matchedPaperCorpusId": "27633066"
                },
                {
                    "start": 139,
                    "end": 165,
                    "matchedPaperCorpusId": "207226901"
                },
                {
                    "start": 165,
                    "end": 179,
                    "matchedPaperCorpusId": "9664502"
                },
                {
                    "start": 317,
                    "end": 344,
                    "matchedPaperCorpusId": "207226901"
                },
                {
                    "start": 1420,
                    "end": 1447,
                    "matchedPaperCorpusId": "207226901"
                },
                {
                    "start": 1985,
                    "end": 2006,
                    "matchedPaperCorpusId": "34158829"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7978515625
        },
        {
            "corpus_id": "259335765",
            "title": "Using Visual Programming Games to Study Novice Programmers",
            "text": "Comparing the effectiveness of block-based programming to conventional text-based programming, [8] evaluated high-school students learning under different modalities. They concluded that students that used the block-based method could transfer their gained knowledge to other modalities and performed as well as or better than their conventional text -based programming classmates. Counter to this finding [17], found statistically insignificant differences in cognitive abilities of 8 and 9-year-old students after learning to program with visual and textbased languages. The benefits of visual programming languages continue to propel them into the classroom to introduce programming concepts and computational thinking [11] .",
            "score": 0.41539916396449583,
            "section_title": "Visual Programming",
            "char_start_offset": 6821,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 381
                },
                {
                    "start": 382,
                    "end": 572
                },
                {
                    "start": 573,
                    "end": 728
                }
            ],
            "ref_mentions": [
                {
                    "start": 95,
                    "end": 98,
                    "matchedPaperCorpusId": "10976181"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7548828125
        },
        {
            "corpus_id": "248524774",
            "title": "Low-Code Programming Models",
            "text": "Config. pane Description. Visual programming languages let users write programs by directly manipulating their visual representation. There is a plethora of possible visual representations [8], often inspired by domain notation, such as electrical circuit diagrams. Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN [28]) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions. Despite the diversity in visual languages, their programming environments tend to comprise similar building blocks, as depicted in Figure 2. The central building block is the code canvas, where the user can both read (red arrow from canvas to eye) and write (blue arrow from hand to canvas) the program. Writing the program also involves dragging components from the palette to the canvas and possibly configuring them in a separate configuration pane. The programming environment also often includes a stage, which visually shows a concrete program execution in progress. For example, in Scratch, the stage shows sprites in a virtual world. Besides making the environment more engaging, the stage is also crucial for program understanding and debugging. To facilitate this, the stage is usually tightly connected to the canvas, helping the user navigate back and forth. \n\nStrengths, weaknesses, and mitigations. One strength of VPLs is that they tend to be easy to read, either by reusing notation that is already familiar to the domain expert or by using a clean notation with general appeal [8]. Another strength is that, in contrast to PBD or PBNL, VPLs are usually unambiguous, thus increasing programmer control and reducing mistakes. Finally, compared to textual programming languages, visual languages can rule out syntax errors [37] and even simple type errors [30] by construction. \n\nIn the context of low-code programming, the main weakness of visual programming languages is that they are not always self-explanatory; that is why Figure 1 connects them to semi-developers. The mitigation for this need-to-learn is user education, and for some VPLs, education is a primary purpose [30].",
            "score": 0.4141396568232528,
            "section_title": "Palette Code canvas Stage",
            "char_start_offset": 13328,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 7
                },
                {
                    "start": 8,
                    "end": 25
                },
                {
                    "start": 26,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 265
                },
                {
                    "start": 266,
                    "end": 412
                },
                {
                    "start": 413,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 895
                },
                {
                    "start": 896,
                    "end": 1044
                },
                {
                    "start": 1045,
                    "end": 1164
                },
                {
                    "start": 1165,
                    "end": 1233
                },
                {
                    "start": 1234,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1462
                },
                {
                    "start": 1465,
                    "end": 1504
                },
                {
                    "start": 1505,
                    "end": 1690
                },
                {
                    "start": 1691,
                    "end": 1832
                },
                {
                    "start": 1833,
                    "end": 1983
                },
                {
                    "start": 1986,
                    "end": 2176
                },
                {
                    "start": 2177,
                    "end": 2289
                }
            ],
            "ref_mentions": [
                {
                    "start": 355,
                    "end": 359,
                    "matchedPaperCorpusId": "2385464"
                },
                {
                    "start": 1929,
                    "end": 1933,
                    "matchedPaperCorpusId": "16189588"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9423828125
        },
        {
            "corpus_id": "253043422",
            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
            "text": "The development of software solutions involves a considerable effort for those users who are not experts, limiting access to the use of the latest technological innovations. To solve this problem, in recent years, EUD has recently experienced a renewed interest, providing the necessary tools for non-expert users to develop their software solutions through adapted languages [11]. \n\nProgramming with VPLs does not require knowledge of textual programming syntax and provides a more visually stimulating environment, having a direct impact on user motivation [13]. Such languages are commonly used in educational settings for promoting students' development of computational thinking [14]. The suitability of block-based environments for novice programmers has already been demonstrated in different studies. Broll et al. [15] propose a web development environment based on Snap! that adds distributed programming capabilities. Kyfonidis et al. [16] present a block-based programming environment focused on learning the C language. Finally, Rao et al. [17] propose a visual programming environment for education in data science. \n\nVPLs can be classified into two categories: imperative languages and flow-based languages [18]. With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others [19].",
            "score": 0.4140161618448794,
            "section_title": "Visual programming languages",
            "char_start_offset": 5567,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 173
                },
                {
                    "start": 174,
                    "end": 381
                },
                {
                    "start": 384,
                    "end": 564
                },
                {
                    "start": 565,
                    "end": 689
                },
                {
                    "start": 690,
                    "end": 808
                },
                {
                    "start": 809,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 1031
                },
                {
                    "start": 1032,
                    "end": 1128
                },
                {
                    "start": 1131,
                    "end": 1226
                },
                {
                    "start": 1227,
                    "end": 1365
                },
                {
                    "start": 1366,
                    "end": 1432
                },
                {
                    "start": 1433,
                    "end": 1516
                },
                {
                    "start": 1517,
                    "end": 1682
                },
                {
                    "start": 1683,
                    "end": 1871
                },
                {
                    "start": 1872,
                    "end": 1992
                }
            ],
            "ref_mentions": [
                {
                    "start": 376,
                    "end": 380,
                    "matchedPaperCorpusId": "67770007"
                },
                {
                    "start": 559,
                    "end": 563,
                    "matchedPaperCorpusId": "219455753"
                },
                {
                    "start": 684,
                    "end": 688,
                    "matchedPaperCorpusId": "202252904"
                },
                {
                    "start": 822,
                    "end": 826,
                    "matchedPaperCorpusId": "44165140"
                },
                {
                    "start": 945,
                    "end": 949,
                    "matchedPaperCorpusId": "35843064"
                },
                {
                    "start": 1052,
                    "end": 1056,
                    "matchedPaperCorpusId": "53080670"
                },
                {
                    "start": 1221,
                    "end": 1225,
                    "matchedPaperCorpusId": "20439639"
                },
                {
                    "start": 1987,
                    "end": 1991,
                    "matchedPaperCorpusId": "6927128"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.958984375
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "Block-based environments are visual programming environments, which are becoming more and more popular because of their ease of use. The ease of use comes thanks to their intuitive graphical representation and structural metaphors (jigsaw-like puzzles) to display valid combinations of language constructs to the users. Part of the current popularity of block-based environments is thanks to Scratch. As a result they are often associated with tools for children or young learners. However, it is unclear how these types of programming environments are developed and used in general. So we conducted a systematic literature review on block-based environments by studying 152 papers published between 2014 and 2020, and a non-systematic tool review of 32 block-based environments. In particular, we provide a helpful inventory of block-based editors for end-users on different topics and domains. Likewise, we focused on identifying the main components of block-based environments, how they are engineered, and how they are used. This survey should be equally helpful for language engineering researchers and language engineers alike.",
            "score": 0.40859326256612427,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8681640625
        },
        {
            "corpus_id": "201761899",
            "title": "Customizing Websites Through Automatic Web Search",
            "text": "End-User Development tools can be divided into 5 categories: Visual Programming, Spreadsheets, Programming By Demonstration, Domain Specific Languages and Model-Based [1]. Visual Programming tools include visual symbols and graphical notations which are used by end-users as if they were small boxes in which users interact with those components to create their own executable programs. These executable programs must be interpreted by the system thanks to a simple and expressive domain-specific language. Domain-Specific Languages are considered as an approach to decrease complexity of software systems development. Accompanied by Domain Specific Language good practices [31] all requirements have been captured by our feature diagram (see figure 5). Next subsections will explain the feature diagram.",
            "score": 0.40570234785288484,
            "section_title": "Excore internal definition",
            "char_start_offset": 17967,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 171
                },
                {
                    "start": 172,
                    "end": 386
                },
                {
                    "start": 387,
                    "end": 506
                },
                {
                    "start": 507,
                    "end": 618
                },
                {
                    "start": 619,
                    "end": 753
                },
                {
                    "start": 754,
                    "end": 804
                }
            ],
            "ref_mentions": [
                {
                    "start": 167,
                    "end": 170,
                    "matchedPaperCorpusId": "3721630"
                },
                {
                    "start": 674,
                    "end": 678,
                    "matchedPaperCorpusId": "207158373"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84521484375
        },
        {
            "corpus_id": "61743331",
            "title": "LittleC.js: A Lightweight, Minimal, Extensible, and Embeddable JavaScript Implementation of the C Programming Language",
            "text": "Visual block languages have introduced new ways of learning computer languages. New Integrated development environments (IDEs) for standard programming languages such as C or SQL have been developed, derived from block languages and based on the metaphor of building blocks. New online IDEs, mostly used in online courses, have then made programming with standard, text-based programming languages such as C or Java, as easy as possible. Nonetheless, a gap still exists between learning computer programming in a Visual environment based on the block metaphor and a standard environment for a text-based programming language. In this paper, we propose a lightweight integrated development environment, developed for an Introductory Computer Programming course at the Faculty of Engineering of Cagliari, which can be used to gradually introduce students to the C programming language. The tool can be easily embedded in online resources that can also be accessed via mobile devices.",
            "score": 0.40242017832307897,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.623046875
        },
        {
            "corpus_id": "5015407",
            "title": "Teaching GUI-Programming Concepts to Prospective K12 ICT Teachers: MIT App Inventor as an Alternative to Text-Based Languages",
            "text": "These enable the developer to create programming expressions by combining through -drag and drop\u2016 or other GUI actions blocks that visually represent programming constructs, as opposed to using text to form expressions in the conventional -text-based\u2016 approach. \n\nAlthough the original purpose of this approach to programming has been to create easier and more practical means for the end-users to develop software applications (Mohamad et al., 2011) there have been researchers claiming that blocks-based visual languages may be used as educational tools in programming (Navarro-Prieto & Ca\u00f1as, 2001) and that they may be beneficial especially for novice students (Maloney, Resnick, Rusk, Silverman, & Eastmond, 2010). In fact, the programming blocks approach have been considered to be such a great way to simplify programming that, there even exists research that aims to teach programming concepts to young children by employing physically tangible blocks (Horn & Jacob, 2006;McNerney, 2004;Wang, Zhang, & Wang, 2011;Wyeth & Purchase, 2002). The main advantage to blocks-based visual programming is that textual syntax, which may largely differ from one programming language to the other, has been replaced with universal blocks that interact with each other only in meaningful ways, much like pieces of a puzzle, leaving less room for error. This enables novices to practice the semantics instead of syntax, lets them code in elements that display a higher-level fashion resembling pseudo-code, eliminates the need to -memorize\u2016 textual code constructs (which is especially the problem in students that do not have English as their mother tongue), while avoiding typing mistakes and type errors in general (Klassen, 2006). However, it should also be noted that blocks-based visual languages that have been used in education so far have mostly been prepared for a target audience of younger age levels in mind (Kelleher, Pausch, & Kiesler, 2007;Utting, Cooper, K\u00f6lling, Maloney, & Resnick, 2010). As such, the idea of using blocks-based visual languages to aid the education of adults in programming has not been encountered often in the literature, at least for a certain period.",
            "score": 0.4020057911974622,
            "section_title": "Introduction",
            "char_start_offset": 3816,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 261
                },
                {
                    "start": 264,
                    "end": 719
                },
                {
                    "start": 720,
                    "end": 1045
                },
                {
                    "start": 1046,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1727
                },
                {
                    "start": 1728,
                    "end": 2000
                },
                {
                    "start": 2001,
                    "end": 2184
                }
            ],
            "ref_mentions": [
                {
                    "start": 428,
                    "end": 450,
                    "matchedPaperCorpusId": "5674825"
                },
                {
                    "start": 571,
                    "end": 601,
                    "matchedPaperCorpusId": "16771725"
                },
                {
                    "start": 665,
                    "end": 718,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 995,
                    "end": 1021,
                    "matchedPaperCorpusId": "565775"
                },
                {
                    "start": 1021,
                    "end": 1044,
                    "matchedPaperCorpusId": "59857513"
                },
                {
                    "start": 1711,
                    "end": 1726,
                    "matchedPaperCorpusId": "5181040"
                },
                {
                    "start": 1914,
                    "end": 1949,
                    "matchedPaperCorpusId": "3910027"
                },
                {
                    "start": 1949,
                    "end": 1999,
                    "matchedPaperCorpusId": "17911112"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.81689453125
        },
        {
            "corpus_id": "64149806",
            "title": "Visual dataflow language for educational robots programming",
            "text": "Evolution of a domain-specific modeling (DSM) tools allows to quickly create a fairly sophisticated visual programming languages [19]. TRIK Studio programming environment is an example of a system that was created using DSM-based approach on QReal platform [7], [8]. Basing on an industrial experience of TRIK Studio developers we decided to create the visual editor of our language on QReal platform. Program on DFVPL is a set of blocks and flows that connect blocks. DFVPL blocks process incoming tokens and emit resulting data into the output data flows. Blocks in our language can be divided into several groups that are described below. Some blocks require to specify information on textual language. The language we use is a statically typed dialect of Lua. \n\n\u2022 Control blocks that implement basic algorithmic constructions (conditions, loops, etc). \n\n\u2022 ConstValue and RandomValue blocks that are responsible for generation of a random number or a predetermined value of any type. \u2022 Wait block delays data processing. \n\n\u2022 DelayAndFilter is the extension of the previous block adding the filtering condition and checking the amount of emitted data validated by condition. \u2022 Fork, EndFork blocks that provide an ability of invoking code in platform-specific execution units. See section 6 for details. \u2022 Drawing. Blocks for drawing on display of the robot and on the floor in simulator mode. \n\n\u2022 PaintSettings defines current background color, thickness and color of pen and color and style of the brush that draw graphical primitives. \u2022 ShapePainter, SmilePainter, Text are used for drawing some shape, text or smile on robot's display. \u2022 Clear block removes all graphics from robot's display when receiving any token. \u2022 Pen block puts down or raises the marker for drawing the robot's trace on the \"floor\" of 2D simulator. \u2022 Flow manipulation. These elements provide opportunity to manipulate data, which flow between blocks. \n\n\u2022 InPort, OutPort emit tokens that come into some instance of Subprogram block into a diagram implementing it and similarly redirect data from subprogram implementation into output flows of active instance of Subprogram block. \u2022 Supressor, Inhibitor inhibit or replace token of some flow with tokens of another.",
            "score": 0.40183414728676603,
            "section_title": "Language Description",
            "char_start_offset": 9521,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 134
                },
                {
                    "start": 135,
                    "end": 266
                },
                {
                    "start": 267,
                    "end": 401
                },
                {
                    "start": 402,
                    "end": 468
                },
                {
                    "start": 469,
                    "end": 557
                },
                {
                    "start": 558,
                    "end": 641
                },
                {
                    "start": 642,
                    "end": 705
                },
                {
                    "start": 706,
                    "end": 763
                },
                {
                    "start": 766,
                    "end": 855
                },
                {
                    "start": 858,
                    "end": 986
                },
                {
                    "start": 987,
                    "end": 1023
                },
                {
                    "start": 1026,
                    "end": 1176
                },
                {
                    "start": 1177,
                    "end": 1278
                },
                {
                    "start": 1279,
                    "end": 1305
                },
                {
                    "start": 1306,
                    "end": 1316
                },
                {
                    "start": 1317,
                    "end": 1395
                },
                {
                    "start": 1398,
                    "end": 1539
                },
                {
                    "start": 1540,
                    "end": 1641
                },
                {
                    "start": 1642,
                    "end": 1723
                },
                {
                    "start": 1724,
                    "end": 1828
                },
                {
                    "start": 1829,
                    "end": 1849
                },
                {
                    "start": 1850,
                    "end": 1931
                },
                {
                    "start": 1934,
                    "end": 2160
                },
                {
                    "start": 2161,
                    "end": 2245
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.759765625
        },
        {
            "corpus_id": "60941791",
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "text": "Three main problems of visual programming languages were identified: scalability, readability and speed of input. \n\nThe scalability problem arises as with increasing program size, visual languages become less usable and face the socalled Deutsch Limit [10], which states that 'you can't have more than 50 visual primitives on the screen at the same time'. The solution of this problem requires more effective methods of using screen area (e.g., automatic layout) and going beyond the 2D representation to achieve more effective representation of program's structure without introducing unnecessary over-complexity. \n\nThe readability problem arises due to inherent parallelism in the robotics domain and complexity of input/output relations between blocks which lead to difficulties in under-standing a program. Many students found visual languages harder to read and understand than textual ones, especially for larger programs. However, this is not sufficient to conclude that visual languages are inherently harder to read than textual. The already formed habits of the students could have made them biased. The problem can be addressed by using colours and other graphical effects (e.g., animation) more effectively beyond simple separation between groups of blocks to represent different views of a program. \n\nThe speed of input for visual programming languages still remains below that of textual languages using the keyboard, which may be a reason why professional programmers prefer text-based languages. The problem could be addressed by introducing more design automation and raising the level of abstraction above simple structures of structural programming (such as loops) to the idiom or pattern level. \n\nThe graphical representation of building blocks in MVPL and NXT-G is different. MVPL has minimalist design, with plain blocks and textual configuration parameters. NTX-G is colourful and represents almost all additional parameters by icons. This presents problems for both: MVPL is less visually appealing and friendly to novice users, while NXT-G might be considered both too difficult to understand and too childish to someone with programming experience. The NXT-G programs proved to be very large in real projects. Overall, students found programming with NXT-G more cumbersome than with textual programming languages (all students had previous programming experience). \n\nBoth MVPL and NXT-G examined in this paper lack identification and interaction capabilities which are needed to integrate a robot into the Internet of Things (IoT).",
            "score": 0.4018125586841107,
            "section_title": "IV. CONCLUSIONS",
            "char_start_offset": 12472,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 113
                },
                {
                    "start": 116,
                    "end": 355
                },
                {
                    "start": 356,
                    "end": 614
                },
                {
                    "start": 617,
                    "end": 810
                },
                {
                    "start": 811,
                    "end": 928
                },
                {
                    "start": 929,
                    "end": 1038
                },
                {
                    "start": 1039,
                    "end": 1109
                },
                {
                    "start": 1110,
                    "end": 1311
                },
                {
                    "start": 1314,
                    "end": 1511
                },
                {
                    "start": 1512,
                    "end": 1714
                },
                {
                    "start": 1717,
                    "end": 1796
                },
                {
                    "start": 1797,
                    "end": 1880
                },
                {
                    "start": 1881,
                    "end": 1957
                },
                {
                    "start": 1958,
                    "end": 2174
                },
                {
                    "start": 2175,
                    "end": 2235
                },
                {
                    "start": 2236,
                    "end": 2390
                },
                {
                    "start": 2393,
                    "end": 2557
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.783203125
        },
        {
            "corpus_id": "233252446",
            "title": "Evolution of Human Computer Interaction",
            "text": "In the eighties, a large number of scientific journals devoted to computer topics were published. The materials of these journals were available to domestic researchers either through scientific libraries or through abstract journals, in which reports of almost all scientific articles were published. The full texts of these articles were available on paper or microfilm. The analysis of publications related to computer graphics allowed to identify the emergence of two new directions the visual programming and the program visualization. It is interesting that at first it was difficult to separate these concepts due to the similarity of the names. \n\nVisual programming implied the use of graphics, in particular schemes, diagrams, iconic images (icons) in the process of developing programs. Visualization of programming assumed that already developed programs were presented in the form of the same graphic elements. Within the framework of programming visualization, one could single out such sections as animation of algorithms, visual debugging etc. The ideas of visual programming languages appeared in the seventies when computer graphics systems began to work quite steadily. Visual languages of the seventies were built on the basis of flowcharts or diagrams of Nassi-Shneiderman, which served to describe structured programming. This direction had developed sufficiently by the end of the eighties. Diagrammatic and iconic programming languages were developed, compilers of visual languages were created, [24]. The first animation system for algorithms was developed back in the mid-sixties. Individual frames were shot on film, and the result was a movie describing the operation of the algorithm. In the eighties, animation systems of algorithms were implemented onthe basis of modern computer graphics at that time [25]. An interesting idea of algorithmic operations was proposed which served as the basis for the animation \"script\" [26]. \n\nIn general,visual debuggers were based on ideas for interactive debugging. The user had the opportunity to view, for example, the program trace to see a graphical displaying the data that the user was interested in. The development of visual debugging systems for parallel computing began. For this purpose both natural graphics for the application were being debugged and traditional schemes and diagrams could be used. The idea of creating software visual complexes was put forward, which consisted in the fact that both the development of programs, their debugging and their maintenance had to be carried out within a single system with the same graphical representation of software entities.",
            "score": 0.400772286196555,
            "section_title": "Visualization software",
            "char_start_offset": 32910,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 98,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 372
                },
                {
                    "start": 373,
                    "end": 540
                },
                {
                    "start": 541,
                    "end": 652
                },
                {
                    "start": 655,
                    "end": 796
                },
                {
                    "start": 797,
                    "end": 922
                },
                {
                    "start": 923,
                    "end": 1058
                },
                {
                    "start": 1059,
                    "end": 1187
                },
                {
                    "start": 1188,
                    "end": 1342
                },
                {
                    "start": 1343,
                    "end": 1412
                },
                {
                    "start": 1413,
                    "end": 1524
                },
                {
                    "start": 1525,
                    "end": 1605
                },
                {
                    "start": 1606,
                    "end": 1712
                },
                {
                    "start": 1713,
                    "end": 1837
                },
                {
                    "start": 1838,
                    "end": 1955
                },
                {
                    "start": 1958,
                    "end": 2032
                },
                {
                    "start": 2033,
                    "end": 2173
                },
                {
                    "start": 2174,
                    "end": 2247
                },
                {
                    "start": 2248,
                    "end": 2378
                },
                {
                    "start": 2379,
                    "end": 2653
                }
            ],
            "ref_mentions": [
                {
                    "start": 1519,
                    "end": 1523,
                    "matchedPaperCorpusId": "47545019"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7783203125
        },
        {
            "corpus_id": "6558922",
            "title": "Honey: A dataflow programming language for the processing, featurization and analysis of multivariate, asynchronous and non-uniformly sampled scalar symbolic time sequences",
            "text": "C, C++, and FORTRAN), adapted architectures and hardware, and specialized libraries (also written with high efficiency programming languages). In the case of smaller problems and for fast prototyping, specialized numerical scientific programming languages are generally more suited (e.g. R, MatLab, SciLab, Octave, Mathematica and Maple). Many such languages have large active communities that develop and maintain specialized scientific libraries. Database programming languages (e.g. Sql, Clarion and DBase) are specialized programming language for querying and modifying databases. They are often used conjointly with another more general programming language. \n\nWhile most programming languages are text based, various other representations have been explored. For example, visual programming relies on the drawing or arrangement of graphical elements to define programs. Graph programming refers to the family of graphical languages relying on the definition of a graph (i.e. a set of nodes connected by edges). Graph programming is generally considered easier to learn than text base programming language. However, graph programs can be slow to execute (in case of fine grain programming), hard to maintain on large programs, and specialized for certain tasks. Graph programming language is mainly divided into two families: Logic Flow and Data Flow programming languages. In a logic flow programming language, nodes represent states of the program, and edges represent the transitions between states. Logic flow programming languages are used for logic controller (Sequential function chart, Function block diagram), game development (Unreal Engine, Gamemaker) and general sequential control (DRAKON, Scratch and Flowgorithm). Instead, in a Data Flow programming languages, nodes represent individual processes (called agents), and edges represent the connection between the outputs of a process to the inputs of the next ones. Pieces of information called tokens travel trough the network and are processed by each node they encounter. Data Flow programming languages are popular in media processing (Pure Data, Max, 3ds Max Material, Blender Shading Composer), machine learning (Weka, Orange, RapidMiner), signal processing (System Studio, SPW, Simulink) and architecture definition (VHDL). \n\nData flow computation modeling refers to the study of hardwares or softwares implementation of Data Flow programming languages.",
            "score": 0.39832932329724235,
            "section_title": "Related work",
            "char_start_offset": 10102,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 142
                },
                {
                    "start": 143,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 338
                },
                {
                    "start": 339,
                    "end": 448
                },
                {
                    "start": 449,
                    "end": 485
                },
                {
                    "start": 486,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 663
                },
                {
                    "start": 666,
                    "end": 764
                },
                {
                    "start": 765,
                    "end": 875
                },
                {
                    "start": 876,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1111
                },
                {
                    "start": 1112,
                    "end": 1266
                },
                {
                    "start": 1267,
                    "end": 1378
                },
                {
                    "start": 1379,
                    "end": 1507
                },
                {
                    "start": 1508,
                    "end": 1733
                },
                {
                    "start": 1734,
                    "end": 1934
                },
                {
                    "start": 1935,
                    "end": 2043
                },
                {
                    "start": 2044,
                    "end": 2299
                },
                {
                    "start": 2302,
                    "end": 2429
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6533203125
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "In visual programming there is always a primary geometric element with some degree of graphical variability and styling. For instance, it is a jigsaw puzzle block in Scratch and Blockly, a game card in Kodu (MacLaurin, 2011), a consumer-producer block in Node-RED, a process block in BPMN, a circuit block in LEGO Mindstorms Eve3, and a command block in Touch Develop. This primary element plays a crucial role, since its choice and representation, commonly as a real-world world metaphor, is extremely important for the quality of the programming experience. To assume a single visual element is capable to model all program elements is questionable and likely optimistic. In fact, there is no such analogy in programming languages, since elements with distinct and diverse semantics like classes, functions, expressions and variables coexist, but with notable structural differences at the source-code definition level. \n\nAlso, a potential mismatch may occur if the visual structures on the graphical domain differ significantly from the implied semantic structures in the underlying programing language paradigm. For instance, consider consumer-producer chains in event management using jigsaw blocks. With independent when blocks (as in Scratch) dependencies are not shown as linked, while via sequential blocks, only a single contained handler is allowed. Thus, to visually express any possible event associations, blocks must be nested, as depicted under Figure 10 (left part). However, as also shown in Figure 10 (right part), semantically the nested structures imply scoped event handlers, something not always true in underlying source code domain. The same scenario in a flow-based paradigm is represented with connected event handlers, but without implying nested scopes, as shown under Figure 11. Thus, for certain programming scenarios, it is clear that some visual metaphors are more appropriate than others. Interestingly, as outlined under Figure 12, while programs are genuine hierarchical structures, jig-saw puzzles have a twodimensional tabular structure, without a hierarchy. In this sense, the jigsaw metaphor is either a mismatch for the target domain, or else and more precisely it is not used as in the real world, but only as a choice of visual style or abstract naming.",
            "score": 0.3983082408091988,
            "section_title": "Appropriate Element Metaphor",
            "char_start_offset": 12338,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 120
                },
                {
                    "start": 121,
                    "end": 368
                },
                {
                    "start": 369,
                    "end": 559
                },
                {
                    "start": 560,
                    "end": 673
                },
                {
                    "start": 674,
                    "end": 921
                },
                {
                    "start": 924,
                    "end": 1115
                },
                {
                    "start": 1116,
                    "end": 1204
                },
                {
                    "start": 1205,
                    "end": 1360
                },
                {
                    "start": 1361,
                    "end": 1483
                },
                {
                    "start": 1484,
                    "end": 1657
                },
                {
                    "start": 1658,
                    "end": 1808
                },
                {
                    "start": 1809,
                    "end": 1922
                },
                {
                    "start": 1923,
                    "end": 2096
                },
                {
                    "start": 2097,
                    "end": 2296
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7880859375
        },
        {
            "corpus_id": "276575362",
            "title": "Retrieval-Augmented Fine-Tuning With Preference Optimization For Visual Program Generation",
            "text": "Recent advances in large language models (LLMs) have significantly improved their capabilities in code generation. Moreover, LLMs such as GPT-4 (Achiam et al., 2023), StarCoder (Li et al., 2023), and DeepSeek-Coder (Guo et al., 2024) are able * Equally contributed to automate large parts of programming tasks and substantially improve programmers' efficiency. Yet, despite these achievements, most of the previous research has focused on text-based programming languages (TPLs) such as Python or Java, which leaves visual programming languages (VPLs) relatively unexplored. \n\nVPLs typically represent programs as node graphs (Figure 1), which allow users with limited programming backgrounds to create and modify programs by graphical manipulation (DeLozier and Shey, 2023). As such, due to their easier accessibility, VPLs have been widely adopted across various domains, from Ladder Diagram (LD) in industrial control systems (IEC, 2013) to Unreal Engine's Blueprints in game development (Games, 2010). Although VPLs lower the barrier to programming, creating such visual programs from scratch can still be cumbersome. Consequently, recent studies (Zhang et al., 2024b;Xue et al., 2024;Zhou et al., 2025) have explored generating visual programs in text formats (e.g., JSON) from user instructions using prompting-based approaches. \n\nWhile these studies have shown promising results in VPL generation, the sole reliance on prompting-based methods can be less effective for industrial VPLs like LD. This is because these languages are widely used in industrial automation, which follow domain-specific configurations (e.g., address mapping) that vary drastically by environments (Alphonsus and Abdullah, 2016). Given the vast number of these configurations, it is challenging to include all such information in a single prompt. In contrast, training-based approaches can implicitly learn these configurations during finetuning. Therefore, we argue that training-based methods are necessary for this setting.",
            "score": 0.3958451603174379,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 114
                },
                {
                    "start": 115,
                    "end": 360
                },
                {
                    "start": 361,
                    "end": 574
                },
                {
                    "start": 577,
                    "end": 775
                },
                {
                    "start": 776,
                    "end": 1005
                },
                {
                    "start": 1006,
                    "end": 1121
                },
                {
                    "start": 1122,
                    "end": 1334
                },
                {
                    "start": 1337,
                    "end": 1500
                },
                {
                    "start": 1501,
                    "end": 1712
                },
                {
                    "start": 1713,
                    "end": 1829
                },
                {
                    "start": 1830,
                    "end": 1929
                },
                {
                    "start": 1930,
                    "end": 2009
                }
            ],
            "ref_mentions": [
                {
                    "start": 749,
                    "end": 774,
                    "matchedPaperCorpusId": "259335765"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.71728515625
        },
        {
            "corpus_id": "231785967",
            "title": "Hybrid Java: The creation of a Hybrid Programming Environment",
            "text": "The study also further pointed to the existence of this \"educational gap\" around the ages of 14-17 where neither language type is ideal. Therefore, we have discerned that text-based languages have their weaknesses, but visual block-based languages also have their issues. This led us to the logical conclusion of taking the best parts of both language types and merging them together into a socalled hybrid programming language. In particular, we wanted to focus on a hybrid blocks-text environment. \n\nThe authors decided to investigate the creation of a hybrid form of Java (the FPL of choice at the authors institution). Other researchers have done similar testing using other languages with promising results (Weintrop, 2015). The premise is that, by creating and teaching with a hybrid programming environment we may see a curve where a visual language proves the easiest to learn for students, a text-based language appears the most difficult to learn but the hybrid \"language\" is placed between these two. This would suggest that a hybrid programming environment could be used within a CS1 module as an intervention tool for students who might be struggling with the text-based approach or additionally to provide a challenge to younger learners who might be bored with the visual programming approach.",
            "score": 0.39404328969097846,
            "section_title": "Motivation and Background",
            "char_start_offset": 7978,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 136
                },
                {
                    "start": 137,
                    "end": 271
                },
                {
                    "start": 272,
                    "end": 428
                },
                {
                    "start": 429,
                    "end": 499
                },
                {
                    "start": 502,
                    "end": 622
                },
                {
                    "start": 623,
                    "end": 729
                },
                {
                    "start": 730,
                    "end": 1011
                },
                {
                    "start": 1012,
                    "end": 1308
                }
            ],
            "ref_mentions": [
                {
                    "start": 712,
                    "end": 728,
                    "matchedPaperCorpusId": "19152833"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5703125
        },
        {
            "corpus_id": "255632969",
            "title": "Exploring the compelling rationale to include programming in the K-12 curriculum",
            "text": "A major distinction between instructional programming tools is whether they offer text-based (for example, Python, Java and JavaScript, C++) or block-based (for example, Scratch, Blockly, Snap) visual programming (Lindberg et al., 2019). Block-based programming, an introductory system, is usually considered to be easier for beginners to simulate coded language by using colorful forms in a canvas work area which can be dragged and dropped with a mouse instead of typing to form a sequenced program (Lindberg et al., 2019;Moors et al., 2018). Text-based programming tools-such as Cobol, FORTRAN, Python, Java, Action Script, Arduino Integrated Development Environments, and Processingare used in professional contexts (Lindberg et al., 2019;Sentance et al., 2019). As students develop, they can use blocks to create a program and understand the complexity of text-based language. However, students must learn the principles of programming, such as events, sequencing, loops/iteration, functions, and variables, throughout K-12 teaching (Moors et al., 2018).",
            "score": 0.39232410986137095,
            "section_title": "The tools",
            "char_start_offset": 7655,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 237
                },
                {
                    "start": 238,
                    "end": 544
                },
                {
                    "start": 545,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 881
                },
                {
                    "start": 882,
                    "end": 1059
                }
            ],
            "ref_mentions": [
                {
                    "start": 213,
                    "end": 236,
                    "matchedPaperCorpusId": "69960068"
                },
                {
                    "start": 501,
                    "end": 524,
                    "matchedPaperCorpusId": "69960068"
                },
                {
                    "start": 524,
                    "end": 543,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 720,
                    "end": 743,
                    "matchedPaperCorpusId": "69960068"
                },
                {
                    "start": 743,
                    "end": 765,
                    "matchedPaperCorpusId": "150086292"
                },
                {
                    "start": 1038,
                    "end": 1058,
                    "matchedPaperCorpusId": "195832237"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82763671875
        },
        {
            "corpus_id": "256662722",
            "title": "On the Applicability of Language Models to Block-Based Programs",
            "text": "Block-based programming languages have recently received increased attention for teaching programming concepts to novices [1] as well as for industrial applications requiring end-user programming [2]- [4]. In this paper, we focus on the popular educational programming language SCRATCH [5]. \n\nA. The Scratch Programming Language SCRATCH [5] is a block based programming language for young learners. SCRATCH programs control the behavior of sprites in an environment (stage); each sprite can implement multiple scripts. Figure 1b exemplifies such a script: Scripts start with event handlers (e.g., When clicked ) followed by blocks that are executed after the event occurred. To support recognition over recall blocks are color coded based on categories: control structures are orange like the block in Fig. 1b, blocks affecting the visual appearance of sprites are purple (e.g., say Hello World! ), etc. Blocks are further divided into different shapes, such as stackable blocks (statements) and round or diamondshaped reporter blocks that fit into holes in other blocks (expressions). Blocks may have free text spaces for numbers and strings like in say Hello World! , and drop-down menus to select pre-set options. SCRATCH enables a remix culture [10] where users share their programs, and others clone and enhance them. \n\nEven though the block shapes prevent syntactical errors, building programs can nevertheless be challenging: learners may struggle to implement functionality or may have misconceptions [12]- [15], and programmers may miss the convenience and support of modern programming environments. As a consequence, various analysis tools have been proposed, mainly implementing traditional program analyses such as linting (e.g., [16], [17]) or automated testing (e.g., [18], [19]). However, analysis tools using NLP methods are, to the best of our knowledge, not available yet.",
            "score": 0.3905045488041528,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 4488,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 205
                },
                {
                    "start": 206,
                    "end": 290
                },
                {
                    "start": 293,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 518
                },
                {
                    "start": 519,
                    "end": 674
                },
                {
                    "start": 675,
                    "end": 1085
                },
                {
                    "start": 1086,
                    "end": 1216
                },
                {
                    "start": 1217,
                    "end": 1322
                },
                {
                    "start": 1325,
                    "end": 1609
                },
                {
                    "start": 1610,
                    "end": 1795
                },
                {
                    "start": 1796,
                    "end": 1891
                }
            ],
            "ref_mentions": [
                {
                    "start": 122,
                    "end": 125,
                    "matchedPaperCorpusId": "219181392"
                },
                {
                    "start": 196,
                    "end": 199,
                    "matchedPaperCorpusId": "35216497"
                },
                {
                    "start": 201,
                    "end": 204,
                    "matchedPaperCorpusId": "236189364"
                },
                {
                    "start": 286,
                    "end": 289,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 337,
                    "end": 340,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 1509,
                    "end": 1513,
                    "matchedPaperCorpusId": "16751175"
                },
                {
                    "start": 1515,
                    "end": 1519,
                    "matchedPaperCorpusId": "219181425"
                },
                {
                    "start": 1743,
                    "end": 1747,
                    "matchedPaperCorpusId": "231924549"
                },
                {
                    "start": 1749,
                    "end": 1753,
                    "matchedPaperCorpusId": "24914097"
                },
                {
                    "start": 1783,
                    "end": 1787,
                    "matchedPaperCorpusId": "9232256"
                },
                {
                    "start": 1789,
                    "end": 1793,
                    "matchedPaperCorpusId": "199501830"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6201171875
        },
        {
            "corpus_id": "204151637",
            "title": "Parametrical design tool and the production of technical data for superadobe domes",
            "text": "Visual programming languages may be argued to have begun in the sixties, when a computer graphic experiment named GRAIL (Graphical input language) was presented as computer programming via flowcharts (ELLIS; HEAFNER; SIBLEY, 1969a)(ELLIS; HEAFNER; SIBLEY, 1969b). Nowadays, the most successful VPLs work as plug-ins in a CAD or BIM modeling system, such as Dynamo for Revit and Grasshopper for Rhinoceros (Grasshopper also connect to Archicad and VisualArq). In this research, the adopted set is the second one.",
            "score": 0.38704866882156796,
            "section_title": "Research validation",
            "char_start_offset": 7973,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 263
                },
                {
                    "start": 264,
                    "end": 458
                },
                {
                    "start": 459,
                    "end": 511
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5615234375
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "The current version of the visual language is shown in Figure 19. This design was influenced by jig-saw puzzle pieces. The mechanics of this version work out better than the previous version. In addition, control flow is more explicit, following the keyed tabs on each object top-down. Data objects are rectangular shapes with tabs on their left and right sides. Originally, these data objects were placed over a recepticle that contained a \"velco\" substance for sticking them to. This was later changed to being simply holes that were filled with the data objects. There are still problems to be overcome in this current version of the visual language. For instance, the issue of nesting plans has still not been fully addressed. In addition, there is still some concern that the shapes of the plans are not adequate in their ability to evoke understanding by the user.\n\nDespite the difficulties with the current version, what is clear at this point is that the use of a visual language is effective.",
            "score": 0.38704866882156796,
            "section_title": "Generation 6",
            "char_start_offset": 53349,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51171875
        },
        {
            "corpus_id": "269747039",
            "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
            "text": "Visual programming interfaces (VPIs) have been extensively studied as tools to aid users in designing and implementing systems through graphical elements rather than text-based code [31].A key benefit of VPIs is their lower entry barrier for novice programmers [45].There are primarily two main paradigms for VPIs.The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph.Pioneering work in this area includes Prograph [17] and LabVIEW [27].The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together.Notable works in this area include Scratch [35] and Blockly [19].Many commercial creative applications have adopted VPIs, including game engines such as Unity [11], CAD tools such as Grasshopper [9], and multimedia development tools such as Max/MSP [12].\n\nVPI concepts have been applied to machine learning applications.For example, Teachable Machine [15] uses a visual interface to help students learn to train a machine learning model.ML Blocks [46] assists developers in training, evaluating, and exporting machine learning model architectures.Very recently, researchers in both academia and industry have worked on VPIs that support the creation of AI workflows through the combination of pre-trained models.Several works have investigated node-based interfaces for building Large Language Model (LLM) pipelines, including PromptChainer [48], FlowiseAI [2], and Langflow [3].Most closely related to our work are Rapsai by Du et al. [18] and ComfyUI [1].Both tools provide a node-based interface for machine learning researchers and enthusiasts to build multimedia machine learning pipelines.These tools are catered more toward users with at least some background knowledge in AI programming, giving users the flexibility to customize the tools through programming at the expense of exposing more technical elements to the user.\n\nOur work builds upon prior and concurrent VPI tools and research.However, we made several design choices for our tool to help better support non-technical designers (Table 1).First, our tool leverages a block-based VPI paradigm, which has been shown to be effective in supporting novice programming learners [35].",
            "score": 0.38701659705408087,
            "section_title": "Visual Programming Interfaces",
            "char_start_offset": 6517,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 187
                },
                {
                    "start": 187,
                    "end": 266
                },
                {
                    "start": 266,
                    "end": 314
                },
                {
                    "start": 314,
                    "end": 455
                },
                {
                    "start": 455,
                    "end": 524
                },
                {
                    "start": 524,
                    "end": 666
                },
                {
                    "start": 666,
                    "end": 731
                },
                {
                    "start": 731,
                    "end": 920
                },
                {
                    "start": 922,
                    "end": 986
                },
                {
                    "start": 986,
                    "end": 1103
                },
                {
                    "start": 1103,
                    "end": 1213
                },
                {
                    "start": 1213,
                    "end": 1378
                },
                {
                    "start": 1378,
                    "end": 1545
                },
                {
                    "start": 1545,
                    "end": 1623
                },
                {
                    "start": 1623,
                    "end": 1761
                },
                {
                    "start": 1761,
                    "end": 1997
                },
                {
                    "start": 1999,
                    "end": 2064
                },
                {
                    "start": 2064,
                    "end": 2174
                },
                {
                    "start": 2174,
                    "end": 2312
                }
            ],
            "ref_mentions": [
                {
                    "start": 182,
                    "end": 186,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 261,
                    "end": 265,
                    "matchedPaperCorpusId": "18983760"
                },
                {
                    "start": 502,
                    "end": 506,
                    "matchedPaperCorpusId": "9693598"
                },
                {
                    "start": 1017,
                    "end": 1021,
                    "matchedPaperCorpusId": "218482766"
                },
                {
                    "start": 1113,
                    "end": 1117,
                    "matchedPaperCorpusId": "251662411"
                },
                {
                    "start": 1507,
                    "end": 1511,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 1602,
                    "end": 1606,
                    "matchedPaperCorpusId": "258216977"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.95263671875
        },
        {
            "corpus_id": "174803664",
            "title": "Easy Prototyping of Multimedia Interactive Educational Tools for Language Learning based on Block Programming",
            "text": "In order to allow the students to learn how to build interactive English phrases and sentences they were first exposed to projects created by using a programming language and then they were taught the basics of computer programming. As mentioned above, we choose a programming language based on the block metaphor, Snap (Harvey and Moenig, 2010, very similar to Scratch) specifically designed to easily teach computer programming to children 8-11, and that allowed for the easy creation of colourful interactive objects. \n\nThe structure of a programming environment for a visual block language is very easy and quick to grasp (figure 5). All \"instructions\" are represented by coloured blocks that are visible in the block area, at the lefthand side of the window). By dragging the blocks from the block area to the central part of the tool (right area in figure 5), users can build sequences of blocks, called \"scripts\", for their characters to behave and interact as expected. \n\nBlocks are organized in categories. Like building blocks, they are grouped in different bins with respect to their color/function. Blocks in each category can be accessed by clicking the desired button right above the block list, at the top left. Among the available categories in Snap we find Movement (to move the characters of the project), Looks (to change their appearance), Control (to make available basic programming structures such as repetition of a given behaviour), Sensing (to allow Snap characters to \"sense\" their environment), etc. \n\nThe organization of blocks in categories is important, so that users can quickly find the desired block by its function.",
            "score": 0.3865286601487031,
            "section_title": "Teaching 2 nd Grade Students How to Manage Visual Programming Blocks",
            "char_start_offset": 10916,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 232
                },
                {
                    "start": 233,
                    "end": 520
                },
                {
                    "start": 523,
                    "end": 637
                },
                {
                    "start": 638,
                    "end": 764
                },
                {
                    "start": 765,
                    "end": 977
                },
                {
                    "start": 980,
                    "end": 1015
                },
                {
                    "start": 1016,
                    "end": 1110
                },
                {
                    "start": 1111,
                    "end": 1226
                },
                {
                    "start": 1227,
                    "end": 1527
                },
                {
                    "start": 1530,
                    "end": 1650
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.71337890625
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "We can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\nManuscript submitted to ACM \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms.",
            "score": 0.3855168034465497,
            "section_title": "Paradigms.",
            "char_start_offset": 49461,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 168
                },
                {
                    "start": 171,
                    "end": 198
                },
                {
                    "start": 201,
                    "end": 272
                },
                {
                    "start": 273,
                    "end": 458
                },
                {
                    "start": 461,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 706
                },
                {
                    "start": 709,
                    "end": 879
                },
                {
                    "start": 880,
                    "end": 942
                },
                {
                    "start": 945,
                    "end": 1144
                },
                {
                    "start": 1145,
                    "end": 1290
                },
                {
                    "start": 1293,
                    "end": 1387
                },
                {
                    "start": 1388,
                    "end": 1481
                },
                {
                    "start": 1482,
                    "end": 1605
                },
                {
                    "start": 1606,
                    "end": 1719
                }
            ],
            "ref_mentions": [
                {
                    "start": 114,
                    "end": 138,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 156,
                    "end": 167,
                    "matchedPaperCorpusId": "48762803"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9013671875
        },
        {
            "corpus_id": "248845951",
            "title": "Case Study: Design Strategies for Enabling Visual Application Blocks of Bluetooth Library",
            "text": "Block-based programming is a visual expression of VPLs that uses block-stack behavior to construct program content. The Scratch language developed in 2003 is a good example; it is currently one of the most widely used VPLs in children's learning software and has been used in the development of many learning programs and applications [27]- [35]. Another representative block-based tool is Blockly (shown in Fig. 1), which is a web-based VPL editor with imperative programming and is an open-source approach proposed by Google in 2012. Its block mode can be converted into an actual programming language mode (red box 1 in Fig. 1). It is different from the Scratch language in that it can support the design or extension of self-defined module blocks for programming languages or domain-specific development environments. The block design modules contain eight basic syntax categories (red box 2 in Fig. 1), which allow users to stack the block contents of applications. Blockly is used extensively in the development of training programs and applications [7], [36]- [44].",
            "score": 0.3835890472241386,
            "section_title": "II. RELATED WORK",
            "char_start_offset": 6898,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 346
                },
                {
                    "start": 347,
                    "end": 535
                },
                {
                    "start": 536,
                    "end": 631
                },
                {
                    "start": 632,
                    "end": 821
                },
                {
                    "start": 822,
                    "end": 970
                },
                {
                    "start": 971,
                    "end": 1072
                }
            ],
            "ref_mentions": [
                {
                    "start": 335,
                    "end": 339,
                    "matchedPaperCorpusId": "12050846"
                },
                {
                    "start": 341,
                    "end": 345,
                    "matchedPaperCorpusId": "242076483"
                },
                {
                    "start": 1056,
                    "end": 1059,
                    "matchedPaperCorpusId": "29919218"
                },
                {
                    "start": 1061,
                    "end": 1065,
                    "matchedPaperCorpusId": "2805973"
                },
                {
                    "start": 1067,
                    "end": 1071,
                    "matchedPaperCorpusId": "246681322"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92236328125
        },
        {
            "corpus_id": "253043422",
            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
            "text": "The objective of the current study is to materialize how flow chart diagrams and block-based languages can be combined with NLP platforms to develop conversational learning experiences. In this section, we first explain the tools used for visual programming and workflow modelling. Then, we describe the execution components created for the programming tool.",
            "score": 0.38317958176394373,
            "section_title": "Authoring of interactive scenarios with visual modelling and programming",
            "char_start_offset": 12827,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 185
                },
                {
                    "start": 186,
                    "end": 281
                },
                {
                    "start": 282,
                    "end": 358
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.75048828125
        },
        {
            "corpus_id": "15385453",
            "title": "Predictive modelling for HCI problems in novice program editors",
            "text": "Programming education is highly topical, and there are several actively-developed novice programming tools that have been widely used, and cited in the literature. These range from child-user \"block\" building systems (like Scratch) to Greenfoota Java game-based development tool used in schools -to \"pure\" visual programming systems, based on flow-chart-style diagrams (such as Lego Mindstorms). There are other systems that sit between the above, such as Alice, StarLogo TNG, and numerous other variations on the \"block\" metaphor. \n\nThere are also \"mainstream\" programming languages that are judged to be the simplest of their kind, used to teach beginners (such as Python, Java, or variants of Basic). All of these systems look, superficially, very differentthey range from toy-like graphics, to monospace text, to complex flow diagrams and lines. However, there are interactions that are common to several of the differently-styled editor types, and there are also systems that look similar, but behave very differently in terms of interaction design. In this paper, we extend previous cognitive modelling work to four new programming systems (McKay 2012). The initial goal of that study was to compare several \"benchmark\" systems to a new editor in development, as part of the design process. Results of the previous paper, which highlighted differences in some visually-similar visual languages, and feedback we received, suggested that there may be other systems that could be approached in this way. This short paper reports on a second series of models, discusses their strengths and weaknesses, and compares them to each other, and to the systems in the first set. We acknowledge, for the record, that viscosity, through task time, is only one of the issues in novice programming systems. A system with low viscosity would not necessarily meet the other (educational) requirements for beginner systems, but observations suggest that excessively viscous interactions may still be problematic for some types of novice user.",
            "score": 0.3830416452896732,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 163
                },
                {
                    "start": 164,
                    "end": 395
                },
                {
                    "start": 396,
                    "end": 531
                },
                {
                    "start": 534,
                    "end": 703
                },
                {
                    "start": 704,
                    "end": 849
                },
                {
                    "start": 850,
                    "end": 1054
                },
                {
                    "start": 1055,
                    "end": 1159
                },
                {
                    "start": 1160,
                    "end": 1296
                },
                {
                    "start": 1297,
                    "end": 1506
                },
                {
                    "start": 1507,
                    "end": 1673
                },
                {
                    "start": 1674,
                    "end": 1797
                },
                {
                    "start": 1798,
                    "end": 2030
                }
            ],
            "ref_mentions": [
                {
                    "start": 1146,
                    "end": 1158,
                    "matchedPaperCorpusId": "4505341"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7783203125
        },
        {
            "corpus_id": "274030378",
            "title": "Assessing the Understanding of Expressions: A Qualitative Study of Notional-Machine-Based Exam Questions",
            "text": "\"Expression as tree\" is one of the NMs described in the aforementioned survey of NMs [21]. It centers around the structure, typing, and evaluation of expressions. The NM is essentially a visualization of the abstract syntax trees that are used to reason about programming languages, both in designing compilers [3] and in the specification of programming language semantics [34]. It is equivalent in structure to pedagogical tools and languages used to teach programming in school, such as the \"circles of evaluation\" [40]. The visualization resembles that of the structure of expressions in block-based programming languages such as Scratch [28] and Snap! [22]. Those block-based languages can be seen as visual versions of textual syntax-directed editors such as the the Cornell Program Synthesizer [46]. \n\nGiven the following Java code: \n\npublic class A { public String m(boolean condition) { return \"condition=\" + (condition ? \"true\" : \"false\"); } } \n\n(1) Draw an expression tree for the expression in the return statement of the method. (2) Annotate each node with the type of the value produced by the node. (3) Annotate each node with the value it produces if the expression is evaluated with condition = true. \n\nMake sure to specify the type of all nodes. Make sure to specify the value of all the nodes that are evaluated. As illustrated in Figure 1, the primary focus of the NM is on the structure. The expression is broken down into subexpressions, and each subexpression is represented as a subtree. Nodes can contain \"holes\" (depicted as little gray circles in Figure 1), which are used as connection points. Edges connect a hole to another node, to indicate that the latter is the root of a subexpression. This representation resembles how expressions are represented in block-based programs; however, the visual \"decomposition\" of the structure allows each node to be annotated with additional information. \n\nOnce the structure is drawn, the type of each node is calculated bottom-up1 and each node is annotated with its type (e.g., in Figure 1 as blue labels at the top left of each node).",
            "score": 0.38293829297519344,
            "section_title": "\"Expression as Tree\" Notional Machine",
            "char_start_offset": 7585,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 90
                },
                {
                    "start": 91,
                    "end": 162
                },
                {
                    "start": 163,
                    "end": 379
                },
                {
                    "start": 380,
                    "end": 523
                },
                {
                    "start": 524,
                    "end": 662
                },
                {
                    "start": 663,
                    "end": 806
                },
                {
                    "start": 809,
                    "end": 839
                },
                {
                    "start": 842,
                    "end": 930
                },
                {
                    "start": 931,
                    "end": 953
                },
                {
                    "start": 956,
                    "end": 1041
                },
                {
                    "start": 1042,
                    "end": 1113
                },
                {
                    "start": 1114,
                    "end": 1217
                },
                {
                    "start": 1220,
                    "end": 1263
                },
                {
                    "start": 1264,
                    "end": 1331
                },
                {
                    "start": 1332,
                    "end": 1408
                },
                {
                    "start": 1409,
                    "end": 1511
                },
                {
                    "start": 1512,
                    "end": 1621
                },
                {
                    "start": 1622,
                    "end": 1719
                },
                {
                    "start": 1720,
                    "end": 1921
                },
                {
                    "start": 1924,
                    "end": 2105
                }
            ],
            "ref_mentions": [
                {
                    "start": 85,
                    "end": 89,
                    "matchedPaperCorpusId": "229379938"
                },
                {
                    "start": 518,
                    "end": 522,
                    "matchedPaperCorpusId": "1674864"
                },
                {
                    "start": 642,
                    "end": 646,
                    "matchedPaperCorpusId": "16831477"
                },
                {
                    "start": 657,
                    "end": 661,
                    "matchedPaperCorpusId": "211519040"
                },
                {
                    "start": 801,
                    "end": 805,
                    "matchedPaperCorpusId": "207566172"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.453125
        },
        {
            "corpus_id": "257496495",
            "title": "Live, Rich, and Composable: Qualities for Programming Beyond Static Text",
            "text": "To this day, though, programmers articulate their thoughts as linear text.\" Similarly, Omar et al. [34] write: \"Diagrams have played a pivotal role in mathematical thought since antiquity, indeed predating symbolic mathematics. Popular computing and creative tooling, too, has embraced visual representation and direct manipulation interfaces for decades. Programming, however, has remained stubbornly mired in textual user interfaces.\" \n\nBefore digging into examples of rich programming systems, we should clarify what we do not mean by \"rich\": A programming system being \"visual\" does not, in and of itself, make it rich in our sense. Many visual programming systems use visual structures to represent the general-purpose, generic structures of textual programming, such as dataflow or control structures. This is not heterogeneous, domain-specific richness. 5 Programming systems that are visual without being rich include block-based programming languages like Scratch [35], node-and-wire editors like Natto [24] and Unreal Engine's \"Blueprints\" [36], visual structure editors like the \"frame-based\" editor in Greenfoot [37], and classic \"visual programming languages\" including VIPR [38], Prograph [39], Forms/3 [40], and Cube [41]. \n\nWe have picked a particularly narrow scope when drawing the boundaries of \"richness\", in order to focus on alternatives to static text that capture the rich, heterogeneous interactivity we have come to expect from applications. This definition is still a work in progress. We welcome continued conversation as part of the shared process of sense-making in our community.",
            "score": 0.38189315953386543,
            "section_title": "Richness",
            "char_start_offset": 9962,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 75
                },
                {
                    "start": 76,
                    "end": 227
                },
                {
                    "start": 228,
                    "end": 355
                },
                {
                    "start": 356,
                    "end": 436
                },
                {
                    "start": 439,
                    "end": 636
                },
                {
                    "start": 637,
                    "end": 807
                },
                {
                    "start": 808,
                    "end": 862
                },
                {
                    "start": 863,
                    "end": 1237
                },
                {
                    "start": 1240,
                    "end": 1467
                },
                {
                    "start": 1468,
                    "end": 1512
                },
                {
                    "start": 1513,
                    "end": 1610
                }
            ],
            "ref_mentions": [
                {
                    "start": 99,
                    "end": 103,
                    "matchedPaperCorpusId": "235474027"
                },
                {
                    "start": 973,
                    "end": 977,
                    "matchedPaperCorpusId": "229934947"
                },
                {
                    "start": 1124,
                    "end": 1128,
                    "matchedPaperCorpusId": "62831677"
                },
                {
                    "start": 1217,
                    "end": 1221,
                    "matchedPaperCorpusId": "206575759"
                },
                {
                    "start": 1232,
                    "end": 1236,
                    "matchedPaperCorpusId": "42620134"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7509765625
        },
        {
            "corpus_id": "268272915",
            "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
            "text": "Graphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements. Since graphical programming does not require a strong understanding of the language and its syntax, these languages are often designed to make programming more intuitive and accessible to non-programmers. \n\nAutomated code development in LabVIEW or any other graphical programming environment is inspired by reversing a standard software development model. This engineering design process can be perceived as a methodical series of steps that allow programmers to create functional products and processes [1]. This process can be highly repetitive, and certain stages often require multiple iterations before proceeding to the next step. Since requirements-based testing and validation, also known as test-driven development, is a common and essential part of software development [2] and a standard procedure for programmers who must verify the code's functionality, by reversing this process, we can automatically generate code instead of developing programs or unit testing frameworks. In this reverse scenario, we can automatically create programs based on the predefined input requirements, and by backpropagating the input-output differences, we can modify the generated code until all requirements are satisfied. By transforming this task into a fully automated process, we can therefore fundamentally reshape the development principles for basic programs, and instead of employing human experts for code development and test report validation, we can utilize computers to generate programs and evaluate test reports. \n\nAutomated code generation in textual-based environments has been used in the software industry for decades [3], and especially in recent years, many novel program generation approaches have been proposed and evaluated on common benchmark problems [4]. These approaches to code generation employ various techniques, including artificial intelligence, machine learning, or genetic evolution methods, to repair or generate efficient and error-free codes. A significant research direction in this field involves the use of machine learning, especially neural network models.",
            "score": 0.38114380565842604,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 227
                },
                {
                    "start": 228,
                    "end": 507
                },
                {
                    "start": 508,
                    "end": 712
                },
                {
                    "start": 715,
                    "end": 863
                },
                {
                    "start": 864,
                    "end": 1016
                },
                {
                    "start": 1017,
                    "end": 1144
                },
                {
                    "start": 1145,
                    "end": 1495
                },
                {
                    "start": 1496,
                    "end": 1726
                },
                {
                    "start": 1727,
                    "end": 2031
                },
                {
                    "start": 2034,
                    "end": 2285
                },
                {
                    "start": 2286,
                    "end": 2485
                },
                {
                    "start": 2486,
                    "end": 2604
                }
            ],
            "ref_mentions": [
                {
                    "start": 1012,
                    "end": 1015,
                    "matchedPaperCorpusId": "225556207"
                },
                {
                    "start": 1288,
                    "end": 1291,
                    "matchedPaperCorpusId": "220647375"
                },
                {
                    "start": 2141,
                    "end": 2144,
                    "matchedPaperCorpusId": "3111613"
                },
                {
                    "start": 2281,
                    "end": 2284,
                    "matchedPaperCorpusId": "257038678"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9091796875
        },
        {
            "corpus_id": "19008624",
            "title": "Integrated Development Environment Gesture for modeling workflow diagrams",
            "text": "With the development and standardization of the Unified Modeling Language (UML) the first steps towards visual programming were taken, something similar to the way software used to be developed in the late 60's [7], but now with more technology. With the release of more robust hardware it was possible to automatically translate and compile visual models directly. \n\nDue to the increased use of visual languages, the first IDE's with visual models translators appeared. These IDE's have the total capacity of generating code from the visual representation of a model, such as translating a UML class diagram to its corresponding code in a specific language (either Java or C++) [8]. \n\nThere are environments with support for specific visual languages. The most remarkable we have is the Robotic Guadalajara, Jalisco, del 25 al 27 de abril. \n\nInvestion System (RIS) marketed as Lego Mindstorm. Basically it's an environment that allows a microcontroller to handle different sensors. The operation is carried out by the arrangement of icons, which are translated and subsequently downloaded to the NXT (ARM7 microcontroller 32-bit). \n\nThe importance of RIS lies in the ease of use, to such an extent that its segment of users ranges from children aged 6 years to adult users, who are interested in starting in the area of software development [9]. \n\nA similar project is Scratch, unlike Lego Mindstorms, Scratch projects are built with objects (in this case is the translation that the team gives to sprite) based on the instructions that are programmed for the object, they are composed of brightly colored graphical blocks, batteries form which gives them the script name. Its interface and the concept of blocks to implement the code make it very attractive and understandable for children and teenagers [10]. \n\nAnother IDE for visual languages, which is also the one with the most consolidation is the Virtual Instrumentation Engineering Workbench Laboratory (known commercially as LabVIEW). It is a development platform for a visual environment developed by National Instruments, this IDE provides the necessary tools to obtain a layer of data where the signals and related data allowed by libraries are acquired. Usually the development of such specialized applications, involves the use of complicated languages on complex architectures, such as VHDL or assembler.",
            "score": 0.38084346631584454,
            "section_title": "Visual languages.",
            "char_start_offset": 5390,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 245
                },
                {
                    "start": 246,
                    "end": 365
                },
                {
                    "start": 368,
                    "end": 470
                },
                {
                    "start": 471,
                    "end": 683
                },
                {
                    "start": 686,
                    "end": 752
                },
                {
                    "start": 753,
                    "end": 840
                },
                {
                    "start": 843,
                    "end": 893
                },
                {
                    "start": 894,
                    "end": 982
                },
                {
                    "start": 983,
                    "end": 1131
                },
                {
                    "start": 1134,
                    "end": 1346
                },
                {
                    "start": 1349,
                    "end": 1673
                },
                {
                    "start": 1674,
                    "end": 1811
                },
                {
                    "start": 1814,
                    "end": 1994
                },
                {
                    "start": 1995,
                    "end": 2217
                },
                {
                    "start": 2218,
                    "end": 2370
                }
            ],
            "ref_mentions": [
                {
                    "start": 679,
                    "end": 682,
                    "matchedPaperCorpusId": "2361261"
                },
                {
                    "start": 1806,
                    "end": 1810,
                    "matchedPaperCorpusId": "17911112"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.75146484375
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "We want to learn how block-based environments are developed. However, given the nature of the papers, this is a non-trivial activity because in most cases we noticed that authors do not mention these details. Below, we present the data we extracted. Depending on how the language was implemented, we classified each paper into one of four categories General-Purpose Programming Language (GPL), grammar, DSL, and not available (N/A). As shown in Table 6, 93 tools did not explicitly mention the tools used for its development, 55 were implemented using a GPL, and from the remaining three: one used a visual language, one used a grammar, and one used a DSL, respectively. \n\nLikewise, we studied what programming languages were used in the implementation of these block-based environments. Table 7 presents a summary of our findings. For conciseness we grouped some of the languages (for the full Manuscript submitted to ACM list see Appendix F). For instance, some languages only mention the use of HTML, so we count it as part of HTML, JavaScript, and CSS. As mentioned before, implementation details are not always discussed, and this is reflected in Table 7; 100 papers do not mention what programming language was used for the development. After this, we see that the most popular programming language for the development of block-based environments is JavaScript. Counting all the appearances, this language was used in the development of more than 30 block-based editors. Another interesting fact is that there is only one language developed using a Language Workbench (JastAdd [150]). \n\nFollowing this direction, we explored whether the papers did not mention programming languages at all, or it was just that they did not present implementation details of their tooling. We used the list of the 50 most popular languages as reported by the TIOBE index [27], but \"visual basic\" was omitted from the search because of the many false positives with the common words \"visual\" and \"basic\". In fact we did not find any block-based editor that was implemented in Visual Basic. \n\nBased on the list of programming languages, we developed a tool 3 for mining the corpus of PDF files and counting the occurrences of each programming language. The results in Figure 5 show the popularity of each of programming language.",
            "score": 0.3805593549538976,
            "section_title": "RQ2: What are the tools used to develop block-based environments?",
            "char_start_offset": 31228,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 60
                },
                {
                    "start": 61,
                    "end": 208
                },
                {
                    "start": 209,
                    "end": 249
                },
                {
                    "start": 250,
                    "end": 432
                },
                {
                    "start": 433,
                    "end": 670
                },
                {
                    "start": 673,
                    "end": 787
                },
                {
                    "start": 788,
                    "end": 831
                },
                {
                    "start": 832,
                    "end": 944
                },
                {
                    "start": 945,
                    "end": 1056
                },
                {
                    "start": 1057,
                    "end": 1242
                },
                {
                    "start": 1243,
                    "end": 1367
                },
                {
                    "start": 1368,
                    "end": 1476
                },
                {
                    "start": 1477,
                    "end": 1590
                },
                {
                    "start": 1593,
                    "end": 1777
                },
                {
                    "start": 1778,
                    "end": 1991
                },
                {
                    "start": 1992,
                    "end": 2076
                },
                {
                    "start": 2079,
                    "end": 2238
                },
                {
                    "start": 2239,
                    "end": 2315
                }
            ],
            "ref_mentions": [
                {
                    "start": 1583,
                    "end": 1588,
                    "matchedPaperCorpusId": "197640713"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.272705078125
        },
        {
            "corpus_id": "174802996",
            "title": "Teaching Computer Programming to Post-millennial Kids: Overview of Goals, Activities and Supporting Tools",
            "text": "Visual programming using block-based languages is widely used to teach coding to children because blocks are easy to recognise through their shape, colour and position in a palette.Those shapes are also designed to only allow valid assembly which rules out a large class of syntactic errors that are a main problem for beginners with a textual programming language.Such languages come in different flavours but most of them are now web-based, and Open Source.Many also rely on the Blockly javascript framework (Google, 2012).The most common are: \u2022 Scratch (MIT, 2002) emphasises on sharing, reusing and combining code through its large community.A large repository of code is available.An example of aquaponics simulation (discussed in section 3.3) is depicted in Figure 6.\u2022 MIT App Inventor (MIT, 2012) is directed to the generation of mobile application.In addition to blocks, it also includes a quite powerful yet simple screen designer.It also supports project sharing.\n\n\u2022 Microsoft MakeCode (Microsoft, 2018) is a framework for creating domain-specific programming experiences for beginners.It brings computer science to life for all students with fun projects, immediate results, and both block and text editors for learners at different levels.Many robotics toolkits such as LEGO Mindstorms or Nao also come with a block-based language for programming a robot through specific blocks mapped to the available sensors and actuators.Although often closed, Open Source alternative exists, e.g.Mindstorms blocks are available in Scratch, App Inventor and MakeCode.Figure 7 shows a typical FLL mission and the corresponding Mindstorms code at the top.Note that in parallel to code the robot also needs to be designed as part of a wider project activity (see next section).Learning textual programming language is proposed by frameworks like CodeCombat (Saines et al., 2013) or CodeMonley (Schor et al., 2016) typically for languages like Python and Javascript variants.\n\nBoth those visual and textual languages provide progressive, usually game-based, challenges to teach basic concept such as objects, function calls, arguments, variables, arrays, loops, conditions and various operators.They also typically rely on event-driven programming for managing user interactions, driving animations or controlling hardware (e.g.robot).",
            "score": 0.3798468635151155,
            "section_title": "Learning to Code",
            "char_start_offset": 9186,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 181
                },
                {
                    "start": 181,
                    "end": 365
                },
                {
                    "start": 365,
                    "end": 459
                },
                {
                    "start": 459,
                    "end": 525
                },
                {
                    "start": 525,
                    "end": 646
                },
                {
                    "start": 646,
                    "end": 686
                },
                {
                    "start": 686,
                    "end": 773
                },
                {
                    "start": 773,
                    "end": 856
                },
                {
                    "start": 856,
                    "end": 940
                },
                {
                    "start": 940,
                    "end": 973
                },
                {
                    "start": 975,
                    "end": 1096
                },
                {
                    "start": 1096,
                    "end": 1251
                },
                {
                    "start": 1251,
                    "end": 1437
                },
                {
                    "start": 1437,
                    "end": 1496
                },
                {
                    "start": 1496,
                    "end": 1566
                },
                {
                    "start": 1566,
                    "end": 1652
                },
                {
                    "start": 1652,
                    "end": 1773
                },
                {
                    "start": 1773,
                    "end": 1970
                },
                {
                    "start": 1972,
                    "end": 2190
                },
                {
                    "start": 2190,
                    "end": 2323
                },
                {
                    "start": 2323,
                    "end": 2330
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.736328125
        },
        {
            "corpus_id": "221802417",
            "title": "A Visual Language for Composable Inductive Programming",
            "text": "Visual representations of programs have co-existed with software for most of its history. Flowcharts were widely used for specification and documentation purposes by the time that high level languages were introduced in the 1950s. Interactive creation of programs as diagrams was introduced by Sutherland in the 1960s as one of the first applications of the enabling graphical display and input technologies [8]. \n\nVisual programming became more widespread in the 1980s and 1990s with the introduction of graphical workstations and personal computers [9]. There are now many visual programming languages [10,11,12]. Many of which are aimed at education or niche domains [13,14,15,16,17]. \n\nVisual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose. \n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users. \n\nThe source code of a conventional program often encodes several orthogonal aspects of software including program statements, program structure, variable scope, control flow, threading, message passing and data flow. Visual languages do not always need to describe a complete system. For example, entity relationship and class diagrams are widely used in some circles to describe database schemas and class models respectively. UML, for example, includes a number of different diagram types to model different system perspectives. While it is possible to generate fragments of code from UML diagrams it is not in itself a complete programming language. \n\nSpecial purpose or domain specific visual languages have also been developed. One interesting early example was the Speech Knowledge Interface [19] which demonstrated that complex knowledge elicitation could be successfully achieved by providing the domain expert with a bespoke visual language. Many other domain specific visual languages have been developed. \n\nVisual languages that try to be complete, general purpose programming languages face a number of challenges. Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality.",
            "score": 0.37955109953353117,
            "section_title": "Visual Programming",
            "char_start_offset": 2695,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 89
                },
                {
                    "start": 90,
                    "end": 230
                },
                {
                    "start": 231,
                    "end": 412
                },
                {
                    "start": 415,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 615
                },
                {
                    "start": 616,
                    "end": 687
                },
                {
                    "start": 690,
                    "end": 798
                },
                {
                    "start": 799,
                    "end": 887
                },
                {
                    "start": 890,
                    "end": 927
                },
                {
                    "start": 930,
                    "end": 973
                },
                {
                    "start": 976,
                    "end": 1015
                },
                {
                    "start": 1018,
                    "end": 1160
                },
                {
                    "start": 1161,
                    "end": 1305
                },
                {
                    "start": 1308,
                    "end": 1523
                },
                {
                    "start": 1524,
                    "end": 1590
                },
                {
                    "start": 1591,
                    "end": 1734
                },
                {
                    "start": 1735,
                    "end": 1837
                },
                {
                    "start": 1838,
                    "end": 1959
                },
                {
                    "start": 1962,
                    "end": 2039
                },
                {
                    "start": 2040,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2322
                },
                {
                    "start": 2325,
                    "end": 2433
                },
                {
                    "start": 2434,
                    "end": 2625
                }
            ],
            "ref_mentions": [
                {
                    "start": 551,
                    "end": 554,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 604,
                    "end": 608,
                    "matchedPaperCorpusId": "5257722"
                },
                {
                    "start": 611,
                    "end": 614,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 670,
                    "end": 674,
                    "matchedPaperCorpusId": "44279097"
                },
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "30037917"
                },
                {
                    "start": 677,
                    "end": 680,
                    "matchedPaperCorpusId": "158715"
                },
                {
                    "start": 683,
                    "end": 686,
                    "matchedPaperCorpusId": "425881"
                },
                {
                    "start": 793,
                    "end": 797,
                    "matchedPaperCorpusId": "561505"
                },
                {
                    "start": 2105,
                    "end": 2109,
                    "matchedPaperCorpusId": "30404857"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94140625
        },
        {
            "corpus_id": "246022597",
            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
            "text": "Not only syntax, but novice programmers may also encounter difficulty in trying to evaluate a logical error. A logical error is also a common mistake, no exception to most experience programmers, and is not easy to evaluate since a logical error requires some moderate competence in a programming including a functionality of currently used the programming language. While the core function of programming language is to solve a problem by creating a set of instructions so called algorithm, a programmer tends to waste time for this process. These difficulties obstruct the main purpose of programming. \n\nRecently, visual programming has become popular for the novice and first-time learner. This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems [3]. There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7,8] which employ a concept of representing computer instruction into a block called block-based programming. Visual programming seems promising for a new programming paradigm as multiple applications employed the idea and concept. For instance, the works of [9] and [10] implemented a visual programming for a machine learning application through a web application. Especially, in [10], the broad of application using MIT block is introduced. [11,12,13,14,15] have selected a Google Blockly, an open-source block-based programming which are developed on web application as a tool for a visual programming and apply to a variety of application ranging from robot to Augment Reality (AR) application. However, [11,12,13,14,15] have some limitations. These works require a user to install and setup a required tool before.",
            "score": 0.3793446774400553,
            "section_title": "Introduction",
            "char_start_offset": 4515,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 108
                },
                {
                    "start": 109,
                    "end": 366
                },
                {
                    "start": 367,
                    "end": 542
                },
                {
                    "start": 543,
                    "end": 603
                },
                {
                    "start": 606,
                    "end": 692
                },
                {
                    "start": 693,
                    "end": 801
                },
                {
                    "start": 802,
                    "end": 852
                },
                {
                    "start": 853,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 1069
                },
                {
                    "start": 1070,
                    "end": 1273
                },
                {
                    "start": 1274,
                    "end": 1566
                },
                {
                    "start": 1567,
                    "end": 1688
                },
                {
                    "start": 1689,
                    "end": 1823
                },
                {
                    "start": 1824,
                    "end": 1900
                },
                {
                    "start": 1901,
                    "end": 2156
                },
                {
                    "start": 2157,
                    "end": 2205
                },
                {
                    "start": 2206,
                    "end": 2277
                }
            ],
            "ref_mentions": [
                {
                    "start": 1065,
                    "end": 1068,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 1901,
                    "end": 1905,
                    "matchedPaperCorpusId": "15999236"
                },
                {
                    "start": 1908,
                    "end": 1911,
                    "matchedPaperCorpusId": "35216497"
                },
                {
                    "start": 1911,
                    "end": 1914,
                    "matchedPaperCorpusId": "221243933"
                },
                {
                    "start": 1914,
                    "end": 1917,
                    "matchedPaperCorpusId": "31119847"
                },
                {
                    "start": 2166,
                    "end": 2170,
                    "matchedPaperCorpusId": "15999236"
                },
                {
                    "start": 2173,
                    "end": 2176,
                    "matchedPaperCorpusId": "35216497"
                },
                {
                    "start": 2176,
                    "end": 2179,
                    "matchedPaperCorpusId": "221243933"
                },
                {
                    "start": 2179,
                    "end": 2182,
                    "matchedPaperCorpusId": "31119847"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.90771484375
        },
        {
            "corpus_id": "234174800",
            "title": "Training in Programming using Innovative Means",
            "text": "Based on the review of existing innovative tools related to programming training and in particular with the description of algorithms was selected for graphical description through a block diagram (block diagram language) when creating a site with basic algorithms, the Flowgorithm application, because it can also automatically generate program code (description using a programming language) and be executed with specific data that are entered from the keyboard. \n\nLucidchart is suitable for use for a block diagram in general without a specific condition for verification, because on its basis there is no way to generate program code or execute it through Flowgorithm. \n\nPython Tutor was chosen to improve programming training by visualizing the implementation of algorithms. \n\nCreated site that includes for each of the algorithms they verbal description, graphical representation by flowchart created with an innovative tool and code realization and visualization. \n\nDiscussed are seven basic algorithms that are associated with early education programming and are implemented and only with simple variables. One of them is described with two different implementations. Others are considered in several variants related to their varieties. The following algorithms are presented in detail: \n\n\u2022 Exchange the values of two variables -By auxiliary variable -By arithmetic operations \u2022 Finding the smallest number \u2022 Finding the largest number \u2022 Sum of a number of numbers \u2022 The product of a number of numbers \u2022 Number of a number of numbers that meet a given condition -In general (without a specific condition) -Provided multiplicity of a given number \u2022 Separate digits by number -Display the digits of a number in reverse order -Sum of digits of a number -Number of digits of a number Each of them is described in three ways: \u2022 Verbal, using natural language; \u2022 Graphic, using block-schematic language \u2022 Programming language. \n\nFigure 1 shows with Flowgorithm a representation of an algorithm for exchanging the values of two variables with a third auxiliary variable through a block diagram and a C++ programming language and its execution with user-entered input data. Visualization of the algorithm has also been added in two ways: through Flowgorithm and Python Tutor. The same type of presentation allows the construction of a system that can be applied to all other algorithms in the learning process.",
            "score": 0.37901133007244014,
            "section_title": "Discussion",
            "char_start_offset": 7271,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 464
                },
                {
                    "start": 467,
                    "end": 672
                },
                {
                    "start": 675,
                    "end": 779
                },
                {
                    "start": 782,
                    "end": 970
                },
                {
                    "start": 973,
                    "end": 1114
                },
                {
                    "start": 1115,
                    "end": 1175
                },
                {
                    "start": 1176,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1295
                },
                {
                    "start": 1298,
                    "end": 1929
                },
                {
                    "start": 1932,
                    "end": 2174
                },
                {
                    "start": 2175,
                    "end": 2276
                },
                {
                    "start": 2277,
                    "end": 2411
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.52587890625
        },
        {
            "corpus_id": "249431936",
            "title": "An Exploratory Analysis of Feedback Types Used in Online Coding Exercises",
            "text": "According to Shu [42], programming involves both hemispheres of the brain so that the use of images for learning processes in programming education is recommended. Likewise, visual programming languages, such as Scratch, are recommended by some educators as an adequate tool for the introductory phase of programming in higher education [25,46], or at least as a supportive measure [4]. Today, an extensive collection of Scratch projects with stories, games and animations is available for practice. Blockly The Blockly open source library [9] allows developers to create blockbased visual programs and integrate them into apps or web applications. The display of code blocks, the design of keywords, and how a block-based program runs, depends on the developers as well as the intended context [9,7,36]. Blockly is the basis for the author's development of a feedback prototype that offers a predefined selection of block-based code snippets [17,20]. The implemented task asks students to develop a recursive solution for the decomposition of a closed matryoshka doll. Students can drag and drop the \"blockly\" representations of code across the workspace and attach them to each other as illustrated in Figure 3. Pseudo code is generated and displayed simultaneously depending Fig. 3. Screenshot of a feedback prototype that utilizes Blockly to recursively unpack a matryoshka doll [17,16] on the blocks' use and arrangement in the workspace. As soon as learners hit the execute-button, an interactive visualizations and a short textual feedback is presented, each depending on the individual input. Individual error messages for 168 error combinations have been prepared. Moreover, a hint-button is available that offers additional, individual tutoring feedback. The help-button provides support regarding the usability of the blocks and the functions of the several buttons. A debugger enables the identification of the first incorrect block by highlighting it with a yellow frame and star.",
            "score": 0.3771170315342809,
            "section_title": "Tools Offering Online Coding Exercises",
            "char_start_offset": 10075,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 163
                },
                {
                    "start": 164,
                    "end": 386
                },
                {
                    "start": 387,
                    "end": 499
                },
                {
                    "start": 500,
                    "end": 648
                },
                {
                    "start": 649,
                    "end": 804
                },
                {
                    "start": 805,
                    "end": 951
                },
                {
                    "start": 952,
                    "end": 1069
                },
                {
                    "start": 1070,
                    "end": 1443
                },
                {
                    "start": 1444,
                    "end": 1600
                },
                {
                    "start": 1601,
                    "end": 1673
                },
                {
                    "start": 1674,
                    "end": 1764
                },
                {
                    "start": 1765,
                    "end": 1877
                },
                {
                    "start": 1878,
                    "end": 1993
                }
            ],
            "ref_mentions": [
                {
                    "start": 337,
                    "end": 341,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 341,
                    "end": 344,
                    "matchedPaperCorpusId": "61034415"
                },
                {
                    "start": 382,
                    "end": 385,
                    "matchedPaperCorpusId": "56686833"
                },
                {
                    "start": 800,
                    "end": 803,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 1387,
                    "end": 1390,
                    "matchedPaperCorpusId": "4870931"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.759765625
        },
        {
            "corpus_id": "268272915",
            "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
            "text": "LabVIEW, short for Laboratory Virtual Instrument Engineering Workbench, is a visual programming environment commonly used in measurement, automation, or control applications. Unlike traditional text-based programming languages, LabVIEW utilizes a graphical data flow programming paradigm where the code is represented in the form of interconnected graphical elements called virtual instruments, denoted as VIs, that can be perceived as functions or subroutines in conventional programming languages. The abstract syntax is typically represented as a data flow graph or a block diagram, where each VI or block is a self-contained unit of code or a native function. The execution of the program is then conceptualized as a flow of data, where variables are propagated via the wires through a sequential series of connected functions, which execute as soon as all data is available on the inputs. \n\nThe core of each VI is divided into two interdependent parts: the front panel, which represents the user interface, and the block diagram, i.e., the code, responsible for the program's logic and functionality. The visual representation of both parts of a simple part of a code is demonstrated in Fig 1. \n\nIf we analyze this part of the code from the programmer's viewpoint, the created method in LabVIEW carries the name add_pi and has one numeric input as a parameter. The output of this function is then an input value increased by the value of \u03c0. However, in a much deeper sense of the language, the created program contains four basic objects (two input objects, a function, and an output), where each object is represented by a specific icon in the block diagram. These objects can be considered instances of objects in object-oriented programming, and therefore each of the four elements contains its own private data and methods (such as captions, labels, or set-value methods). Since every single object inserted in the block diagram is a child of a prime class called LabVIEW Object, each element created in the block diagram and also on the front panel is a child of this class. Hence, if we are able to refer to any object by using a pointer, we can also programmatically change its publicly accessible data or invoke its publicly accessible methods. It is also possible to get this reference through all objects contained in the data of our \"main\" object, which is our program.",
            "score": 0.3770633386521647,
            "section_title": "Labview development environment language syntax",
            "char_start_offset": 9164,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 174
                },
                {
                    "start": 175,
                    "end": 499
                },
                {
                    "start": 500,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 893
                },
                {
                    "start": 896,
                    "end": 1105
                },
                {
                    "start": 1106,
                    "end": 1198
                },
                {
                    "start": 1201,
                    "end": 1365
                },
                {
                    "start": 1366,
                    "end": 1445
                },
                {
                    "start": 1446,
                    "end": 1664
                },
                {
                    "start": 1665,
                    "end": 1881
                },
                {
                    "start": 1882,
                    "end": 2084
                },
                {
                    "start": 2085,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2385
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.73974609375
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "To answer the first research question, we analyzed the selected articles against the five research question dimensions discussed in the subsequent subsections. Furthermore, we used examples from some of the selected articles to shed light on details of interest. \n\nA. RQ1-D1: VPL CLASSIFICATION 43.3% (13) of the articles used a block-based approach, while 40% (12) of the selected articles used a diagram-based approach. 13.3% (4) of the selected articles used a form-based approach, whereas only 6.6% (2) articles used an icon-based approach (Figure 4). Despite the differences of the approaches, all the tools use high-level abstractions to simplify the process of creating a program and hide implementation details. The abstractions are often represented as visual components that end users can drag and drop. The abstractions allow end users to incorporate into their applications: functions [32], [51], web services [43] or software modules [41]. Abstractions are used to increase tool accessibility though this may be at the cost of expressiveness as the abstractions are often designed to operate in a restricted way. Another common theme is the use of color to represent data flowing between components [51], [60].",
            "score": 0.37594480507987044,
            "section_title": "VI. FIRST RESEARCH QUESTION DIMENSIONS",
            "char_start_offset": 25531,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 159
                },
                {
                    "start": 160,
                    "end": 262
                },
                {
                    "start": 265,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 719
                },
                {
                    "start": 720,
                    "end": 813
                },
                {
                    "start": 814,
                    "end": 952
                },
                {
                    "start": 953,
                    "end": 1125
                },
                {
                    "start": 1126,
                    "end": 1223
                }
            ],
            "ref_mentions": [
                {
                    "start": 897,
                    "end": 901,
                    "matchedPaperCorpusId": "66914713"
                },
                {
                    "start": 903,
                    "end": 907,
                    "matchedPaperCorpusId": "26243684"
                },
                {
                    "start": 922,
                    "end": 926,
                    "matchedPaperCorpusId": "195785412"
                },
                {
                    "start": 947,
                    "end": 951,
                    "matchedPaperCorpusId": "146808112"
                },
                {
                    "start": 1212,
                    "end": 1216,
                    "matchedPaperCorpusId": "26243684"
                },
                {
                    "start": 1218,
                    "end": 1222,
                    "matchedPaperCorpusId": "7388219"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9013671875
        },
        {
            "corpus_id": "264306865",
            "title": "Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers",
            "text": "No-Code programming is a special case of Low-Code (visual) programming [13]. Low-Code requires minimal but some programming skills, targeting professionals that lack expertise in a speci c domain, whereas No-Code requires technical skills but no programming skills, targeting end-users who are citizens. \n\nBoth No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code. \n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code. With Kogi [37], a tool for deriving Blockly code from a simpli ed context-free grammar of a given language [36], a block-based coding visual environment can be generated for many languages. However, not every block-based coding visual environment necessarily provides a No-Code programming experience for citizen developers, because the graphical abstractions do not necessarily hide the complexity of the underlying language. \n\nToo distinguishes itself from traditional visual languages in its intent and purpose. The intention of Low-Code platforms is often to reduce coding e ort in order to enable rapid development. In comparison, the intention of Too is to empower citizen developers. Most No-Code and Low-Code platforms are special purpose, targeting a speci c domain, such as No-Code AI (e.g., Obviously.AI) 10 or Low-Code Machine Learning (e.g., AutoML).11 They enable \"domain citizens\" to reap the bene ts of the domain without deep knowledge of that domain. In comparison, Too is general purpose. \n\nOne of the main goals of Too is to make programming accessible for citizens. Although Too provides an ecosystem to create complete software solutions, it would be bene cial to have interfaces to other languages. This would enable integration with modules developed by professional programmers in di erent programming languages.",
            "score": 0.37547402264727736,
            "section_title": "Discussion and Related Work",
            "char_start_offset": 53870,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 76
                },
                {
                    "start": 77,
                    "end": 303
                },
                {
                    "start": 306,
                    "end": 462
                },
                {
                    "start": 463,
                    "end": 524
                },
                {
                    "start": 527,
                    "end": 699
                },
                {
                    "start": 700,
                    "end": 820
                },
                {
                    "start": 821,
                    "end": 991
                },
                {
                    "start": 992,
                    "end": 1181
                },
                {
                    "start": 1182,
                    "end": 1418
                },
                {
                    "start": 1421,
                    "end": 1506
                },
                {
                    "start": 1507,
                    "end": 1612
                },
                {
                    "start": 1613,
                    "end": 1682
                },
                {
                    "start": 1683,
                    "end": 1857
                },
                {
                    "start": 1858,
                    "end": 1960
                },
                {
                    "start": 1961,
                    "end": 1999
                },
                {
                    "start": 2002,
                    "end": 2078
                },
                {
                    "start": 2079,
                    "end": 2213
                },
                {
                    "start": 2214,
                    "end": 2329
                }
            ],
            "ref_mentions": [
                {
                    "start": 556,
                    "end": 560,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 694,
                    "end": 698,
                    "matchedPaperCorpusId": "27376867"
                },
                {
                    "start": 846,
                    "end": 850,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 1002,
                    "end": 1006,
                    "matchedPaperCorpusId": "227154812"
                },
                {
                    "start": 1099,
                    "end": 1103,
                    "matchedPaperCorpusId": "243867310"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88671875
        },
        {
            "corpus_id": "232029733",
            "title": "A survey on the design space of end-user-oriented languages for specifying robotic missions",
            "text": "Block-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45].\n\nThe majority, that is, 23 out of our 30 environments offer a block-based syntax. Most of these environments are used for teaching, as shown in Table 2. There is some attempt to use these languages for industrial use. 2 The syntaxes of these block-based languages are typically implemented using the popular open-source libraries Blockly [17,88] and Scratch [51]. Specifically, Blockly is developed by Google for creating visual notations, where each block represents a programming concept. The library can be extended to define new blocks, support functions, and procedures. Blockly allows access to the parse tree and offers a code-generation framework to generate code in the target (general-purpose) language [87]. Scratch is similar to Blockly, but developed by the MIT media laboratory [51]. The library can be extended to add custom, end-user-oriented blocks.",
            "score": 0.37534345840243005,
            "section_title": "Environments with block-based languages",
            "char_start_offset": 15063,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 812,
                    "end": 815,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 1183,
                    "end": 1187,
                    "matchedPaperCorpusId": "6808751"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.90234375
        },
        {
            "corpus_id": "64771513",
            "title": "Robots and Their Applications",
            "text": "Every educational robotics system includes a software development environment. The programming language can be a version of a standard programming language like Java or Python. Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes.",
            "score": 0.3749681041156981,
            "section_title": "Software Development Environments",
            "char_start_offset": 13160,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 78
                },
                {
                    "start": 79,
                    "end": 176
                },
                {
                    "start": 177,
                    "end": 298
                },
                {
                    "start": 301,
                    "end": 411
                },
                {
                    "start": 412,
                    "end": 518
                },
                {
                    "start": 519,
                    "end": 656
                },
                {
                    "start": 659,
                    "end": 730
                },
                {
                    "start": 731,
                    "end": 858
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9033203125
        },
        {
            "corpus_id": "199002134",
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "text": "Most common syntax errors found in text-based languages are avoided or they cannot occur [41]. However, according to Bau et al. [40], \" . . . plain text as the representation of program text is still the norm for proficient and professional programmers and the accepted educational goal for programming instruction in schools in many countries (p. 1)\", which means that students will face a transition from blocks to text-based programming somewhere in their school life, but the move to new text-based environments is still a challenge. \n\nAnother problem attributed to block-based programming is that it becomes difficult to understand/debug programs when they start having many blocks of code. The diversity of colors of the blocks and the need to move the page from top to bottom (and vice versa) in search of execution errors, ends up confusing the programmers [21]. \n\nIn recent years, a new type of environment has emerged, joining the two models of programming, block-based and text-based. In these environments, pupils have the possibility to switch between the block-based and text-based versions of their programs. This strategy tends to be used by newcomers when using these environments to learn to program [42,43]. \n\nUsing these VPEs, pupils can learn and practice the main concepts of programming, such as instructions, containers (variables, constants and lists), conditional statements, loops, logical operators and input/output data. In addition, some studies concluded that block-based programming, together with efficient pedagogy, can promote a strong path for developing computational skills and prepare pupils for computer science education [44]. \n\nNowadays, there are many visual programming environments available as tools to introduce programming in primary and secondary schools. All these applications share the same principles of programming, but different core characteristics, forms of programming, system requirements, and types of processing, among others. In this article we report a cross-analysis of 26 selected VPEs (for example Scratch, App Inventor, Alice, Pencil Code, Tynker, Kodu, Code Studio, Thunkable, m-Block) focusing on their pedagogical potentialities and characteristics.",
            "score": 0.3744672363710637,
            "section_title": "Visual and Block-based Programming Environment",
            "char_start_offset": 14468,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 94
                },
                {
                    "start": 95,
                    "end": 141
                },
                {
                    "start": 142,
                    "end": 347
                },
                {
                    "start": 348,
                    "end": 537
                },
                {
                    "start": 540,
                    "end": 695
                },
                {
                    "start": 696,
                    "end": 870
                },
                {
                    "start": 873,
                    "end": 995
                },
                {
                    "start": 996,
                    "end": 1123
                },
                {
                    "start": 1124,
                    "end": 1226
                },
                {
                    "start": 1229,
                    "end": 1449
                },
                {
                    "start": 1450,
                    "end": 1667
                },
                {
                    "start": 1670,
                    "end": 1804
                },
                {
                    "start": 1805,
                    "end": 1987
                },
                {
                    "start": 1988,
                    "end": 2219
                }
            ],
            "ref_mentions": [
                {
                    "start": 89,
                    "end": 93,
                    "matchedPaperCorpusId": "62831677"
                },
                {
                    "start": 865,
                    "end": 869,
                    "matchedPaperCorpusId": "7587880"
                },
                {
                    "start": 1218,
                    "end": 1222,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 1222,
                    "end": 1225,
                    "matchedPaperCorpusId": "207220310"
                },
                {
                    "start": 1662,
                    "end": 1666,
                    "matchedPaperCorpusId": "557120"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8076171875
        },
        {
            "corpus_id": "257580368",
            "title": "Modularization for mastery learning in CS1: a 4-year action research study",
            "text": "The process of learning computational thinking and programming demands the concurrent display of a complex mix of skills, including reading comprehension, problem analysis, abstraction, and elaborating the solution representation. According to learning edge momentum theory (Robins, 2010), mastering these basic skills is key to academic success in the course. Traditional ways in which computational thinking and algorithm design skills have been taught in CS1 courses have been based on the generation of pseudocode, flowcharts or the use of visual modeling tools. More recently, the use of block programming languages, such as MIT Scratch and code.org, has become common, especially in K12 education. Despite the fact that these languages are frequently used for recreational purposes (e.g., for creating video games and multimedia), experience in the modular course shows that they are an powerful means for introducing post-secondary students to algorithm design and programming. Through these languages, students do not have to type code, including all the syntactic subtleties involved, such as indenting code with tabulation, and correctly typing each line. Instead, students use programming blocks that are easily recognizable (i.e., visual, with definite shapes and colors), and syntactically helpful (pluggable). The fact that with block programming students do not have to type code from the very beginning in a blank file brings the benefit of offloading some of the cognitive load of the task, so that they can rather dedicate more cognition and effort to model the solution, test it, and try different ways to solve the problem. In addition, other desirable skills, such as program tracing and debugging can be developed by the students early in the course through the use of block-based programming. The introduction of block-based programming and text-based programming worked well in a spiral fashion, meaning that students can be introduced to text-based programing through the same examples they saw before with block-based programming. The intent of this is to facilitate schema building and knowledge transfer, and again, offloading some of the cognitive load, so that when they come to learn the text-based programming language they can focus on learning the syntax and the mechanics of typing code sentences, through examples whose algorithmic and computational underpinnings they are already familiar with.",
            "score": 0.3743472522519969,
            "section_title": "Block programming before text-based programming",
            "char_start_offset": 64757,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 230
                },
                {
                    "start": 231,
                    "end": 360
                },
                {
                    "start": 361,
                    "end": 566
                },
                {
                    "start": 567,
                    "end": 703
                },
                {
                    "start": 704,
                    "end": 984
                },
                {
                    "start": 985,
                    "end": 1165
                },
                {
                    "start": 1166,
                    "end": 1323
                },
                {
                    "start": 1324,
                    "end": 1643
                },
                {
                    "start": 1644,
                    "end": 1815
                },
                {
                    "start": 1816,
                    "end": 2056
                },
                {
                    "start": 2057,
                    "end": 2431
                }
            ],
            "ref_mentions": [
                {
                    "start": 274,
                    "end": 288,
                    "matchedPaperCorpusId": "10852710"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.55712890625
        },
        {
            "corpus_id": "62322929",
            "title": "Dynamic Modeling of Scorbot-ER Vu Plus Industrial Robot Manipulator using LabVIEW",
            "text": "LabVIEW (Laboratory Virtual Instrument Engineering Workbench) is a graphical programming language which implements icons as an alternative to text lines for creating applications. In dissimilarity to text-based programming language which instructs the program execution order, LabVIEW utilizes dataflow programming, where the data flow via the nodes on the block diagram brings up the order of execution of the VIs and its functions. VIs, or virtual instruments, is LabVIEW programs which replicate physical instruments. Ever VI holds components that are three in quantity: A front panel, a block diagram and a connector panel. The control panel symbolizes the VI in the block diagrams of other, calling VIs. Controls and indicators on the front panel permits input data or extract data to an operator from a functioning virtual instrument. In LabVIEW, a user interface could be build by means of a tools and objects set. The user interface has been referred much as the front panel and it could also serve as a programmatic interface. Hence a virtual instrument could either be run as a program, holding the front panel helping as a user interface, or, on dropping as a node onto the block diagram, the front panel briefs the inputs and outputs for the given node via the connector pane. Into a larger program this involve each VI could be effortlessly tested previous of being embedded as a subroutine. Then sum up code utilizing graphical representations of functions for controlling the front panel objects. This graphical source code has also referred to be G code or block diagram code. By some means, the block diagram looks like a flowchart. Figure 3 illustrates simulated window of LabVIEW program output.",
            "score": 0.37418714447002,
            "section_title": "Simulation of Scorbot-Er Vu Plus Robot in Labview",
            "char_start_offset": 9841,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.607421875
        },
        {
            "corpus_id": "249298826",
            "title": "Improving Computational Thinking in Nursing Students through Learning Computer Programming",
            "text": "Block-based visual programming environments (Code.org, Lightbot) and Python programming language were selected for teaching the introduction to programming and development of skills related to computational thinking in the third learning unit of the Basic Computer course taught to students of the nursing professional career in the period 2020-B. \n\nTable I shows the programming topics that were developed using the selected programming environments, where the students learned computational thinking concepts considered in the work of Luo, Antonenko and Davis [17], such as sequential instructions, conditionals, and loops. \n\nStudents began learning the block-based visual programming language using Code.org by completing exercises in the \"hour of code\" tutorials that enabled them to understand concepts of sequential statements, loops, and functions. An example of block programming on Code.org is shown in Fig. 1, where students understood the utility of iterative statements by replacing repetitive blocks of code (left) with loops (right) to draw the geometric figure of the square, in which the students acquired some computational thinking practices such as iteration and abstraction through the identification of repetitive patterns, which allowed them to acquire the ability to reduce unnecessary details and propose new solutions. www.ijacsa.thesai.org The Lightbot video game was used to reinforce algorithmic thinking skills in students by thinking in sequence of instructions for problem solving. Fig. 2 shows an example of the Lightbot third level solution using only sequential instructions (move, jump, turn left) in the MAIN METHOD for the robot to move and turn on all blue blocks, which is the objective of the video game, where repetitive patterns such as moving forward and turning on are identified. \n\nIn Fig. 3, a second solution for the third level of Lightbot is shown, where students, through generalization (identification of repetitive patterns go forward and turn on), abstraction (reduction of unnecessary details) and decomposition of the program using one of the functions (FUNCT. 1), acquire the ability to find better solutions to the problem and make use of code reuse. \n\nIn addition, the students practiced the Lightbot video game from Code.org, where they used recursion to create loops in the PROC1 procedure (Fig. 4).",
            "score": 0.37258194873527073,
            "section_title": "IV. DESCRIPTION OF THE EXPERIENCE",
            "char_start_offset": 9213,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 54
                },
                {
                    "start": 55,
                    "end": 347
                },
                {
                    "start": 350,
                    "end": 625
                },
                {
                    "start": 628,
                    "end": 855
                },
                {
                    "start": 856,
                    "end": 1343
                },
                {
                    "start": 1344,
                    "end": 1365
                },
                {
                    "start": 1366,
                    "end": 1512
                },
                {
                    "start": 1513,
                    "end": 1824
                },
                {
                    "start": 1827,
                    "end": 2115
                },
                {
                    "start": 2116,
                    "end": 2207
                },
                {
                    "start": 2210,
                    "end": 2284
                },
                {
                    "start": 2285,
                    "end": 2359
                }
            ],
            "ref_mentions": [
                {
                    "start": 562,
                    "end": 566,
                    "matchedPaperCorpusId": "210118220"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.609375
        },
        {
            "corpus_id": "253049931",
            "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
            "text": "A block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled. \n\nModern block-based programming editors offer support for drag-and-drop of blocks and for snapping matching blocks together. Individual blocks can be picked from a palette and inserted into a program by dropping them on another block where it will snap in place if the dents/nobs of the blocks match. This feature helps to intuitively explain coding concepts and to facilitate access to programming for novice users. According to Bau et al. (2017), block-based programming languages are advantageous over conventional textual languages with respect to learnability due to the following reasons: \n\n\u2022 Programming languages usually require learning the programming vocabulary. However, blocks rely on recognition -not on recall, since blocks can be picked from palettes and need not be remembered. Additionally, the listing of all block types helps the user to become familiar with language elements and to maintain an overview of system components. \n\n\u2022 Programming causes a high cognitive load, in particular for new users. This is reduced because block-based programs typically are structured into smaller and easily recognizable pieces. \n\n\u2022 In contrast to conventional programming approaches, syntax errors can be avoided in block-based programming. The related environment prevents the user from connecting mismatching blocks when assembling elements to programs. \n\nOne example block-based language environment is Blockly. Specifically, it is an open-source JavaScript library for building block-based programming editors for the web, mainly developed by Google. 1 Blockly defines the general graphical syntax and provides some basic language blocks out of the box.",
            "score": 0.3721991141151649,
            "section_title": "Block-based programming languages",
            "char_start_offset": 3116,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 76
                },
                {
                    "start": 77,
                    "end": 253
                },
                {
                    "start": 254,
                    "end": 378
                },
                {
                    "start": 379,
                    "end": 511
                },
                {
                    "start": 512,
                    "end": 737
                },
                {
                    "start": 738,
                    "end": 884
                },
                {
                    "start": 887,
                    "end": 1010
                },
                {
                    "start": 1011,
                    "end": 1186
                },
                {
                    "start": 1187,
                    "end": 1302
                },
                {
                    "start": 1303,
                    "end": 1480
                },
                {
                    "start": 1483,
                    "end": 1559
                },
                {
                    "start": 1560,
                    "end": 1680
                },
                {
                    "start": 1681,
                    "end": 1832
                },
                {
                    "start": 1835,
                    "end": 1907
                },
                {
                    "start": 1908,
                    "end": 2022
                },
                {
                    "start": 2025,
                    "end": 2135
                },
                {
                    "start": 2136,
                    "end": 2250
                },
                {
                    "start": 2253,
                    "end": 2309
                },
                {
                    "start": 2310,
                    "end": 2552
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94677734375
        },
        {
            "corpus_id": "236566925",
            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
            "text": "Visual programming languages use drawing, graphics, and a graphical interface (GUI: Graphical User Interface) to issue instructions for the computer. It can be said that the field of visual programming develops as a result of a wonderful integration between three fields which are Programming Languages, Computer Graphics, and Human-Computer Interaction (HCI). \n\nIn visual programming languages, we can distinguish between two types of icons, (Process Icons) which denote accounts, and (Object Icons) which in turn consist of two types: The (Elementary) represents basic objects and (Composite) represents composite objects that are formed from several simple icons using specific operations. \n\nVisual programming is a relatively modern method of programming, in which assistant programs are used to design a graphical user interface (buttons, texts ...) and linking it with the programming code. These assistant programs are called the Integrated Development Environment (IDE). This type of programming uses visual expressions in the programming process or it may treat the visual information or support visual interaction between the user and the computer. \n\nAmong the most popular graphic development environments are Visual C ++, Visual J ++, Delphi, Visual Basic, Visual Basic.net, Java Builder, etc. \n\nA programming language is known in more than one way, it can be said that it is a language that uses the (mouse) and (icons) on the screen and (menus) to prepare or develop programs. It can also be said that it is a language that uses Visual Representation of Logical Objects to process visual information and supports visual interaction in the programming process and uses visual expressions.",
            "score": 0.3721991141151649,
            "section_title": "Visual programming:",
            "char_start_offset": 28669,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 149
                },
                {
                    "start": 150,
                    "end": 360
                },
                {
                    "start": 363,
                    "end": 692
                },
                {
                    "start": 695,
                    "end": 896
                },
                {
                    "start": 897,
                    "end": 978
                },
                {
                    "start": 979,
                    "end": 1158
                },
                {
                    "start": 1161,
                    "end": 1286
                },
                {
                    "start": 1287,
                    "end": 1305
                },
                {
                    "start": 1308,
                    "end": 1490
                },
                {
                    "start": 1491,
                    "end": 1701
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87841796875
        },
        {
            "corpus_id": "211227882",
            "title": "LearnBlock: A Robot-Agnostic Educational Programming Tool",
            "text": "Block programming is carried out through a graphical user interface that includes the necessary tools to create, modify and execute the code (Fig. 2). Blocks are organised in several tabs associated with different categories that represent the main functionality of the blocks they contain. Four of these categories are inherent to the visual language: control, operators, variables and user functions (definition and calls). These four categories are often understood as compatible between different robots. It seems clear to all designers of block-based languages, that for example, the statement If is the same for any device, however, they do not raise that level of abstraction to common primitives in robotics, such as move forward or rotate a certain number of degrees. LearnBlock fills this gap by proposing an underlying software architecture that allows it. \n\nThus, in LearnBlock, all the remaining block categories not included in the above four ones are related to blocks providing platform-independent robot skills. Each of these blocks is associated with a Python function that implements that functionality. These Python functions (section IV-C) are independent modules that are included in the GUI through blockconfiguration files. A block-configuration file is a JSONformat file describing the block attributes used to visually represent each function. Listing 1 shows an example of the block configuration of a function named turn in charge of turning the base of the robot a certain angle.",
            "score": 0.3713761996521242,
            "section_title": "A. BLOCK PROGRAMMING",
            "char_start_offset": 16863,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 150
                },
                {
                    "start": 151,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 508
                },
                {
                    "start": 509,
                    "end": 776
                },
                {
                    "start": 777,
                    "end": 867
                },
                {
                    "start": 870,
                    "end": 1028
                },
                {
                    "start": 1029,
                    "end": 1122
                },
                {
                    "start": 1123,
                    "end": 1247
                },
                {
                    "start": 1248,
                    "end": 1369
                },
                {
                    "start": 1370,
                    "end": 1508
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.830078125
        },
        {
            "corpus_id": "252355042",
            "title": "Not As Easy As You Think - Experiences and Lessons Learnt from Trying to Create a Bottom-Up Visualization Image Typology",
            "text": "Images have been categorized in several ways based on how they are constructed rather than how they are seen by the viewers. Textbooks, in particular, often rely on categorizations to structure their content [67]. While early books such as Brinton's [13] were collections of graphical representations in use, modern textbooks regularly use one of a few structures:\n\nFocus on construction rules for design purposes. A first and highly influential approach to characterizing visual designs was Bertin's visual semiotics [7]. Bertin discussed the fundamental building blocks of visualizations that are modified by visual variables (visual channels), which encode data. Similar in spirit, several proposals have been made to describe visualizations through the lens of a visual language with a set of syntactic rules. Examples include the Grammar of Graphics by Wilkinson [93], Engelhardt's Language of Graphics [83], or Mackinlay's automatic design [55]. Applying rules formulated in a visual language can lead to a broad range of visualization designs [59] and several existing visualization tools and libraries such as Tableau [56], D3 [12], or Vega-lite [70] are based on them. Others, such as Tufte's Envisioning Information [79] differentiate techniques by higher-level construction rules such as small multiples, or principles such as layering and separation.\n\nWhat unites these approaches is that they attempt to describe how to construct a visualization but do not focus on what the end-product of the construction looks like. Different sets of rules may lead to images that look very similar. Bar charts and histograms, for example, require very different construction rules according to the Grammar of Graphics but both look very much alike through their use of bars, a rectangular arrangement, and length as an encoding of quantity. We used an inverse approach in that we took existing images and attempted to describe their visual appearance. By using this approach, our characterization incorporates our assessment of what is important in a visualization; this assessment is related to encoding of marks and channels without necessarily considering what data is encoded.\n\nWe are certainly not the first to realize the feature differences between what we design and what we see. Computer vision community has realized that many feature descriptors (e.g., Canny edge",
            "score": 0.37037787234858516,
            "section_title": "Visualization Categorizations",
            "char_start_offset": 6756,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 208,
                    "end": 212,
                    "matchedPaperCorpusId": "67915353"
                },
                {
                    "start": 946,
                    "end": 950,
                    "matchedPaperCorpusId": "2362307"
                },
                {
                    "start": 1126,
                    "end": 1130,
                    "matchedPaperCorpusId": "13457388"
                },
                {
                    "start": 1135,
                    "end": 1139,
                    "matchedPaperCorpusId": "14970263"
                },
                {
                    "start": 1154,
                    "end": 1158,
                    "matchedPaperCorpusId": "206805969"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.25927734375
        },
        {
            "corpus_id": "264371146",
            "title": "Core competencies of K-12 computer science education from the perspectives of college faculties and K-12 teachers",
            "text": "Programming is one of the fundamental skills in CS and a vital tool to develop CT skills (Grover & Pea, 2013;Lye & Koh, 2014). Research indicated that introducing CT to students in their earlier years is important as it could equip students with critical thinking skills (Tran, 2019). The programming approach has been implemented for CT education in pre-school (e.g., \u00c7iftci & Bildiren, 2020) and K-12 education (e.g., Schmidt, 2016). For example, \u00c7iftci and Bildiren (2020) found that programming can help develop 4-5-year-old preschool students' problem solving and cognitive skills. Irish and Kang (2018) found that integrating programming into other learning activities can engage students in both programming and general subjects learning. \n\nConsequently, programming languages and environments play an important role in K-12 CS education. The question of which language should be taught in K-12 has been a controversial topic. Currently, popular programming languages such as Python, Java, C, and C++ are widely used in industry and academia (TIOBE, 2021). These languages are also called textual programming languages as they are primarily written in text editors. Therefore, programmers should learn not only logical thinking but also the syntax of the language. Although textual programming languages may be difficult to approach for novice learners, research has indicated that students who learn textual programming language as the introductory programming language can transit to other textual languages easier as they move forward (Enbody & Punch, 2010). Thus, they recommend that it is preferable to have textual programming language for novice learners, given that the textual programming languages are universally used in real life. \n\nOn the contrary, the non-textual programming languages and environments, which comprises diverse visual formats such as diagrams, flowcharts, and coding blocks (Dehouck, 2016), are expected to be easy enough for beginners to get started and extensive enough to meet the needs for advanced programming (Grover & Pea, 2013). Visual programming environments that are widely used include Scratch, Game Maker, Code.org, Alice, Kodu, etc. Some of the visual programming languages, such as Scratch and Alice, are block-based languages in the programming environments, of which students can drag and drop coding blocks to the workspace.",
            "score": 0.37025442677982146,
            "section_title": "Programming Languages in CS Education",
            "char_start_offset": 5917,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 126
                },
                {
                    "start": 127,
                    "end": 284
                },
                {
                    "start": 285,
                    "end": 435
                },
                {
                    "start": 436,
                    "end": 586
                },
                {
                    "start": 587,
                    "end": 745
                },
                {
                    "start": 748,
                    "end": 845
                },
                {
                    "start": 846,
                    "end": 933
                },
                {
                    "start": 934,
                    "end": 1063
                },
                {
                    "start": 1064,
                    "end": 1172
                },
                {
                    "start": 1173,
                    "end": 1271
                },
                {
                    "start": 1272,
                    "end": 1568
                },
                {
                    "start": 1569,
                    "end": 1749
                },
                {
                    "start": 1752,
                    "end": 2074
                },
                {
                    "start": 2075,
                    "end": 2166
                },
                {
                    "start": 2167,
                    "end": 2184
                },
                {
                    "start": 2185,
                    "end": 2380
                }
            ],
            "ref_mentions": [
                {
                    "start": 109,
                    "end": 125,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 271,
                    "end": 283,
                    "matchedPaperCorpusId": "67320246"
                },
                {
                    "start": 369,
                    "end": 393,
                    "matchedPaperCorpusId": "212664197"
                },
                {
                    "start": 420,
                    "end": 434,
                    "matchedPaperCorpusId": "8288189"
                },
                {
                    "start": 449,
                    "end": 475,
                    "matchedPaperCorpusId": "212664197"
                },
                {
                    "start": 587,
                    "end": 608,
                    "matchedPaperCorpusId": "149230231"
                },
                {
                    "start": 1545,
                    "end": 1567,
                    "matchedPaperCorpusId": "189052"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7080078125
        },
        {
            "corpus_id": "257395014",
            "title": "Recent Robots in STEAM Education",
            "text": "In the description of the above robots, the related programming languages were mentioned.Some of these languages are presented in more detail below.First, there are traditional scripting languages and visual programming languages.The first category includes Python [66][67][68], C, C++, Java, JavaScript [69], etc., and is the basis for the creation of the second, i.e., visual programming languages.\n\nIn primary school age or education in general, it would be easier to use a visual programming language.The term \"visual programming language\" means a programming language that is based on visual expressions and is suitable for beginners [70].These expressions are either icons and blocks (puzzles), or diagrams and forms, which act as commands and conditions for the user to program the robot object he desires.These expressions are asked by the user to drag them and put them in the appropriate order to write the code that will command the robot to act.Some visual programming languages used in education are AgentSheets, App Inventor (for Android), Blocky, Bubble, Scratch, etc.\n\nOne of the most popular languages is Scratch (Figure 5).This is evidenced by the fact that it has been used in a variety of studies [71][72][73][74][75][76][77][78][79][80][81].Scratch's goal is for students to learn programming concepts by playing and creating videos and music.In other words, it enables teachers to use it as a means of teaching in their classrooms.Scratch is free and available online.Its shape makes it quite attractive to students of both primary and secondary education.Moreover, one of its advantages is that it is dynamic, as users can edit and modify its code while it is running.Behind the visual expressions, the executable code runs in the Squeak (Scratch 0. x, Scratch 1. x) or ActionScript (Scratch 2.0) written programming languages.According to the research in [28], 50% of the published work they found on STEAM education uses Scratch.Scratch can be an important lead in introducing advanced students to the Python programming language [82].",
            "score": 0.36988095120051245,
            "section_title": "Programming Languages",
            "char_start_offset": 24224,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 89
                },
                {
                    "start": 89,
                    "end": 148
                },
                {
                    "start": 148,
                    "end": 230
                },
                {
                    "start": 230,
                    "end": 400
                },
                {
                    "start": 402,
                    "end": 505
                },
                {
                    "start": 505,
                    "end": 644
                },
                {
                    "start": 644,
                    "end": 813
                },
                {
                    "start": 813,
                    "end": 957
                },
                {
                    "start": 957,
                    "end": 1083
                },
                {
                    "start": 1085,
                    "end": 1141
                },
                {
                    "start": 1141,
                    "end": 1262
                },
                {
                    "start": 1262,
                    "end": 1364
                },
                {
                    "start": 1364,
                    "end": 1453
                },
                {
                    "start": 1453,
                    "end": 1490
                },
                {
                    "start": 1490,
                    "end": 1578
                },
                {
                    "start": 1578,
                    "end": 1691
                },
                {
                    "start": 1691,
                    "end": 1850
                },
                {
                    "start": 1850,
                    "end": 1954
                },
                {
                    "start": 1954,
                    "end": 2060
                }
            ],
            "ref_mentions": [
                {
                    "start": 269,
                    "end": 273,
                    "matchedPaperCorpusId": "155729844"
                },
                {
                    "start": 273,
                    "end": 277,
                    "matchedPaperCorpusId": "233178376"
                },
                {
                    "start": 304,
                    "end": 308,
                    "matchedPaperCorpusId": "211211914"
                },
                {
                    "start": 639,
                    "end": 643,
                    "matchedPaperCorpusId": "18077793"
                },
                {
                    "start": 1221,
                    "end": 1225,
                    "matchedPaperCorpusId": "250717356"
                },
                {
                    "start": 1225,
                    "end": 1229,
                    "matchedPaperCorpusId": "225315516"
                },
                {
                    "start": 1229,
                    "end": 1233,
                    "matchedPaperCorpusId": "63548771"
                },
                {
                    "start": 1237,
                    "end": 1241,
                    "matchedPaperCorpusId": "145028763"
                },
                {
                    "start": 1241,
                    "end": 1245,
                    "matchedPaperCorpusId": "248821748"
                },
                {
                    "start": 1245,
                    "end": 1249,
                    "matchedPaperCorpusId": "237702196"
                },
                {
                    "start": 1249,
                    "end": 1253,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 1253,
                    "end": 1257,
                    "matchedPaperCorpusId": "6556344"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.865234375
        },
        {
            "corpus_id": "235507728",
            "title": "A Holistic Digital Game-Based Learning Approach to Out-of-School Primary Programming Education",
            "text": "There are many types of visual programming environments for beginner programmers that highlight distinct benefits of programming behaviors for problem-solving strategies in DGBL. Visual programming environments reduce the unnecessary syntax difficulties and assist programmers in visualizing the effects (Papadakis and Orfanakis, 2018). Such environments are able to enforce syntactic validity, which reduces error proneness in the notation by making it impossible for novices to encounter syntax errors (Chao, 2016). \n\nThe Scratch visual programming environment (Resnick et al., 2009) has been chosen as a key DGBL software for teaching programming in Phase 1 of the proposed educational approach. Scratch is a free block-based learning environment tool designed for children aged 8 to 16 which aims at teaching programming principles such as loops, synchronization, variables, conditionals, operators, broadcasts, and more (Fields et al., 2017;Stripeikait\u0117, 2017), through the use of graphical blocks which are overlapped by the \"drag and drop\" technique. Blocks are organized into different categories according to the functions they perform (motion, data, events, control, sensing, operators etc.). They are marked with different colors, which makes it easy to see the relationship between them. Moreover, the learning process can be integrated with geometric, arithmetic, and statistical concepts to investigate the key elements of solving problems and cultivate children's creative computational thinking for producing a joyful learning of programming. \n\nThe Scratch programming software is the most popular visual computing tool, more than doubling the next closest language (Blockly) according to (Rich et al., 2018). However, there are several alternatives such as Kodu (MacLaurin, 2009), Lightbot 2.0 (Piteira and Haddad, 2011), and Alice 2 (Cooper et al., 2003) for 3D modelling. More recent visual programming environments include Snap, Stencyl, Game Maker Studio and Tynker. Nevertheless, Scratch remains the most suitable visual programming language to develop computational thinking capabilities though programming (Maloney et al., 2010). Moreover, according to (Kim and Ko, 2017;Sweigart, 2016), Scratch is the best and the most successful educational visual programming environment available today.",
            "score": 0.36979092023428883,
            "section_title": "Phase 1. Learning programming",
            "char_start_offset": 14566,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 178
                },
                {
                    "start": 179,
                    "end": 336
                },
                {
                    "start": 337,
                    "end": 517
                },
                {
                    "start": 520,
                    "end": 698
                },
                {
                    "start": 699,
                    "end": 1057
                },
                {
                    "start": 1058,
                    "end": 1202
                },
                {
                    "start": 1203,
                    "end": 1299
                },
                {
                    "start": 1300,
                    "end": 1558
                },
                {
                    "start": 1561,
                    "end": 1725
                },
                {
                    "start": 1726,
                    "end": 1890
                },
                {
                    "start": 1891,
                    "end": 1987
                },
                {
                    "start": 1988,
                    "end": 2153
                },
                {
                    "start": 2154,
                    "end": 2315
                }
            ],
            "ref_mentions": [
                {
                    "start": 304,
                    "end": 335,
                    "matchedPaperCorpusId": "202252904"
                },
                {
                    "start": 504,
                    "end": 516,
                    "matchedPaperCorpusId": "206930744"
                },
                {
                    "start": 925,
                    "end": 946,
                    "matchedPaperCorpusId": "20966853"
                },
                {
                    "start": 946,
                    "end": 965,
                    "matchedPaperCorpusId": "40312873"
                },
                {
                    "start": 1779,
                    "end": 1796,
                    "matchedPaperCorpusId": "27027620"
                },
                {
                    "start": 1811,
                    "end": 1837,
                    "matchedPaperCorpusId": "10860192"
                },
                {
                    "start": 2130,
                    "end": 2152,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 2177,
                    "end": 2195,
                    "matchedPaperCorpusId": "6717766"
                },
                {
                    "start": 2195,
                    "end": 2210,
                    "matchedPaperCorpusId": "32202501"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.81982421875
        },
        {
            "corpus_id": "259318509",
            "title": "Visual Low-Code Language for Orchestrating Large-Scale Distributed Computing",
            "text": "As a recent study shows, the development of computation applications (HPC, parallel processing) is dominated by textual programming languages [13]. Only 5% of the developers use purely visual languages. The dominating model is to use a generalpurpose textual programming language and equip it with features specific to the existing parallel and distributed programming models like MPI or OpenMP [14]. In these approaches, programmers need to deal with relatively low-level issues like message passing and memory sharing. This means that programmers need to have appropriate skills due to the significant technical complexity of parallel programming models. \n\nThe role of visual notations is to reduce the \"accidental\" complexity [15] and raise the level of abstraction at which programs are formulated through presenting computation flows in a graphical form. It is already a long-time discussion on whether visual notations are of benefit to professional programming [16]. However, they are more comprehensible for novice programmers [17] and increase the capability to create a mental representation of computation problems [18]. This generally stems from the fact that diagrams are most often better than text in expressing complex issues, including complex programs [19]. \n\nIn the past, various graphical notations were used to assist parallel program development [20][21][22]. Thus, the idea to apply visual languages to high-performance computations (including parallel and distributed programming) has emerged quite early [23]. As a natural consequence, several visual programming systems have been proposed [24,25] together with graph grammars [26] and models [27] supporting the definition of parallelised computation. Syntactically, practically all such languages support graph structures, where graph nodes define the computation elements and graph arcs define data or control flows. This is also the case for the Computation Application Language (CAL) presented in the current work. However, CAL has several characteristics that distinguish it from other such languages. \n\nThe CODE, CODE 2.0, and Hence languages [28][29][30] are based on graph structures, where nodes define simple operations and the edges represent the order of their execution. Such a visual approach allows for a better representation of the concurrency of computations. These languages were used to define computations using atomic operations, and the graph was used to generate code directly executed on machines.",
            "score": 0.3691984322763696,
            "section_title": "Related Work",
            "char_start_offset": 7818,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 147
                },
                {
                    "start": 148,
                    "end": 202
                },
                {
                    "start": 203,
                    "end": 400
                },
                {
                    "start": 401,
                    "end": 520
                },
                {
                    "start": 521,
                    "end": 656
                },
                {
                    "start": 659,
                    "end": 859
                },
                {
                    "start": 860,
                    "end": 973
                },
                {
                    "start": 974,
                    "end": 1131
                },
                {
                    "start": 1132,
                    "end": 1275
                },
                {
                    "start": 1278,
                    "end": 1381
                },
                {
                    "start": 1382,
                    "end": 1534
                },
                {
                    "start": 1535,
                    "end": 1727
                },
                {
                    "start": 1728,
                    "end": 1894
                },
                {
                    "start": 1895,
                    "end": 1994
                },
                {
                    "start": 1995,
                    "end": 2082
                },
                {
                    "start": 2085,
                    "end": 2259
                },
                {
                    "start": 2260,
                    "end": 2353
                },
                {
                    "start": 2354,
                    "end": 2498
                }
            ],
            "ref_mentions": [
                {
                    "start": 729,
                    "end": 733,
                    "matchedPaperCorpusId": "372277"
                },
                {
                    "start": 968,
                    "end": 972,
                    "matchedPaperCorpusId": "9664502"
                },
                {
                    "start": 1035,
                    "end": 1039,
                    "matchedPaperCorpusId": "62709493"
                },
                {
                    "start": 1126,
                    "end": 1130,
                    "matchedPaperCorpusId": "16771725"
                },
                {
                    "start": 1270,
                    "end": 1274,
                    "matchedPaperCorpusId": "14495436"
                },
                {
                    "start": 1368,
                    "end": 1372,
                    "matchedPaperCorpusId": "18430817"
                },
                {
                    "start": 1372,
                    "end": 1376,
                    "matchedPaperCorpusId": "2425331"
                },
                {
                    "start": 1376,
                    "end": 1380,
                    "matchedPaperCorpusId": "16785577"
                },
                {
                    "start": 1615,
                    "end": 1619,
                    "matchedPaperCorpusId": "18966575"
                },
                {
                    "start": 1619,
                    "end": 1622,
                    "matchedPaperCorpusId": "1428008"
                },
                {
                    "start": 1652,
                    "end": 1656,
                    "matchedPaperCorpusId": "18728484"
                },
                {
                    "start": 1668,
                    "end": 1672,
                    "matchedPaperCorpusId": "55679289"
                },
                {
                    "start": 2125,
                    "end": 2129,
                    "matchedPaperCorpusId": "13226592"
                },
                {
                    "start": 2129,
                    "end": 2133,
                    "matchedPaperCorpusId": "1672115"
                },
                {
                    "start": 2133,
                    "end": 2137,
                    "matchedPaperCorpusId": "18401168"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8662109375
        },
        {
            "corpus_id": "258325793",
            "title": "AlgoPoint as an Original Didactic Tool for Introductory Programming Using Flowcharts",
            "text": "Unlike Scratch, the blocks have different shapes for specific functionalities and are not placed like puzzles on a stack, but are appropriately connected by lines with arrows. The notation of the operators used in the expressions contained in used is mixed, i.e. one operation can be performed using several operators which can be misleading. On the other hand, Flowgorithm allows one to preview the source code properly generated in various programming languages (Cook et al., 2015). Two more applications with similar functionalities are Raptor and Visual Logic. The characteristic feature of Raptor is the ability to choose the level of advancement, from basic to even object-oriented programming. However, certain elements, such as the appearance of the scheme and the language of the application, cannot be changed. Another similar application is Visual Logic. Despite its similarities to Flowgorithm, it lacks some rudimentary features. For instance, the speed of algorithm execution cannot be controlled and exporting a diagram to an image is impossible (Kourouma, 2016). Aside from that, there are other programs such as Microsoft Visio that are used to model and visualise multiple types of information without carefully checking the execution of the algorithm (Yu and Xiong, 2018). \n\nBased on our knowledge and the availability of information about other applications, AlgoPoint stands out from others with such features as extensive personalisation of the flowchart elements, detailed Functions and Data Editor, adjustment of many algorithm execution parameters, as well as a user-friendly modern user interface.",
            "score": 0.36882894790925597,
            "section_title": "RELATED WORK",
            "char_start_offset": 5312,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 342
                },
                {
                    "start": 343,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 564
                },
                {
                    "start": 565,
                    "end": 700
                },
                {
                    "start": 701,
                    "end": 820
                },
                {
                    "start": 821,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 942
                },
                {
                    "start": 943,
                    "end": 1078
                },
                {
                    "start": 1079,
                    "end": 1291
                },
                {
                    "start": 1294,
                    "end": 1623
                }
            ],
            "ref_mentions": [
                {
                    "start": 464,
                    "end": 483,
                    "matchedPaperCorpusId": "278010751"
                },
                {
                    "start": 1270,
                    "end": 1290,
                    "matchedPaperCorpusId": "116482009"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.324462890625
        },
        {
            "corpus_id": "236780515",
            "title": "Cognition of Graphical Notation for Processing Data in ERDAS IMAGINE",
            "text": "Textual programming languages encode information as a sequence of characters, while visual languages encode information using the spatial layout of graphic (or text) elements. Text information is linear one-dimensional. Visual representation is two-dimensional (spatial).",
            "score": 0.3685763966626367,
            "section_title": "\uf0b7",
            "char_start_offset": 1293,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 219
                },
                {
                    "start": 220,
                    "end": 271
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.58837890625
        },
        {
            "corpus_id": "20991852",
            "title": "Abstraction Level Taxonomy of Programming Language Frameworks",
            "text": "Visual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages. Some of the programming languages which use this concept are Visual Basic (VB), Visual Java, and Visual C++ etc.",
            "score": 0.3685763966626367,
            "section_title": "e)",
            "char_start_offset": 21367,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 98
                },
                {
                    "start": 99,
                    "end": 299
                },
                {
                    "start": 300,
                    "end": 434
                },
                {
                    "start": 435,
                    "end": 580
                },
                {
                    "start": 581,
                    "end": 674
                },
                {
                    "start": 675,
                    "end": 737
                },
                {
                    "start": 738,
                    "end": 850
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91845703125
        },
        {
            "corpus_id": "149925230",
            "title": "Approaches to Assess Computational Thinking Competences Based on Code Analysis in K-12 Education: A Systematic Mapping Study",
            "text": "Research Question. Which approaches exist to assess (and grade) programming activities based on code created with block-based visual programming languages in the context of K-12 education? \n\nWe refined this research question into the following analysis questions: \n\nProgram analysis \u2022 AQ1: Which approaches exist and what are their characteristics? AQ2: Which programming concepts related to computational thinking are analyzed? AQ3: How are these programming concepts related to computational thinking analyzed? Instructional feedback and assessment \u2022 AQ4: If, and how a score is generated? AQ5: If, and in which manner instructional feedback is presented? Automation of assessment \u2022 AQ6: If, and how the approach has been automated? Data source. We examined all published English-language articles that are available on Scopus being the largest abstract and citation database of peer-reviewed literature, including publications from ACM, Elsevier, IEEE and Springer with free access through the Capes Portal1 . \n\nInclusion/exclusion criteria. We consider only peer-reviewed English-language articles that present an approach to the assessment of algorithms and programming concepts based on the analysis of the code. We only consider research focusing on approaches for block-based visual programming languages. And, although our primary focus is on K-12 education, we include also approaches that cover concepts commonly addressed in K-12, but which might have been used on other educational stages (such as higher education). We consider articles that have been published during the last 21 years, between January 1997 (the following year in which the first block-based programming language was created) and August 2018. \n\nWe exclude approaches that analyze code written with text-based programming languages, assess algorithms and programming concepts/practices based on other sources than the code developed by the student, such as tests, questionnaires, interviews, etc., or perform code analysis outside an educational context, e.g., software quality assessment. \n\nQuality criteria. We consider only articles that present substantial information on the presented approach in order to enable the extraction of relevant information regarding the analysis questions.",
            "score": 0.3684310986260436,
            "section_title": "Definition of the Review Protocol",
            "char_start_offset": 11353,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 18
                },
                {
                    "start": 19,
                    "end": 188
                },
                {
                    "start": 191,
                    "end": 263
                },
                {
                    "start": 266,
                    "end": 348
                },
                {
                    "start": 349,
                    "end": 428
                },
                {
                    "start": 429,
                    "end": 512
                },
                {
                    "start": 513,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 657
                },
                {
                    "start": 658,
                    "end": 734
                },
                {
                    "start": 735,
                    "end": 747
                },
                {
                    "start": 748,
                    "end": 1012
                },
                {
                    "start": 1015,
                    "end": 1044
                },
                {
                    "start": 1045,
                    "end": 1218
                },
                {
                    "start": 1219,
                    "end": 1313
                },
                {
                    "start": 1314,
                    "end": 1529
                },
                {
                    "start": 1530,
                    "end": 1724
                },
                {
                    "start": 1727,
                    "end": 2070
                },
                {
                    "start": 2073,
                    "end": 2090
                },
                {
                    "start": 2091,
                    "end": 2271
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6533203125
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Only a handful of studies reviewed visual programming related research. The studies reviewed how visual programming tools were used in specific domains such as IoT, robotics, and education. \n\nAs an example, the authors in [8] surveyed 16 visual programming environments allowing end users to create applications involving robots with social capabilities. Only one article out of the 16 articles was published in a journal. The study shows that recent tools are adopting component-based software engineering approaches, but the tools need to be evaluated with real end users as opposed to university students, and should be validated in a real setting as opposed to a laboratory. The study mainly focused on the analysis and challenges specific to robotics-related approaches such as scripting-based, rule-based systems, state-based and behavior-based systems. \n\nAnother example of a domain-specific visual programming review study is the study in [10]. The author surveyed 13 articles that use visual programming to support the creation of IoT-based applications. The vast majority of the articles were conference articles. The study reported that VPLs make it easy for end users to visualize the programming logic and eliminate the burden of handling syntactical errors. However, significant time is spent on creating small-scale IoT applications with visual programming. The study focused on IoT-specific attributes such as the hardware platform (e.g. Raspberry Pi, Arduino) and overlooked the broad VPL classifications (e.g. diagrammatic, iconic, block-based). \n\nA recent study conducted a systematic literature review to examine the role of visual and textual programming languages in helping students learn how to program [30]. The study reported that the choice of textual programming language is not a crucial one as languages are alike. However, the use of visual programming to introduce students to programming concepts is of utility as long as it is within a short time frame. \n\nTo sum up, all the aforementioned review studies are domain specific, and as such do not provide a generic view of VPL approaches applied in multiple domains beyond the domains of education, IoT and robotics. \n\nOur study differs from the aforementioned reviews by focusing on the articles related to visual programming tools that represent several domains, closely examining the visual programming approaches with all its classifications, and identifying how such approaches are used to solve particular problems in several domains.",
            "score": 0.3673892989192877,
            "section_title": "B. VISUAL PROGRAMMING REVIEW STUDIES",
            "char_start_offset": 15847,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 71
                },
                {
                    "start": 72,
                    "end": 189
                },
                {
                    "start": 192,
                    "end": 354
                },
                {
                    "start": 355,
                    "end": 422
                },
                {
                    "start": 423,
                    "end": 678
                },
                {
                    "start": 679,
                    "end": 859
                },
                {
                    "start": 862,
                    "end": 952
                },
                {
                    "start": 953,
                    "end": 1063
                },
                {
                    "start": 1064,
                    "end": 1123
                },
                {
                    "start": 1124,
                    "end": 1271
                },
                {
                    "start": 1272,
                    "end": 1372
                },
                {
                    "start": 1373,
                    "end": 1453
                },
                {
                    "start": 1454,
                    "end": 1527
                },
                {
                    "start": 1528,
                    "end": 1563
                },
                {
                    "start": 1566,
                    "end": 1732
                },
                {
                    "start": 1733,
                    "end": 1844
                },
                {
                    "start": 1845,
                    "end": 1987
                },
                {
                    "start": 1990,
                    "end": 2198
                },
                {
                    "start": 2201,
                    "end": 2522
                }
            ],
            "ref_mentions": [
                {
                    "start": 222,
                    "end": 225,
                    "matchedPaperCorpusId": "219455753"
                },
                {
                    "start": 947,
                    "end": 951,
                    "matchedPaperCorpusId": "30037917"
                },
                {
                    "start": 1727,
                    "end": 1731,
                    "matchedPaperCorpusId": "4039308"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.90380859375
        },
        {
            "corpus_id": "233902035",
            "title": "Category-Theoretic Formulation of the Model-Based Systems Architecting Cognitive-Computational Cycle",
            "text": "Modeling languages are categories, since they are essentially programming languages [82], and programming languages are categories [20,21]. Moreover, programs are equivalent to theories [22], and likewise, models are equivalent to system concepts, which can be thought of as 'theories' about how a system works or might work. System models are instantiations of MLs, much like software programs are instantiations of programming languages. Similarly, representation languages for creating graphs, matrices, trees, or animations may also be thought of as categories. Transitions across representations are essential for gaining system understanding, and for implementing the system or parts of the system. For example, transforming functional models into visual animations, hardware and software designs, text specifications, etc. may further explain the system. \n\nThe assertion that MLs are categories must be backed up by valid categorical representation. MLs like OPM and SysML [83] capture structural, behavioral, and relational entities syntactically. The concept set constitutes a syntactic domain-agnostic ontology that accommodates a wide range of instantiations. The Block, for instance, is a fundamental SysML concept. SysML Blocks are modeled in Block Definition Diagrams (BDDs) and Internal Block Diagrams (IBDs). BDDs capture relations among blocks, while IBDs capture interactions among blocks and their internal structure. A block may be both structural and functional, which is both useful and confusing. For example, a block can specify both the sensor and its sensing function, f Sensor . \n\nIn SysML and its predecessor, the Unified Modeling Language (UML) [84], capturing a component's behavior, rather than its structure or function, requires behavioral notation such as Activity Diagram or State Chart. In the Activity Diagram notation, activities and actions are 'boxes' (types), while control or data flows are 'arrows' (morphisms). In the State Chart notation states are 'boxes' and state-transitions are 'arrows'. The different semantics applied to 'boxes' and 'arrows' in SysML diagrams can be confusing, although experienced analysts know which notation to use to interpret various diagrams to make sense. Transforming SysML models through categorical specifications into a unified notation requires tremendous effort. We defer this endeavor to future research.",
            "score": 0.36667871396751905,
            "section_title": "The Modeling Language as a Category",
            "char_start_offset": 37819,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 139
                },
                {
                    "start": 140,
                    "end": 325
                },
                {
                    "start": 326,
                    "end": 439
                },
                {
                    "start": 440,
                    "end": 565
                },
                {
                    "start": 566,
                    "end": 704
                },
                {
                    "start": 705,
                    "end": 861
                },
                {
                    "start": 864,
                    "end": 956
                },
                {
                    "start": 957,
                    "end": 1055
                },
                {
                    "start": 1056,
                    "end": 1170
                },
                {
                    "start": 1171,
                    "end": 1227
                },
                {
                    "start": 1228,
                    "end": 1324
                },
                {
                    "start": 1325,
                    "end": 1436
                },
                {
                    "start": 1437,
                    "end": 1519
                },
                {
                    "start": 1520,
                    "end": 1605
                },
                {
                    "start": 1608,
                    "end": 1822
                },
                {
                    "start": 1823,
                    "end": 1954
                },
                {
                    "start": 1955,
                    "end": 2037
                },
                {
                    "start": 2038,
                    "end": 2231
                },
                {
                    "start": 2232,
                    "end": 2344
                },
                {
                    "start": 2345,
                    "end": 2387
                }
            ],
            "ref_mentions": [
                {
                    "start": 84,
                    "end": 88,
                    "matchedPaperCorpusId": "44592507"
                },
                {
                    "start": 186,
                    "end": 190,
                    "matchedPaperCorpusId": "62150543"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.25732421875
        },
        {
            "corpus_id": "238126162",
            "title": "DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology",
            "text": "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts. \n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13]. \n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages. These are special and different from the traditional programming which employs numeric opcodes and parameters in bare-metal coding. Traditional programming came up with higher level languages that abstract away the low-level instruction set via human-readable alpha-numeric textual syntax. Another approach is block programming which makes coding feel less like a technical undertaking and more like an artistic endeavor. \n\nThe most famous block programming technologies include Snap [3]. Snap originated from Berkeley, and was inspired by an earlier block programming environment called Scratch [2]. Both offer browser-based environments for coding and running applications -which run using standard web technologies such as JavaScript, HTML and CSS. However, they make it unnecessary to know about the underlying implementation details, and nor does one need to explicitly write any JavaScript or HTML while using these environments -except perhaps, for the expert engineer needing to develop new blocks or extend the environment itself [14]. \n\nIt should be noted that the use of drag-and-drop interfaces in programs like Microsoft Visual Studio to design and specify the look and behavior of traditional Windows Forms (WF) applications or modern XAML powered Windows Presentation Foundation (WPF) applications, does not entirely eliminate the need to code business logic and the application's event handling instructions in text, away from the visual interface.",
            "score": 0.3665447550339148,
            "section_title": "Programming Complexity: Visual Programming Interfaces and Languages Simplifying Software Construction",
            "char_start_offset": 9711,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 190
                },
                {
                    "start": 191,
                    "end": 335
                },
                {
                    "start": 336,
                    "end": 554
                },
                {
                    "start": 557,
                    "end": 636
                },
                {
                    "start": 637,
                    "end": 916
                },
                {
                    "start": 919,
                    "end": 1022
                },
                {
                    "start": 1023,
                    "end": 1154
                },
                {
                    "start": 1155,
                    "end": 1312
                },
                {
                    "start": 1313,
                    "end": 1444
                },
                {
                    "start": 1447,
                    "end": 1511
                },
                {
                    "start": 1512,
                    "end": 1623
                },
                {
                    "start": 1624,
                    "end": 1774
                },
                {
                    "start": 1775,
                    "end": 2067
                },
                {
                    "start": 2070,
                    "end": 2487
                }
            ],
            "ref_mentions": [
                {
                    "start": 330,
                    "end": 334,
                    "matchedPaperCorpusId": "4039308"
                },
                {
                    "start": 631,
                    "end": 635,
                    "matchedPaperCorpusId": "4039308"
                },
                {
                    "start": 911,
                    "end": 915,
                    "matchedPaperCorpusId": "17653432"
                },
                {
                    "start": 1507,
                    "end": 1510,
                    "matchedPaperCorpusId": "220755838"
                },
                {
                    "start": 2062,
                    "end": 2066,
                    "matchedPaperCorpusId": "17452915"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.931640625
        },
        {
            "corpus_id": "233181921",
            "title": "Languages for Smart and Computable Contracts",
            "text": "Occasionally, a DSML may have a visual programming interface (specification with visual elements rather than textsee Section 4.2). \n\nA markup language such as XML22 can be used to annotate natural language with tags to provide additional information relating to presentation, structure or semantics and may act as a specification language, albeit in a limited way since its purpose is to annotate existing natural language expressions rather than to provide an alternative expression.23 \n\n\u2022 Programming language. Computer programmers construct software using a programming language. Often these are general-purpose languages, but domain specific programming languages (DSPLs) are designed for a specific purpose -for example, to target a specific application, or a specific distributed ledger platform. 24 DSMLs and DSPLs belong to the general category of Domain Specific Languages (DSLs). There are many programming languages, with differing styles of expression and with differing degrees of formality in terms of their defined syntax and semantics. The semantics (or meaning) of programming languages is at the heart of our understanding of how a computer program behaves and what it computes, and is an important tool for the validation of all but the simplest code. 25 Declarative languages such as the functional languages Haskell 26,27 and Miranda 28,29 , and the logic language Prolog 30,31 , have formally defined semantics and are especially helpful in providing certainty about the meaning of code; they may also be used either as a programming language or as a specification language or both. 32 Where there is a desire for flexibility in targeting multiple platforms, a programmer might construct software using a general-purpose programming language and then automatically (or semi-automatically) translate the software to a platform-specific programming language. \n\n\u2022 Assembly language and object code. Software written in a programming language must be converted to a lower-level language for execution by a computer. For example, a 'compiler' converts a program expressed in a programming language into a program expressed in an executable language: 'machine code' (see below).",
            "score": 0.36636967961702277,
            "section_title": "The Language Stack",
            "char_start_offset": 12808,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 130
                },
                {
                    "start": 133,
                    "end": 486
                },
                {
                    "start": 489,
                    "end": 512
                },
                {
                    "start": 513,
                    "end": 582
                },
                {
                    "start": 583,
                    "end": 805
                },
                {
                    "start": 806,
                    "end": 889
                },
                {
                    "start": 890,
                    "end": 1051
                },
                {
                    "start": 1052,
                    "end": 1273
                },
                {
                    "start": 1274,
                    "end": 1607
                },
                {
                    "start": 1608,
                    "end": 1878
                },
                {
                    "start": 1881,
                    "end": 1917
                },
                {
                    "start": 1918,
                    "end": 2033
                },
                {
                    "start": 2034,
                    "end": 2194
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1851806640625
        },
        {
            "corpus_id": "240506878",
            "title": "Evaluation of a machine learning classifier for metamodels",
            "text": "Feature-based criteria for classifying approaches according to the type of spatial relation involved have been widely discussed [16]. In contrast to our work, this is a taxonomic approach that manually identifies categories for visual languages based on their structure (and neglecting concrete syntax and semantics). The taxonomy promoted by Burnett et al. [21] only considers visual programming languages, mainly from the paradigm they express. This is a brief (and non-exhaustive) survey of purpose-oriented classification approaches, and further secondary studies are available. However, it goes beyond the scope of our paper to discuss the why classifications, as well as their enabling techniques, are necessary. \n\nMost of the approaches that are agnostic of the classification purpose are based on lexical and structural information encoded in the metamodels. Such knowledge can be leveraged in a more semantic-aware analysis when the artifacts are constrained to specific categories. For instance, an approach [51] focuses on requirement diagrams where the various relationships within a diagram have particular meanings that help achieve better classification performance. More recently, generic clustering techniques have been extensively investigated [75]. The work presents a tool that supports the decomposition of a metamodel into clusters of model elements. The main goal is to improve model maintainability by facilitating model comprehension. In particular, modularity is achieved by decomposing the input model into a set of sub-models. The main feature that makes this study different from others is that it works by splitting a single model into clusters, and a post-processing phase is introduced: Users are allowed to add more clusters or to rename, remove, as well as to regroup existing ones. Indeed, the identified clusters result unnamed in contrast to our approach, and the representation is only grouping similar concepts in the same containers.",
            "score": 0.3639772559039603,
            "section_title": "Categorization of metamodels",
            "char_start_offset": 73961,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 317
                },
                {
                    "start": 318,
                    "end": 446
                },
                {
                    "start": 447,
                    "end": 582
                },
                {
                    "start": 583,
                    "end": 718
                },
                {
                    "start": 721,
                    "end": 866
                },
                {
                    "start": 867,
                    "end": 991
                },
                {
                    "start": 992,
                    "end": 1181
                },
                {
                    "start": 1182,
                    "end": 1267
                },
                {
                    "start": 1268,
                    "end": 1372
                },
                {
                    "start": 1373,
                    "end": 1459
                },
                {
                    "start": 1460,
                    "end": 1554
                },
                {
                    "start": 1555,
                    "end": 1816
                },
                {
                    "start": 1817,
                    "end": 1973
                }
            ],
            "ref_mentions": [
                {
                    "start": 128,
                    "end": 132,
                    "matchedPaperCorpusId": "5799447"
                },
                {
                    "start": 358,
                    "end": 362,
                    "matchedPaperCorpusId": "1426814"
                },
                {
                    "start": 1018,
                    "end": 1022,
                    "matchedPaperCorpusId": "7461556"
                },
                {
                    "start": 1262,
                    "end": 1266,
                    "matchedPaperCorpusId": "15123531"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5625
        },
        {
            "corpus_id": "60833664",
            "title": "A visual programming language for novices",
            "text": "We have reported on BridgeTalk, a new approach to visual languages for novice programmers. BridgeTalk is based on actual data about how novices learn to program. It allows novices to program with programming plans, and focuses novices on the interactions between plans, not on the implementation details for a particular plan. Beginning with plans as a basis for a novice programming language, we were forced to develop a programming formalism that could deal with multiple levels of detail, merged plan implementations, and interrelationships between plans. Finally, we used six \"design, implement, test, and redesign\" cycles to develop a specific visual representation for the language.\n\nA key contribution of this work is the systematic support for a plan-like view of programming. We feel that such support is essential if programming languages are to allow a programmer, novice or expert, to work with programming constructs that reflect actual world semantics. Unfortunately, \"high level programming language\" has come to mean more abstract data structures and more formal semantics. We advocate, and have demonstrated the feasability of, \"high level languages\" that reflect the semantics of real-world objects.\n\nConsistant with a language that makes a richer connection to the semantics of real-world objects, our language provides novices with a pathway from experience in the real-world, to real-world plans, to standard programming language constructs. Current software systems force a user to either use the system as is, or become a programmer. BridgeTalk illustrates an approach that provides a smoother transition with many intermediate steps along the way. That is, programming strictly with plans simplifies programming by allowing users to draw on their knowledge of real-world situations, but limits users to those plans provided in the system. Because the internals of the plans can be examined, modified, and specialized, users can extend the power of their system beyond the predefined plans.\n\nOne of the most important lessons of this work is the criticality of empiricial work in the design of visual languages. Without the extensive empirical work documented in this report, our language would be much poorer. Furthermore, the language would more than likely be unsuitable for use with novices. There is no reason to believe that languages designed based on purely formal and intuitive arguments will be usable. Until a suitable theory of visual interface design emerges, we feel that",
            "score": 0.3631565012736072,
            "section_title": "Conclusions",
            "char_start_offset": 56745,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8017578125
        },
        {
            "corpus_id": "244714931",
            "title": "Enhancing syntax expressiveness in domain-specific modelling",
            "text": "In this section, we discuss related work, which may be confined to the realm of meta-editors, visual languages and positional grammars, and general user interface and experience. As to meta-editors, we briefly surveyed existing tools and approaches in Sect. II; the list of considered frameworks is not exhaustive, but most likely, they have pretty extended coverage of current meta-editor usage. The corpus research related to visual language is vast. In this context, Costagliola et al. [11], [12] extend context-free grammars for visual languages by considering graphical constructs in addition to string concatenation. The paper represents a class of approaches that aim to support diagrammatic languages and generate the corresponding programming environment through so-called Visual Language Compiler-Compilers (VL-CCs). In particular, relation-based representation describes a set of graphical objects and a set of relations. In contrast, a set of attributed graphical objects are specified by attributebased representation. Here, the authors provide a first attempt to express language's attributes and references by graphical notation. Similar works, including [13]- [15], include variants on the expressiveness and present formal characterizations. A more systematic review of the literature for the field of visual languages is deferred to future work. The main objective will be to identify approaches that provide insights and that can easily be leveraged to metamodeling. More recently, in [2] a discussion of how model-driven platforms fall short concerning User interface and eXperience (UX). While most of the focus is on platform usability, characteristics, advantages, and disadvantages, very little is said on the intrinsic quality of the generated environments. Nevertheless, the paper introduces a notion of user experience for MDE (MX) to highlight the challenges and opportunities surrounding UX for MDE tool development, such as user model integration, processes for tailoring UX to a domain-specific language, and interoperability. In such a context, jjodel makes a step forward in the usability of modeling tools by getting a more faithful alignment between domain community needs and provided modeling environments.\n\nMore general papers discussing what nowadays still is challenging in current platforms have been recently published (see [16], [17]). In particular, it is worth noting how accidental complexity",
            "score": 0.36171153702980935,
            "section_title": "V. RELATED WORK",
            "char_start_offset": 28349,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 495,
                    "end": 499,
                    "matchedPaperCorpusId": "12709012"
                },
                {
                    "start": 1170,
                    "end": 1174,
                    "matchedPaperCorpusId": "31625583"
                },
                {
                    "start": 1176,
                    "end": 1180,
                    "matchedPaperCorpusId": "314773"
                },
                {
                    "start": 1504,
                    "end": 1507,
                    "matchedPaperCorpusId": "3404182"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.65380859375
        },
        {
            "corpus_id": "672072",
            "title": "Comparative Ease of Use of a Diagrammatic vs. an Iconic Query Language",
            "text": "error rate, time to complete a task, etc.). A few tens of subjects are usually involved in the experiments (ranging from 18 in [12] and 20 in [14] to 65 in [8]). \n\nIn a recent empirical study, Catarci and Santucci, compared the visual query language QBD* (Query by Diagram) with SQL [15]. The results of the study confirmed the hypothesis that a visual language is easier to understand and use than a traditional textual language. In this paper, using primarily the same type of query writing task used earlier by Catarci and Santucci, we describe the outcome of an experiment to compare the effects on user's performance of two different query languages, one iconic and the other one diagrammatic. The independent variables of the experiment are user's skill and query classes. Since we conjectured that there is a significant relationship between the independent variables and the visual query language used, we designed our experiment to test such conjecture. \n\n1 Talking to real users, visiting their working environment, observing how they approach their task are activities which form the basis of usability engineering [3]. \n\nThe two visual query languages, developed at the Dipartimento di Informatica e Sistemistica, are QBD* [16,17,18] and QBI (Query by Icon) [19,20]. As we will clarify below, the two languages differ in both the adopted visual formalism (diagrams vs. icons) and the main query strategy (navigation vs. composition). \n\nThe visual formalism and the query strategy are two fundamental features of VQLs, since they both determine the nature of the human-computer dialogue, whose improvement is the primary goal of VQLs [1,6,21]. Being both diagrams and icons, as well as navigational and compositional query strategies used in most of existing VQLs (see [1]), the two systems under analysis can be also seen as representative of larger VQL classes. To the best of our knowledge, this is the first experiment comparing the ease of use of two VQLs based on different visual formalisms and query strategies. \n\nThe actual experiment was preceded by a teaching period.",
            "score": 0.3613248565104268,
            "section_title": "Introduction",
            "char_start_offset": 4317,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 43
                },
                {
                    "start": 44,
                    "end": 161
                },
                {
                    "start": 164,
                    "end": 288
                },
                {
                    "start": 289,
                    "end": 430
                },
                {
                    "start": 431,
                    "end": 698
                },
                {
                    "start": 699,
                    "end": 778
                },
                {
                    "start": 779,
                    "end": 962
                },
                {
                    "start": 965,
                    "end": 1130
                },
                {
                    "start": 1133,
                    "end": 1278
                },
                {
                    "start": 1279,
                    "end": 1445
                },
                {
                    "start": 1448,
                    "end": 1654
                },
                {
                    "start": 1655,
                    "end": 1874
                },
                {
                    "start": 1875,
                    "end": 2030
                },
                {
                    "start": 2033,
                    "end": 2089
                }
            ],
            "ref_mentions": [
                {
                    "start": 127,
                    "end": 131,
                    "matchedPaperCorpusId": "10502702"
                },
                {
                    "start": 142,
                    "end": 146,
                    "matchedPaperCorpusId": "61038836"
                },
                {
                    "start": 156,
                    "end": 159,
                    "matchedPaperCorpusId": "43876982"
                },
                {
                    "start": 283,
                    "end": 287,
                    "matchedPaperCorpusId": "14521411"
                },
                {
                    "start": 1235,
                    "end": 1239,
                    "matchedPaperCorpusId": "14926266"
                },
                {
                    "start": 1239,
                    "end": 1242,
                    "matchedPaperCorpusId": "30315129"
                },
                {
                    "start": 1242,
                    "end": 1245,
                    "matchedPaperCorpusId": "13387051"
                },
                {
                    "start": 1274,
                    "end": 1277,
                    "matchedPaperCorpusId": "6329709"
                },
                {
                    "start": 1648,
                    "end": 1650,
                    "matchedPaperCorpusId": "10719810"
                },
                {
                    "start": 1650,
                    "end": 1653,
                    "matchedPaperCorpusId": "387064"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.58154296875
        },
        {
            "corpus_id": "246448099",
            "title": "The Effects on Secondary School Students of Applying Experiential Learning to the Conversational AI Learning Curriculum",
            "text": "In conventional programming, programs are written with strict syntax, which can be difficult for general populations to learn, especially non-native English speakers, since a program cannot run successfully it has even minor spelling errors. On the other hand, if students use block-based programming to build the program, these errors will not occur. Block-based programming emphasizes recognition over recall; code-blocks are readily available in the visual interface. Furthermore, the blocks are categorized according to their function or logic. Students only need to concentrate on using appropriate blocks to complete the work they want to do or to create the effect they desire, rather than memorize syntax or particular keywords of the programming language. Moreover, the shape and color of the blocks provide the students with scaffolding to emphasize which blocks can be linked together and how code can (or cannot) be developed. During this process of visual code development, students learn the concepts of programming, students usually need only drag and connect the blocks, reducing the cognitive load and allowing students to focus on the logic and structures involved in programming rather than the syntax of writing programs (Kelleher & Pausch, 2005). Block-based programming provides students with media-rich learning environments, allowing them to connect with various personal interests (Brennan & Resnick, 2012). Chiu (2020) discovered that learners were very positive about the creation of applications (apps) by visual programming and project development, and recommended that novice programmers create apps with block-based programming. Finally, when students used a visual programming tool to write a program, they tended to focus on solving problems. Researchers have indicated that visual programming tools have a positive impact on programming self-efficacy and decrease student frustration (Yukselturk & Altiok, 2017).\n\nIt is especially important to reduce learning frustration for those who are underrepresented in computer science, as they face additional challenges when they first enter the field. Furthermore, it is important to increase their participation in computer science, as underrepresented groups provide unique perspectives and diverse, innovative solutions. In this paper, we investigated the effectiveness of different learning techniques by gender, since historically, females have been underrepresented in computer science, and the relative number of females entering the field has significantly decreased over the past 30 years (Weston et al., 2019). By determining and using the most effective",
            "score": 0.36103127682853453,
            "section_title": "Literature Review",
            "char_start_offset": 2764,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1241,
                    "end": 1266,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 1433,
                    "end": 1444,
                    "matchedPaperCorpusId": "212726996"
                },
                {
                    "start": 1918,
                    "end": 1945,
                    "matchedPaperCorpusId": "7007858"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80859375
        },
        {
            "corpus_id": "258987846",
            "title": "AI for Low-Code for AI",
            "text": "AI for Low-code for AI: In adopting a visual programming approach to low-code, we follow a long tradition [7]. We were particularly inspired by Scratch, a popular visual programming environment for children that uses lego-like connected blocks [31]. \n\nOur other inspiration came from projectional editors, where the visual programming interface is a projection, or view, over an internal domain-specific language (DSL) [37]. Our implementation uses Blockly, a meta-tool for creating block-based visual programming tools [27], and Lale, a DSL for AI pipelines [4]. AI for Low-code for AI: Most low-code interfaces for programming AI pipelines use visual programming. Examples include WEKA [18], Orange [12], and KNIME [6]. Each has a palette of operators that can be dragged onto a canvas, where they can be connected into a boxes-and-arrows style diagram. Commercial lowcode visual interfaces follow the same approach, such as Vertex AI, Sagemaker, AzureML, and Watson Studio. A related approach for low-code AI pipeline development is automated machine learning (AutoML) which is also used by many of the same commercial AI interfaces mentioned earlier. These tools tend to have a black-box approach where the user has little control over the AutoML search and may not even see the resulting pipeline. AutoML libraries such as auto-sklearn [16], TPOT [26], and hyperopt [5] provide a Python interface, which is intended for textual code development. There are also natural-language interfaces for professional developers based on large language models such as GitHub Copilot which uses Codex [10] and ChatGPT. Since these support APIs for which there is sufficient publicly available code to use as training data, they cover popular machine learning libraries such as sklearn. The main difference between these low-code for AI tools and our paper is that we combine the ease-of-use of visual programming with a natural language interface to help users discover and configure operators and, inspired by Scratch [31], our tool encourages liveness [33] through immediate user feedback for each user input into the system.",
            "score": 0.36046854902938524,
            "section_title": "RELATED WORK",
            "char_start_offset": 4842,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 110
                },
                {
                    "start": 111,
                    "end": 249
                },
                {
                    "start": 252,
                    "end": 424
                },
                {
                    "start": 425,
                    "end": 563
                },
                {
                    "start": 564,
                    "end": 665
                },
                {
                    "start": 666,
                    "end": 721
                },
                {
                    "start": 722,
                    "end": 855
                },
                {
                    "start": 856,
                    "end": 976
                },
                {
                    "start": 977,
                    "end": 1154
                },
                {
                    "start": 1155,
                    "end": 1302
                },
                {
                    "start": 1303,
                    "end": 1450
                },
                {
                    "start": 1451,
                    "end": 1610
                },
                {
                    "start": 1611,
                    "end": 1777
                },
                {
                    "start": 1778,
                    "end": 2119
                }
            ],
            "ref_mentions": [
                {
                    "start": 419,
                    "end": 423,
                    "matchedPaperCorpusId": "16189588"
                },
                {
                    "start": 520,
                    "end": 524,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 559,
                    "end": 562,
                    "matchedPaperCorpusId": "244427746"
                },
                {
                    "start": 688,
                    "end": 692,
                    "matchedPaperCorpusId": "13861754"
                },
                {
                    "start": 701,
                    "end": 705,
                    "matchedPaperCorpusId": "6995153"
                },
                {
                    "start": 717,
                    "end": 720,
                    "matchedPaperCorpusId": "408188"
                },
                {
                    "start": 1341,
                    "end": 1345,
                    "matchedPaperCorpusId": "856717"
                },
                {
                    "start": 1352,
                    "end": 1356,
                    "matchedPaperCorpusId": "12399099"
                },
                {
                    "start": 1371,
                    "end": 1374,
                    "matchedPaperCorpusId": "3356163"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85205078125
        },
        {
            "corpus_id": "258184800",
            "title": "Closed group private chat application with translation feature with firebase database",
            "text": "Block-based programming is a revolutionary way for developers to code using visual block elements, rather than typing complex commands. It eradicates syntax errors, making it more accessible and user-friendly. It is particularly useful for beginners or children who are interested in programming, as it eliminates the need for learning complicated code syntax. Block-based programming simplifies the process of implementing logic, making it incredibly intuitive for young users. It stands in contrast to higher-level programming languages that can require the learning of challenging concepts. With block-based programming, children can easily learn how to run programs and showcase their creativity.",
            "score": 0.3586409076178619,
            "section_title": "About block-based coding",
            "char_start_offset": 9470,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 135
                },
                {
                    "start": 136,
                    "end": 209
                },
                {
                    "start": 210,
                    "end": 360
                },
                {
                    "start": 361,
                    "end": 478
                },
                {
                    "start": 479,
                    "end": 593
                },
                {
                    "start": 594,
                    "end": 700
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85400390625
        },
        {
            "corpus_id": "6455062",
            "title": "Visual Representation of 3D Language Constructs Specified by Generic Depictions",
            "text": "The basic idea of containers and stretch intervals-as used in our three-dimensional generic depictions-goes back to the VPE system [Gra98] that generates 2D visual language editors. Furthermore, the idea is successfully used in the generator system DEViL [SKC06], which generates 2D language editors, too. \n\nThe idea for three-dimensional languages goes back to a publication of Glinert [Gli87]. Najork [Naj96] developed the first 3D language Cube, which is semantically similar to Prolog and makes use of the data-flow paradigm. In this language all language constructs are represented by a cube. The hierarchical nesting of constructs is an inherent concept of the Cube language. In the context of generator systems for visual languages, Minas has supervised an exploration [Vo\u00df09] of 3D languages in the context of his DiaGen/DiaMeta [Min02,Min06] frameworks. \n\nThe work of Chung et al. [CHM99] exactly addresses the topic of our paper. They have developed a tool called 3DComposer that is related to our editor for generic depictions. 3DComposer is a tool for specifying so called 3Dvixels, which can be used as building blocks for 3D applications. Such 3Dvixels can be generally used in 3D applications, which include 3D languages and also visualization tools. The usage in different applications is possible by generating reusable software components in form of JavaBeans. The construction of exemplary 3D programs is being done directly in 3DComposer by the end user. 3DComposer is not part of a generator framework, which would distinguish between language designer and language user. Hence, 3DComposer does not need concepts such as containers or stretch intervals. \n\nThe AgentCubes [IRW09] system uses a mechanism to construct language object representations. For such purpose a so called Inflatable Icons Editor is provided. It allows users to quickly draft 3D objects by drawing 2D images and turn them step by step into 3D models by using a diffusion-based inflation technique. In 3D games, which are specified with AgentCubes, these models are mostly located on the ground plane. Hence, the flat bottom side resulting from the inflation approach is not a concern.",
            "score": 0.35852472679583325,
            "section_title": "Related Work",
            "char_start_offset": 32184,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 181
                },
                {
                    "start": 182,
                    "end": 305
                },
                {
                    "start": 308,
                    "end": 395
                },
                {
                    "start": 396,
                    "end": 529
                },
                {
                    "start": 530,
                    "end": 597
                },
                {
                    "start": 598,
                    "end": 681
                },
                {
                    "start": 682,
                    "end": 862
                },
                {
                    "start": 865,
                    "end": 939
                },
                {
                    "start": 940,
                    "end": 1038
                },
                {
                    "start": 1039,
                    "end": 1152
                },
                {
                    "start": 1153,
                    "end": 1265
                },
                {
                    "start": 1266,
                    "end": 1378
                },
                {
                    "start": 1379,
                    "end": 1474
                },
                {
                    "start": 1475,
                    "end": 1592
                },
                {
                    "start": 1593,
                    "end": 1674
                },
                {
                    "start": 1677,
                    "end": 1769
                },
                {
                    "start": 1770,
                    "end": 1835
                },
                {
                    "start": 1836,
                    "end": 1990
                },
                {
                    "start": 1991,
                    "end": 2093
                },
                {
                    "start": 2094,
                    "end": 2177
                }
            ],
            "ref_mentions": [
                {
                    "start": 131,
                    "end": 138,
                    "matchedPaperCorpusId": "206575887"
                },
                {
                    "start": 255,
                    "end": 262,
                    "matchedPaperCorpusId": "11986823"
                },
                {
                    "start": 387,
                    "end": 394,
                    "matchedPaperCorpusId": "46703006"
                },
                {
                    "start": 403,
                    "end": 410,
                    "matchedPaperCorpusId": "206575841"
                },
                {
                    "start": 837,
                    "end": 844,
                    "matchedPaperCorpusId": "10232504"
                },
                {
                    "start": 844,
                    "end": 850,
                    "matchedPaperCorpusId": "19085527"
                },
                {
                    "start": 890,
                    "end": 897,
                    "matchedPaperCorpusId": "31124087"
                },
                {
                    "start": 1692,
                    "end": 1699,
                    "matchedPaperCorpusId": "9523126"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.401611328125
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "Flowhub is a web-based IDE for flow-based programming. The visual language allows the use of visual blocks and connections as a way of programming the system's logic. It is built on NoFlo.js for both client and server and can connect to 3rd party systems using the FBP Network Protocol. An example of a data-flow in the platform is given in Figure 12. XOD 30 XOD is an edge device programming platform (microcontrollers). It uses a visual language to programming the devices and then generates native code for the target platform. In the language, a node is a block that represents either some physical device like a sensor, motor, or relay, or some operation such as addition, comparison, or text concatenation. Each node has one or more inputs that accept values to be processed and outputs that return results. Creating a link from an output to an input builds a path for data, allowing one node to feed values into another. Visuino is a visual programming environment for Arduino-based boards. It provides a drag-and-drop visual programming language to interact with the hardware, and then make the connection between the different modules. \n\nWoTKit33 [Blackstock and Lea 2012b] WoTKit provides a cloud-hosted Node-RED service (FRED) to allow the development of cloud layer IoT solutions. It follows the same visual programming principles of Node-RED and additional extensions and integrations. The solutions are part of the STS IoT Platform that is tightly integrated with FRED. Losant34 \n\nLosant is a developer platform that provides scalable device management, data collection, data visualization, and data reaction workflows in real-time. As such, the implemented visual language is based on workflows, allows the definition of how the devices communicate with each other and other services, focusing on the data component of the IoT. IFTTT 35IFTTT is a mobile application that leverages the use of a visual programming language in order to develop if-this-then-that rules. The language provides integration with several third parties. Despite not being focused on IoT solutions, it provides integration with several IoT products on the market allowing the programming of their behavior. Blynk36",
            "score": 0.3579576545755033,
            "section_title": "Flowhub IoT Platform 29",
            "char_start_offset": 65255,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 54
                },
                {
                    "start": 55,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 286
                },
                {
                    "start": 287,
                    "end": 351
                },
                {
                    "start": 352,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 530
                },
                {
                    "start": 531,
                    "end": 712
                },
                {
                    "start": 713,
                    "end": 813
                },
                {
                    "start": 814,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 997
                },
                {
                    "start": 998,
                    "end": 1144
                },
                {
                    "start": 1147,
                    "end": 1292
                },
                {
                    "start": 1293,
                    "end": 1398
                },
                {
                    "start": 1399,
                    "end": 1483
                },
                {
                    "start": 1484,
                    "end": 1492
                },
                {
                    "start": 1495,
                    "end": 1646
                },
                {
                    "start": 1647,
                    "end": 1842
                },
                {
                    "start": 1843,
                    "end": 1981
                },
                {
                    "start": 1982,
                    "end": 2043
                },
                {
                    "start": 2044,
                    "end": 2195
                },
                {
                    "start": 2196,
                    "end": 2203
                }
            ],
            "ref_mentions": [
                {
                    "start": 1156,
                    "end": 1182,
                    "matchedPaperCorpusId": "14987960"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82080078125
        },
        {
            "corpus_id": "276684953",
            "title": "Two Approaches for Programming Education in the Domain of Graphics: An Experiment",
            "text": "There are multiple senses in which programming education can be related to graphics. This section clarifies the scope of this work. \n\nA fundamental separation exists between graphical and text-based programming. Doing 'graphical programming' commonly means using a visual programming language to create programs graphically, instead of textually. Scratch [33] is an example of a visual programming language popular in educational contexts at the school level. Scratch programs are composed of 'blocks' connected visually. The success of blockbased visual programming languages led to the creation of Blockly [44], a library that facilitates the creation of other block-based languages. Scratch also inspired the creation of Snap! [26], a block-based language in which users can define their own blocks. Our work instead concerns text-based programming languages, which university-level educational contexts use more frequently. \n\nEven when written using text-based programming languages, programs can involve 'the domain of graphics' to different extents. For instance, a program can produce 'static' graphics (2D or 3D), 'animated' graphics, or 'interactive' graphics (known as Graphical User Interfaces). \n\nWhile creating interactive graphical programs has also been explored as a possibility to learn programming (e.g., [17,34]), our work focuses on approaches to create static 2D graphics, among which there is already considerable variety.",
            "score": 0.3579152567309107,
            "section_title": "Graphics and Programming Education",
            "char_start_offset": 3499,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 84
                },
                {
                    "start": 85,
                    "end": 131
                },
                {
                    "start": 134,
                    "end": 211
                },
                {
                    "start": 212,
                    "end": 346
                },
                {
                    "start": 347,
                    "end": 459
                },
                {
                    "start": 460,
                    "end": 521
                },
                {
                    "start": 522,
                    "end": 685
                },
                {
                    "start": 686,
                    "end": 802
                },
                {
                    "start": 803,
                    "end": 927
                },
                {
                    "start": 930,
                    "end": 1055
                },
                {
                    "start": 1056,
                    "end": 1206
                },
                {
                    "start": 1209,
                    "end": 1444
                }
            ],
            "ref_mentions": [
                {
                    "start": 355,
                    "end": 359,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 608,
                    "end": 612,
                    "matchedPaperCorpusId": "2701916"
                },
                {
                    "start": 730,
                    "end": 734,
                    "matchedPaperCorpusId": "220755838"
                },
                {
                    "start": 1323,
                    "end": 1327,
                    "matchedPaperCorpusId": "3102760"
                },
                {
                    "start": 1327,
                    "end": 1330,
                    "matchedPaperCorpusId": "14479674"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.86181640625
        },
        {
            "corpus_id": "212726996",
            "title": "Facilitating K-12 Teachers in Creating Apps by Visual Programming and Project-based Learning",
            "text": "Traditional textual programming languages have text-based interface that require precise and complex syntax which are unfamiliar and unnatural for beginners. The programming syntax is usually complicated and difficult to understand for novice programmers and syntax overload results in barriers to learning programming [9]- [10]. Easier to read and easier to write programs may relieve syntax complexity for learners. Instead of inputting text-based statements, visual programming environments often contain block-based programming elements which provide useful visual cues on how and where to use commands to develop programs. A program can be easily created just by dragging-and-dropping block-based programming elements so that the syntax problems are eliminated. Visualization helps learners understand the semantics of introduced constructs, elucidate principles of program structure and execution, and protects them from developing misconceptions. Study by [15] indicated that students who used the visual interface for programming spent less time off track and completed more of the activity's goals in less time when compared to those who used the textual interface for programming. Saito, Washizaki, and Fukazawa also compared the learning effects of text-based and visual-based programming and found that visual-based programming induces a larger change in attitude toward programming [16]. Therefore, research results suggest that visual-based programming is advantageous in a programming implementation environment for novice programmers. \n\nNumerous studies have shown the benefits and feasibility of visual programming environments such as Scratch (scratch. mit.edu), Alice (www.alice.org), and Kodu (www.kodugamelab.com). Since they are easy to use and understand, visual programming environments have been used as lead-in courses for more advanced computer science courses. For example, research [17]- [18] taught Scratch in a CS0 course to improve the retention rate of at-risk majors and to stimulate interest and positive attitudes toward computer science. Scratch and Kodu were also used to teach important concepts of computer science for students [19]- [21]. Furthermore, research by Werner, Denner, Campe, and Kawamoto also pointed out that visual programming environment is helpful in the development of learners' computational thinking skills [22].",
            "score": 0.3575339319179301,
            "section_title": "Visual programming environment",
            "char_start_offset": 5363,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 329
                },
                {
                    "start": 330,
                    "end": 417
                },
                {
                    "start": 418,
                    "end": 627
                },
                {
                    "start": 628,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 953
                },
                {
                    "start": 954,
                    "end": 1190
                },
                {
                    "start": 1191,
                    "end": 1400
                },
                {
                    "start": 1401,
                    "end": 1550
                },
                {
                    "start": 1553,
                    "end": 1670
                },
                {
                    "start": 1671,
                    "end": 1680
                },
                {
                    "start": 1681,
                    "end": 1703
                },
                {
                    "start": 1704,
                    "end": 1735
                },
                {
                    "start": 1736,
                    "end": 1888
                },
                {
                    "start": 1889,
                    "end": 2074
                },
                {
                    "start": 2075,
                    "end": 2179
                },
                {
                    "start": 2180,
                    "end": 2372
                }
            ],
            "ref_mentions": [
                {
                    "start": 319,
                    "end": 322,
                    "matchedPaperCorpusId": "33572463"
                },
                {
                    "start": 324,
                    "end": 328,
                    "matchedPaperCorpusId": "2965215"
                },
                {
                    "start": 963,
                    "end": 967,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 1395,
                    "end": 1399,
                    "matchedPaperCorpusId": "38535646"
                },
                {
                    "start": 1911,
                    "end": 1915,
                    "matchedPaperCorpusId": "59837822"
                },
                {
                    "start": 1917,
                    "end": 1921,
                    "matchedPaperCorpusId": "22652302"
                },
                {
                    "start": 2168,
                    "end": 2172,
                    "matchedPaperCorpusId": "16831477"
                },
                {
                    "start": 2174,
                    "end": 2178,
                    "matchedPaperCorpusId": "3344110"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8681640625
        },
        {
            "corpus_id": "5015407",
            "title": "Teaching GUI-Programming Concepts to Prospective K12 ICT Teachers: MIT App Inventor as an Alternative to Text-Based Languages",
            "text": "The purpose of this research is to investigate the short and long-term effects of using GUI-oriented visual Blocks-Based Programming languages (BBL) as a 2 nd tier tool when teaching programming to prospective K12 ICT teachers. The said effects are within the scope of a) academic success and; b) professional opinions and preferences in the context of programming education. \n\nConsidering two groups of teacher candidates who have initially been taught at 1 st tier course introductory programming using a text-based language and by developing desktop console applications, the following hypotheses have been formulated: \n\n1. Compared in terms of academic success in a 2 nd tier course dealing with GUI-programming skills, the group that was taught with a visual, blocks-based programming language (BBL) is expected to be more successful than the group that was taught the same concepts with a text-based language (TBL). \n\n2. There is an influence of the factor of being -experienced\u2016 or -novice\u2016 upon the effect of using BBL instead of TBL in GUI-programming courses at university level Considering two groups of teacher candidates, one of which have been taught programming using both the TBL and the BBL and the other having been taught programming only with the TBL; the following research questions have been asked: \n\n1. Will the opinions prospective ICT teachers as to what age programming education should start in children show any difference between the groups? \n\n2. How will the preference of programming language differ between two groups of prospective ICT teachers when given a microteaching assignment seeking to teach 8th-grade children a reference topic in programming?",
            "score": 0.35704955794183413,
            "section_title": "Purpose",
            "char_start_offset": 16230,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 227
                },
                {
                    "start": 228,
                    "end": 375
                },
                {
                    "start": 378,
                    "end": 621
                },
                {
                    "start": 624,
                    "end": 921
                },
                {
                    "start": 924,
                    "end": 1321
                },
                {
                    "start": 1324,
                    "end": 1471
                },
                {
                    "start": 1474,
                    "end": 1686
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.68603515625
        },
        {
            "corpus_id": "264371146",
            "title": "Core competencies of K-12 computer science education from the perspectives of college faculties and K-12 teachers",
            "text": "Daxton holds a similar opinion: \"They're going to have to know how to do sequence selection iteration, whether it's graphical or not. I think it [block-based visual programming] is good for K-2 to K-5. But once they get to K-6 through 12, I think it should be a text-based programming language.\" (Daxton, a CS instructor in higher education) 4.2.2 Code II: Syntax-based Languages: Python, Java, C++ In particular, the specific text-based programming languages that are encouraged included Python, Java, and C++, etc. For example, Kash says, \"Python is appropriate for K-12 CS education. In Python, students don't receive too many syntax issues, and they can focus on improving problem-solving techniques.\" (Kash, a CS associate professor). Moreover, Kate and Lisa mention that their schools have already taught syntax-based programming language in high school. \n\n\"At the high school, we use Python and Java. We use programming languages and tools that they can utilize. Now we teach an AP Computer Science class. So that does have to be the Java language because that's what the test is on. But those are all very marketable software tools that they can use, whether it's in college or if they decide college is not for them. They can also use in the real world.\" (Kate, a K-12 high school CS teacher) \"We also use Python to begin to develop the understanding of what is the language and how do you learn it. By ninth grade, they're doing full-on Python. They can take Java after ninth grade. And so those are both options for continuation\" (Lucy, a K-12 middle school CS teacher) 4.2.3 Code III: Specific Programming Language does not Matter Overall, four interviewees think that the specific programming language is not that important compared to CT skills for problem-solving. K-12 students can learn CT skills without using particular \"real\" programming language, as indicated in previous cites from Aiden and Kash. \n\nStudents can learn any programming language, such as Python, to learn CT skills. Once they master one programming language, the knowledge can be transferred when learning other programming languages.",
            "score": 0.356815633462248,
            "section_title": "Code I: From Block-Based Programming to Syntax-Based Languages",
            "char_start_offset": 32177,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 133
                },
                {
                    "start": 134,
                    "end": 201
                },
                {
                    "start": 202,
                    "end": 295
                },
                {
                    "start": 296,
                    "end": 347
                },
                {
                    "start": 348,
                    "end": 516
                },
                {
                    "start": 517,
                    "end": 586
                },
                {
                    "start": 587,
                    "end": 705
                },
                {
                    "start": 706,
                    "end": 739
                },
                {
                    "start": 740,
                    "end": 860
                },
                {
                    "start": 863,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 969
                },
                {
                    "start": 970,
                    "end": 1012
                },
                {
                    "start": 1013,
                    "end": 1090
                },
                {
                    "start": 1091,
                    "end": 1225
                },
                {
                    "start": 1226,
                    "end": 1263
                },
                {
                    "start": 1264,
                    "end": 1408
                },
                {
                    "start": 1409,
                    "end": 1454
                },
                {
                    "start": 1455,
                    "end": 1492
                },
                {
                    "start": 1493,
                    "end": 1586
                },
                {
                    "start": 1587,
                    "end": 1779
                },
                {
                    "start": 1780,
                    "end": 1919
                },
                {
                    "start": 1922,
                    "end": 2002
                },
                {
                    "start": 2003,
                    "end": 2121
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2178955078125
        },
        {
            "corpus_id": "276317900",
            "title": "Code Style Sheets: CSS for Code",
            "text": "Existing tree transformation and query languages (e.g., XSLT [71] and XQuery [70]) may provide a starting point for defining a suitable language of selectors for AST elements. But how should AST elements matched by code style sheet selectors be related to corresponding document elements to be styled? Alas, in a standard architecture, there is no persistent connection between the input to the view function and the output document. Our first key insight is the need to maintain provenance [15] that connects these \"source\" and \"view\" values, respectively. \n\nDesign Goal: Compact Layout for Nested Blocks of Text. Once AST elements have been selected and their corresponding displays (documents) styled, the second challenge for \"CSS for code\" stems from the fact that program text comprises heavily nested and non-rectangular regions, and these substructures should be subject to visual decoration as demonstrated in Figure 1 and Figure 3 . Unfortunately, existing box-based layout engines, as for HTML and CSS, offer essentially only rectangles for display. Rendering the nested structure of abstract syntax trees (ASTs) naively using rectangles leads to displays that differ significantly from the raw, unstyled program text. (To preview this inadequacy, see Figure 8 and Figure 9 in \u00a72.) Our second key technical step is to identify a class of rectilinear shapes, called stylish blocks or s-blocks (Figure 6), and an algorithm for generating them which renders nested, stylized blocks of text in a way that more closely resembles the unstyled text. Importantly, s-blocks can tightly wrap multiline, nonrectangular regions of text even when heavily nested as demonstrated in Figure 1 and Figure 3.",
            "score": 0.3564543039973573,
            "section_title": "Cascading Style Sheets (CSS) for Code",
            "char_start_offset": 6978,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 175
                },
                {
                    "start": 176,
                    "end": 301
                },
                {
                    "start": 302,
                    "end": 433
                },
                {
                    "start": 434,
                    "end": 557
                },
                {
                    "start": 560,
                    "end": 614
                },
                {
                    "start": 615,
                    "end": 942
                },
                {
                    "start": 943,
                    "end": 1060
                },
                {
                    "start": 1061,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1292
                },
                {
                    "start": 1293,
                    "end": 1553
                },
                {
                    "start": 1554,
                    "end": 1701
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.06243896484375
        },
        {
            "corpus_id": "264307073",
            "title": "Game Engine Wizardry for Programming Mischief",
            "text": "Visual programming environments have the potential to make programming more accessible to programmers of all backgrounds and skill levels. For instance, Domain-Specific Languages (DSLs) have been shown to help non-programmers raise their productivity, and improve the quality of their work [26]. DSLs offer specific abstractions and notations that provide increased expressiveness over particular problem domains, e.g., banking, digital forensics and game design. \n\nLanguage workbenches and meta-programming languages provide techniques and approaches that support rapid prototyping of DSLs [9], especially compilers and interpreters, e.g., based on Visual Studio Code and the Language Server Protocol (LSP). However, generic language technology often has limited support for visual programming environments, e.g., projectional editors [30], block-based editors [20], or web interfaces [31]. Language engineers require tools and techniques to speed up and simplify the development of visual programming environments that are user friendly, aesthetically pleasing, and easy to deploy, maintain and extend. \n\nGame engines are collections of software libraries, toolkits and cross-compilers that have been especially designed for developing portable visual applications, games in particular. These engines represent the state of the art in 2D and 3D frameworks for creating visual simulations, Heads-Up Displays (HUDs) and immersive interactive experiences. \n\nTo date, only a limited number of authors have explored using game engines for creating DSLs [19,27,34]. We see a research opportunity to bridge the gap between the technological spaces of game engine technology and Programming Language (PL) research, language workbenches in particular. \n\nWe hypothesize that game engines are well-suited for the automated development of interactive programming environments, especially visual DSLs. In particular, we aim to learn how game engines can be used for creating visual input and feedback mechanisms that support exploratory programming, live programming and creative tinkering. \n\nTo shed light on this matter, we conduct a feasibility analysis and carry out a pilot study. First, we create a concise overview of a limited number of well-known game engines in Section 2. We assess strengths, weaknesses, opportunities and threats.",
            "score": 0.3564368558850086,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 138
                },
                {
                    "start": 139,
                    "end": 295
                },
                {
                    "start": 296,
                    "end": 463
                },
                {
                    "start": 466,
                    "end": 708
                },
                {
                    "start": 709,
                    "end": 891
                },
                {
                    "start": 892,
                    "end": 1104
                },
                {
                    "start": 1107,
                    "end": 1288
                },
                {
                    "start": 1289,
                    "end": 1454
                },
                {
                    "start": 1457,
                    "end": 1561
                },
                {
                    "start": 1562,
                    "end": 1744
                },
                {
                    "start": 1747,
                    "end": 1890
                },
                {
                    "start": 1891,
                    "end": 2079
                },
                {
                    "start": 2082,
                    "end": 2174
                },
                {
                    "start": 2175,
                    "end": 2331
                }
            ],
            "ref_mentions": [
                {
                    "start": 290,
                    "end": 294,
                    "matchedPaperCorpusId": "264769167"
                },
                {
                    "start": 591,
                    "end": 594,
                    "matchedPaperCorpusId": "5234848"
                },
                {
                    "start": 836,
                    "end": 840,
                    "matchedPaperCorpusId": "7129564"
                },
                {
                    "start": 862,
                    "end": 866,
                    "matchedPaperCorpusId": "243867310"
                },
                {
                    "start": 886,
                    "end": 890,
                    "matchedPaperCorpusId": "254126377"
                },
                {
                    "start": 1550,
                    "end": 1554,
                    "matchedPaperCorpusId": "27875923"
                },
                {
                    "start": 1557,
                    "end": 1560,
                    "matchedPaperCorpusId": "6365940"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7080078125
        },
        {
            "corpus_id": "39606061",
            "title": "Measuring an Impact of Block-Based Language in Introductory Programming",
            "text": "The use of block-based visual language in introductory programming is a popular method in education. However, there is little research which provides evidence showing advantages of block-based language. This paper presents the results of learning data analysis with fine grain logs recorded by students\u2019 development environment where the students can select their language in block-based or Java. A total of 400+ students\u2019 logs collected each of four years were analyzed. The results show that migration from Block to Java can be consistently seen each year, although the whole block-editing rate was influenced by the method of the instructor\u2019s introduction. Though block-editing did not affect working time and Lines of Code (LOC), it could reduce the compile error correction time, whereas using Java requires approximately 20% of compile error correction time for students. We concluded that block-based language worked to encourage students to focus high-level algorithm creation, as well as it provides an advantage to understanding text-based language.",
            "score": 0.35555241147962624,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5380859375
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "The mock-up of Figure 6 resolves the necessity of multiple distinct \"when\" blocks in Scratch, per event type and target, with just a single block. It depicts event target specifiers, defining the event target expression, followed at the end by the actual event type. \n\nFor example, in 2d games, sprite targets require firstly the main category \"sprite\" and then the sprite class, like \"shield\", with the contextually applicable event types suggested via a dropdown list. \n\nAnother mockup, illustrated under Figure 7, concerns flow-based programming, and suggests the provision of adaptive tooltips between connected elements, carrying brief information on the type of propagated data items. When interactive updates change the output data types, all outdated visual cues must be automatically refreshed and synced. Quick information is usually provided as informative tooltips, something known to encourage users in interactively exploring features and functionality. In Figure 8 we show how block-level editors may introduce tooltips to inform learners in using programming elements. Such tooltips offer a live, brief, and interactive tutorial of the visual language. In Figure 9, in flow-based programming, if a producer is selected, an appropriate dropdown list of matching consumers is composed and shown, based on the type of the output port and the information on the input ports of all available consumer types.",
            "score": 0.354527656354938,
            "section_title": "Examples:",
            "char_start_offset": 9967,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 266
                },
                {
                    "start": 269,
                    "end": 470
                },
                {
                    "start": 473,
                    "end": 690
                },
                {
                    "start": 691,
                    "end": 814
                },
                {
                    "start": 815,
                    "end": 967
                },
                {
                    "start": 968,
                    "end": 1084
                },
                {
                    "start": 1085,
                    "end": 1168
                },
                {
                    "start": 1169,
                    "end": 1418
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7578125
        },
        {
            "corpus_id": "225216594",
            "title": "Algorithmic Synergy and Architectural Form Generation Mechanisms",
            "text": "The form of mathematical design is represented by the type of programming language used in three methods on different abstract levels (Celani and Vaz, 2012), as follows: \uf0b7 Iconic representation: On a more realistic way, parametric representations can be described as Iconic representations, for example, some programs like CAD software allows specified parametric relations between graphic entities visually in a direct way on the screen as in programs like MicroStation and later versions of AutoCAD (Celani and Vaz, 2012). \uf0b7 Analogue representation: This one uses active Visual Programming Languages to discover forms through the generating in the representation process. Icons are used to represent and process entities in an indirect way through environments. It allows describing visual relations between entities without the need to write code or specific encode as in Generative Component's Symbolic Diagram and Grasshopper language (software), that represents node-based algorithmic editor. It represents singular components connected in different ways depending on a Visual Programming Language to create programs (Melendez, 2019). \uf0b7 Symbolic representation: This uses text-based textual programming languages to represent architectural form using text and numbers to describe and execute operations on graphic entities, and the likes of this type are all scripting languages of CAD, Rhino Script, AutoLisp, VBA (Celani and Vaz, 2012). As was previously noted, in mathematical design, in a synergetic way programming fields (Behavior of tool) and design (Designer's mind) are merged to define architecture, it can be stated that the methods or mechanics of architectural form representation; is done through either Analogue representation which utilizes Visual programming languages, or the Symbolic one which utilizes textual programming languages. Both of them depend on generative design to generate and discover architectural form using algorithms, parameters as well as objects according 120 to the vision of the designer taking into consideration that textual programming languages proved more freedom in dealing with the tools and enables the designer to develop and build his own tools depending on the nature of his information or need or according to a certain target or goal.",
            "score": 0.3544891364383005,
            "section_title": "b) Methods (a mechanism) of synergetic computational Digital Design",
            "char_start_offset": 14554,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 524
                },
                {
                    "start": 525,
                    "end": 673
                },
                {
                    "start": 674,
                    "end": 763
                },
                {
                    "start": 764,
                    "end": 998
                },
                {
                    "start": 999,
                    "end": 1140
                },
                {
                    "start": 1141,
                    "end": 1444
                },
                {
                    "start": 1445,
                    "end": 1858
                },
                {
                    "start": 1859,
                    "end": 2295
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.74267578125
        },
        {
            "corpus_id": "269622739",
            "title": "Graphical Block Structured Programming: A Visual Programming Paradigm",
            "text": "This paper discusses the concept and design of a graphical block-structured programming paradigm that presents a model for constructing computer programs using a set of graphical objects that resembles the existing lexical instructions in a C language. The design of the paradigm was motivated by the results from studies investigating the previous designs and the acquisition of existing visual programming languages. Studies showed that most people are having trouble expressing the structures that they cannot write or verbally describe due to their limited grasp of natural language. The aim of this proposed programming paradigm is to improve the user\u2019s ability to create programs by making programming more accessible to some particular audience and improving the correctness and speed with which people perform programming tasks.",
            "score": 0.3544289123930477,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9111328125
        },
        {
            "corpus_id": "264371146",
            "title": "Core competencies of K-12 computer science education from the perspectives of college faculties and K-12 teachers",
            "text": "Some of the visual programming languages, such as Scratch and Alice, are block-based languages in the programming environments, of which students can drag and drop coding blocks to the workspace. Thus, novice CS learners can focus on the computational concepts and logic without being bothered by the syntax (Bau et al., 2017;Kelleher & Pausch, 2005). Some research argues that visual programming languages might be more appropriate for novice learners as they are easier to learn (Bau et al., 2017;Chen et al., 2020;Malan & Leitner, 2007). For example, Chen et al. (2020) analyzed data from 10,000 undergraduate students who enrolled in CS courses and found that students whose first programming language was visual performed better than did students whose first programming language was textual when the programming languages were first introduced in K-12 stages. Moreover, the visual languages and environments provide scaffolds and enable knowledge transfer. Research indicates that visual programming languages are used in K-12 CT education. For example, Hsu et al. (2018) and Lockwood and Mooney (2017) find that many schools have utilized visual programming languages to teach CT skills. Other studies indicate that using visual programming languages to teach students CT skills is effective in elementary education (The Horizon Report, 2017). Application of visual program languages in K-12 CS education is found to significantly improve students' understanding of computational concepts and computation practices (Saez-Lopez et al., 2016), logical thinking skills (Lindh and Holgersson 2007), and problem-solving skills in general (Chou 2018). \n\nGiven the mixed opinions of introducing visual or textual programming languages in K-12 CS education, Xu et al. (2019) conduct a meta-analysis on the block-based versus textual programming on student learning outcomes by reviewing 13 publications. They find a small effect size in favor of block-based programming languages on cognitive learning outcomes and suggest more research on the effectiveness of using block-based programming languages for novice learners in the future. \n\nTo sum up, the epistemology of K-12 CS education, including its necessity, its core competencies as well as programming languages that should be taught in its implementation, still need to be clarified.",
            "score": 0.3544289123930477,
            "section_title": "Programming Languages in CS Education",
            "char_start_offset": 8102,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 195
                },
                {
                    "start": 196,
                    "end": 351
                },
                {
                    "start": 352,
                    "end": 540
                },
                {
                    "start": 541,
                    "end": 865
                },
                {
                    "start": 866,
                    "end": 962
                },
                {
                    "start": 963,
                    "end": 1046
                },
                {
                    "start": 1047,
                    "end": 1194
                },
                {
                    "start": 1195,
                    "end": 1350
                },
                {
                    "start": 1351,
                    "end": 1652
                },
                {
                    "start": 1655,
                    "end": 1902
                },
                {
                    "start": 1903,
                    "end": 2134
                },
                {
                    "start": 2137,
                    "end": 2339
                }
            ],
            "ref_mentions": [
                {
                    "start": 326,
                    "end": 350,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 517,
                    "end": 539,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 1060,
                    "end": 1077,
                    "matchedPaperCorpusId": "52813623"
                },
                {
                    "start": 1522,
                    "end": 1547,
                    "matchedPaperCorpusId": "27633066"
                },
                {
                    "start": 1573,
                    "end": 1600,
                    "matchedPaperCorpusId": "31042634"
                },
                {
                    "start": 1640,
                    "end": 1651,
                    "matchedPaperCorpusId": "55683453"
                },
                {
                    "start": 1757,
                    "end": 1773,
                    "matchedPaperCorpusId": "67914194"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84375
        },
        {
            "corpus_id": "58394",
            "title": "Towards rule-based visual programming of generic visual systems",
            "text": "This paper illustrates how the diagram programming language DiaPlan can be used to program visual systems. DiaPlan is a visual rule-based language that is founded on the computational model of graph transformation. The language supports object-oriented programming since its graphs are hierarchically structured. Typing allows the shape of these graphs to be specified recursively in order to increase program security. Thanks to its genericity, DiaPlan allows to implement systems that represent and manipulate data in arbitrary diagram notations. The environment for the language exploits the diagram editor generator DiaGen for providing genericity, and for implementing its user interface and type checker.",
            "score": 0.3544289123930477,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85107421875
        },
        {
            "corpus_id": "236447670",
            "title": "Guided Optimization for Image Processing Pipelines",
            "text": "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes [31]. Alice [32] and Scratch [33] are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks. Weintrop and Wilensky found that block-based programming tools were easier to use for high school students than text-based alternatives [34]. \n\nInspired by the prior work on VPLs, Roly-poly offers an interactive block-like visualization of the execution of the image processing pipeline. Compared with manual text-based scheduling, we narrow users' freedom by only providing a set of choices. However, our design choices are that using visual constraints in Roly-poly will help users focus only on essential ideas, not on syntactical mistakes. Also, some VPLs assign colors to categories based on their functionalities (e.g., control blocks and operators blocks). This inspired Roly-poly to assign distinguished colors to different functions.",
            "score": 0.3544289123930477,
            "section_title": "E. Visual Programming Language",
            "char_start_offset": 15457,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 349
                },
                {
                    "start": 350,
                    "end": 491
                },
                {
                    "start": 494,
                    "end": 637
                },
                {
                    "start": 638,
                    "end": 742
                },
                {
                    "start": 743,
                    "end": 893
                },
                {
                    "start": 894,
                    "end": 1013
                },
                {
                    "start": 1014,
                    "end": 1092
                }
            ],
            "ref_mentions": [
                {
                    "start": 193,
                    "end": 197,
                    "matchedPaperCorpusId": "34589974"
                },
                {
                    "start": 205,
                    "end": 209,
                    "matchedPaperCorpusId": "62491646"
                },
                {
                    "start": 222,
                    "end": 226,
                    "matchedPaperCorpusId": "273180521"
                },
                {
                    "start": 486,
                    "end": 490,
                    "matchedPaperCorpusId": "207226901"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9375
        },
        {
            "corpus_id": "164831179",
            "title": "Students\u2019 Perceptions on Using a Dual Modality Programming Environment",
            "text": "Block-based programming has succeeded in introducing programming to novices. \"Jigsaw puzzle\" metaphor makes users feel comfortable from the beginning. Nevertheless, students who move from block-based environments to textbased ones believe that they are transferred to a new and totally different environment. Learners do not consider visual languages \"real\" programming languages. This view is supported by preconceived ideas about what is programming, the fact that visual languages are easier and that textual programming is later found to be difficult. Some users even find textual languages and syntax intimidating. Educators try to facilitate this transition [9], [10], [13]. \n\nThere are numerous efforts to support this transfer, mostly with the aim to use the computational thinking skills which students have gained through their involvement with the block-based environment in order to support their development to text-based programming. One example is Robinson who introduced Patch -a modified version of Scratch 1.4-that will ease the transition from Scratch to Python [14]. Moreover, there are researches that try to facilitate the interface of block-based programming languages (e.g. grouping blocks by functionality) in order to improve usability [15]. \n\nPrice and Barnes analyzed the outcome of a study in two groups of novice programmers -one assigned to block interface and the other to text interface-and came to the conclusion that \"students using the block interface spent less time off task and completed more of the activity's goals in less time\". The chosen environment was Tiled Grace that allows the user to switch between the two modes. In their article there is an extended description of block-based environments along with references to previous evaluations of such software. There are reviews of studies that compare textual and block programming environments and reviews of studies about the transition from block-based to textual programming [16]. \n\nWeintrop and Wilensky [5], provide two cases of systematic comparisons of block-based and text-based environments. In a study using Snap!, they came to the conclusion that students perform \"better on block-based questions related to conditional logic, function calls and definite loops\" and found \"no differences on questions related to variables, indefinite loops, and program comprehension questions\".",
            "score": 0.35419903479351683,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 8668,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 76
                },
                {
                    "start": 77,
                    "end": 150
                },
                {
                    "start": 151,
                    "end": 308
                },
                {
                    "start": 309,
                    "end": 380
                },
                {
                    "start": 381,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 619
                },
                {
                    "start": 620,
                    "end": 680
                },
                {
                    "start": 683,
                    "end": 947
                },
                {
                    "start": 948,
                    "end": 1086
                },
                {
                    "start": 1087,
                    "end": 1197
                },
                {
                    "start": 1198,
                    "end": 1267
                },
                {
                    "start": 1270,
                    "end": 1570
                },
                {
                    "start": 1571,
                    "end": 1663
                },
                {
                    "start": 1664,
                    "end": 1805
                },
                {
                    "start": 1806,
                    "end": 1980
                },
                {
                    "start": 1983,
                    "end": 2097
                },
                {
                    "start": 2098,
                    "end": 2386
                }
            ],
            "ref_mentions": [
                {
                    "start": 664,
                    "end": 667,
                    "matchedPaperCorpusId": "7906930"
                },
                {
                    "start": 669,
                    "end": 673,
                    "matchedPaperCorpusId": "55399814"
                },
                {
                    "start": 675,
                    "end": 679,
                    "matchedPaperCorpusId": "25090136"
                },
                {
                    "start": 1081,
                    "end": 1085,
                    "matchedPaperCorpusId": "17190342"
                },
                {
                    "start": 1262,
                    "end": 1266,
                    "matchedPaperCorpusId": "22250224"
                },
                {
                    "start": 1975,
                    "end": 1979,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 2005,
                    "end": 2008,
                    "matchedPaperCorpusId": "10976181"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.55810546875
        },
        {
            "corpus_id": "260704716",
            "title": "Spellburst: A Node-based Interface for Exploratory Creative Coding with Natural Language Prompts",
            "text": "Creative coders work across a semantic-syntactic divide, as described by Reas [60]. Artists often envision and explicate their work through visual metaphors [17] or rich verbal descriptions [76]. When using programming languages to create art, artists must then map expressive intents in the semantic space (i.e., \"undulating waves of color, \" a doodle of a design) to low-level program syntax (i.e., p5.js functions such as lerp() or sin()) [60,79]. However, effectively mapping semantic concepts to low-level code can be difficult for creative coders of all levels [32,77]. Prior research in visual programming languages (VPLs) [52] have looked at reducing friction by presenting some components of the code via two-dimensional visuals. For example, block-based programming languages such as Scratch [46] or node-based programming languages such as TouchDesigner, Stamper [12], and natto.dev [67] help users abstract important aspects such as control flow, variables, and data into visual representations. By leveraging advances in computer vision, systems such as Sketch2Code [33] directly map hand-drawn sketches to HTML code. \n\nRecent advancements in generative AI and text-to-code models such as Codex and Copilot have allowed users to write code using natural language prompts and autocomplete features within integrated development environments (IDEs) such as VSCode [1] and Replit [63]. LLMs have accelerated the progress in bridging semantic and syntactic space by autonomously mapping natural language prompts to code output. Anecdotally, ChatGPT has already been integrated into common creative tools such as Unity and Adobe Suite. However, publically available LLMs are not necessarily optimized for a creative coding context. Mapping parameters within a high-dimensional design space to human language and feedback requires domain-specific frameworks [69]. \n\nWhile VPLs and natural language tools provide more accessible representations of code, direct manipulation interfaces provide more accessible interactions with code.",
            "score": 0.3511432968081904,
            "section_title": "Support for Expressive Programming",
            "char_start_offset": 9109,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 83
                },
                {
                    "start": 84,
                    "end": 195
                },
                {
                    "start": 196,
                    "end": 450
                },
                {
                    "start": 451,
                    "end": 575
                },
                {
                    "start": 576,
                    "end": 738
                },
                {
                    "start": 739,
                    "end": 893
                },
                {
                    "start": 894,
                    "end": 1007
                },
                {
                    "start": 1008,
                    "end": 1130
                },
                {
                    "start": 1133,
                    "end": 1395
                },
                {
                    "start": 1396,
                    "end": 1536
                },
                {
                    "start": 1537,
                    "end": 1643
                },
                {
                    "start": 1644,
                    "end": 1739
                },
                {
                    "start": 1740,
                    "end": 1870
                },
                {
                    "start": 1873,
                    "end": 2038
                }
            ],
            "ref_mentions": [
                {
                    "start": 567,
                    "end": 571,
                    "matchedPaperCorpusId": "23999609"
                },
                {
                    "start": 630,
                    "end": 634,
                    "matchedPaperCorpusId": "7335020"
                },
                {
                    "start": 802,
                    "end": 806,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 874,
                    "end": 878,
                    "matchedPaperCorpusId": "218482984"
                },
                {
                    "start": 1865,
                    "end": 1869,
                    "matchedPaperCorpusId": "221369529"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7763671875
        },
        {
            "corpus_id": "268249114",
            "title": "Making Hybrid Languages: A Recipe",
            "text": "In February 2020, a research group at the Hasso-Plattner-Institut f\u00fcr Digitales Engineering at Universit\u00e4t Potsdam published a technical report [Bein et al. 2020] on the Sandblocks system. the Smalltalk programming language and its Morphic graphical development environment. At first glance, the visual syntax extensions look related to the ones presented here. Its visual extensions can be interleaved with program text. Furthermore, the project report carefully spells out the design goal that visual syntax must not interfere with a developer's tool chain and workflow. \n\nUnfortunately, the design falls short of its goals. Unlike the hybrid language presented in this paper, visual elements in the Sandblocks implementation are not general. For example, programmers cannot add visualizations for field definitions, methods, patterns, templates, and other syntactic forms. Further, the visual constructs do not respect the language's static semantics such as lexical scope. As a result, the developer's toolchain and workflow are not preserved.",
            "score": 0.3509754580961078,
            "section_title": "Sandblocks",
            "char_start_offset": 43877,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 274
                },
                {
                    "start": 275,
                    "end": 361
                },
                {
                    "start": 362,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 572
                },
                {
                    "start": 575,
                    "end": 626
                },
                {
                    "start": 627,
                    "end": 744
                },
                {
                    "start": 745,
                    "end": 875
                },
                {
                    "start": 876,
                    "end": 976
                },
                {
                    "start": 977,
                    "end": 1047
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.564453125
        },
        {
            "corpus_id": "270427107",
            "title": "Formation of an information retrieval system of visual programming scenarios for information modeling software complexes",
            "text": "In recent years, visual programming tools in the information modeling environment have become increasingly popular. Visual programming is a way of developing a program based on manipulations with graphic objects instead of writing code in the form of text. This tool allows you to generate script code even without knowledge of the syntax of the programming language. [1][2] The main purpose of using visual programming, including in the information modeling environment, is to expand the functionality of the software package by developing its own functions. As a result, designers can automate routine tasks and go beyond the basic functionality of the program. [3] Visual programming includes a library of previously prepared program code blocks in the form of a graphical node element. Formed in a certain way by a set of nodes is a scriptscript, as a result of which one or another task is performed automatically. Simultaneously with the basic node library, additional packages created by users can be added to the program. [4][5] The spread and development of visual programming in the information modeling environment has led to a sharp increase in the number of scripts both in a particular company and in the industry as a whole. And already today, large project companies are faced with the difficulties of interacting with a large number of scripts that perform various functions. There are problems with storing, searching, processing and updating scripts, which leads to an increase in the duration of the design and additional labor costs of specialists. [6][7] Thus, it is advisable to create a tool that will eliminate the problems of working with a large number of different types of scripts. The purpose of this work is to develop an information retrieval system for working with visual programming scripts, the tasks are to analyze the file structure of script storage, form database requirements, develop algorithms for database formation and dynamic SQL query formation (Structured Query Language) to filter the necessary scripts.",
            "score": 0.3502770236080408,
            "section_title": "Introdution",
            "char_start_offset": 14,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 256
                },
                {
                    "start": 257,
                    "end": 367
                },
                {
                    "start": 368,
                    "end": 559
                },
                {
                    "start": 560,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 789
                },
                {
                    "start": 790,
                    "end": 919
                },
                {
                    "start": 920,
                    "end": 1029
                },
                {
                    "start": 1030,
                    "end": 1239
                },
                {
                    "start": 1240,
                    "end": 1392
                },
                {
                    "start": 1393,
                    "end": 1569
                },
                {
                    "start": 1570,
                    "end": 1710
                },
                {
                    "start": 1711,
                    "end": 2052
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78466796875
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "In this category, we grouped several topics and points of view regarding using of the block-based modality in programming education. For instance, Weintrop [167] studied the impact of using a block-based environment in education, and Xinogalos et al. [174] investigates students' perceptions of five popular educational programming environments and the features that introductory programming environments must-have. Similarly, Yoon et al. [175] designed a curriculum that integrates socio-scientific issues in the design and development of mobile apps using App Inventor. Turbak et al. [153] studied the importance of teaching event-based programming in computer science curricula. Dong et al. [42] propose a tinkering environment for students when they struggle in problem-solving activities. Dwyer et al. [43] study the readability of block-based programs by students. \n\nThere are different points of view regarding the modality in which programming should be introduced to novice users. Some advocate that visual languages are the best option for introducing novices to programming, while others support text-based languages as the best modality since that is what professional developers use. Thus, researchers have tried to address this topic, and they have work on evaluating the effects that the modality (block-based, text-based, and hybrid) has in the learning process [26,103,118,170,171]. Franklin et al. [53] study the differences between block-based languages (e.g., Scratch) and text-based languages (e.g., C and Java). Other researchers focus on studying how to ease the transition from a block-based language into a text-based language [81,172] and the drawbacks users face in this transition [104,105]. Milne and Ladner [102] study the relevance of accessibility features in block-based environments. \n\nFinally, Table 10 presents the tools aimed at teaching computer science concepts in general and learning environments to support the teaching of computational concepts. \n\nTable 11 shows the languages used to support and transfer computational skills to learners. \n\nTable 12 contains the block-based languages used to teach other subjects such as aerodynamics, Latin language, mathematics, music, and chemistry.",
            "score": 0.35012248502569077,
            "section_title": "Programming literacy",
            "char_start_offset": 40430,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 132
                },
                {
                    "start": 133,
                    "end": 415
                },
                {
                    "start": 416,
                    "end": 571
                },
                {
                    "start": 572,
                    "end": 681
                },
                {
                    "start": 682,
                    "end": 793
                },
                {
                    "start": 794,
                    "end": 870
                },
                {
                    "start": 873,
                    "end": 989
                },
                {
                    "start": 990,
                    "end": 1196
                },
                {
                    "start": 1197,
                    "end": 1533
                },
                {
                    "start": 1534,
                    "end": 1719
                },
                {
                    "start": 1720,
                    "end": 1817
                },
                {
                    "start": 1820,
                    "end": 1988
                },
                {
                    "start": 1991,
                    "end": 2082
                },
                {
                    "start": 2085,
                    "end": 2230
                }
            ],
            "ref_mentions": [
                {
                    "start": 156,
                    "end": 161,
                    "matchedPaperCorpusId": "198986538"
                },
                {
                    "start": 439,
                    "end": 444,
                    "matchedPaperCorpusId": "199006001"
                },
                {
                    "start": 586,
                    "end": 591,
                    "matchedPaperCorpusId": "61427297"
                },
                {
                    "start": 694,
                    "end": 698,
                    "matchedPaperCorpusId": "67866205"
                },
                {
                    "start": 807,
                    "end": 811,
                    "matchedPaperCorpusId": "14955855"
                },
                {
                    "start": 1382,
                    "end": 1386,
                    "matchedPaperCorpusId": "22570972"
                },
                {
                    "start": 1386,
                    "end": 1390,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 1390,
                    "end": 1394,
                    "matchedPaperCorpusId": "223424"
                },
                {
                    "start": 1394,
                    "end": 1398,
                    "matchedPaperCorpusId": "51750550"
                },
                {
                    "start": 1416,
                    "end": 1420,
                    "matchedPaperCorpusId": "16719280"
                },
                {
                    "start": 1652,
                    "end": 1656,
                    "matchedPaperCorpusId": "15209878"
                },
                {
                    "start": 1656,
                    "end": 1660,
                    "matchedPaperCorpusId": "201132502"
                },
                {
                    "start": 1709,
                    "end": 1714,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 1714,
                    "end": 1718,
                    "matchedPaperCorpusId": "25090136"
                },
                {
                    "start": 1737,
                    "end": 1742,
                    "matchedPaperCorpusId": "209496022"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.406494140625
        },
        {
            "corpus_id": "7844885",
            "title": "An Interactive Book Authoring Tool to Introduce Programming Logic in Schools",
            "text": "The user creates a text, which may have one or more wiki link to other texts, which may also connect to other ones, and so forth. For increasing usability, Twine provides a visualization tool where the user can see the overall story graph, in a way similar to StoryTec. However, differently from the latter, it does not provide a visual editor for authoring the story logic. In Twine, each wiki-text may also have embedded a chunk of code (written in Javascript) in order to control, for instance, how many times the user has passed by that text or if a part of the text should be visible or not. This approach allows more control. However, it requires previous knowledge of a specific programming language. Figure 2 illustrates the Twine approach to embed variables and coding instructions into a narrative text. The two previously mentioned approaches, exemplified by StoryTec and Twine, have advantages and pitfalls. While a purely visual method does not provide all programming mechanisms, a direct use of a programming language may pose a barrier to beginners. It is worth then note that each approach targets a particular audience: non-programmer users and programmer ones. By focusing on a unique audience, they do not provide enough mechanisms to guide a non programmer user to become a programmer one. In other words, they are not adequate to be used as a learning tool. \n\nAiming at this learning guidance in programming skills, several tools have been constructed using a block-based visual programming strategy, as the one present in Scratch (Resnick et al., 2009). Indeed, the interest in block-based visual programming has grown in recent years, specially in the educational context, helping beginners to get involved in their programming first steps (Fraser, 2015). From a leaner perspective, the advantages of using block-based programming relies on the ability to use a visual language modeled for a specific domain, the possibility of gradually presenting parts of that language, and, finally, the capacity of not allowing syntax errors (only semantic errors) (Fraser, 2015). \n\nBecause of the previously mentioned reasons, authoring applications using block-based programming, such as Scratch (Resnick et al., 2009) and AppIventor (Wolber, 2011), have been widely used by educators to teach programming.",
            "score": 0.34967728568089246,
            "section_title": "RELATED WORK",
            "char_start_offset": 6488,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 269
                },
                {
                    "start": 270,
                    "end": 374
                },
                {
                    "start": 375,
                    "end": 596
                },
                {
                    "start": 597,
                    "end": 631
                },
                {
                    "start": 632,
                    "end": 707
                },
                {
                    "start": 708,
                    "end": 813
                },
                {
                    "start": 814,
                    "end": 919
                },
                {
                    "start": 920,
                    "end": 1065
                },
                {
                    "start": 1066,
                    "end": 1179
                },
                {
                    "start": 1180,
                    "end": 1310
                },
                {
                    "start": 1311,
                    "end": 1379
                },
                {
                    "start": 1382,
                    "end": 1576
                },
                {
                    "start": 1577,
                    "end": 1779
                },
                {
                    "start": 1780,
                    "end": 2092
                },
                {
                    "start": 2095,
                    "end": 2320
                }
            ],
            "ref_mentions": [
                {
                    "start": 1764,
                    "end": 1778,
                    "matchedPaperCorpusId": "44698743"
                },
                {
                    "start": 2077,
                    "end": 2091,
                    "matchedPaperCorpusId": "44698743"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.802734375
        },
        {
            "corpus_id": "1837720",
            "title": "A Survey of Query Languages for Geographic Information Systems",
            "text": "This paper presents a survey of query languages dedicated to Geographic Information Systems (GIS). Five categories of query languages can be identified : (1) natural languages, (2) extensions of SQL, (3) tabular languages : use of skeletons or forms, (4) graphical languages : use of symbols, which are only graphical conventions (like in the entity-relationship diagrams) and (5) visual languages : use of visual metaphors (e.g., icons, blackboard metaphor and map-overlay metaphor). The principles of each of them are presented. Respective strengths and weaknesses are pointed out, based on a set of predefined queries. The main objective of this paper is to present the state of the art of research work in a domain which is suitable for graphical querying. The last part of this paper describes hypermedia techniques.",
            "score": 0.3492369545073124,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2900390625
        },
        {
            "corpus_id": "53492260",
            "title": "Remote SMS Instrumentation Supervision and Control Using LabVIEW",
            "text": "LabVIEW is a powerful platform for algorithm development, design, prototyping, and interfacing of embedded system with real-world hardware. LabVIEW uses graphical language (G) that enables the creation of programs in block-diagram form, which are called virtual instruments (VI). The main executable program is called the top-level VI and the programs used as modular subroutines are called subVIs. Every VI consists of two main components, the graphical user interface that is named front panel; and the graphical code that implements the functionality of the VI, called block diagram. Once a VI is created and saved, it can be used as a subVI in the block diagram of another VI, acting as a subroutine (Gan & Kuo, 2007;Oussalah & Djezzar, 2010;Sumathi & Surekha, 2007). The front panel contains objects known as controls and indicators. Controls are the inputs that provide data to the block diagram, and indicators shows output data from the block diagram. These objects, such as buttons, switches, LEDs and graphs are selected from the controls palette. In the Figure 3, the controls palette and the front panel with some examples of controls and indicators are shown. Front panel controls and indicators have a corresponding terminal block on the block diagram, which holds the graphical source code that defines how the VI will operate. A block diagram is built with terminals and nodes available in the functions palette and that are connected by wires. An example using the same controls and indicators used in the front panel is illustrated in the Figure 4; the colors indicate the data type, e.g., numerical indicators are blue and floating-point ones are orange. The block diagram code executes based on the principle of dataflow. The rule of dataflow states that functions execute only when all of their required inputs are populated with data. This programming architecture allows both sequential and parallel execution to be easily defined graphically. When a node completes execution, it supplies data to its output terminals on the right, and follows the dataflow imposed by the wires connecting the block diagram objects (Gan & Kuo, 2007;Sumathi & Surekha, 2007).",
            "score": 0.3487742625878134,
            "section_title": "LabVIEW",
            "char_start_offset": 12991,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 721,
                    "end": 746,
                    "matchedPaperCorpusId": "52264298"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5703125
        },
        {
            "corpus_id": "224865976",
            "title": "EUD-MARS: End-user development of model-driven adaptive robotics software systems",
            "text": "When end-users are developing a program, they could define the different elements, action sequences, events, and calls using any visual organization that they choose. Upon saving a program and generating its XML representation, EUD-MARS regroups the elements under the different sections shown in Fig. 12. Robot profiles, mappings, sequences, and adaptations, presented in this section, are contained within programs such as the one shown in Fig. 12. \n\nAfter demonstrating this example of EUD-MARS and its XML-based representation, we should emphasize that EUD-MARS only uses Blockly for the visual representation of its programs. It does not use Blockly for XML generation. The XML representation of the programs comprises the EUD-MARS concepts presented in Fig. 3 to Fig. 7. A converter component (from EUD-MARS) transforms the visual programs to an XML representation that is interpretable by an EUD-MARS interpreter. We should also reemphasize that we do not expect end-users to define robotics programs using XML. We provide end-users with a visual language that makes the development of robotics programs less challenging. The XML that we demonstrated in this section is the underlying representation of this visual language. Hence, with EUD-MARS, end-users do not have to create, read, or update any artifacts using XML or any other text-based language. The next section presents the tools that we devised to support the software developers and end-users who wish to use EUD-MARS.",
            "score": 0.34793066737838435,
            "section_title": "An example EUD-MARS application",
            "char_start_offset": 82309,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 450
                },
                {
                    "start": 453,
                    "end": 630
                },
                {
                    "start": 631,
                    "end": 674
                },
                {
                    "start": 675,
                    "end": 776
                },
                {
                    "start": 777,
                    "end": 920
                },
                {
                    "start": 921,
                    "end": 1018
                },
                {
                    "start": 1019,
                    "end": 1128
                },
                {
                    "start": 1129,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1360
                },
                {
                    "start": 1361,
                    "end": 1487
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.56640625
        },
        {
            "corpus_id": "17399148",
            "title": "A Survey on Teaching and Learning Recursive Programming",
            "text": "Visual programming languages enable the composition of program constructs by manipulating graphical representations instead of writing text. Good and Brna (1996) were the first to investigate whether these languages provided a better support for learning recursion than textual languages, and concluded negatively. Spreadsheet languages are sometimes considered as visual programming languages or even functional languages, and Burnett et al. (2001) focused on testing recursive programs with them. Kim (2003) proposed a string of classroom exercises to learn recursion with Excel. \n\nVirtual worlds. Tasc\u00f3n-Vidarte et al. (2010) designed an interactive interface based on a tangible block-world with augmented reality to learn iteration on lists and aiming at the transfer of skills to directly write tail recursive definitions in Erlang. An earlier, three-dimensional virtual world was designed by Dann et al. (2001). For two-dimensional geometry considered as a virtual world, we have Logo.",
            "score": 0.3475544306000783,
            "section_title": "Multimedia Environments",
            "char_start_offset": 60137,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 140
                },
                {
                    "start": 141,
                    "end": 314
                },
                {
                    "start": 315,
                    "end": 498
                },
                {
                    "start": 499,
                    "end": 581
                },
                {
                    "start": 584,
                    "end": 599
                },
                {
                    "start": 600,
                    "end": 838
                },
                {
                    "start": 839,
                    "end": 918
                },
                {
                    "start": 919,
                    "end": 992
                }
            ],
            "ref_mentions": [
                {
                    "start": 141,
                    "end": 161,
                    "matchedPaperCorpusId": "62684178"
                },
                {
                    "start": 428,
                    "end": 449,
                    "matchedPaperCorpusId": "11031065"
                },
                {
                    "start": 499,
                    "end": 509,
                    "matchedPaperCorpusId": "63846569"
                },
                {
                    "start": 600,
                    "end": 628,
                    "matchedPaperCorpusId": "44012611"
                },
                {
                    "start": 899,
                    "end": 917,
                    "matchedPaperCorpusId": "9790523"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.59033203125
        },
        {
            "corpus_id": "271874441",
            "title": "Can Large Language Models Understand Symbolic Graphics Programs?",
            "text": "Recently, [48] has advanced this direction by examining large language models (LLMs) for synthesizing graphics programs to reconstruct visual input. In contrast, we benchmark LLMs to perform semantic-level question answering, similar to VQA, but use graphics programs as input without relying on any visual modality. \n\nLarge language models. LLMs have demonstrated growing potential in many applications, ranging from mathematical problem solving and theorem proving assistance [65,114,116,15] to aiding biological discovery [67,27,94,59]. Applying LLMs for programming tasks is also a popular direction of research. Specifically, many works have explored topics such as code retrieval [26], automated testing [19,62,109], repairing [44,106,41,42,100], documentation [13,2], and generation [11,5,54,28,72]. These abilities of understanding and generating programs are usually gained from pretraining or finetuning on large datasets of code. Our work investigates LLMs' capability of understanding symbolic graphics programs, which differs significantly from the prior works since the semantic meaning of graphics programs are often defined visually by their corresponding graphics. \n\nRelevant benchmarks and datasets. Many benchmarks have evaluated different aspects of LLMs: AI safety/ethics [107,38], out-of-distribution performance [115,110], API/tool usage [52], code generation [35], etc. Perhaps the most relevant aspect of LLM evaluation to our task is (non-graphics) program understanding abilities [96,44,35,64,57,63,90,34,11]. As graphics programs can be rendered into images, it is also highly relevant to investigate how vision-language models are capable of visual understanding [12,1,74,40,70,32,6,91,85,120]. For SVG programs, [10] studies whether LLMs can understand them and [122] introduces a concurrent benchmark for this purpose. Different from existing benchmarks, SGP-Bench is one of the first benchmarks to evaluate the semantic understanding of general graphics programs. \n\nConcluding Remarks.",
            "score": 0.34671604772981457,
            "section_title": "RELATED WORK AND CONCLUDING REMARKS",
            "char_start_offset": 39962,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 148
                },
                {
                    "start": 149,
                    "end": 316
                },
                {
                    "start": 319,
                    "end": 341
                },
                {
                    "start": 342,
                    "end": 539
                },
                {
                    "start": 540,
                    "end": 616
                },
                {
                    "start": 617,
                    "end": 806
                },
                {
                    "start": 807,
                    "end": 940
                },
                {
                    "start": 941,
                    "end": 1181
                },
                {
                    "start": 1184,
                    "end": 1217
                },
                {
                    "start": 1218,
                    "end": 1393
                },
                {
                    "start": 1394,
                    "end": 1536
                },
                {
                    "start": 1537,
                    "end": 1723
                },
                {
                    "start": 1724,
                    "end": 1849
                },
                {
                    "start": 1850,
                    "end": 1995
                },
                {
                    "start": 1998,
                    "end": 2017
                }
            ],
            "ref_mentions": [
                {
                    "start": 525,
                    "end": 529,
                    "matchedPaperCorpusId": "256304602"
                },
                {
                    "start": 532,
                    "end": 535,
                    "matchedPaperCorpusId": "259947046"
                },
                {
                    "start": 714,
                    "end": 717,
                    "matchedPaperCorpusId": "254535728"
                },
                {
                    "start": 733,
                    "end": 737,
                    "matchedPaperCorpusId": "220425306"
                },
                {
                    "start": 737,
                    "end": 741,
                    "matchedPaperCorpusId": "250627519"
                },
                {
                    "start": 741,
                    "end": 744,
                    "matchedPaperCorpusId": "256808267"
                },
                {
                    "start": 744,
                    "end": 747,
                    "matchedPaperCorpusId": "257495997"
                },
                {
                    "start": 747,
                    "end": 751,
                    "matchedPaperCorpusId": "261494010"
                },
                {
                    "start": 796,
                    "end": 799,
                    "matchedPaperCorpusId": "246527904"
                },
                {
                    "start": 1511,
                    "end": 1514,
                    "matchedPaperCorpusId": "220425306"
                },
                {
                    "start": 1517,
                    "end": 1520,
                    "matchedPaperCorpusId": "231855531"
                },
                {
                    "start": 1698,
                    "end": 1701,
                    "matchedPaperCorpusId": "6941275"
                },
                {
                    "start": 1701,
                    "end": 1704,
                    "matchedPaperCorpusId": "152282269"
                },
                {
                    "start": 1704,
                    "end": 1707,
                    "matchedPaperCorpusId": "173991173"
                },
                {
                    "start": 1707,
                    "end": 1710,
                    "matchedPaperCorpusId": "8081284"
                },
                {
                    "start": 1710,
                    "end": 1712,
                    "matchedPaperCorpusId": "52804681"
                },
                {
                    "start": 1712,
                    "end": 1715,
                    "matchedPaperCorpusId": "85553602"
                },
                {
                    "start": 1715,
                    "end": 1718,
                    "matchedPaperCorpusId": "250729995"
                },
                {
                    "start": 1718,
                    "end": 1722,
                    "matchedPaperCorpusId": "19713015"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.07196044921875
        },
        {
            "corpus_id": "560431",
            "title": "An exploratory study of forces and frictions affecting large-scale model-driven development",
            "text": "While model-driven engineering at GM provides the specialized team of codegeneration engineers with powerful abstraction to capture domain-specific architectures, it does not empower its end-users, i.e., domain experts and software engineers, to express their own problem-specific languages and type systems. \n\nIn general, the visual language of domain experts seems to be much richer and broader than the languages provided by modeling tools. In particular, there seems to be a need for problem-specific \"little languages\" that can be defined on the fly. Currently, domain experts are unable to create new abstractions that would allow them to achieve productivity gains in algorithm innovation. Neither Simulink, which is largely a visual representation of common coding patterns, nor Rhapsody, by virtual of its limitation to the UML standard's visual languages, offer the ability to define the kind of rich visual languages that we learned about from the domain expert's requirements documents. \n\nVisual programming in Simulink traces its ancestry to circuit diagrams and aims at expressing low-level programming constructs such as conditionals and mathematical operators with the visual language of circuit diagrams. Mathematical operations and conditionals are each represented as single blocks. While this language is visual, it does not seem be an actual abstraction from source code. Even worse, as we learned through our interviews, the level of abstraction seems to be lower than high-level source code. For example, engineers reported that they struggle to introduce abstraction such as nested scopes of variable visibility, enumerators, or refactoring duplicated code into a new method. \n\nCompared to source-based high-level languages, we found that, while modeldriven engineering increases the abstraction level of program compilation, it does achieve the same increase in abstraction for program representation. Modeldriven engineering provides specialists with the power to build a domain-specific global architecture by customizing the program compilation through code-generation rules. Yet, the \"end-users\" of model-driven engineering, that is domain experts and software engineers, are left without the power to create their own APIs to address local problem-specific needs in a formal manner.",
            "score": 0.34587539609142154,
            "section_title": "On Problem-Specific Needs of Modelers",
            "char_start_offset": 33300,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 308
                },
                {
                    "start": 311,
                    "end": 443
                },
                {
                    "start": 444,
                    "end": 555
                },
                {
                    "start": 556,
                    "end": 696
                },
                {
                    "start": 697,
                    "end": 998
                },
                {
                    "start": 1001,
                    "end": 1221
                },
                {
                    "start": 1222,
                    "end": 1301
                },
                {
                    "start": 1302,
                    "end": 1392
                },
                {
                    "start": 1393,
                    "end": 1514
                },
                {
                    "start": 1515,
                    "end": 1699
                },
                {
                    "start": 1702,
                    "end": 1926
                },
                {
                    "start": 1927,
                    "end": 2103
                },
                {
                    "start": 2104,
                    "end": 2312
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.662109375
        },
        {
            "corpus_id": "252305562",
            "title": "Digitizing Arudh and Qowafi Classics as Android-Based Student Learning Media Using Flutter",
            "text": "Visual code can be used to develop mobile, web, desktop and cloud applications. Visual Code makes it easy to write code that supports several types of programming, such as C++, C#, Java, Python, PHP, GO [12] [13]. Visual Code has the ability to identify the type of programming language used and provide color variations according to the function in the code series. Visual Studio Code has also been integrated into Github [14]. Dart is an object-oriented, class-based language with a C-style syntax. Darts can be compiled to native code or JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and type inference [15]. Dart is an interesting programming language which is getting more and more popular day by day. The language is scalable and can be used to write simple scripts or full-featured applications. Use Case Diagrams are usually referred to as behavior diagrams that are used to describe a series of actions (use cases) that several systems or systems (subjects) must or can perform in collaboration with one or more external users of the system (actors). Each use case must provide some observable and valuable result for the actors or other stakeholders of the system. Use Case Diagrams are used to capture dynamic aspects of the system. In general, it aims to collect the needs of a system, get views from outside the system, identify factors that affect the system both internally and externally, show the interaction between actors and the system. Class diagrams provide an overview of the relationship between the tables in the database [16]. Each class has attributes and methods or functions according to the process that occurs [17]. From the design of the diagram, it will be known how the relationship between the tables in the database and what input processes are in it. Activity Diagrams describe the workflow (workflow) or activities of a system or business process. After creating a Use Case model, each scenario in the Use Case will be described more clearly in the activity diagram. Activity diagram is a modeling that describes a working system of an object or a system, an activity diagram is described with a structured flow of the work process from the use case that is being processed from the starting point to the end point, each activity is described with notations according to its function [17] [18].",
            "score": 0.3450110533972601,
            "section_title": "Literature Review",
            "char_start_offset": 6905,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 79
                },
                {
                    "start": 80,
                    "end": 213
                },
                {
                    "start": 214,
                    "end": 366
                },
                {
                    "start": 367,
                    "end": 428
                },
                {
                    "start": 429,
                    "end": 500
                },
                {
                    "start": 501,
                    "end": 552
                },
                {
                    "start": 553,
                    "end": 645
                },
                {
                    "start": 646,
                    "end": 740
                },
                {
                    "start": 741,
                    "end": 836
                },
                {
                    "start": 837,
                    "end": 1093
                },
                {
                    "start": 1094,
                    "end": 1208
                },
                {
                    "start": 1209,
                    "end": 1277
                },
                {
                    "start": 1278,
                    "end": 1490
                },
                {
                    "start": 1491,
                    "end": 1586
                },
                {
                    "start": 1587,
                    "end": 1680
                },
                {
                    "start": 1681,
                    "end": 1821
                },
                {
                    "start": 1822,
                    "end": 1919
                },
                {
                    "start": 1920,
                    "end": 2038
                },
                {
                    "start": 2039,
                    "end": 2366
                }
            ],
            "ref_mentions": [
                {
                    "start": 208,
                    "end": 212,
                    "matchedPaperCorpusId": "212558645"
                },
                {
                    "start": 423,
                    "end": 427,
                    "matchedPaperCorpusId": "235192578"
                },
                {
                    "start": 640,
                    "end": 644,
                    "matchedPaperCorpusId": "55011688"
                },
                {
                    "start": 1675,
                    "end": 1679,
                    "matchedPaperCorpusId": "237772371"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.389892578125
        },
        {
            "corpus_id": "258564479",
            "title": "ShapeCoder: Discovering Abstractions for Visual Programs from Unstructured Primitives",
            "text": "We discuss ShapeMOD separately at the end of this section. \n\nVisual program generation. Several deep generative models have been proposed to generate visual programs. MatFormer [Guerrero et al. 2022] generates node graphs for materials, several methods propose generative models for SVG images [Carlier et al. 2020;Reddy et al. 2021a], CAD sketches [Ganin et al. 2021;Para et al. 2021;Seff et al. 2022], and 3D CAD Modelling sequences [Li et al. 2022;Wu et al. 2021;Xu et al. 2022]. The ShapeAssembly [Jones et al. 2020] and ShapeMOD [Jones et al. 2021] methods mentioned above can also be used as generative models. Similar to methods for visual program induction, all of these methods, except for ShapeMOD, require a DSL with a full set of operators. \n\nDreamCoder. This work proposes a system that jointly discovers abstractions and performs program induction over arbitrary functional programming languages [Ellis et al. 2021]. At its core Dream-Coder uses three phases to perform this hard task. A dream phase samples random programs from a library (optionally augmented with abstractions). A wake phase trains a recognition network to infer programs based on the dream samples. An abstraction phase looks over a corpus of returned programs from the wake phase, and proposes and integrates abstractions that improve an objective function. The objective function trade-offs program likelihood under the library with the complexity of the library. While DreamCoder's generality allows it to effectively scale across a wide-variety of program inference tasks, its abstractions are purely structural, treating real-valued program components as discretizations. This means that it is not well-suited for shapes (or other visual domains) where ideally abstractions would capture both complex parametric and structural relationships. Another challenge of applying DreamCoder to shape programs is that its iterative procedure is reliant on a curriculum to solve tasks: all of its stages (dreaming, waking, abstraction) rely on the assumption that solutions to at least some of the input tasks have a high probability under the current library functions. When the input tasks form a curriculum (e.g.",
            "score": 0.34425958120972455,
            "section_title": "RELATED WORK",
            "char_start_offset": 12878,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 58
                },
                {
                    "start": 61,
                    "end": 87
                },
                {
                    "start": 88,
                    "end": 166
                },
                {
                    "start": 167,
                    "end": 482
                },
                {
                    "start": 483,
                    "end": 616
                },
                {
                    "start": 617,
                    "end": 752
                },
                {
                    "start": 755,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 930
                },
                {
                    "start": 931,
                    "end": 999
                },
                {
                    "start": 1000,
                    "end": 1094
                },
                {
                    "start": 1095,
                    "end": 1182
                },
                {
                    "start": 1183,
                    "end": 1342
                },
                {
                    "start": 1343,
                    "end": 1449
                },
                {
                    "start": 1450,
                    "end": 1660
                },
                {
                    "start": 1661,
                    "end": 1830
                },
                {
                    "start": 1831,
                    "end": 2149
                },
                {
                    "start": 2150,
                    "end": 2194
                }
            ],
            "ref_mentions": [
                {
                    "start": 294,
                    "end": 315,
                    "matchedPaperCorpusId": "220686491"
                },
                {
                    "start": 315,
                    "end": 333,
                    "matchedPaperCorpusId": "231802181"
                },
                {
                    "start": 349,
                    "end": 368,
                    "matchedPaperCorpusId": "233864603"
                },
                {
                    "start": 368,
                    "end": 385,
                    "matchedPaperCorpusId": "235358817"
                },
                {
                    "start": 385,
                    "end": 402,
                    "matchedPaperCorpusId": "238215827"
                },
                {
                    "start": 451,
                    "end": 466,
                    "matchedPaperCorpusId": "234789948"
                },
                {
                    "start": 466,
                    "end": 480,
                    "matchedPaperCorpusId": "250360845"
                },
                {
                    "start": 910,
                    "end": 929,
                    "matchedPaperCorpusId": "235474001"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.47802734375
        },
        {
            "corpus_id": "253049931",
            "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
            "text": "On the other hand, we infer from our observations that visual languages by themselves provide too little support to enable non-programmers to implement complex, realistic tasks without additional assistance. \n\nThe remainder of this paper is structured as follows: We provide a short introduction to block-based programming languages in Section 2 together with a description of the industry context. Section 3 details the study design including research questions and experiment procedure. We show experiment results in Section 4, list participant feedback on usability aspects in Section 5 before discussing the results and their implications in Section 6. We review related work in Section 7 before concluding this paper with an outlook on future work in Section 8.",
            "score": 0.3441653753236377,
            "section_title": "Introduction",
            "char_start_offset": 2300,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 207
                },
                {
                    "start": 210,
                    "end": 398
                },
                {
                    "start": 399,
                    "end": 488
                },
                {
                    "start": 489,
                    "end": 656
                },
                {
                    "start": 657,
                    "end": 766
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.63916015625
        },
        {
            "corpus_id": "196196006",
            "title": "Fifty years of the psychology of programming",
            "text": "with diagrams rather than text -followed routine use of diagrams by professional programmers (especially the flowcharts ubiquitous in the 1970s) and systems analysts (in the various approaches to business-oriented planning of data files and processing). However programming languages themselves, from FORTRAN and COBOL on, used teletype characters, with manual translation from diagrammatic designs to text that could be processed by compilers. This textual nature of programming \"language\" had not been inevitable -indeed the first formal proposal by Goldstine and Von Neumann (1947) was purely diagrammatic. However the economics of interactive graphical displays, despite the early celebrity of Sutherland's Sketchpad (1963/2003) meant that mass-market deployment of graphical user interfaces had only become feasible in the mid 1980s. \n\nIn the following 13 years of the IEEE Symposia on Visual Languages until the series ended in 2000, the research presented focused primarily on description of specific languages (129 papers), and on theoretical or engineering frameworks for classes of visual language (125 papers). In addition to these topics that might be regarded as core to visual programming languages, the VL symposia also paid significant attention to visualisation of software and data (62 papers), and other aspects of graphical user interface design more generally (67 papers). Other regular themes included discussion of diagrammatic modelling languages and notations (38 papers), algorithms for parsing, layout or rendering of visual languages (30 papers), and other types of interactive drawing tool (28 papers). Some specialist topics have remained a constant minority interest, including tools for the construction or generation of user interfaces (14 papers) and the use of inference methods for end-user programming by example (11 papers). However, it is remarkable how few of the papers published in this period of the series paid attention to theories of human factors that justified the change from textual to visual language, or empirical studies that attempted to measure or evaluate the benefits of that change, with only one or two papers each year dealing with those topics. As noted by Blackwell in a 1996 paper, subsequently recognised with an award for most influential paper after 20 years (Blackwell 1996), research in the field relied mainly on theories of pop psychology, folk wisdom, or personal subjective intuition to justify its core technical concerns.",
            "score": 0.3441653753236377,
            "section_title": "A C C E P T E D M A N U S C R I P T",
            "char_start_offset": 31159,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 253
                },
                {
                    "start": 254,
                    "end": 444
                },
                {
                    "start": 445,
                    "end": 609
                },
                {
                    "start": 610,
                    "end": 838
                },
                {
                    "start": 841,
                    "end": 1121
                },
                {
                    "start": 1122,
                    "end": 1393
                },
                {
                    "start": 1394,
                    "end": 1631
                },
                {
                    "start": 1632,
                    "end": 1862
                },
                {
                    "start": 1863,
                    "end": 2205
                },
                {
                    "start": 2206,
                    "end": 2495
                }
            ],
            "ref_mentions": [
                {
                    "start": 552,
                    "end": 584,
                    "matchedPaperCorpusId": "62644505"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.68212890625
        },
        {
            "corpus_id": "4039308",
            "title": "Visual and textual programming languages: a systematic review of the literature",
            "text": "A more traditional approach to visual languages came in the form of using flowcharts. Most \"modern\" languages don't use this methodology, but for completeness, results from the search that covered this style of design are included here. Greyling et al (2006) discuss the concept of the B# language that they developed. B# uses an iconic flowchart approach to give students two options in developing their code, via drag-and-drop of code pieces, or by the traditional textual approach. As a user is building a flowchart, code is generated in parallel in C++, Pascal or Java. Flow chart icons are connected by lines, making the ordering and structure of the program obvious. While this methodology worked well in the early stages of a CS1 course, the authors note that \"unfortunately initial evaluation sessions showed that many students did not succeed in developing adequate coding skills while working with B#\". Another example of a flowchart based VPL is RAPTOR (Carlisle et al (2005)). RAPTOR's goal is to improve problem solving skills while reducing the emphasis on syntax. It uses a similar approach to B#, except without a textual counterpart. Different elements are built up via drag-and-drop, ensuring that program structure is correct. From a study of 959 test subjects, the authors found that students prefer to express their algorithms visually, with 95% choosing to use a flowchart on the final exam over a textual language. This lends credence to the concept of a VPL, allowing more advanced tools to be built.",
            "score": 0.3441653753236377,
            "section_title": "Flowchart Approach",
            "char_start_offset": 13323,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 85
                },
                {
                    "start": 86,
                    "end": 236
                },
                {
                    "start": 237,
                    "end": 318
                },
                {
                    "start": 319,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 573
                },
                {
                    "start": 574,
                    "end": 672
                },
                {
                    "start": 673,
                    "end": 912
                },
                {
                    "start": 913,
                    "end": 988
                },
                {
                    "start": 989,
                    "end": 1078
                },
                {
                    "start": 1079,
                    "end": 1150
                },
                {
                    "start": 1151,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1437
                },
                {
                    "start": 1438,
                    "end": 1524
                }
            ],
            "ref_mentions": [
                {
                    "start": 237,
                    "end": 258,
                    "matchedPaperCorpusId": "16180135"
                },
                {
                    "start": 964,
                    "end": 986,
                    "matchedPaperCorpusId": "16095985"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.80810546875
        },
        {
            "corpus_id": "247450910",
            "title": "Visualization in virtual reality: a systematic review",
            "text": "Beginning with Bertin's Semiology of Graphics (Bertin 1983), the formalization of the principles of graphic communication started, which later transformed into structural theories of graphics to establish a bond between computer graphics and information visualization theories. Cleveland and McGill (1984) experimented with retinal variables (position, color, and size). More recently, the ideas and theories of Wilkinson (2012) provide a basis for visualization interfaces, Lyra (Satyanarayan and Heer 2014) and VegaLite (Satyanarayan et al. 2017), and grammar-based systems such as Polaris (Stolte et al. 2002), which extends the pivot table interface. Visualization production tools such as Lyra and iVisDesigner (Ren et al. 2014) enable the creation of various customized graphic visualizations based on conceptual modularity without writing code. Unfortunately, they support only a small set of visual forms and parameters that limit users.\n\nMany visualization grammars, toolkits, and frameworks have been implemented from Wilkinson's grammar with the formalization of the grammar of graphics. The majority of visualization grammars can be described as declarative specifications, which only relive low-level details and allow users to produce a variety of visualizations using a maintainable number of building blocks. Users only need to describe the properties of components, such as data processing, scaling, marking, and encoding, to construct the final visual representation. They are generally grouped into lowlevel and high-level grammar. While low-level grammars demand specification for each mapping element, high-level languages encapsulate the properties of visualization construction (Tommasini et al. 2019). During the process, the data can be subjected to a set of transforms such as filtering and encoded using multiple visual channels like color, form, or any measurements of a selected shape. Data attributes are Fig. 3 Distribution of the 110 papers into ten categories. The radius of the circles is proportional to the number of studies. The circular dendrogram was obtained using RAWGraphs mapped to the characteristics of the visual markers according to the encoding. Low-level expressive grammars like D3 (Bostock et al. 2011), Vega (Satyanarayan et al. 2015), and Protovis (Heer 2009)",
            "score": 0.3439947104189587,
            "section_title": "3",
            "char_start_offset": 25741,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 480,
                    "end": 508,
                    "matchedPaperCorpusId": "32370368"
                },
                {
                    "start": 522,
                    "end": 548,
                    "matchedPaperCorpusId": "206805969"
                },
                {
                    "start": 592,
                    "end": 612,
                    "matchedPaperCorpusId": "260928204"
                },
                {
                    "start": 716,
                    "end": 732,
                    "matchedPaperCorpusId": "12627199"
                },
                {
                    "start": 1701,
                    "end": 1724,
                    "matchedPaperCorpusId": "190007667"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.305908203125
        },
        {
            "corpus_id": "230573295",
            "title": "Learning Programming Fundamentals via Music",
            "text": "Scratch was developed by Mitch Resnick at the MIT Media Lab, who believed that the ability to code computer programs is an important part of literacy in today's society. While acquiring programming abilities, students learn important strategies for solving problems, designing projects, and communicating ideas. Scratch is a block-based visual programming language, which is most suitable for young students but can be used by older ones as well. Via Scratch, one can create online projects using a block-like interface. In the present study, I decided to use Scratch 2.0. In this version, the block palette is located in the middle of the screen (Figure 1). Each category of commands has a different color. For example, the color of commands referring to sounds is pink. \n\nFigure 1 shows the different areas of the Scratch 2.0 screen. \n\nA: The graphical area in which the objects 'act' following orders/instructions. B: The list of the objects that have been added to the program. C: The list of blocks according to categories listed in the upper part of this area. D: The programming area where the user joins programming blocks to create scripts. \n\nThe 'Motion' category includes motion blocks, changing angles, and X and Y values. The 'Looks' category controls the visuals of the sprite: speech or thought, background, size, transparency, and shade. \n\nDue to the research focus, the 'Sound' category is elaborated in Table 1. The 'Pen' category includes blocks controlling the drawing of object motion on the graphic screen, the pen size, its color, and shade. \n\nThe 'Data' category includes the ability to add variables and lists to a program. The 'Events' category includes blocks controlling the flow of a program. The 'Control' category includes blocks of defined and undefined repetitive structures and conditional structures. \n\nThe 'Sensing' category includes blocks enabling sprites to interact with the surroundings the user has created. \n\nThe 'Operations' category includes mathematical operators, a random number generator, and 'and/or' statements that compare sprite positions. \n\nThe 'More Blocks' category includes custom procedures (adding new blocks) and external device control. \n\nLearning how to program is done via music programming, and therefore programming commands belonging to the 'Sound' category are displayed below (Table 1). \n\nIn this study, the students will learn programming principles via music.",
            "score": 0.3435321129843373,
            "section_title": "A BRIEF INTRodUCTIoN To SCRATCH wITH A SPECIAL FoCUS oN MUSIC BLoCKS",
            "char_start_offset": 5859,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 169
                },
                {
                    "start": 170,
                    "end": 311
                },
                {
                    "start": 312,
                    "end": 446
                },
                {
                    "start": 447,
                    "end": 520
                },
                {
                    "start": 521,
                    "end": 572
                },
                {
                    "start": 573,
                    "end": 658
                },
                {
                    "start": 659,
                    "end": 707
                },
                {
                    "start": 708,
                    "end": 771
                },
                {
                    "start": 774,
                    "end": 835
                },
                {
                    "start": 838,
                    "end": 917
                },
                {
                    "start": 918,
                    "end": 981
                },
                {
                    "start": 982,
                    "end": 1066
                },
                {
                    "start": 1067,
                    "end": 1149
                },
                {
                    "start": 1152,
                    "end": 1234
                },
                {
                    "start": 1235,
                    "end": 1353
                },
                {
                    "start": 1356,
                    "end": 1429
                },
                {
                    "start": 1430,
                    "end": 1564
                },
                {
                    "start": 1567,
                    "end": 1648
                },
                {
                    "start": 1649,
                    "end": 1721
                },
                {
                    "start": 1722,
                    "end": 1835
                },
                {
                    "start": 1838,
                    "end": 1949
                },
                {
                    "start": 1952,
                    "end": 2092
                },
                {
                    "start": 2095,
                    "end": 2197
                },
                {
                    "start": 2200,
                    "end": 2354
                },
                {
                    "start": 2357,
                    "end": 2429
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7587890625
        },
        {
            "corpus_id": "276421946",
            "title": "HumanEval-V: Benchmarking High-Level Visual Reasoning with Complex Diagrams in Coding Tasks",
            "text": "Figure 21 presents a comprehensive comparison of five distinct categories of diagrams commonly used in various benchmarks and coding platforms, showcasing the diverse range of visual reasoning challenges in the open world. The first category consists of real-world images from benchmarks such as MMMU, MMBench, and MM-Vet, encompassing everyday photographs of food, sports, architecture, art, and wildlife in both color and monochrome formats. These images test general visual recognition and understanding capabilities, contrasting sharply with the more structured representations found in other categories. \n\nThe second and third categories focus on analytical and scientific visualization. Analytical tables and charts, evaluated through benchmarks like ChartQA (Masry et al., 2022) and Charxiv (Wang et al., 2024c), comprise business and scientific data visualizations including bar charts, line graphs, and frequency tables. Scientific diagrams featured in MMMU (Yue et al., 2024), MMBench (Liu et al., 2023), and ScienceQA (Lu et al., 2022) present technical illustrations of molecular structures, particle dynamics, and ecosystem relationships. While both categories deal with data representation, they differ in their approach: analytical charts emphasize quantitative interpretation, whereas scientific diagrams focus on conceptual understanding. Mathematical diagrams, assessed through benchmarks such as MathVista (Lu et al., 2023) and Math-Vision (Wang et al., 2024a), represent another crucial category that bridges pure mathematics with practical applications. These include function graphs, geometric constructions, and physics diagrams, demonstrating complex mathematical concepts through visual means. This category shares some common ground with programmingrelated diagrams, particularly in their emphasis on logical relationships and systematic thinking. \n\nThe fifth category encompasses visual abstract reasoning, evaluated through benchmarks like ARC-AGI (Chollet, 2019), RAVEN (Zhang et al., 2019), and Bongard (Nie et al., 2020). These tests feature grid-based patterns and geometric transformations that assess abstract thinking and pattern recognition skills. This category bears the closest resemblance to programming-related diagrams in terms of logical abstraction and systematic problem-solving approaches.",
            "score": 0.3416662866218368,
            "section_title": "A.2 Diagrams in Other Benchmarks",
            "char_start_offset": 26551,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 222
                },
                {
                    "start": 223,
                    "end": 443
                },
                {
                    "start": 444,
                    "end": 608
                },
                {
                    "start": 611,
                    "end": 692
                },
                {
                    "start": 693,
                    "end": 929
                },
                {
                    "start": 930,
                    "end": 1151
                },
                {
                    "start": 1152,
                    "end": 1355
                },
                {
                    "start": 1356,
                    "end": 1574
                },
                {
                    "start": 1575,
                    "end": 1718
                },
                {
                    "start": 1719,
                    "end": 1873
                },
                {
                    "start": 1876,
                    "end": 2052
                },
                {
                    "start": 2053,
                    "end": 2184
                },
                {
                    "start": 2185,
                    "end": 2335
                }
            ],
            "ref_mentions": [
                {
                    "start": 967,
                    "end": 985,
                    "matchedPaperCorpusId": "265466525"
                },
                {
                    "start": 1029,
                    "end": 1046,
                    "matchedPaperCorpusId": "252383606"
                },
                {
                    "start": 1999,
                    "end": 2019,
                    "matchedPaperCorpusId": "71148268"
                },
                {
                    "start": 2033,
                    "end": 2051,
                    "matchedPaperCorpusId": "222125270"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.283447265625
        },
        {
            "corpus_id": "37160034",
            "title": "Shelves: A User-Defined Block Management Tool for Visual Programming Languages",
            "text": "Block editors such as the one used in Scratch are now found in many visual programming languages (VPLs). While considered user-friendly for non-programmers or program learners, they have at least three important display limitations: readability, program structure, and re-use. To address these issues we have developed block shelves, a formatting and organizing tool in support of user-defined VPL structures. Usability experiment results indicate that block shelves can significantly enhance block code navigation and searches, as well as project structure clarification. In the interest of improving project collaboration and code re-use, users can utilize the extensible markup language file format to export/import shelves, and thereby share block codes between projects. Features designed for shelves and the experiment findings are value for course design in project-based learning and future block editor interface improvements.",
            "score": 0.34081316299006786,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83203125
        },
        {
            "corpus_id": "258564479",
            "title": "ShapeCoder: Discovering Abstractions for Visual Programs from Unstructured Primitives",
            "text": "Procedural models are an attractive representation for visual data. Visual programs, expressions that produce visual outputs when executed, offer many advantages over alternative representations, such as compactness, interpretability, and editability [Ritchie et al. 2023]. There is a wide-range of domains that fall under the purview of visual programs, and procedural workflows are becoming increasingly common in modeling software [Freiknecht and Effelsberg 2017;SideFx 2014]. A trait that many visual programming domains share, is that their programs often contain both structural diversity and variables that are constrained by complex parametric relationships. \n\nTypically, visual programs are written in domain-specific languages (DSLs) targeted for specific visual applications. Not all visual programs are equally useful. Well-structured programs that capture and constrain properties of the visual data they represent typically benefit downstream applications (e.g. editing, generation, analysis). On the other hand, badly written programs lose this advantage. For instance, given an input visual scene composed of a collection of primitives, a visual program that simply unions instantiated primitives together might achieve a perfect reconstruction, but would lose all of the aforementioned benefits of the underlying representation. The functions a DSL contains influences the types of programs it can represent, and access to a 'good' collection of functions is often a prerequisite for finding well-structured programs. \n\n1:2 \u2022 R. Kenny Jones, Paul Guerrero, Niloy J. Mitra, and Daniel Ritchie Abstraction functions that extract out common patterns of structural and parametric use for a particular domain, can significantly improve visual program quality, but these types of programs (and their abstractions) are hard to obtain without expert manual design. \n\nThe idea of automatic abstraction discovery has been investigated for general programming domains [Ellis et al. 2021]. Some approaches have also been designed for visual domains [Jones et al. 2021], where programs contain complex parametric relationships that complicate this task. While previous methods have made headway towards solving this task, none offer a complete solution. Two central limitations holding back the applicability of such methods are that they are either designed without visual programs in mind (so fail to find meaningful parametric relationships) or rely on heavy input assumptions that are hard to meet.",
            "score": 0.340807846142792,
            "section_title": "INTRODUCTION",
            "char_start_offset": 2054,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 67
                },
                {
                    "start": 68,
                    "end": 273
                },
                {
                    "start": 274,
                    "end": 479
                },
                {
                    "start": 480,
                    "end": 666
                },
                {
                    "start": 669,
                    "end": 786
                },
                {
                    "start": 787,
                    "end": 830
                },
                {
                    "start": 831,
                    "end": 975
                },
                {
                    "start": 976,
                    "end": 1007
                },
                {
                    "start": 1008,
                    "end": 1070
                },
                {
                    "start": 1071,
                    "end": 1345
                },
                {
                    "start": 1346,
                    "end": 1534
                },
                {
                    "start": 1537,
                    "end": 1873
                },
                {
                    "start": 1876,
                    "end": 1994
                },
                {
                    "start": 1995,
                    "end": 2157
                },
                {
                    "start": 2158,
                    "end": 2257
                },
                {
                    "start": 2258,
                    "end": 2506
                }
            ],
            "ref_mentions": [
                {
                    "start": 251,
                    "end": 272,
                    "matchedPaperCorpusId": "258236273"
                },
                {
                    "start": 434,
                    "end": 466,
                    "matchedPaperCorpusId": "4589744"
                },
                {
                    "start": 1974,
                    "end": 1992,
                    "matchedPaperCorpusId": "235474001"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.716796875
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "As such, nowadays, the five categories more used to characterize VPLs are the following: \n\n\u2022 Purely Visual Languages: Languages that totally rely on visual techniques throughout the programming process and the program is compiled directly from its visual representation. In this case, the language is never translated into an interim text-based language. \n\n\u2022 Hybrid Systems (Textual/Visual): Languages that can be either created visually and then translated into an underlying high-level textual language or involve the use of graphical elements in an otherwise textual language. \n\n\u2022 Programming-by-Example systems: In these systems, the paradigm of programming-by-demonstration is followed and the user is allowed to create and manipulate visual objects in order to teach the system how to perform tasks. \n\n\u2022 Constraint-oriented Systems: Languages that are designed to act in a constraint scenario or environments, such as simulation design or graphical user interfaces development. \n\n\u2022 Form-based systems: Languages that take advantage of any spreadsheet metaphor. \n\nIt is important to note that these categories are by no means mutually exclusive. Indeed, many languages can be placed in more than one category. \n\nCharacterizing IoT VPLs and their Development Environments. A typical development lifecycle for the IoT is similar to the development of any other system, plus some particularities inherent to the IoT ecosystem. However, since IoT is still in its early stages of development, its development mechanisms and tools are still lagging behind on the best practices and lessons learned from the Software Engineering community in the past decades. Such earliness of development is noticed in the lack of Integrated Development Environments with proper mechanisms of debugging and testing [Dias et al. 2018]. \n\nIn spite of the novelty of the IoT, several Visual Programming Languages appeared (altogether with their supporting tools and development environments). And, similarly to any other programming language, there is an array of aspects that have impact when it comes to picking the Visual Programming system to use, beyond the language itself, but the features it provides and others aspects such as the openness, extensibility, community support, thus, we see that the traditional characterization approaches do not cover all the details of these systems. \n\nIn the following paragraphs we propose a set of guidelines for characterizing these languages and their development environments, enumerating the aspects that must be taken into account.",
            "score": 0.3398914003638871,
            "section_title": "Control-flow.",
            "char_start_offset": 54856,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 88
                },
                {
                    "start": 91,
                    "end": 270
                },
                {
                    "start": 271,
                    "end": 354
                },
                {
                    "start": 357,
                    "end": 579
                },
                {
                    "start": 582,
                    "end": 805
                },
                {
                    "start": 808,
                    "end": 983
                },
                {
                    "start": 986,
                    "end": 1066
                },
                {
                    "start": 1069,
                    "end": 1150
                },
                {
                    "start": 1151,
                    "end": 1214
                },
                {
                    "start": 1217,
                    "end": 1276
                },
                {
                    "start": 1277,
                    "end": 1428
                },
                {
                    "start": 1429,
                    "end": 1657
                },
                {
                    "start": 1658,
                    "end": 1817
                },
                {
                    "start": 1820,
                    "end": 1972
                },
                {
                    "start": 1973,
                    "end": 2372
                },
                {
                    "start": 2375,
                    "end": 2561
                }
            ],
            "ref_mentions": [
                {
                    "start": 1798,
                    "end": 1816,
                    "matchedPaperCorpusId": "49895548"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.98974609375
        },
        {
            "corpus_id": "216234689",
            "title": "DEVELOPMENT OF A VISUAL PROGRAMMING ALGORITHM FOR BIM-MODELS USING MODULE OF STRUCTURES BY DYNAMO MODULE.",
            "text": "The same goes for the formwork design. This type of design also uses a set of rules and has repetitive tasks that can affect performance if performed manually. \n\nTherefore, it is advisable to use visual programming tools to automate the design and obtain the optimal BIM model. The purpose of this article is to develop BIM-model design algorithms using visual programming language tools, in particular, Dynamo visual programming language. Dynamo is a platform that extends the standard Revit functionality and allows you to perform any calculations with the click of a button. Any engineer who designs residential buildings in Autodesk Revit knows that there are no turnkey solutions that take into account all the subtleties of the process of calculating the parameters of a residential complex. Dynamo was created to extend the core functionality of Revit and save designers time. \n\nTools based on VPL (Visual Programming Language) allow you to encode design rules and then process them to create 3D models. Tools such as Dynamo\u00ae, Grasshopper\u00ae, and Generative Components\u00ae are examples of applications that use this type of language. \n\nThis study aims to explore the possibility of using VPL-based tools to reduce simulation time in the production of LoD 400 BIM models. To achieve this, Autodesk Revit\u00ae and Dynamo\u00ae applications were selected. \n\nThe research was conducted in terms of limitations, capabilities and ease of use of the Dynamo\u00ae tool with an emphasis on the development of BIM LoD 400 masonry models. \n\nVisual programming languages were developed in the 70 s and arose as a result of combining work in the field of computer graphics, programming languages and human-computer interaction \n\nThe main idea of such a language is easier to use and learn through the use of graphic artifacts, rather than a text programming language. \n\nIn text-based programming languages, users need to learn the language syntax before they can code programs. In VPL tools, logic programs are constructed using diagrams called graphs, which consist of elements called nodes. \n\nNodes contain encapsulated structures used by the visual programming language. When a user creates a program graph indirectly, he creates program codes that are hidden in the nodes of the graph. Using the Grasshopper\u00ae module, a graph is created on the basis of this graph, when this graph is working, threedimensional geometry is generated from the built-in processing code in its nodes.",
            "score": 0.3393969225208689,
            "section_title": "Materials and Methods",
            "char_start_offset": 2053,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 38
                },
                {
                    "start": 39,
                    "end": 159
                },
                {
                    "start": 162,
                    "end": 277
                },
                {
                    "start": 278,
                    "end": 439
                },
                {
                    "start": 440,
                    "end": 577
                },
                {
                    "start": 578,
                    "end": 797
                },
                {
                    "start": 798,
                    "end": 883
                },
                {
                    "start": 886,
                    "end": 1010
                },
                {
                    "start": 1011,
                    "end": 1135
                },
                {
                    "start": 1138,
                    "end": 1272
                },
                {
                    "start": 1273,
                    "end": 1345
                },
                {
                    "start": 1348,
                    "end": 1515
                },
                {
                    "start": 1518,
                    "end": 1701
                },
                {
                    "start": 1704,
                    "end": 1842
                },
                {
                    "start": 1845,
                    "end": 1952
                },
                {
                    "start": 1953,
                    "end": 2067
                },
                {
                    "start": 2070,
                    "end": 2148
                },
                {
                    "start": 2149,
                    "end": 2264
                },
                {
                    "start": 2265,
                    "end": 2457
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.79638671875
        },
        {
            "corpus_id": "270521705",
            "title": "Structure Editor for Building Software Models",
            "text": "Block based editors, which are currently the most popular type of structure editor, have users build programs by using a drag-n-drop interface to connect blocks of code.Each block typically represents a syntactic form within the language, e.g. an if statement.The visual design of blocks can provide valuable context.For instance, the shape of blocks can indicate how blocks interconnect.Figure 2 displays a hello world program in Scratch, one of the most popular block based editor [21].\"Event\" code blocks are yellow and represent the start of a program, given by its shape which allows blocks to be added to the bottom but not the top.The interlocked purple block is a \"Looks\" code block that has a character say \"hello.\"\n\nScratch has been successfully used in introductory programming courses, even at the K-12 level [14,26,37].This later point is of interest to us, as one of the main applications we envision is to help users learn Alloy faster and easier than is currently possible using the Analyzer.Therefore, our structure editor is inspired by the best practices derived from Scratch's success.As figures 4 and 5 show, like Scratch, our structure editor is composed of three interconnected panels.The \"Formula Type\" panel displays different categories of blocks and the \"Blocks\" panel displays all selectable blocks of that type, which can be dragged and dropped into the \"Model\" panel canvas to build a formula.The use of blocks themselves is already helpful at preventing errors, as blocks remove typos, which would prevent the type error on line 11 in Figure 1.The difference between the implication and the cross product operators is two similar looking characters that are also neighboring keys on a keyboard, increasing the chance a user might mix them up.However, in a structure editor the user would instead select the implication operator and not type it, as Figure 4 (d) illustrates.While this mistake throws an error, it is possible for the user to make a typo that compiles, such as mixing up set intersection and set difference, which are also neighboring keys.Moreover, if the user actually intended to use the cross product operator, our structure editor will prevent this placement, since as Figure 4 (c) illustrates, the operator would not be selectable.",
            "score": 0.3392038008077472,
            "section_title": "Blocked Based Editor",
            "char_start_offset": 8196,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 169
                },
                {
                    "start": 169,
                    "end": 260
                },
                {
                    "start": 260,
                    "end": 317
                },
                {
                    "start": 317,
                    "end": 388
                },
                {
                    "start": 388,
                    "end": 488
                },
                {
                    "start": 488,
                    "end": 638
                },
                {
                    "start": 638,
                    "end": 723
                },
                {
                    "start": 723,
                    "end": 724
                },
                {
                    "start": 726,
                    "end": 832
                },
                {
                    "start": 832,
                    "end": 1008
                },
                {
                    "start": 1008,
                    "end": 1105
                },
                {
                    "start": 1105,
                    "end": 1208
                },
                {
                    "start": 1208,
                    "end": 1423
                },
                {
                    "start": 1423,
                    "end": 1575
                },
                {
                    "start": 1575,
                    "end": 1773
                },
                {
                    "start": 1773,
                    "end": 1904
                },
                {
                    "start": 1904,
                    "end": 2085
                },
                {
                    "start": 2085,
                    "end": 2282
                }
            ],
            "ref_mentions": [
                {
                    "start": 483,
                    "end": 487,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 821,
                    "end": 825,
                    "matchedPaperCorpusId": "258193870"
                },
                {
                    "start": 825,
                    "end": 828,
                    "matchedPaperCorpusId": "236379536"
                },
                {
                    "start": 828,
                    "end": 831,
                    "matchedPaperCorpusId": "245532362"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.74365234375
        },
        {
            "corpus_id": "19003564",
            "title": "Knowledge Technologies",
            "text": "In Section 4.2.2.2 we saw that trees and diagrams are useful ways of showing information. Graphical mark-up languages allow these to be shown using web formats. The two main languages are SVG and XAML.\n\nSVG means \"Scalable Vector Graphics\". It is a Web standard for two-dimensional graphics written in a specialised form of XML. A web browser renders an SVG file to display shapes and images. These can be animated and made interactive.\n\nXAML is also an XML-based file format for describing 2D graphics. Unlike SVG, XAML does not include a programming API for graphical applications, but it does support things like 3D and controls.\n\nSVG and XAML allow the nodes on trees and diagrams to be automatically hot-linked to annotation pages, and allow functions such as search, pan and zoom.",
            "score": 0.33864483124384903,
            "section_title": "Graphical Mark-up Languages",
            "char_start_offset": 76656,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1971435546875
        },
        {
            "corpus_id": "248510289",
            "title": "Programming Experience Requirements for Future Visual Development Environments",
            "text": "The visual programming system should rely on an explicit underlying theoretically-oriented language paradigm, sometimes carefully chosen combinations of paradigms such as: imperative, object-oriented, event-driven, flow-based, batch processing, functional programming, message passing, constrained systems, etc. \n\nClearly, it is crucial to document and explain the primary reason a specific paradigm is chosen for the target learner audience and domain (if one or some are explicit targeted), setting an anticipated learning curve and engineering criteria like: ease-of-use, intuitive deployment, rapid development, error prevention, engineering scalability, proximity to a real language that learners might have to use, etc. \n\nOnce the paradigm is selected, designers may optionally expose ideas and techniques regarding the way the primary programming elements of the paradigm may be mapped to visual counterparts, and the reason such a mapping is considered appropriate and consistent. In certain cases, when visual designs aim for specific purposes or tasks, even if the underlying language paradigm is of general purpose, it has to be explicitly stated and justified. \n\nExamples: The most common programming language paradigm is the imperative, with variables, assignments, statements and expressions, and the flow-based, blending functional characteristics with event-oriented elements. In particular, Scratch offers blocks reflecting a purely imperative paradigm, while Lego Mindstorms Ev3 (Vallance et al., 2009) provides elements with an imperative look, but a genuine functional style. Business Process Modelling and Notation (BPMN, Ko et al., 2009) is a domain-specific visual language that adopts the flow-based programming paradigm (FBP, Morrisson, 1994). The roots of FBP are in controlflow and stream processing, while it borrows elements from functional composition, batch processing and event-driven systems. \n\nIn general, we refer to such cases as visual syntactic illusions when the graphical language conveys an underlying paradigm but with a frontend that mimics alternative more familiar paradigms. \n\nTouch Develop by Microsoft (Ball et al., 2016) combined the imperative programming style with typical object-based elements (not including any class definition or inheritance features), while offering the syntactic illusion of message-passing regarding method invocations.",
            "score": 0.33748140519510234,
            "section_title": "Explicit Language Paradigm",
            "char_start_offset": 3495,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 311
                },
                {
                    "start": 314,
                    "end": 725
                },
                {
                    "start": 728,
                    "end": 988
                },
                {
                    "start": 989,
                    "end": 1172
                },
                {
                    "start": 1175,
                    "end": 1392
                },
                {
                    "start": 1393,
                    "end": 1595
                },
                {
                    "start": 1596,
                    "end": 1768
                },
                {
                    "start": 1769,
                    "end": 1925
                },
                {
                    "start": 1928,
                    "end": 2120
                },
                {
                    "start": 2123,
                    "end": 2395
                }
            ],
            "ref_mentions": [
                {
                    "start": 1497,
                    "end": 1520,
                    "matchedPaperCorpusId": "208013563"
                },
                {
                    "start": 1643,
                    "end": 1658,
                    "matchedPaperCorpusId": "9504064"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8916015625
        },
        {
            "corpus_id": "58394",
            "title": "Towards rule-based visual programming of generic visual systems",
            "text": "As this generic model uses graphs for modeling very different diagram notations, we can also use diagrams for visualizing graphs. This capability allows to tackle the problem that graphs are basically a visual data structure, but using graphs for programming directly might be too abstract. Instead, we can choose an arbitrary visual syntax for external representations even if the programming language represents visual data as graphs internally. The user interface of a program can so be customized for the visual representations which are best suited in its application domain. This makes it possible to use the programming language of this paper which is based on graph transformations as a generic visual programming language. By representing very different diagram notations by graphs and operating on these graphs, many different flavors of visual (programming) languages can be described and implemented. Obvious examples are Pictorial Janus [12] (whose agents with ports directly correspond to our notion of typed edges) or KidSim [24].",
            "score": 0.33748140519510234,
            "section_title": "Genericity",
            "char_start_offset": 20066,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 447
                },
                {
                    "start": 448,
                    "end": 580
                },
                {
                    "start": 581,
                    "end": 731
                },
                {
                    "start": 732,
                    "end": 912
                },
                {
                    "start": 913,
                    "end": 1045
                }
            ],
            "ref_mentions": [
                {
                    "start": 950,
                    "end": 954,
                    "matchedPaperCorpusId": "43464074"
                },
                {
                    "start": 1040,
                    "end": 1044,
                    "matchedPaperCorpusId": "8161155"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.91943359375
        },
        {
            "corpus_id": "225668137",
            "title": "2-Dimensional Simulation of Field Anomaly Gravity Based on Scratch Programming",
            "text": "The design of this program uses the SCRATCH programming language.Scratch is one of the programming languages developed by the Lifelong Kindergarten Group at MIT (Massachusetts Institute of Technology) Media Lab, United States.Scratch is a visual language that is making projects using intermediaries in the form of images [13].\n\nThe pattern of programming with images is a distinction between Scratch and other text-based programming languages such as PHP, C, and Pearl which seem more complicated [14].Next is the Scratch application interface ( Figure 6).Here is the main program flow diagram (Figure 7).",
            "score": 0.33712006136680445,
            "section_title": "III. RESEARCH METHODS",
            "char_start_offset": 3250,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 65
                },
                {
                    "start": 65,
                    "end": 226
                },
                {
                    "start": 226,
                    "end": 327
                },
                {
                    "start": 329,
                    "end": 503
                },
                {
                    "start": 503,
                    "end": 557
                },
                {
                    "start": 557,
                    "end": 606
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.41943359375
        },
        {
            "corpus_id": "246022597",
            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
            "text": "In order to create a computer program, an integrated development environment (IDE) is required. There are two basic components for every IDE, 1) text editor and 2) compiler or interpreter. Text editor is used for a text input to create a programming instruction. After the program is written, a compiler or interpreter (depending on which type of programming language) translates the human comprehensible language into a hardware native machine code. One of the drawbacks is when starting learning a program, programmers do not only learn syntax and sematic of the language but also have to learn how to perform an installation and configurations of the additional tools. Luckily, many modern IDEs have included all the required components in a single installation package. Yet, another issue is raised, with a different environment of each computer (e.g., OS, version, and previously install program). These can affect the operation of an IDE. In order to avoid this matter but still provide programming environment, a web-application online IDE seems to be a promising solution. A general idea of online-IDE is to provide a programming service via a web-browser without any installation of specified tool set. Moreover, variant of environment, compared to locally installed IDE, is relatively small (concerning on web-browser and its version). \n\nThe proposed visual programming for AI and Robotic Application system is designed for beginners in the world of programming. The key concept of the proposed system is the visual programming for representing a complex computation and logic flow while providing an insight of a program by translating the visual to text-based language. Users should be able to visualize a program flow via visual-based approach. Once they are competent in the flow of logic, a text-based approach is introduced to them. Thus, our system uses block-based for visualizing of program and providing a translation of that block-based to text-based code. In addition, the proposed system was designed to be web-application. The concern is on the complexity of tool setup and installation when writing a program. In that sense, the proposed system should be designed in ready-to-use manner without further installation. \n\nAs for block and text-based programming language, Python is selected because of its simplicity and suitability for novice programmers. For block-based programming, we use Google Blockly.",
            "score": 0.3362520180084486,
            "section_title": "Proposal of Visual Programming for AI and Robotic Application via Online IDE",
            "char_start_offset": 13497,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 95
                },
                {
                    "start": 96,
                    "end": 188
                },
                {
                    "start": 189,
                    "end": 262
                },
                {
                    "start": 263,
                    "end": 450
                },
                {
                    "start": 451,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 773
                },
                {
                    "start": 774,
                    "end": 902
                },
                {
                    "start": 903,
                    "end": 944
                },
                {
                    "start": 945,
                    "end": 1080
                },
                {
                    "start": 1081,
                    "end": 1211
                },
                {
                    "start": 1212,
                    "end": 1345
                },
                {
                    "start": 1348,
                    "end": 1472
                },
                {
                    "start": 1473,
                    "end": 1681
                },
                {
                    "start": 1682,
                    "end": 1757
                },
                {
                    "start": 1758,
                    "end": 1848
                },
                {
                    "start": 1849,
                    "end": 1977
                },
                {
                    "start": 1978,
                    "end": 2046
                },
                {
                    "start": 2047,
                    "end": 2134
                },
                {
                    "start": 2135,
                    "end": 2241
                },
                {
                    "start": 2244,
                    "end": 2378
                },
                {
                    "start": 2379,
                    "end": 2430
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.671875
        },
        {
            "corpus_id": "202120706",
            "title": "Visual Input Mechanisms in Textual Programming for Architecture",
            "text": "Algorithmic Design (AD) is a recent technological revolution in the field of architecture, being an alternative approach to the manual generation and manipulation of geometry within modeling and analysis tools. Therefore, instead of creating geometry directly in these tools, architects create a program that, when executed, generates the correspondent model in a chosen tool. This program is a set of rules and constraints defined using Programming Languages (PLs), that can either be visual (VPLs) or textual (TPLs). \n\nVPLs use icons and connections to feed information and instructions to the computer, structuring diagrams of blocks connected by wires (Schaefer 2011) (figure 1). According to Noone and Mooney (2018), a VPL is any PL that allows users to manipulate the un-derlying code graphically, thus specifying the execution of a program without textual scripting (Menzies 2002). In a VPL, programs consist of icons that can be manipulated interactively and according to some spatial grammar (Myers 1990), i.e. iconic elements of data -that can contain either values, functions, or geometry, for example, related between each other through output-input relations. Contrarily to VPLs, textual programming languages, as the name suggests, belong to the category of PLs that use written text to build programs (figure 2), using a one-dimensional stream of characters (Brown and Kimura 1994). These programs structure a script of written instructions and descriptions that the computer understands and processes unequivocally. Just like any other language in the world, TPLs also obey specific syntax and semantics. The relative advantages and disadvantages between VPLs and TPLs have already been discussed in several studies (Leit\u00e3o and Santos 2011, Davis et al. 2011, Leit\u00e3o et al. 2012, Janssen 2014, Zboinska 2015). However, in the current practice of architecture, there is a clear propensity to the use of VPLs over TPLs, due to the user-friendly features and interactive mechanisms they provide that are absent in most textual approaches. Nevertheless, TPLs offer clear benefits when dealing with complex programs, which is a strong argument for the implementation of similar features, such as Visual Input Mechanisms (VIMs), in order to bring them closer to architects.",
            "score": 0.3360610683996769,
            "section_title": "INTRODUCTION",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 210
                },
                {
                    "start": 211,
                    "end": 376
                },
                {
                    "start": 377,
                    "end": 518
                },
                {
                    "start": 521,
                    "end": 683
                },
                {
                    "start": 684,
                    "end": 888
                },
                {
                    "start": 889,
                    "end": 1172
                },
                {
                    "start": 1173,
                    "end": 1397
                },
                {
                    "start": 1398,
                    "end": 1531
                },
                {
                    "start": 1532,
                    "end": 1620
                },
                {
                    "start": 1621,
                    "end": 1825
                },
                {
                    "start": 1826,
                    "end": 2051
                },
                {
                    "start": 2052,
                    "end": 2283
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77294921875
        },
        {
            "corpus_id": "233391838",
            "title": "Development of a cyber design modeling declarative Language for cyber physical production systems",
            "text": "Based on the proposed above specification of the language matamodel, the authors propose the following syntax diagram, which is shown in Figure 1. Identifiers value and name belongs to not_domen (non-list) type. This is justified by the fact that the values value can be set by the developer depending on the requirements put forward by the developed CPPS. For identifier name , which is included in ariable LingusticV the name that refers to olution ContainerS containing the necessary fragment or part of the program code ( cod ), set by the user of the system being developed, taking into account his logical preferences and ease of use. \n\nFor ease of reading and presentation of the developed declarative language (Figures 1 and 2), it is necessary that it has the qualities of understanding and reading. This can be achieved using at least three principles of language representation [20], namely was: \n\n-maximally linear; -short; -self-documented. \n\nBased on the proposed assumptions and recommendations for the declarative language being developed, the CPPS developer proposes the following type of model language notation style, which makes it possible to simplify and standardize the code. /# ?** the block of description of visual graphic elements closing r Form_maste **? Use of \"/\" (slash) will allow the ML interpreter to determine the degree of a visual element nesting (belonging) to another, that is, to implement a CPPS structure tree in the development environment. Figure 3      Based on 10-12 meta descriptions and Figure 3, you can set any nesting depth for graphical user interface elements. This makes it possible to implement, using the proposed ML syntax diagram (Figure 1), a CPPS structure of complexity degree, and to simplify the process of developing a visual component based on an object-oriented approach to programming. \n\nBased on the proposed syntax diagram presented in Figure 1, the following event method description is proposed ( event ) for Form and m ElementFor . Based on example 1, we will  where cod is a a piece of program code in the selected object-oriented language.",
            "score": 0.33422211942399715,
            "section_title": "CPPS cyber-design modeling language syntax diagram development",
            "char_start_offset": 7501,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 211
                },
                {
                    "start": 212,
                    "end": 356
                },
                {
                    "start": 357,
                    "end": 640
                },
                {
                    "start": 643,
                    "end": 808
                },
                {
                    "start": 809,
                    "end": 906
                },
                {
                    "start": 909,
                    "end": 953
                },
                {
                    "start": 956,
                    "end": 1198
                },
                {
                    "start": 1199,
                    "end": 1483
                },
                {
                    "start": 1484,
                    "end": 1613
                },
                {
                    "start": 1614,
                    "end": 1852
                },
                {
                    "start": 1855,
                    "end": 2003
                },
                {
                    "start": 2004,
                    "end": 2113
                }
            ],
            "ref_mentions": [
                {
                    "start": 889,
                    "end": 893,
                    "matchedPaperCorpusId": "16392549"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.040374755859375
        },
        {
            "corpus_id": "149450790",
            "title": "Optimization of SVM Parameters with Hybrid CS-PSO Algorithms for Parkinson's Disease in LabVIEW Environment",
            "text": "e emerging technology needed the development of objectoriented programming languages instead of text-based programming languages. us, visual programming was possible without writing code. With National Instruments' development of the LabVIEW program, it was possible to program the model graphically with ready-made functions, and there was no need to write code. With LabVIEW (Laboratory Virtual Instrument Engineering Workbench), it was possible to make programs more quickly and to avoid time loss. LabVIEW generally uses a data ow model instead of text codes. Also, LabVIEW has an ability of multiple parallel processes [24]. \n\nLabVIEW consists of two components: the rst one is the front panel that is the user interface and the second one is the block diagram in which graphical codes are shown. Both of them are shown in Figures 6 and 7, respectively. Inputs connected to the virtual instrument on the front panel are called controls, while the outputs are called indicator. e control palette is used in the front panel, and the function palette is used in the block diagram. \n\ne control palette allows access to various controls and indicators and is displayed only on the front panel. In the same way, the function palette also allows access to blocks with various functions to design a system and is displayed only in the block diagram. With LabVIEW, subVI can be created just like a VI. Also, a subVI can be created from code already within another VI. e created subVI, with the customized icon and the con gured terminals, is used within other VIs repeatedly. e subVI prevents the program from appearing too crowded. As a matter of fact, subVI was used in this study.",
            "score": 0.3342163931269921,
            "section_title": "LabVIEW",
            "char_start_offset": 11690,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 187
                },
                {
                    "start": 188,
                    "end": 363
                },
                {
                    "start": 364,
                    "end": 501
                },
                {
                    "start": 502,
                    "end": 563
                },
                {
                    "start": 564,
                    "end": 629
                },
                {
                    "start": 632,
                    "end": 801
                },
                {
                    "start": 802,
                    "end": 858
                },
                {
                    "start": 859,
                    "end": 981
                },
                {
                    "start": 982,
                    "end": 1082
                },
                {
                    "start": 1085,
                    "end": 1193
                },
                {
                    "start": 1194,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1397
                },
                {
                    "start": 1398,
                    "end": 1463
                },
                {
                    "start": 1464,
                    "end": 1571
                },
                {
                    "start": 1572,
                    "end": 1628
                },
                {
                    "start": 1629,
                    "end": 1679
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.441162109375
        },
        {
            "corpus_id": "258564479",
            "title": "ShapeCoder: Discovering Abstractions for Visual Programs from Unstructured Primitives",
            "text": "ShapeCoder's recognition network (used in the wake phase) solves sub-problems that are stitched together through combinator operations. A downside of this design decision is that the recognition network must be retrained whenever the library version changes. Further, as the network does not predict an entire program in one-shot, inference can be expensive to run, and there is less consistency in how programs will be inferred across a dataset. Replacing this bottom-up network with a top-down network would be more challenging. Still, it would open up other possibilities, such as removing the need for the input data to be represented as collections of primitives. \n\nLooking forward, we believe that ShapeCoder should be helpful for many other visual programming domains, beyond the 2D and 3D shape grammars we consider in this report. ShapeCoder requires the following domain attributes: (a) the language is functional, (b) it contains a combinator operation (e.g. Union), and (c) visual inputs can be decomposed into primitive types. In fact, properties (b) and (c) are only needed for the wake phase, so this requirement could be relaxed by using program inference networks that consume 'raw' visual data. Sketches, CSG, SVG, and even shader programs could make good matches for future explorations. For the first time, ShapeCoder provides the ability to perform program abstraction discovery directly on unstructured collections of primitives, reducing the burden of collecting, annotating, and grouping shape categories. We italicize all non-terminal parts of the grammar, and explain what the terminal operators in the language do (non-italicized). Union combines two sub-shapes together. SymRef is a symmetry reflection across an axis. SymTrans is a symmetry translation over an axis, that creates a specified number of copies, up to a specified distance. Rotate specifies an Euler angle rotation about an axis. Move moves a cuboid by a specified amount. Cuboid instantiates a cuboid with the specified dimensions. Axes can be either the X, Y, or Z axis. Ints can be an integer between 1 and 6.",
            "score": 0.3341775486468581,
            "section_title": "Limitations and Future Work",
            "char_start_offset": 61535,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 135
                },
                {
                    "start": 136,
                    "end": 258
                },
                {
                    "start": 259,
                    "end": 446
                },
                {
                    "start": 447,
                    "end": 530
                },
                {
                    "start": 531,
                    "end": 668
                },
                {
                    "start": 671,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 969
                },
                {
                    "start": 970,
                    "end": 1039
                },
                {
                    "start": 1040,
                    "end": 1212
                },
                {
                    "start": 1213,
                    "end": 1306
                },
                {
                    "start": 1307,
                    "end": 1529
                },
                {
                    "start": 1530,
                    "end": 1658
                },
                {
                    "start": 1659,
                    "end": 1698
                },
                {
                    "start": 1699,
                    "end": 1746
                },
                {
                    "start": 1747,
                    "end": 1866
                },
                {
                    "start": 1867,
                    "end": 1922
                },
                {
                    "start": 1923,
                    "end": 1965
                },
                {
                    "start": 1966,
                    "end": 2025
                },
                {
                    "start": 2026,
                    "end": 2065
                },
                {
                    "start": 2066,
                    "end": 2105
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.61669921875
        },
        {
            "corpus_id": "268681493",
            "title": "Learning to Infer Generative Template Programs for Visual Concepts",
            "text": "Given a collection of related visual inputs, our goal is to find a symbolic structure capable of representing this group as a concept.This structure must be able to account for both (i) the shared attributes across the group and (ii) the allowable divergences that differentiate various group members.\n\nTowards this goal, we introduce Template Programs to represent visual concepts.A Template Program (T P ) is a partial program specification from a domain-specific language (DSL).We assume this DSL is a functional language, where each function takes other functions or parameter arguments as input.Template Programs admit fully instantiated programs (z).These programs can be run through a domainspecific executor (E) to produce visual outputs.\n\nTemplate Programs are composed of a hierarchy of function calls (i.e an expression tree) and are optionally allowed to define relationships between parameter arguments (e.g.variable reuse).All instantiations from a Template Program must invoke the specified functions and use the described relations.To allow instantiations to vary structurally (i.e.use different functions), we introduce a special HOLE construct.Each HOLE in the Template Program can be filled in with an arbitrary expression tree.This process creates a Structural Expansion (SE), which completely specifies the function call sequence of an instantiation.Any function parameters that lack a specified relation in the SE are allowed to differ freely in the output programs.",
            "score": 0.333359941864408,
            "section_title": "Template Programs",
            "char_start_offset": 9863,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 134
                },
                {
                    "start": 134,
                    "end": 301
                },
                {
                    "start": 303,
                    "end": 382
                },
                {
                    "start": 382,
                    "end": 481
                },
                {
                    "start": 481,
                    "end": 600
                },
                {
                    "start": 600,
                    "end": 656
                },
                {
                    "start": 656,
                    "end": 746
                },
                {
                    "start": 748,
                    "end": 921
                },
                {
                    "start": 921,
                    "end": 937
                },
                {
                    "start": 937,
                    "end": 1048
                },
                {
                    "start": 1048,
                    "end": 1098
                },
                {
                    "start": 1098,
                    "end": 1162
                },
                {
                    "start": 1162,
                    "end": 1247
                },
                {
                    "start": 1247,
                    "end": 1371
                },
                {
                    "start": 1371,
                    "end": 1488
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3271484375
        },
        {
            "corpus_id": "256446785",
            "title": "Model-Driven Engineering Techniques and Tools for Machine Learning-Enabled IoT Applications: A Scoping Review",
            "text": "A modeling language has multiple facets, such as its abstract syntax (i.e., its concepts, relationships, and constraints) and concrete syntax (i.e., its textual or graphical concrete representation). These facets are implemented and supported by specific tools commonly known as language workbenches or language frameworks [13,14,39]. Popular language workbenches that provide graphical editors are DiaGen, Eugenia, GMF, Graphiti, MetaEdit+, Obeo Designer, and Sirius [40], while those that support textual languages are Xtext and MetaEdit. Six ( 6) studies (P1, P4, P21, P32, P46, P56) refer to the use of textual languages implemented with the Xtext framework, while, regarding visual modeling languages (i.e., with graphical concrete syntax), 7 studies reported the use of Sirius (P3, P10, P14, P12, P22, P24, P35), 4 studies the use of Eugenia (P5, P7, P13, P50), 6 studies the use of GMF (P2, P7, P13, P65, P67, P50), and other studies report the use of language workbenches like Obeo Designer (P12) and MetaEdit+ (P39). \n\nTable 3 presents the studies that refer to the implementation or use of textual and graphical modeling languages.",
            "score": 0.3325025923565659,
            "section_title": "What tools are used? (RQ1.2)",
            "char_start_offset": 29698,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 199
                },
                {
                    "start": 200,
                    "end": 334
                },
                {
                    "start": 335,
                    "end": 540
                },
                {
                    "start": 541,
                    "end": 1025
                },
                {
                    "start": 1028,
                    "end": 1141
                }
            ],
            "ref_mentions": [
                {
                    "start": 323,
                    "end": 327,
                    "matchedPaperCorpusId": "221521541"
                },
                {
                    "start": 327,
                    "end": 330,
                    "matchedPaperCorpusId": "21632806"
                },
                {
                    "start": 330,
                    "end": 333,
                    "matchedPaperCorpusId": "22373947"
                },
                {
                    "start": 468,
                    "end": 472,
                    "matchedPaperCorpusId": "28597264"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.450439453125
        },
        {
            "corpus_id": "5015407",
            "title": "Teaching GUI-Programming Concepts to Prospective K12 ICT Teachers: MIT App Inventor as an Alternative to Text-Based Languages",
            "text": "As stated by many researchers so far, there is yet another factor that contributes into entry-level programming courses: the fact that the classroom consists of students that possess prior knowledge and experience in ICT and programming subjects at largely varying degrees (Davis, Carr, Cooke, & White, 2001;Jenkins & Davy, 2002;R\u00f6\u00dfling & Freisleben, 2000) and that this kind of situation is becoming more and more common with each passing year (Hagan & Markham, 2000). The problem posed by the large gap observed between the experienced and novice students has two dimensions. Due to observing how their peers are struggling, experienced students are prone to perceive the subject as easier than it is, which leads them into a state of neglect towards the course. Novice students, on the other hand, compare themselves with experienced students and tend to lose their motivation due to the feeling of inferiority. Several researchers have come up with ideas to overcome this problem (Sanders & Mueller, 2000;Shackelford & LeBlanc Jr, 1997) and mentioned a need for supportive courses for novice students in settings of IT education. All and all, it can be said that existing knowledge or lack thereof of students may impact their performance in programming courses. Therefore, research conducted for the purpose of examining success in IT courses should perhaps be designed to take into account the knowledge and experience levels of pupils. \n\nSeveral factors that have an impact on student success in programming education have been highlighted in the current literature. Another important one among these is the choice of programming language taught at the courses. In this context, the question as to which programming languages and which paradigms should be used to introduce students to programming, has been a popular one in the field of computer science education. \n\nBlocks-based visual programming languages and their associated development environments follow -as the name suggests-the -visual\u2016 and -component-based\u2016 programming concepts. These enable the developer to create programming expressions by combining through -drag and drop\u2016 or other GUI actions blocks that visually represent programming constructs, as opposed to using text to form expressions in the conventional -text-based\u2016 approach.",
            "score": 0.3324864673051621,
            "section_title": "Introduction",
            "char_start_offset": 1767,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 469
                },
                {
                    "start": 470,
                    "end": 577
                },
                {
                    "start": 578,
                    "end": 764
                },
                {
                    "start": 765,
                    "end": 914
                },
                {
                    "start": 915,
                    "end": 1133
                },
                {
                    "start": 1134,
                    "end": 1266
                },
                {
                    "start": 1267,
                    "end": 1442
                },
                {
                    "start": 1445,
                    "end": 1573
                },
                {
                    "start": 1574,
                    "end": 1668
                },
                {
                    "start": 1669,
                    "end": 1872
                },
                {
                    "start": 1875,
                    "end": 2048
                },
                {
                    "start": 2049,
                    "end": 2310
                }
            ],
            "ref_mentions": [
                {
                    "start": 308,
                    "end": 329,
                    "matchedPaperCorpusId": "61960950"
                },
                {
                    "start": 329,
                    "end": 356,
                    "matchedPaperCorpusId": "16537610"
                },
                {
                    "start": 984,
                    "end": 1009,
                    "matchedPaperCorpusId": "35414648"
                },
                {
                    "start": 1009,
                    "end": 1040,
                    "matchedPaperCorpusId": "62144909"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5927734375
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Figure 7 shows the target domain of the selected articles. All the surveyed tools are domain specific, and not meant to be used for multiple purposes. 23.3% (7) of the tools presented in the selected articles fit in the category of IoT. Some of these tools allow end users to utilize the resources of their personal phones such as [32] and [51]. Others enable the usage of sensors deployed in cities such as [43] or sensors used in variety of contexts such as smart homes or available for medical staff to monitor patients' health [60]. While tools built for IoT applications use different VPL approaches (form-based, diagram-based, and block-based), a common theme among the tools is allowing end users to access services such as sensors and phone resources by means of visual abstractions. For instance, the tool presented in [46] shows various types of sensors (such as motion and presence sensors) as visual blocks. End users can define logic that is related to the the states of such sensors. As a simple example, end users may specify a welcoming message upon switching on a certain light. \n\n23.3% (7) of the tools are intended to be used in an educational setting. Some of these tools such as [38] and [39] are utilized for teaching basic programming principles such as loops and conditionals, whereas the tool in [44] aims at teaching data science concepts to non-programmers, and the tool in [45] is intended for teaching computing and engineering concepts and for programming robots. \n\nApart from one tool [45], all the tools built for educational applications used a block-based approach. The block-based educational tools use similar visual blocks to represent programming constructs such as variable setting, control flow, and conditionals. The tools aimed at teaching a specific topic in computer science such as parallel programming represent related concepts (e.g. parallel blocks, message passing, events) visually. For instance, the concept of events is represented by a ''When'' visual block in [37] and [49]. \n\nThe tool explained in [45] uses a diagram-based approach to programming education. For instance, a while loop is represented by a sequence of connected boxes. Each box represents a command, e.g. setting a variable.",
            "score": 0.33216997179715685,
            "section_title": "D. RQ1-D4: DOMAIN",
            "char_start_offset": 37365,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 58
                },
                {
                    "start": 59,
                    "end": 150
                },
                {
                    "start": 151,
                    "end": 236
                },
                {
                    "start": 237,
                    "end": 345
                },
                {
                    "start": 346,
                    "end": 536
                },
                {
                    "start": 537,
                    "end": 791
                },
                {
                    "start": 792,
                    "end": 919
                },
                {
                    "start": 920,
                    "end": 997
                },
                {
                    "start": 998,
                    "end": 1095
                },
                {
                    "start": 1098,
                    "end": 1171
                },
                {
                    "start": 1172,
                    "end": 1493
                },
                {
                    "start": 1496,
                    "end": 1599
                },
                {
                    "start": 1600,
                    "end": 1753
                },
                {
                    "start": 1754,
                    "end": 1880
                },
                {
                    "start": 1881,
                    "end": 1932
                },
                {
                    "start": 1933,
                    "end": 2028
                },
                {
                    "start": 2031,
                    "end": 2113
                },
                {
                    "start": 2114,
                    "end": 2189
                },
                {
                    "start": 2190,
                    "end": 2225
                },
                {
                    "start": 2226,
                    "end": 2245
                }
            ],
            "ref_mentions": [
                {
                    "start": 157,
                    "end": 160,
                    "matchedPaperCorpusId": "195856963"
                },
                {
                    "start": 331,
                    "end": 335,
                    "matchedPaperCorpusId": "66914713"
                },
                {
                    "start": 340,
                    "end": 344,
                    "matchedPaperCorpusId": "26243684"
                },
                {
                    "start": 408,
                    "end": 412,
                    "matchedPaperCorpusId": "195785412"
                },
                {
                    "start": 531,
                    "end": 535,
                    "matchedPaperCorpusId": "7388219"
                },
                {
                    "start": 828,
                    "end": 832,
                    "matchedPaperCorpusId": "222210810"
                },
                {
                    "start": 1104,
                    "end": 1107,
                    "matchedPaperCorpusId": "195856963"
                },
                {
                    "start": 1200,
                    "end": 1204,
                    "matchedPaperCorpusId": "211104795"
                },
                {
                    "start": 1209,
                    "end": 1213,
                    "matchedPaperCorpusId": "211206448"
                },
                {
                    "start": 1321,
                    "end": 1325,
                    "matchedPaperCorpusId": "53080670"
                },
                {
                    "start": 1401,
                    "end": 1405,
                    "matchedPaperCorpusId": "67453782"
                },
                {
                    "start": 1516,
                    "end": 1520,
                    "matchedPaperCorpusId": "67453782"
                },
                {
                    "start": 2014,
                    "end": 2018,
                    "matchedPaperCorpusId": "16591367"
                },
                {
                    "start": 2023,
                    "end": 2027,
                    "matchedPaperCorpusId": "44165140"
                },
                {
                    "start": 2053,
                    "end": 2057,
                    "matchedPaperCorpusId": "67453782"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.88916015625
        },
        {
            "corpus_id": "12337509",
            "title": "Exploiting XPG for Visual Languages: Definition, Analysis and Development",
            "text": "defined language several tasks can be easily performed such as customization and modifications as well as the maintenance and the debug. Moreover, syntax-directed translations can be carried out based on the syntactic structure, which is the output of the syntactic analysis process, in order to verify properties of visual sentences. Analogously, code and report generation can be effectively realized by suitably exploiting the syntax structure. All of these benefits turn out to be especially interesting in the setting of visual modeling languages because they are subject to continuous changes as the history of UML diagrams shows.\n\nStarting from a syntax and semantic specification of the language, a visual environment specific for a language can be automatically generated exploiting the Visual Language Compiler-Compiler (VLCC) system, a graphical system which is able to assist a designer in the definition of a visual language and automatically generate a corresponding visual environment [6]. In recent years, special focus has been put on the implementation of systems that generate visual environments starting from formal specifications of visual languages [2,5,6,8,9,22].\n\nThe formalism of Extended Positional Grammars provides the syntactic framework for the VLCC. The most appealing feature of VLCC is that it inherits and extends to the visual field concepts and techniques of traditional compiler generation tools like YACC [13]. This is due to the characteristics of the extended positional grammar model which represents a natural extension of the context-free grammars. Indeed, a goal of the formalism is to overcome the inefficiency of visual languages parsing algorithms by researching suitable extensions of the well-known LR technique. As a result, some versions of the formalism have been defined as new more powerful parsing algorithms have been devised. In particular, the Extended Positional Grammars formalism is based on an extension of LR parsing, named XpLR methodology [7]. The XpLR methodology consists of algorithms to encode a positional grammar into an XpLR parsing table. Then this parsing table deterministically drives a shift-reduce syntax analysis of diagrammatic sentences. As a main difference with traditional LR parsing the input access is no longer sequential but driven by the relations contained in the positional grammars. In particular, the parser retrieves the next symbol to be analyzed",
            "score": 0.33199887748436896,
            "section_title": "Introduction",
            "char_start_offset": 2256,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 1000,
                    "end": 1003,
                    "matchedPaperCorpusId": "812535"
                },
                {
                    "start": 1172,
                    "end": 1175,
                    "matchedPaperCorpusId": "5985096"
                },
                {
                    "start": 1175,
                    "end": 1177,
                    "matchedPaperCorpusId": "3023909"
                },
                {
                    "start": 1177,
                    "end": 1179,
                    "matchedPaperCorpusId": "812535"
                },
                {
                    "start": 1179,
                    "end": 1181,
                    "matchedPaperCorpusId": "36814067"
                },
                {
                    "start": 1181,
                    "end": 1183,
                    "matchedPaperCorpusId": "41440675"
                },
                {
                    "start": 1183,
                    "end": 1186,
                    "matchedPaperCorpusId": "11930938"
                },
                {
                    "start": 2005,
                    "end": 2008,
                    "matchedPaperCorpusId": "12709012"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7392578125
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "Node-RED is a IoT-focused development toolkit that presents a flow-based development for wiring together hardware devices, APIs, and online services. It was originally developed by IBM, and its runtime is built on Node.js12 . The language can be extended by building new blocks using JavaScript snippets. The flows created can be exported in JSON format. A sample flow diagram is given in Figure 10. NETLab Toolkit (NTK) is a visual programming environment that empowers designers, developers, makers, researchers, and students who want to design and build tangible IoT projects. Its visual language allows the connection of sensors, actuators, media and networks with drag-and-drop smart widgets. NTK works with Arduino and Linux-based embedded systems (e.g. Intel Edison, Raspberry Pi). The language can be easily adapted for new things, by allowing the user to develop their own widgets using Javascript snippets. ArduBlock is a programming environment designed to allow drag-and-drop programming of physical computing devices that use Arduino. The visual language allows the use of visual code-block and connections between them as a way of programming. An example of a code-snippet is given in Figure 11. S4A 16   S4A is a modified version of the original Scratch programming language (focused on educational purposes) that targets Arduino-based hardware. It provides visual blocks as a way to manage sensors and actuators connected to Arduino-based boards. It keeps the Scratch original focus on educational purposes only. Modkit17 \n\nModkit for VEX is a graphical programming environment developed specifically for VEX IQ 18 . It is based on the Scratch programming language, basing itself on snap-together visual blocks, and maintain the focus on educational purposes. miniBloq19 miniBloq is a visual programming environment targeting Multiplo boards, Arduino boards, physical computing devices, and robots. miniBloq presents itself as an all-in-one language for interaction with hardware. It is highly modular, allowing the developer to create new and personalized blocks. Plus it allows the developer to easily add support to new boards and platforms by the extension of the given language. NooDL20",
            "score": 0.33121058349865057,
            "section_title": "Node-RED 11",
            "char_start_offset": 59942,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 149
                },
                {
                    "start": 150,
                    "end": 225
                },
                {
                    "start": 226,
                    "end": 304
                },
                {
                    "start": 305,
                    "end": 354
                },
                {
                    "start": 355,
                    "end": 399
                },
                {
                    "start": 400,
                    "end": 579
                },
                {
                    "start": 580,
                    "end": 697
                },
                {
                    "start": 698,
                    "end": 759
                },
                {
                    "start": 760,
                    "end": 788
                },
                {
                    "start": 789,
                    "end": 916
                },
                {
                    "start": 917,
                    "end": 1047
                },
                {
                    "start": 1048,
                    "end": 1157
                },
                {
                    "start": 1158,
                    "end": 1209
                },
                {
                    "start": 1210,
                    "end": 1360
                },
                {
                    "start": 1361,
                    "end": 1462
                },
                {
                    "start": 1463,
                    "end": 1528
                },
                {
                    "start": 1529,
                    "end": 1537
                },
                {
                    "start": 1540,
                    "end": 1632
                },
                {
                    "start": 1633,
                    "end": 1775
                },
                {
                    "start": 1776,
                    "end": 1914
                },
                {
                    "start": 1915,
                    "end": 1996
                },
                {
                    "start": 1997,
                    "end": 2080
                },
                {
                    "start": 2081,
                    "end": 2199
                },
                {
                    "start": 2200,
                    "end": 2207
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77783203125
        },
        {
            "corpus_id": "215807495",
            "title": "A Language for Specifying Informational Graphics from First Principles",
            "text": "We then describe the primary constructs in the language and the output generation process for our implementation, which was used to generate the graphics shown in this paper. Some aspects of the language have not yet been implemented (in particular, constraints other than equality), but are described so as to provide a fuller picture of the potential scope of visualizations that can be generated in this way.",
            "score": 0.33092007672030155,
            "section_title": "INTRODUCTION",
            "char_start_offset": 2265,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 174
                },
                {
                    "start": 175,
                    "end": 411
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.333984375
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "These Hybrid approaches, however, are very bound to specific well-known text programming languages and do not provide more language independent approaches. The usage of more language independent text in the blocks is an essential part of the education, because students that already have some experience in well-known text programming language will not be able to use their previous experience to outcompete other students with no previous experience in assignment in which this could be important. Moreover, usage of more universal Hybrid Visual-Textual notation would make development of cross-translation to multiple text languages easier. \n\nA significant adaptation addressing some downsides reviewed could be made using a \"semigraphical\" approach, in which students still have to describe a language independent \"pseudocode\" in some of the visual components of the VPL, which makes it a Hybrid VPL (HVPL). The last would allow a smoother transition from a visual environment to a subsequent classic text environment. On the other hand, cross-compiling code from VPL to more than one text programming language allows students to perform comparative analysis on the linguistic constructions of different well-known text programming languages. Using the hybrid visual-text approach teaches students algorithmic thinking while describing an algorithm as code. \n\nThis paper presents an author's environment for performing a VPL with a hybrid visual-text approach (HVTA). Based on a visual block chart editor, a cross-translator is created from the code generated by the visual editor to a language for immediate execution or compilation, (linking) and execution. The developed environment is suitable for teaching first year students in a higher education institution in Introduction to Programming Languages and can be used as an integrated environment for programming training through VPL.",
            "score": 0.33092007672030155,
            "section_title": "Introduction",
            "char_start_offset": 1943,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 155
                },
                {
                    "start": 156,
                    "end": 498
                },
                {
                    "start": 499,
                    "end": 642
                },
                {
                    "start": 645,
                    "end": 910
                },
                {
                    "start": 911,
                    "end": 1021
                },
                {
                    "start": 1022,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1360
                },
                {
                    "start": 1363,
                    "end": 1470
                },
                {
                    "start": 1471,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1891
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7470703125
        },
        {
            "corpus_id": "86787308",
            "title": "Development of application software without programming",
            "text": "In computer science, the visual programming language (hereinafter referred to as \"VPL\") allows users to create programs by manipulating more graphic elements of the program than text files. VPL allows programming with visual expressions, spatial layout of text and graphic symbols that are used either as elements of syntax or secondary writing. Visual programming languages also make it possible to create a more natural programming environment that will be familiar and familiar to the user. In order to be used by non-programmers, visual programming languages must use intuitive metadata and specific to the area they are intended to, reduce the cognitive load of end-users in their learning and adoption, to enable the writing of a readable and understandable code, and They are simple and fun. \n\nAs scientists point out, in this type of programming more than one dimension is used to represent the semantics [11]. Examples of such additional dimensions are reflected in the use of multidimensional objects, the use of spatial relationships, and the time dimension by typing, so-called. \"before-after\" semantic relations. Any such potentially significant object or relationship is a sign, and the collection of one or more of them is an image expression. Examples of visual expressions used in visual programming include diagrams, idle sketches, icons, or demonstrations of actions using graphic objects. If in some programming language the syntax includes visual expressions, then this programming language is visual. Multidimensionality is the important difference between VPLs and strictly textual languages.",
            "score": 0.33092007672030155,
            "section_title": "Visual programming",
            "char_start_offset": 13785,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 345
                },
                {
                    "start": 346,
                    "end": 493
                },
                {
                    "start": 494,
                    "end": 798
                },
                {
                    "start": 801,
                    "end": 918
                },
                {
                    "start": 919,
                    "end": 1090
                },
                {
                    "start": 1091,
                    "end": 1125
                },
                {
                    "start": 1126,
                    "end": 1258
                },
                {
                    "start": 1259,
                    "end": 1408
                },
                {
                    "start": 1409,
                    "end": 1522
                },
                {
                    "start": 1523,
                    "end": 1615
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.89453125
        },
        {
            "corpus_id": "234326946",
            "title": "A Concept of Visual Programming Tool for Learning VHDL",
            "text": "A crucial role in the implementation of the visual programming approach plays the library of the visual components used by the students to build a VHDL model. The library content is formalized as two taxonomies, respectively for visual objects and for visual blocks (Figure 3 and Figure 4). As seen on figures 3 and 4, the visual objects substitute declarations, operators, statements, keywords, as the visual blocks substitute complete logic circuits. A VHDL model could be constructed only by visual objects, but for the students it will be easier and more convenient to use visual blocks for their first attempts with the training environment.",
            "score": 0.33092007672030155,
            "section_title": "Taxonomy of the visual components library",
            "char_start_offset": 7772,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 158
                },
                {
                    "start": 159,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 452
                },
                {
                    "start": 453,
                    "end": 646
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.802734375
        },
        {
            "corpus_id": "251936144",
            "title": "VMetaFlow: A Meta-Framework for Integrating Visualizations in Coordinated View Applications",
            "text": "Traditionally, a program is generated from a structured 244 sequence of words with a syntactical meaning. Alternatively, 245 visual programs use graphics and two-dimensional layouts as 246 part of the program specification [24]. This approach is easier 247 to understand and work with, as it resembles the human men-248 tal representation of problems. Unlike the one-dimensional 249 textual way, visual programming uses higher-level descrip-250 tions of the program functionality. Users without program-251 ming skills find this approach more accessible [25].",
            "score": 0.33092007672030155,
            "section_title": "C. VISUAL PROGRAMMING 243",
            "char_start_offset": 7940,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 105
                },
                {
                    "start": 106,
                    "end": 228
                },
                {
                    "start": 229,
                    "end": 351
                },
                {
                    "start": 352,
                    "end": 480
                },
                {
                    "start": 481,
                    "end": 559
                }
            ],
            "ref_mentions": [
                {
                    "start": 223,
                    "end": 227,
                    "matchedPaperCorpusId": "1351280"
                },
                {
                    "start": 554,
                    "end": 558,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6904296875
        },
        {
            "corpus_id": "259316337",
            "title": "Bluefish: Composing Diagrams with Declarative Relations",
            "text": "To better balance between expressiveness and abstraction, we introduce Bluefish, a diagramming framework inspired by modern component-based user interface (UI) toolkits such as React. The basic building block of UI toolkits, the component, offers authors several advantages: UIs can be specified declaratively, in terms of what the interface should look like rather than how it should be laid out and rendered; components can be composed together (e.g., by nesting them) to express custom UIs; and authors can extend the specification language with custom components (e.g., to capture a recurring design pattern and make it reusable). However, the component model imposes limitations when applied to authoring diagrams (Section 3). Components are assembled in tree-based hierarchies. But unlike UI elements, diagrammatic relationships frequently overlap -a single element (e.g., a shape) may participate in many visual relationships simultaneously (Figure 1). These relationships cannot be easily expressed in a structure where an element can only have a single parent. As a result, in UI frameworks, diagram authors are forced to adopt low-level workarounds (e.g., manual bounding box calculations) that undo many of the advantages that components offer. \n\nIn response, Bluefish relaxes the definition of a component to a relation (Section 4.2). A relation, unlike a component, does not have sole ownership over its children nor does it need to fully specify their layout. Rather, a child element can be shared between multiple relations through scoped declarative references, and its layout determined jointly by all parents. With these changes, authors can smoothly trade locality for expressiveness (Section 4.3) -opting for a slightly more diffuse specification as it enables a more nimble prototyping process through the design space -without sacrificing the benefits of declarativity, composability, or extensibility. \n\nAuthors construct Bluefish diagrams via the JSX syntax extension, which the language runtime compiles into a compound scenegraph (Section 5) -an extension of a traditional tree-based scenegraph that captures both hierarchical and adjacency relationships between nodes.",
            "score": 0.33084580726566465,
            "section_title": "INTRODUCTION",
            "char_start_offset": 1746,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 183
                },
                {
                    "start": 184,
                    "end": 634
                },
                {
                    "start": 635,
                    "end": 731
                },
                {
                    "start": 732,
                    "end": 783
                },
                {
                    "start": 784,
                    "end": 959
                },
                {
                    "start": 960,
                    "end": 1069
                },
                {
                    "start": 1070,
                    "end": 1255
                },
                {
                    "start": 1258,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1473
                },
                {
                    "start": 1474,
                    "end": 1627
                },
                {
                    "start": 1628,
                    "end": 1924
                },
                {
                    "start": 1927,
                    "end": 2195
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.40185546875
        },
        {
            "corpus_id": "268348107",
            "title": "Analyzing-Evaluating-Creating: Assessing Computational Thinking and Problem Solving in Visual Programming Domains",
            "text": "The development of ACE is centered around the higher cognitive levels of Bloom's taxonomy: Analyzing, Evaluating, and Creating.The test contains items grounded in the domain of block-based visual programming.Specifically, we consider the popular block-based visual programming domain of Hour of Code: Maze Challenge [16] by code.org[25].\n\nWe picked this domain as it encapsulates important CT and problem-solving concepts of conditionals, loops, and sequences, within the simplicity of the block-based structure.\n\nStudents can attempt tasks in this domain with a simple description of the constructs and task, as discussed in the caption of Figure 1.Next, we describe the items in ACE which are divided into the following three categories based on Bloom's higher cognitive levels:\n\n\u2022 Applying-Analyzing: This category comprises items either on finding a solution code of a given task or reasoning about the trace of a given solution code on one or more visual grids.They are based on the Applying and Analyzing levels of Bloom's taxonomy, as they require applying CT concepts and analyzing code traces.These items are typically the most common type of items included in several CT tests [7,20].\n\n\u2022 Analyzing-Evaluating: This category comprises items that require reasoning about errors in candidate solution codes of a task and evaluating the equivalence of different codes for a given task.They are based on the Analyzing and Evaluating levels of Bloom's taxonomy.Several CT assessments also include these types of debugging items [9,13].\n\n\u2022 Evaluating-Creating: This category comprises items that require reasoning about the design of task grids for given solution codes.They are based on the Evaluating and Creating levels of Bloom's taxonomy, as they involve synthesizing components of visual grids such as Avatar, Goal, and Wall.These items are unique to ACE and capture the open-ended nature of task design, such as counting several possible task configurations to satisfy a given solution code (see items Q18 and Q21 in Figure 1).",
            "score": 0.33061409729781543,
            "section_title": "OUR TEST: ACE",
            "char_start_offset": 8620,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 127
                },
                {
                    "start": 127,
                    "end": 208
                },
                {
                    "start": 208,
                    "end": 332
                },
                {
                    "start": 332,
                    "end": 337
                },
                {
                    "start": 339,
                    "end": 512
                },
                {
                    "start": 514,
                    "end": 650
                },
                {
                    "start": 650,
                    "end": 780
                },
                {
                    "start": 782,
                    "end": 966
                },
                {
                    "start": 966,
                    "end": 1102
                },
                {
                    "start": 1102,
                    "end": 1194
                },
                {
                    "start": 1196,
                    "end": 1391
                },
                {
                    "start": 1391,
                    "end": 1465
                },
                {
                    "start": 1465,
                    "end": 1539
                },
                {
                    "start": 1541,
                    "end": 1673
                },
                {
                    "start": 1673,
                    "end": 1834
                },
                {
                    "start": 1834,
                    "end": 2037
                }
            ],
            "ref_mentions": [
                {
                    "start": 1190,
                    "end": 1193,
                    "matchedPaperCorpusId": "232126210"
                },
                {
                    "start": 1532,
                    "end": 1535,
                    "matchedPaperCorpusId": "60471875"
                },
                {
                    "start": 1535,
                    "end": 1538,
                    "matchedPaperCorpusId": "240439944"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5537109375
        },
        {
            "corpus_id": "255340860",
            "title": "Coinductive Streams in Monoidal Categories",
            "text": "Dataflow languages. Dataflow (or stream-based ) programming languages, such as Lucid [WA`85, HLR92], follow a paradigm in which every declaration represents an infinite list of values: a stream [BCLH93,UV05]. The following program in a Lucid-like language (Figure 1) computes the Fibonacci sequence, thanks to a Fby (\"followed by\") operator.\n\nfib \" 0 Fby pfib`p1 Fby Waitpfibqqq Figure 1. The Fibonacci sequence is 0 followed by the Fibonacci sequence plus the Fibonacci sequence preceded by a 1.\n\nThe control structure of dataflow programs is inspired by signal flow graphs [BCLH93,Sha42,Mas53]. Signal flow graphs are diagrammatic specifications of processes with feedback loops, widely used in control system engineering. In a dataflow program, feedback loops represent how the current value of a stream may depend on its previous values. For instance, the previous program ( Figure 1) corresponds to the signal flow graph in Figure 2. Monoidal categories. Any theory of processes that compose sequentially and in parallel, satisfying reasonable axioms, forms a monoidal category. Examples include functions [Lam86], probabilistic channels [CJ19,Fri20], partial maps [RR88,CL02], database queries [BSS18], linear resource theories [CFS16] and quantum processes [AC09]. Signal flow graphs are the graphical syntax for feedback monoidal categories [KSW02, BSZ14, BSZ15, DLGR`21, GKS22]: they are the string diagrams for any of these theories, extended with feedback. For instance, the previous program ( Figure 1) corresponds to the formal morphism in Figure 2. Yet, semantics of dataflow languages have been mostly restricted to theories of pure functions [BCLH93, UV08, Cou19, Del19,Oli84]: what are called cartesian monoidal categories. We claim that this restriction is actually inessential; dataflow programs may take semantics in non-cartesian monoidal categories, exactly as their signal flow graphs do.",
            "score": 0.3305655128954718,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 93,
                    "end": 99,
                    "matchedPaperCorpusId": "15482863"
                },
                {
                    "start": 194,
                    "end": 202,
                    "matchedPaperCorpusId": "852217"
                },
                {
                    "start": 202,
                    "end": 207,
                    "matchedPaperCorpusId": "566028"
                },
                {
                    "start": 575,
                    "end": 583,
                    "matchedPaperCorpusId": "852217"
                },
                {
                    "start": 589,
                    "end": 595,
                    "matchedPaperCorpusId": "17565263"
                },
                {
                    "start": 1143,
                    "end": 1149,
                    "matchedPaperCorpusId": "49185879"
                },
                {
                    "start": 1149,
                    "end": 1155,
                    "matchedPaperCorpusId": "201103837"
                },
                {
                    "start": 1170,
                    "end": 1176,
                    "matchedPaperCorpusId": "36660126"
                },
                {
                    "start": 1176,
                    "end": 1181,
                    "matchedPaperCorpusId": "2956992"
                },
                {
                    "start": 1200,
                    "end": 1207,
                    "matchedPaperCorpusId": "5034287"
                },
                {
                    "start": 1234,
                    "end": 1241,
                    "matchedPaperCorpusId": "18298095"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.02886962890625
        },
        {
            "corpus_id": "56482403",
            "title": "Truly Visual Polymorphic Algebraic Data Structures through Maramafication",
            "text": "Hence, these languages require the user to still largely move within the original not-so-accessible textual programming paradigm. The hardest parts to truly capture with internal semantics are, possibly unconsciously, left in a textual form. In this article, however, we cover such a hard and nontrivial part. \n\nThis paper focusses on a fragment of the 'maramafication-challenge': it presents a new way to (truly) visually represent fully polymorphic algebraic data structures (ADSs) as they occur in modern functional programming languages, and does so in line with the aforementioned paradigm. The design is modular: it can be adopted straightforwardly into any visual functional programming language. \n\nADSs are designed in such a way that type consistency is entirely forced by the form of the M-constructs (maramafied constructs). In other words, a user of these constructs cannot create ill-typed values, simply because the 'pieces will not fit'. In this sense, the approach in this paper is genuinely visual: the semantics of the visual blocks is embodied by their visual structure and spatial manipulation options, and does not require a definition by textual or spoken means. Hence, a beginner using the M-constructs can find out how to program with them, without any prior textual or spoken explanation about how these constructs work. \n\nAnother way to phrase it, is that the semantics of the visualisation of polymorphy and datastructures proposed in this paper solely relies on shared human intuition for manipulation of 3D objects. \n\nIn this article, the term spatial necessity is coined for the aforementioned property of the visual designs, the property that given the laws of mechanics (as far as they are intuitively understood by the majority of humans) it is only possible to construct something that is correct. An example of such a widely shared intuition on which the spatial necessity design paradigm can rely, is that most people from an already very young age will predict that a ball that is held in the air, and then let lose, will move downward. \n\nThe design covers ADSs based on algebraic data type definitions with at most one type-parameter (but is easily extensible with any number of typeparameters), can cope with polymorphic constructors, and can classify a given ADS polymorphically (through 'typing statements').",
            "score": 0.33054797643004363,
            "section_title": "Introduction",
            "char_start_offset": 2251,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 129
                },
                {
                    "start": 130,
                    "end": 241
                },
                {
                    "start": 242,
                    "end": 309
                },
                {
                    "start": 312,
                    "end": 595
                },
                {
                    "start": 596,
                    "end": 703
                },
                {
                    "start": 706,
                    "end": 835
                },
                {
                    "start": 836,
                    "end": 952
                },
                {
                    "start": 953,
                    "end": 1184
                },
                {
                    "start": 1185,
                    "end": 1345
                },
                {
                    "start": 1348,
                    "end": 1544
                },
                {
                    "start": 1547,
                    "end": 1831
                },
                {
                    "start": 1832,
                    "end": 2073
                },
                {
                    "start": 2076,
                    "end": 2349
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.68505859375
        },
        {
            "corpus_id": "259165347",
            "title": "ARCOR2: Framework for Collaborative End-User Management of Industrial Robotic Workplaces using Augmented Reality",
            "text": "One of the framework's goals is to support collaboration between nonprogrammers who prefer creating programs visually and programmers who prefer to work with code. Because of this, there are two language representations. For visual programming, there is an intermediate program representation based on JSON format, which is language agnostic, easy to serialize, supports common programming techniques (cycles, conditions, variables), allows flexible parameter specification, and is easily manipulable from user interfaces. For URDFs/meshes Fig. 3: Block diagram of the system in a state when object instances are created in the ARServer (scene/project opened and online). Green lines depict WebSockets connections (two-way communication necessary), blue are REST APIs, and for red, an implementer is free to choose appropriate technology. execution, the intermediate format is translated into Python, which is currently the most popular scripting language 8 . The same language is also used to implement object types, through which a new device can be integrated into the system. This also allows a use case when a non-expert user creates the program visually, and the result is adjusted by an expert programmer. The form of Python code was designed with the possibility of transferring the code back into the intermediate format. However, this was not implemented yet. \n\nThe structure of the JSON format is as follows. Within a project, there might be [0, n] action points, where each might contain [0, n] actions. Each action is assigned a UID, unique human-readable name, type (scene object UID and corresponding underlying method/action), and [0, n] parameters (corresponding to parameters of the method). Action parameters can be given as literal or referenced to either a project variable (constant shared by multiple actions) or a previous result (return value of precedent action). On the project level, there is an array of objects defining logical structure (visualized as blue lines, see Fig. 5), each containing UID of source and target action and optional condition. Actions together with those linkages then form a directed acyclic graph, where the loops are forbidden at an application level. Without a condition, two actions could be connected only with one logic linkage.",
            "score": 0.329552907699619,
            "section_title": "Program Representation",
            "char_start_offset": 19690,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 163
                },
                {
                    "start": 164,
                    "end": 220
                },
                {
                    "start": 221,
                    "end": 522
                },
                {
                    "start": 523,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 838
                },
                {
                    "start": 839,
                    "end": 959
                },
                {
                    "start": 960,
                    "end": 1079
                },
                {
                    "start": 1080,
                    "end": 1212
                },
                {
                    "start": 1213,
                    "end": 1330
                },
                {
                    "start": 1331,
                    "end": 1369
                },
                {
                    "start": 1372,
                    "end": 1419
                },
                {
                    "start": 1420,
                    "end": 1515
                },
                {
                    "start": 1516,
                    "end": 1709
                },
                {
                    "start": 1710,
                    "end": 1889
                },
                {
                    "start": 1890,
                    "end": 2079
                },
                {
                    "start": 2080,
                    "end": 2207
                },
                {
                    "start": 2208,
                    "end": 2288
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.32373046875
        },
        {
            "corpus_id": "240916683",
            "title": "A Cross-Sectional Study Investigating Primary School Children\u2019s Coding Practices and Computational Thinking Using ScratchJr",
            "text": "code while also contributing to the development of their CT. With these programming tools the coding process can be performed via drag and drop of visual objects, known as blocks, using a modular editing interface which allows learners to develop and execute programs in a more intuitive and user-friendly way (Chao, 2016;Durak, 2020;Hu et al., 2021;Lye & Koh, 2014). This drag and drop process keeps young children more focused on the programming process itself and decreases their cognitive load (Durak, 2020;Mladenovic et al., 2018;Moors et al., 2018;Vasilopoulos & Van Schaik, 2019). In contrast to textbased programming, visual programming does not require children memorizing complex programming syntax or debugging errors in their codes (Durak, 2020;Lindberg et al., 2019). Instead, these programming tools are argued to enable the introduction of children to coding, via facilitating their understanding of how to use basic algorithmic forms through a smooth and straightforward visual mode of programming (Portelance & Bers, 2015).\n\nSuch visual-based environments enable children to construct meaningful programs with instant output, which in turn sustains their engagement with the programming process (Bers, 2018;Kong & Wang, 2019). Active engagement is significant in learning programming, otherwise, students' interest, artifacts and learning can be affected (Durak, 2020). Visual programming tools transform young children into active creators of games, animations, and interactive stories in various disciplines (e.g., language, science, or mathematics), which can boost their interest in CT learning (Mladenovic et al., 2018;Moors et al., 2018). Many of these visual-based tools work on touch devices (tablets) whose interactive interface makes them even more accessible to young learners and children (Hill et al., 2015).\n\nThe literature suggests that visual programming tools are most often used to foster the acquisition of coding skills and CT in educational contexts (de Araujo et al., 2016;Resnick et al., 2009;Shute et al., 2017), as they effectively facilitate the cognitive, motor, and social development of young children (Lee et al., 2013). This study examines CT using ScratchJr, which was especially designed for",
            "score": 0.3293398465442564,
            "section_title": "The Role of Visual-Based Programming in Addressing Children's Difficulties With Coding and CT",
            "char_start_offset": 8363,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 310,
                    "end": 322,
                    "matchedPaperCorpusId": "206930744"
                },
                {
                    "start": 322,
                    "end": 334,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 334,
                    "end": 350,
                    "matchedPaperCorpusId": "225492990"
                },
                {
                    "start": 350,
                    "end": 366,
                    "matchedPaperCorpusId": "11994747"
                },
                {
                    "start": 498,
                    "end": 511,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 535,
                    "end": 554,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 554,
                    "end": 586,
                    "matchedPaperCorpusId": "67309000"
                },
                {
                    "start": 744,
                    "end": 757,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 757,
                    "end": 779,
                    "matchedPaperCorpusId": "69960068"
                },
                {
                    "start": 1014,
                    "end": 1039,
                    "matchedPaperCorpusId": "22376466"
                },
                {
                    "start": 1212,
                    "end": 1224,
                    "matchedPaperCorpusId": "52202617"
                },
                {
                    "start": 1372,
                    "end": 1385,
                    "matchedPaperCorpusId": "69880168"
                },
                {
                    "start": 1641,
                    "end": 1660,
                    "matchedPaperCorpusId": "195832237"
                },
                {
                    "start": 1818,
                    "end": 1837,
                    "matchedPaperCorpusId": "2173765"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.69921875
        },
        {
            "corpus_id": "234857990",
            "title": "Application-based sales system interface design for dumpling noodles xyz",
            "text": "A system has definite goals and is deterministic. \n\nA data flow diagram illustrates the processes, data stores, and external entities in a business or other system and the connecting data flows [9]. Data Flow Diagrams (DFD) are graphic techniques that describe the flow of information and transformations that are applied when data moves from input data to output [3]. Data Flow Diagrams (DFD) can be defined and analyzed the data requirements required in accordance with the required information system processes [4]. The Data Flow Diagram (DFD) explains to the user how the flow of system-functions will work. The designed grooves consist of data inputs and processes on diagrams that can be viewed from the system design [11]. \n\nVisual Studio 2010 is basically a computer programming language, and is also often referred to as a means of producing windows-based application programs. Visual Basic is an object-centered programming language (Object Oriented Programming) used in making Windows applications in the form of a Graphical User Interface. The Visual Studio language is quite simple and uses commonly used English words. In addition, the visual development tools allow us to develop Windows-based, mouse-driven and highly efficient applications [5].",
            "score": 0.3290434119190062,
            "section_title": "System Goals (Objective)",
            "char_start_offset": 3361,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 49
                },
                {
                    "start": 52,
                    "end": 198
                },
                {
                    "start": 199,
                    "end": 368
                },
                {
                    "start": 369,
                    "end": 518
                },
                {
                    "start": 519,
                    "end": 611
                },
                {
                    "start": 612,
                    "end": 729
                },
                {
                    "start": 732,
                    "end": 886
                },
                {
                    "start": 887,
                    "end": 1051
                },
                {
                    "start": 1052,
                    "end": 1132
                },
                {
                    "start": 1133,
                    "end": 1261
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1885986328125
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "editor is to offer a programming experience based on what-you-see-is-what-you-get (WYSIWYG) and the impossibility of syntactic errors [105,118,168,170]. Moreover, these editors support different block-based programming paradigms, such as configuration, serial, parallel, and event-driven [57]. The popularity of block-based editors have increased in recent years, partially due to Scratch's popularity (23rd most popular programming language [27]). However, languages that provide such a type of editors are not new, yet block-based editors have been mainly used and associated with computer science education or applications for children. \n\nThis paper explores whether this is true or not. In case this claim is not true, we explore how these programming environments have been adopted beyond the realms of education or children. Moreover, this paper identifies block-based environments' main components to understand them and increase their adoption in different domains and for different user groups; and studies whether the development of block-based environments is supported by specialized language engineering tooling (e.g., language workbenches). \n\nTo have a clear overview of the landscape of block-based environments and understand how they are developed, we conducted a systematic and a less-systematic literature review. A systematic literature review collects and summarizes all the existing research evidence of a domain and identifies possible gaps in current research [79]. Initially we started with the less-systematic method, in which we sought block-based environments and their features. We ran into the limits of this ad-hoc method and continued with an SLR (structured literature review) to identify possible gaps in current research [79]. \n\nSince there exists no primary conference or journal focused on block-based environments, we expect that papers on this topic are spread over different academic communities with different characteristics. The papers we found in the venues will frame the answers to the research questions about block-based environments. \n\nThe contributions of this paper are summarized as follows: \n\n\u2022 A systematic literature review on block-based environments which provides an overview of the main features of block-based environments, the landscape in which these programming environments are used, publication venues, programming languages used in their development, and the most popular environments (Section 3).",
            "score": 0.32896797127607186,
            "section_title": "INTRODUCTION",
            "char_start_offset": 1882,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 152
                },
                {
                    "start": 153,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 448
                },
                {
                    "start": 449,
                    "end": 639
                },
                {
                    "start": 642,
                    "end": 690
                },
                {
                    "start": 691,
                    "end": 830
                },
                {
                    "start": 831,
                    "end": 1154
                },
                {
                    "start": 1157,
                    "end": 1332
                },
                {
                    "start": 1333,
                    "end": 1489
                },
                {
                    "start": 1490,
                    "end": 1607
                },
                {
                    "start": 1608,
                    "end": 1761
                },
                {
                    "start": 1764,
                    "end": 1967
                },
                {
                    "start": 1968,
                    "end": 2082
                },
                {
                    "start": 2085,
                    "end": 2143
                },
                {
                    "start": 2146,
                    "end": 2463
                }
            ],
            "ref_mentions": [
                {
                    "start": 134,
                    "end": 139,
                    "matchedPaperCorpusId": "25090136"
                },
                {
                    "start": 139,
                    "end": 143,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 143,
                    "end": 147,
                    "matchedPaperCorpusId": "5041136"
                },
                {
                    "start": 147,
                    "end": 151,
                    "matchedPaperCorpusId": "223424"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.336669921875
        },
        {
            "corpus_id": "276317900",
            "title": "Code Style Sheets: CSS for Code",
            "text": "Furthermore, the relative simplicity of CSS has led to the design of many higher-level style sheet languages-such as Sass [13], Less [57], and Stylus [27]-which offer variables, functions, etc. and compile to CSS. Tree transformation languages, such as XSLT [71], XQuery [70], and XDuce [28], offer expressive building blocks for querying richly-structured data, which may be useful to incorporate into a code style sheets language. Going beyond syntactic querying constructs, one can also imagine a code style sheets design that relies on a relational query language. \n\nAdditional Layout Constraints. Our layout algorithm computes and renders s-blocks, which encapsulate multiline regions of text more compactly than rectangles. There are additional visual constraints we might wish s-block layouts to satisfy. Perhaps layout should aim for consistent line height rather than minimizing the height of each line, or ensure that horizontally aligned elements in the source text remain aligned after layout-which could help reduce the amount of vertical and horizontal whitespace shown in Figure 1 . A layout system that considers additional relationships-perhaps building on CCSS [3], a system that extends CSS with constraints [4]-might produce more desirable program displays. As the visual goals for layout become more complex, it may be useful to extend the work by Panchekha et al. [52] that formalizes accessibility and usability specifications for CSS layouts with such constraints. \n\nBeyond rectilinear shapes (rectangles in HTML, s-blocks in Hass, \"ragged\" blocks in Deuce [25]), one can imagine other straight-edge shapes (e.g., convex hulls) or more amorphous contours that may be useful for displaying programs-even if they are less of a good fit with existing HTML and SVG layout systems. (FFL [73] and Penrose [74], for example, offer non-HTML based mechanisms for separating the definition of formulas and other diagrams from their styling.) Stylish Text with HTML. Another future direction is to more fully integrate textual and visual displays in Hass.",
            "score": 0.32826538902038876,
            "section_title": "Limitations and Future Work",
            "char_start_offset": 60158,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 213
                },
                {
                    "start": 214,
                    "end": 432
                },
                {
                    "start": 433,
                    "end": 568
                },
                {
                    "start": 571,
                    "end": 601
                },
                {
                    "start": 602,
                    "end": 729
                },
                {
                    "start": 730,
                    "end": 811
                },
                {
                    "start": 812,
                    "end": 1097
                },
                {
                    "start": 1098,
                    "end": 1277
                },
                {
                    "start": 1278,
                    "end": 1488
                },
                {
                    "start": 1491,
                    "end": 1800
                },
                {
                    "start": 1801,
                    "end": 1955
                },
                {
                    "start": 1956,
                    "end": 1979
                },
                {
                    "start": 1980,
                    "end": 2068
                }
            ],
            "ref_mentions": [
                {
                    "start": 287,
                    "end": 291,
                    "matchedPaperCorpusId": "13040912"
                },
                {
                    "start": 1179,
                    "end": 1182,
                    "matchedPaperCorpusId": "7167054"
                },
                {
                    "start": 1386,
                    "end": 1390,
                    "matchedPaperCorpusId": "46937226"
                },
                {
                    "start": 1581,
                    "end": 1585,
                    "matchedPaperCorpusId": "46557970"
                },
                {
                    "start": 1806,
                    "end": 1810,
                    "matchedPaperCorpusId": "264350384"
                },
                {
                    "start": 1823,
                    "end": 1827,
                    "matchedPaperCorpusId": "267825269"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.109130859375
        },
        {
            "corpus_id": "262825529",
            "title": "Nuzzlebug: Debugging Block-based Programs in Scratch",
            "text": "Scratch is a block-based programming language primarily aimed at children and is increasingly used in schools and coding clubs to introduce programming [35]. Program statements in Scratch are blocks that can be stacked to create scripts. Blocks can also contain holes of different shapes into which other blocks of matching shapes can be placed, for example to report the values of attributes or variables (reporter blocks) or conditions (Boolean blocks). Block shapes ensure that resulting programs are syntactically valid [46]. \n\nScratch programs are structured into targets: The stage is the application window containing the background image, and sprites are rendered on top of the stage. Each target contains scripts that control its behavior. The first block of a script is always an event handler (hat block), and the execution of a script is triggered every time the event represented by the hat block occurs. One particular such event is the green flag , which the user can click to start the program execution. Scripts are executed in separate threads by the Scratch Virtual Machine (VM), and thread switching occurs when scripts encounter a waiting state, reach the end of a loop, or have no more blocks to execute. To avoid that learners have to deal with confusing error messages, Scratch uses a 'failsoft' approach where runtime errors are swallowed and execution is resumed without informing the user [23]. \n\nThe Scratch's Graphical User Interface (GUI) is divided into four main sections (Fig. 4): The block palette on the left contains all available blocks divided into different color-coded categories. Blocks can be dragged out of the block palette and then dropped and snapped together in the coding area in the middle to define the behavior of the currently selected target. The upper right contains the stage, which renders the programmed behavior. The bottom right area enables selecting and editing targets.",
            "score": 0.3279261208258121,
            "section_title": "BACKGROUND 2.1 The Scratch Programming Environment",
            "char_start_offset": 4088,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 237
                },
                {
                    "start": 238,
                    "end": 455
                },
                {
                    "start": 456,
                    "end": 529
                },
                {
                    "start": 532,
                    "end": 692
                },
                {
                    "start": 693,
                    "end": 748
                },
                {
                    "start": 749,
                    "end": 917
                },
                {
                    "start": 918,
                    "end": 1020
                },
                {
                    "start": 1021,
                    "end": 1226
                },
                {
                    "start": 1227,
                    "end": 1421
                },
                {
                    "start": 1424,
                    "end": 1620
                },
                {
                    "start": 1621,
                    "end": 1795
                },
                {
                    "start": 1796,
                    "end": 1870
                },
                {
                    "start": 1871,
                    "end": 1931
                }
            ],
            "ref_mentions": [
                {
                    "start": 152,
                    "end": 156,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 1416,
                    "end": 1420,
                    "matchedPaperCorpusId": "267830776"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.55126953125
        },
        {
            "corpus_id": "269157061",
            "title": "Context-Free Languages of String Diagrams",
            "text": "Monoidal categories have an intuitive, sound and complete graphical syntax: string diagrams.String diagrams resemble graphical languages commonly found in engineering and science, and indeed, they allow us to reason about Markov kernels [20], linear algebra [6], or quantum processes [1].In computer science, they provide foundations for visual programming [27,29].\n\nThe use of string diagrams as a syntax in these various domains suggests the need for a corresponding theory of string diagrams as a formal language.This is one aim of recent work on languages of string diagrams or monoidal languages, such as that elaborated by Soboci\u0144ski and the first author [14,15], who introduced the class of regular monoidal languages.A monoidal language in this sense is simply a subset of morphisms in a strict monoidal category, just as a classical formal language is a subset of a monoid.In this work, we introduce a natural class of context-free monoidal languages, which capture various extended notions of context-free language found in the computer science literature.",
            "score": 0.3277981857985656,
            "section_title": "Languages of string diagrams",
            "char_start_offset": 1721,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 92
                },
                {
                    "start": 92,
                    "end": 288
                },
                {
                    "start": 288,
                    "end": 365
                },
                {
                    "start": 367,
                    "end": 516
                },
                {
                    "start": 516,
                    "end": 725
                },
                {
                    "start": 725,
                    "end": 882
                },
                {
                    "start": 882,
                    "end": 1066
                }
            ],
            "ref_mentions": [
                {
                    "start": 258,
                    "end": 261,
                    "matchedPaperCorpusId": "198185298"
                },
                {
                    "start": 284,
                    "end": 287,
                    "matchedPaperCorpusId": "692816"
                },
                {
                    "start": 361,
                    "end": 364,
                    "matchedPaperCorpusId": "231725028"
                },
                {
                    "start": 661,
                    "end": 665,
                    "matchedPaperCorpusId": "250243606"
                },
                {
                    "start": 665,
                    "end": 668,
                    "matchedPaperCorpusId": "259275270"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1927490234375
        },
        {
            "corpus_id": "3949077",
            "title": "General-Purpose Visual Language and Information System with Case-Studies in Developing Business Applications",
            "text": "Learning computer programming has been always challenging. Since the sixties of the last century, many researchers developed Visual Programming Languages (VPLs) to help in this regard. In this thesis, ten VPLs were specifically selected, studied, experimented with, and evaluated. A total of fifteen metrics were used to evaluate the tools. Comparisons, classification, and gap analysis were then presented. A list of requirements for a general-purpose VPL and a guide to help the novice programmer choose the right tool were generated and finally the PWCT (Programming Without Coding Technology, a novel general-purpose visual programming language) is developed and presented. PWCT has been launched as a Sourceforge project, which currently has more than 230,000 downloads for the language and more than 19,500,000 downloads for samples, tutorials and movies. Many business applications and projects are developed using PWCT, Also we developed the Supernova programming language and the Ring programming language using PWCT to prove that it can be used for advanced and large projects. Feedback from developers and results from the studies indicate that PWCT is a very appealing, competitive, and powerful language.",
            "score": 0.3276843530888929,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87744140625
        },
        {
            "corpus_id": "44123962",
            "title": "Using Elm to Introduce Algebraic Thinking to K-8 Students",
            "text": "Our Graphics library, GraphicSVG, is based on the original Elm Graphics module which targeted HTML canvas elements, and it is partially backwards compatible. GraphicSVG's principal types (Stencil, Shape and Collage) model real-world concepts: Stencil describes a recipe for creating a shape; for example, a circle with a certain radius, a rectangle with a width and height or text with a certain font and size: \n\nBut, like a real-life stencil, a visible shape is not created until the user fills it in or traces its edge: \n\nThus, a concrete analogy explains why shapes cannot show up on the screen unless they are filled or outlined. This architecture limits the number of parameters each function takes, making them easy to learn or even guess, and the types match students intuition closely enough that we do not have to talk about them. The limited number of arguments also make it easy to put all the basic functions in an interactive crib sheet (Figure 1). The types Stencil and Shape are introduced to students orally and we use the structure of the ShapeCreator to reinforce this. We do not use type signatures, but students see the type names in compiler errors, e.g., when they try to move a Stencil rather than a Shape. They never use constructors for these types directly, using exposed functions instead, some of which simplify the underlying type construction. Fortunately, Elm's type errors (e.g. found a Stencil where a Shape was expected) also match their intuitive understanding of these types, and need little explanation, and, so far, students who choose to attempt more complicated user interaction are able to build a workable understanding of Elm types from there. (See the last section to learn how we plan to use types as a teaching tool in the future.) Figure 1: ShapeCreator: As a consequence of GraphicSVG's design, we were able to expose the combinatorial nature of shape construction in an interactive tool for API discovery.",
            "score": 0.3276843530888929,
            "section_title": "GraphicSVG",
            "char_start_offset": 14817,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 410
                },
                {
                    "start": 413,
                    "end": 521
                },
                {
                    "start": 524,
                    "end": 633
                },
                {
                    "start": 634,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 961
                },
                {
                    "start": 962,
                    "end": 1087
                },
                {
                    "start": 1088,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1373
                },
                {
                    "start": 1374,
                    "end": 1410
                },
                {
                    "start": 1411,
                    "end": 1686
                },
                {
                    "start": 1687,
                    "end": 1777
                },
                {
                    "start": 1778,
                    "end": 1954
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.149169921875
        },
        {
            "corpus_id": "201651331",
            "title": "Foundations of brick diagrams",
            "text": "We discuss the foundations of 2-dimensional graphical languages, with a view towards their computer implementation in a 'compiler' for monoidal categories. In particular, we discuss the close relationship between string diagrams, pasting diagrams, linear logic proof trees and k-d trees, the last being a data structure from computational geometry and computer graphics that recursively partitions a space. We introduce a minor variant of cubical pasting diagrams, which we call 'brick diagrams', which are used in the Statebox visual programming language. This paper is intended as a discussion and literature review, and contains little mathematics.",
            "score": 0.3276843530888929,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.53076171875
        },
        {
            "corpus_id": "257102909",
            "title": "Integrating Data Structures and Algorithms in K-12 Education using Block-based Programming",
            "text": "There is block4ds, a block-based simulation tool developed to teach undergraduate computer science students advanced data structures such as Binary Search Trees (BST) [32]. These tools are designed to help students visualize hard concepts and help view data structure manipulations by generating relevant visual models representing the data structure, such as generating a BST after a node has been removed from the tree. These tools are aimed at undergraduate students. \n\nDSAScratch, on the other hand, is designed to help K-12 students explore data structures and apply them to actual use cases in a block-based programming context. DSAScratch has a strong integration as an extension into the Scratch framework, which allows students to create programs that incorporate such concepts into learning. Furthermore, it complements the current Scratch interface in its ability to view data structures as variables in Scratch, this allows users to view manipulations on data and inspect resulting changes to a data structure within the Scratch interface. It aims to help students formulate good solutions to problems and develop high-level abstraction capabilities while writing programs. Thus, when students switch to textual languages, they possess some familiarity with such advanced concepts.",
            "score": 0.3275561306190132,
            "section_title": "Fig. 2: Frequency of elements in the array",
            "char_start_offset": 8948,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 172
                },
                {
                    "start": 173,
                    "end": 421
                },
                {
                    "start": 422,
                    "end": 470
                },
                {
                    "start": 473,
                    "end": 634
                },
                {
                    "start": 635,
                    "end": 801
                },
                {
                    "start": 802,
                    "end": 1051
                },
                {
                    "start": 1052,
                    "end": 1185
                },
                {
                    "start": 1186,
                    "end": 1293
                }
            ],
            "ref_mentions": [
                {
                    "start": 167,
                    "end": 171,
                    "matchedPaperCorpusId": "203707561"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.69482421875
        },
        {
            "corpus_id": "233137618",
            "title": "When Language Evolution Meets Multimodality: Current Status and Challenges Toward Multimodal Computational Models",
            "text": "Visual/textual languages refer to languages that are expressed through a graphical notation, such as visual programming languages, visual query languages, etc.. Computational models of visual/textual evolution rely mainly on graph-based methods that allow representing linguistic units (e.g. words, sentences, etc.) as nodes in a graph and relations between them as edges. Algebraic graph transformation represents an evolution of the abstract syntax of these linguistic units. This formalism allows all kinds of transformations that range from language definition by grammars via model migration to language integration by extending the grammar rule set and/or the vocabulary [42]. Very few studies investigated the use of iterated learning [43] as a modelling approach to the evolution of graphical symbols. Iterated learning is an agent-based technique that is mainly concerned with the transmission of Language between successive generations of agents. Garrod et al. [43] in their study apply the game ''Pictionary'' for investigating the emergence of graphical communication systems and their evolution through a process of interactive grounding.",
            "score": 0.3271255848744828,
            "section_title": "C. COMPUTATIONAL MODELS OF VISUAL/TEXTUAL EVOLUTION",
            "char_start_offset": 15935,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 291
                },
                {
                    "start": 292,
                    "end": 372
                },
                {
                    "start": 373,
                    "end": 477
                },
                {
                    "start": 478,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 809
                },
                {
                    "start": 810,
                    "end": 956
                },
                {
                    "start": 957,
                    "end": 1151
                }
            ],
            "ref_mentions": [
                {
                    "start": 677,
                    "end": 681,
                    "matchedPaperCorpusId": "18149863"
                },
                {
                    "start": 742,
                    "end": 746,
                    "matchedPaperCorpusId": "13922777"
                },
                {
                    "start": 971,
                    "end": 975,
                    "matchedPaperCorpusId": "13922777"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.426025390625
        },
        {
            "corpus_id": "209056321",
            "title": "Tiny Thing Blocks: Integrating Everyday Objects into IoT Context",
            "text": "The IoT code development has usually been done with several tools and using different approaches. \n\nAn example is the Node-RED, which is a flow-based tool that belongs to the JS Foundation. The flow-based programming is a method to describe the application's behavior as a network of nodes. Therefore, each node has its data to handle and represent. The flow of these data between nodes depends on the network. The visual representation of data is interesting since it turns the tool more accessible to beginners [9]. \n\nAnother tool is Visuino, which uses blocks and drag-anddrop paradigm to create a visual programming language to develop software to Arduino boards. This tool represents the hardware actions using blocks, thus it only requires the user to understand what the hardware should do and translate these actions to code [11]. \n\nVisualino is another example of a drag-and-drop based visual language to generate software for Arduino boards. Visualino is different from Visuino in the sense that it focus on the direct development of code. Visualino provides blocks to represent the structures of the language used by Arduino [5]. \n\nNode-Red is the more recognized and used by developers and teachers on the Internet of Things subject. According to Google trends, it maintained the relevance of the researches since 2018. The following tool is the Visuino, although its relevance of the researchers has been inconstant. \n\nWe used Blockly [7] which is a Javascript library used in many online code generation tools such as App Inventor, CODE, Microsoft MakeCode, and others. Using Blockly we created an online tool that generates the model through a visual language based on blocks, and translates this visual language to a C-based language. \n\nCombined to Blockly we used the Graphviz tool, which is an open source graph visualization software that uses the DOT language to create a finite state machine [3], which represents the models behavior. Comparing to the other tools quoted previously, Tiny Thing Blocks focus on receiving a behavior model and generate code from that. This tool works using the same paradigm of Visuino and Visualino, the drag-and-drop model. Nevertheless, the blocks used at this tool represents structures and state transitions.",
            "score": 0.3266943566232122,
            "section_title": "II. RELATED WORK",
            "char_start_offset": 2751,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 100,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 349
                },
                {
                    "start": 350,
                    "end": 410
                },
                {
                    "start": 411,
                    "end": 517
                },
                {
                    "start": 520,
                    "end": 667
                },
                {
                    "start": 668,
                    "end": 838
                },
                {
                    "start": 841,
                    "end": 951
                },
                {
                    "start": 952,
                    "end": 1049
                },
                {
                    "start": 1050,
                    "end": 1140
                },
                {
                    "start": 1143,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1331
                },
                {
                    "start": 1332,
                    "end": 1429
                },
                {
                    "start": 1432,
                    "end": 1583
                },
                {
                    "start": 1584,
                    "end": 1750
                },
                {
                    "start": 1753,
                    "end": 1955
                },
                {
                    "start": 1956,
                    "end": 2086
                },
                {
                    "start": 2087,
                    "end": 2177
                },
                {
                    "start": 2178,
                    "end": 2265
                }
            ],
            "ref_mentions": [
                {
                    "start": 1913,
                    "end": 1916,
                    "matchedPaperCorpusId": "38213379"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85693359375
        },
        {
            "corpus_id": "51857791",
            "title": "Metamodel Specialization for Graphical Language and Editor Definition",
            "text": "See a more detailed analysis of the related research in our paper (Kalnins and Barzdins, 2016 b). All these workbenches have as a primary goal the implementation of the given graphical language either by code generation or interpretation. Therefore for simpler use cases, when the main goal is just to create syntactically correct diagrams in the given graphical language, simpler and more direct solutions are possible. The platform devoted most directly to graphical DSL editor definition on the basis of the graphical syntax is the platform developed by IMCS UL -Transformation Driven Architecture (TDA) (Barzdins et al., 2007, 2008, Sprogis, 2010, 2013). \n\nA common feature of all these workbenches is that they are based on a metamodel instantiation, typically in a MOF (OMG, 2015 c) style 4-layer architecture. The workbench itself has a fixed meta-metamodel, a tool for a given language (including both the language definition, and editor and other components) is based on a metamodel obtained by the instantiation. A model created by the tool user (in fact, a program in the given DSL) is obtained by instantiation of this metamodel, and at runtime the instantiated objects are present. Now let us explain in more detail the instantiation approach. Let us take the TDA and consider the graphical language definition by instantiation. According to TDA principles this task is based on a Type metamodel for graphical languages. Fig. 1 shows such a simplified type metamodel, to be named further simply a Type metamodel in TDA. It is a fixed metamodel which contains type classes for all elements of a simple graphical diagram language -GraphDiagram, Node, Edge and Compartment (of a Node or Edge). In our approach the Compartment is any logical textual element in a diagram, a line or multiline (thus our terminology slightly differs from that used e. g. in Eclipse GMF (WEB, a) where only multiline texts are named compartments). The classes of Type metamodel contain also the basic style attributes of diagram elements.",
            "score": 0.32663065846871264,
            "section_title": "Introduction",
            "char_start_offset": 2167,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 97
                },
                {
                    "start": 98,
                    "end": 238
                },
                {
                    "start": 239,
                    "end": 420
                },
                {
                    "start": 421,
                    "end": 658
                },
                {
                    "start": 661,
                    "end": 816
                },
                {
                    "start": 817,
                    "end": 1022
                },
                {
                    "start": 1023,
                    "end": 1194
                },
                {
                    "start": 1195,
                    "end": 1256
                },
                {
                    "start": 1257,
                    "end": 1341
                },
                {
                    "start": 1342,
                    "end": 1433
                },
                {
                    "start": 1434,
                    "end": 1532
                },
                {
                    "start": 1533,
                    "end": 1703
                },
                {
                    "start": 1704,
                    "end": 1936
                },
                {
                    "start": 1937,
                    "end": 2027
                }
            ],
            "ref_mentions": [
                {
                    "start": 66,
                    "end": 96,
                    "matchedPaperCorpusId": "14381064"
                },
                {
                    "start": 607,
                    "end": 629,
                    "matchedPaperCorpusId": "7452725"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.485107421875
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "This section addresses research question RQ1 based on the data collected. For this purpose, we used the papers' classification from the previous section and we took the ones from the languages group. From the total number of papers we considered a subset of 95 papers (Table 5). \n\nBased on the different features offered from all the block-based environments in this study, we developed a feature diagram [73] that summarizes the most common features found across different platforms. The complete set of features of block-based environments is shown in Figures 3 and 4. To ease the diagram's readability, we split the editor feature into a separate diagram, as shown in Figure 4. In the feature model, we used two types of features, mandatory and optional. The first is used for standard features (depicted as a box in Figures 3 and 4), and the latter for unique features (depicted as a box with a blank circle on top). \n\nThe root node in Figure 3  Type. There are mainly two types of block-based environments, tools, and languages. The former refers to utilities that help the development of such environments. Instead, the latter are languages that come with a block-based editor. \n\nEditor. Block-based environments provide a block-based editor, but, we identified that some tools also support a hybrid editor (text and blocks), which means that it is possible to interact with the underlying language either through a blocks editor or text-based editor. Based on this, 69 of the studied tools support a block editor only, while 15 \n\nManuscript submitted to ACM support both blocks and text editor [6,7,12,15,18,20,22,34,40,62,76,77,90,143,164]. The remaining ten tools do not mention it at all. \n\nDeployment. A block-based environment can be used through a heterogeneous set of devices (e.g., laptops, tablets, and wearables). Therefore, we investigated what device do block-based environment users write or develop their programs with. The majority of tools are used through a browser-enabled PC (76), five through mobile devices (e.g., smartphones), four by manipulating physical elements, and one as Software as a Service (SaaS).",
            "score": 0.3259370327079924,
            "section_title": "RQ1: What are the components of a block-based environment?",
            "char_start_offset": 19268,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 73
                },
                {
                    "start": 74,
                    "end": 199
                },
                {
                    "start": 200,
                    "end": 278
                },
                {
                    "start": 281,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 680
                },
                {
                    "start": 681,
                    "end": 757
                },
                {
                    "start": 758,
                    "end": 920
                },
                {
                    "start": 923,
                    "end": 955
                },
                {
                    "start": 956,
                    "end": 1033
                },
                {
                    "start": 1034,
                    "end": 1112
                },
                {
                    "start": 1113,
                    "end": 1183
                },
                {
                    "start": 1186,
                    "end": 1193
                },
                {
                    "start": 1194,
                    "end": 1457
                },
                {
                    "start": 1458,
                    "end": 1534
                },
                {
                    "start": 1537,
                    "end": 1648
                },
                {
                    "start": 1649,
                    "end": 1698
                },
                {
                    "start": 1701,
                    "end": 1712
                },
                {
                    "start": 1713,
                    "end": 1830
                },
                {
                    "start": 1831,
                    "end": 1940
                },
                {
                    "start": 1941,
                    "end": 2136
                }
            ],
            "ref_mentions": [
                {
                    "start": 1604,
                    "end": 1606,
                    "matchedPaperCorpusId": "208355747"
                },
                {
                    "start": 1606,
                    "end": 1609,
                    "matchedPaperCorpusId": "211227882"
                },
                {
                    "start": 1609,
                    "end": 1612,
                    "matchedPaperCorpusId": "204732473"
                },
                {
                    "start": 1612,
                    "end": 1615,
                    "matchedPaperCorpusId": "8230112"
                },
                {
                    "start": 1618,
                    "end": 1621,
                    "matchedPaperCorpusId": "209496125"
                },
                {
                    "start": 1621,
                    "end": 1624,
                    "matchedPaperCorpusId": "56783509"
                },
                {
                    "start": 1624,
                    "end": 1627,
                    "matchedPaperCorpusId": "47018308"
                },
                {
                    "start": 1627,
                    "end": 1630,
                    "matchedPaperCorpusId": "218483249"
                },
                {
                    "start": 1630,
                    "end": 1633,
                    "matchedPaperCorpusId": "5041444"
                },
                {
                    "start": 1633,
                    "end": 1636,
                    "matchedPaperCorpusId": "51872764"
                },
                {
                    "start": 1636,
                    "end": 1639,
                    "matchedPaperCorpusId": "203706364"
                },
                {
                    "start": 1639,
                    "end": 1643,
                    "matchedPaperCorpusId": "52127227"
                },
                {
                    "start": 1643,
                    "end": 1647,
                    "matchedPaperCorpusId": "220259187"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.29150390625
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "This paper presents an overview of block-based environments and their features. Also, it presents a detailed view of how these programming environments are developed and the technologies involved in this process. We listed and summarized more than one hundred languages and extensions, which were grouped into seven categories. These categories highlight the fact that block-based environments have a broader scope than computer science education. \n\nThe results show that authors do not mention implementation details or possible troubles that the development of a block-based editor has. Moreover, there is a vast diversity of applications in which the block-based metaphor is adopted (e.g., arts, education, science, robotics). Yet, there is a lack of tool support for developing a whole language that supports a block-based editor. Existing tools do not support the whole development cycle of a language. In most cases, designers of block-based environments rely on code generators for defining the semantics of the languages. We believe that the usage of meta-programming technologies, such as found in Language Workbenches, would enable engineers to fully develop a language and obtain a block-based editor almost \"for free\", as is the case already for textual editors. \n\nLikewise, we confirmed that Scratch has had a significant impact on the development of most of current block-based environments, both conceptually and technically. \n\nAnother interesting conclusion of the current survey is that using different methods and sources (systematic and less-systematic, academic and non-academic) allowed us to synthesize a more complete overview of this particular topic than would otherwise be possible. In particular, the less-systematic approach to collect information from non-academic sources presented findings complementary to the systematic literature study, which were also fundamental to the interpretation of the data from the systematic literature study. \n\nWe also provided an overview of academic research on usability and learnability of block-based editors (as compared to text editors) and other studies of large collections of block-based programs. \n\nAs future work, we foresee different directions: (i) Study what are the best practices for using and implementing block-based editors. The current paper presents an overview of the features we identified across languages. However, it is interesting to explore the particularities of block-based interfaces to improve the users' programming experience; \n\nand how this can be used to implement better block-based editors.",
            "score": 0.3258316235477047,
            "section_title": "CONCLUSIONS AND FUTURE WORK",
            "char_start_offset": 64243,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 79
                },
                {
                    "start": 80,
                    "end": 212
                },
                {
                    "start": 213,
                    "end": 327
                },
                {
                    "start": 328,
                    "end": 447
                },
                {
                    "start": 450,
                    "end": 588
                },
                {
                    "start": 589,
                    "end": 729
                },
                {
                    "start": 730,
                    "end": 834
                },
                {
                    "start": 835,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 1029
                },
                {
                    "start": 1030,
                    "end": 1274
                },
                {
                    "start": 1277,
                    "end": 1440
                },
                {
                    "start": 1443,
                    "end": 1708
                },
                {
                    "start": 1709,
                    "end": 1970
                },
                {
                    "start": 1973,
                    "end": 2169
                },
                {
                    "start": 2172,
                    "end": 2306
                },
                {
                    "start": 2307,
                    "end": 2393
                },
                {
                    "start": 2394,
                    "end": 2523
                },
                {
                    "start": 2526,
                    "end": 2591
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5380859375
        },
        {
            "corpus_id": "224865976",
            "title": "EUD-MARS: End-user development of model-driven adaptive robotics software systems",
            "text": "A tool to support software developers in the definition and maintenance of robot profiles and configurations; 5. A tool to support end-user programmers in the development of robotics programs using the concepts and visual language offered by EUD-MARS. We evaluated EUD-MARS from different perspectives as follows: \n\n\uf0b7 We conducted a technical evaluation by using EUD-MARS to program different types of robots, and by assessing the paradigm (interlocking blocks) of its visual programming language against the recommendations of the cognitive dimensions framework [101]. \uf0b7 We asked software developers to prepare robot profiles and API configurations using EUD-MARS and to provide feedback on strengths and points for improvement concerning the overall approach and its supporting tool for software developers. \uf0b7 We asked end-users to explain and develop EUD-MARS programs, and to provide feedback mainly on understandability, ease-of-programming, and desirability. End-users found the visual programs to be overall understandable and easy to program, and they perceived the approach to be desirable. Google developed Blockly as a JavaScript library for creating block-based visual programming languages. We should note that although EUD-MARS uses Blockly for representing its visual programming language, it does not rely on any technical concepts from Blockly. EUD-MARS merely uses Blockly as a way of visualizing its concepts (contributions 1 and 2). Even the program interpreter and the component that converts visual programs to XML (refer to Fig. 1) are EUD-MARS components that do not rely on Blockly. Furthermore, in this paper, we do not aim to develop new robot APIs. Hence, we used existing robot APIs for evaluating the contributions of EUD-MARS. \n\nWe should note that EUD-MARS does not aim to replace traditional code-based (text-based non-visual) programming languages that professional programmers use for developing robotics systems. Code-based languages have many merits and offer numerous advanced features such as object-orientation and complex data structures. EUD-MARS does not aim to offer all these advanced features; for example, its visual language is not fully object-oriented. The main aim of EUD-MARS is to provide a simple way for end-users to develop model-driven adaptive robotics software systems without going through the technical complications that require the expertise of professional programmers.",
            "score": 0.325731290212825,
            "section_title": "4.",
            "char_start_offset": 9107,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 112
                },
                {
                    "start": 113,
                    "end": 251
                },
                {
                    "start": 252,
                    "end": 313
                },
                {
                    "start": 316,
                    "end": 569
                },
                {
                    "start": 570,
                    "end": 809
                },
                {
                    "start": 810,
                    "end": 964
                },
                {
                    "start": 965,
                    "end": 1099
                },
                {
                    "start": 1100,
                    "end": 1203
                },
                {
                    "start": 1204,
                    "end": 1361
                },
                {
                    "start": 1362,
                    "end": 1452
                },
                {
                    "start": 1453,
                    "end": 1607
                },
                {
                    "start": 1608,
                    "end": 1676
                },
                {
                    "start": 1677,
                    "end": 1757
                },
                {
                    "start": 1760,
                    "end": 1948
                },
                {
                    "start": 1949,
                    "end": 2079
                },
                {
                    "start": 2080,
                    "end": 2202
                },
                {
                    "start": 2203,
                    "end": 2433
                }
            ],
            "ref_mentions": [
                {
                    "start": 563,
                    "end": 568,
                    "matchedPaperCorpusId": "11750514"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.826171875
        },
        {
            "corpus_id": "62770711",
            "title": "Islay3D\u2014A Programming Environment for Authoring Interactive 3D Animations in Terms of State-Transition Diagram",
            "text": "Figure 11 shows Alice [8], a programming environment designed to introduce student to the concept of objectoriented programming by creating 3D animated movies and simple video games. In Alice, students create a virtual world by using with a 3D scene editor, and the 3D objects in the scene are animated by creating a program  through selecting statements corresponding to production-oriented programming language such as Java, C++, and C#. Learning a scripting language is required because it is the very purpose of Alice to educate non-programmers to be programmers. On the other hand, Islay3D does not requires the user to write text-based programs, and they only need to draw a set of state-transition diagrams. \n\nKodu Game Lab [9] is a tile-based visual programming tool that enables users to learn programming concepts through making and playing computer games in real-time isometric 3D gaming environment. It is designed specifically for young children, with a real-time isometric 3D gaming environment that is designed to compete with modern console games in terms of intuitive user interface and graphical production values. \n\nKodu's programming language is a high-level visual language that can be represented as a context-free grammar. Unlike other programming languages like Java or C++, Kodu is entirely event driven, whereby programming involves the placement of tiles in a meaningful sequence to form a condition and action on each rule as shown in Figure 12. Each Kodu rule has two clauses, a condition and an action, which is similar to Islay3D's transition and state. \n\nHowever, the language paradigm of Islay3D has the advantage in that the user is able to represent the control flow of the program visually and comprehensively. This is possible through the usage of states, where each character can only be at one state at any given time in a state-transition diagram. Contrasting this to the rule-based event-driven programming environment such as Kodu, this allows user to learn easily the fundamental concept of serial control flow which forms the building block of programming language [10].",
            "score": 0.32460794673103144,
            "section_title": "Related Works",
            "char_start_offset": 10008,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 182
                },
                {
                    "start": 183,
                    "end": 439
                },
                {
                    "start": 440,
                    "end": 567
                },
                {
                    "start": 568,
                    "end": 714
                },
                {
                    "start": 717,
                    "end": 911
                },
                {
                    "start": 912,
                    "end": 1132
                },
                {
                    "start": 1135,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1473
                },
                {
                    "start": 1474,
                    "end": 1584
                },
                {
                    "start": 1587,
                    "end": 1746
                },
                {
                    "start": 1747,
                    "end": 1887
                },
                {
                    "start": 1888,
                    "end": 2114
                }
            ],
            "ref_mentions": [
                {
                    "start": 731,
                    "end": 734,
                    "matchedPaperCorpusId": "18713650"
                },
                {
                    "start": 2109,
                    "end": 2113,
                    "matchedPaperCorpusId": "17585571"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77685546875
        },
        {
            "corpus_id": "273707620",
            "title": "VISUALCODER: Guiding Large Language Models in Code Execution with Fine-grained Multimodal Chain-of-Thought Reasoning",
            "text": "A.1 Control Flow Graph Representation Definition 1 (Control Flow Graph -CFG) A Control Flow Graph (CFG) is a graphical representation of the control flow within a program. Nodes in the CFG correspond to basic blocks of code, which may include individual statements or groups of statements that are executed sequentially. The edges between nodes represent the possible transitions or flow of control between these blocks, typically influenced by control structures such as loops, conditional statements (e.g., if-else), or function calls. \n\nIn VISUALCODER, the CFG serves as a crucial component for visualizing and reasoning about a program's execution flow. By aligning each code segment with its corresponding node in the CFG, we provide the model with a more structured and intuitive understanding of the dynamic behavior of the program. This enhanced alignment helps in improving code execution reasoning, error detection, and prediction of execution outcomes. \n\nTo generate the Control Flow Graphs (CFGs) used in VISUALCODER, we adapted code from an open-source repository by (Jiang, 2023). The modifications made to the original code focused on improving clarity and reducing unnecessary information in the CFG. Specifically, we removed certain function call nodes that did not correspond to any specific line of code, thus eliminating extraneous details that could distract the model. Additionally, we simplified the labels on the edges of conditional branches by replacing the full conditional statements with \"T\" (True) and \"F\" (False). \n\nIn addition to the visual representations of Control Flow Graphs (CFGs), we utilize the Mermaid language to provide a text-based representation. \n\nThe following Mermaid code corresponds to the CFG depicted in Figure 1:",
            "score": 0.3245480020218683,
            "section_title": "A Appendix",
            "char_start_offset": 31062,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 171
                },
                {
                    "start": 172,
                    "end": 320
                },
                {
                    "start": 321,
                    "end": 537
                },
                {
                    "start": 540,
                    "end": 657
                },
                {
                    "start": 658,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 963
                },
                {
                    "start": 966,
                    "end": 1094
                },
                {
                    "start": 1095,
                    "end": 1216
                },
                {
                    "start": 1217,
                    "end": 1390
                },
                {
                    "start": 1391,
                    "end": 1544
                },
                {
                    "start": 1547,
                    "end": 1691
                },
                {
                    "start": 1694,
                    "end": 1765
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.48095703125
        },
        {
            "corpus_id": "116768063",
            "title": "DSCBlocks: An Open-Source Platform for Learning Embedded Systems Based on Algorithm Visualizations and Digital Signal Controllers",
            "text": "Integrating a database for course management. \n\nPasternak et al. [17] discussed creating visual languages with Blockly. Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations. In addition, every VPL has grammar and vocabulary that define the behavior of the language that has been created. In any case, the authors marked out some reflection points that could give a horizon for the design of VPLs with Blockly:",
            "score": 0.3244780451268607,
            "section_title": "\u2022",
            "char_start_offset": 8536,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 45
                },
                {
                    "start": 48,
                    "end": 119
                },
                {
                    "start": 120,
                    "end": 322
                },
                {
                    "start": 323,
                    "end": 436
                },
                {
                    "start": 437,
                    "end": 558
                }
            ],
            "ref_mentions": [
                {
                    "start": 65,
                    "end": 69,
                    "matchedPaperCorpusId": "2701916"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.896484375
        },
        {
            "corpus_id": "221802417",
            "title": "A Visual Language for Composable Inductive Programming",
            "text": "Algorithmic information theory [20,21] suggests that any single notation used to describe software must either be as complex as the software it describes or else it must trade off generality. The use of multiple notations does not improve on this situation. \n\nWhilst visual programming has always seemed like a good idea, it has constantly grappled with the following issues: \n\n\u2022 Diagrams take up a lot of space on the screen compared to equivalent code; \n\n\u2022 Software is complex and diagrams of software can quickly become incomprehensible; \n\n\u2022 It often takes longer to produce a diagram than the equivalent code in a conventional language; \n\n\u2022 Literal visual languages have all of the same concepts as equivalent conventional programming language (variables, conditions, control structures, etc.) so learning such a visual language is not significantly easier; \n\n\u2022 Languages and frameworks often employ many classes and methods making it difficult to remember, find or discover relevant components and functions; \n\n\u2022 There are often too many concepts to represent visually in a distinctive or recognisable way so visual languages often rely heavily on textual annotation. \n\nThese issues have never been completely addressed. This is mostly due to the intrinsic complexity of the various visual languages themselves. While visual programming plays an important role in some areas a complete and compelling visual programming language remains elusive. \n\nAbstraction is often identified as a possible way of addressing some of these problems. As with conventional programming languages there is much interest in approaches that involve different programming paradigms, higher level languages and higher order programming. Unfortunately none of these approaches have addressed the issues associated with visual programming to a significant extent.",
            "score": 0.3244780451268607,
            "section_title": "Visual Programming",
            "char_start_offset": 5129,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 191
                },
                {
                    "start": 192,
                    "end": 257
                },
                {
                    "start": 260,
                    "end": 375
                },
                {
                    "start": 378,
                    "end": 454
                },
                {
                    "start": 457,
                    "end": 540
                },
                {
                    "start": 543,
                    "end": 640
                },
                {
                    "start": 643,
                    "end": 861
                },
                {
                    "start": 864,
                    "end": 1013
                },
                {
                    "start": 1016,
                    "end": 1172
                },
                {
                    "start": 1175,
                    "end": 1225
                },
                {
                    "start": 1226,
                    "end": 1316
                },
                {
                    "start": 1317,
                    "end": 1450
                },
                {
                    "start": 1453,
                    "end": 1540
                },
                {
                    "start": 1541,
                    "end": 1719
                },
                {
                    "start": 1720,
                    "end": 1844
                }
            ],
            "ref_mentions": [
                {
                    "start": 31,
                    "end": 35,
                    "matchedPaperCorpusId": "115528616"
                },
                {
                    "start": 35,
                    "end": 38,
                    "matchedPaperCorpusId": "271709362"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7373046875
        },
        {
            "corpus_id": "259548857",
            "title": "Software analysis for mobile robots control programs",
            "text": "Also, robot control environments are distinguished by whether they are specialized in controlling a particular robot or support a number of robots from different manufacturers (Fig. 2). \n\nOne of the important features of working with text languages is that you have to remember the syntax of the language, keywords, parentheses, commas, and so on. But with a visual programming language, it is easier to determine which block is responsible for what and how to build connections between them. Visual programming is used not only for simple tasks, but also in quite complex tasks. For example, in relationship editors in relational databases, dataflow programming, program designers, and so on [14 -18]. \n\nDuring the development of any program, it is assumed that it will develop over time -to receive new functions and entities. Perhaps some parts may change with an increase in the number of robot sensors. In visual programming, the interface for manipulating graphic objects is currently limited, but development is actively underway to expand the work area, which will allow creating complex programs. To manage complexity in text programming, many concepts and architectural approaches have come up. For example, object-oriented programming, various architectural design patterns. If you follow them, it will save the developer time and it will be easier to scale the project. Arduino, etc. \n\nBricxCC, etc. \n\nSupporting for a range of robots of artificial intelligence and virtual reality. Additionally, there are a large number of free libraries for Python. Python is useful in robotics because it is one of the main programming languages in ROS (along with C++). But it may become even more popular as more robotic electronics support this language by default. Pascal is a BASIC language, and is literally based on the BASIC language. Most often, industrial robots are programmed in the Pascal language. It is simple because it uses structured programming and data structuring. Java is a general-purpose object-oriented programming language based on classes. It is designed to allow application developers to build code once and then reuse it anywhere. \n\nIn other words, JAVA code can run on any JAVAenabled platform without the need for recompilation. In addition, JAVA is a useful language in robotics and is used in the creation of artificial intelligence. Scratch is extremely popular among beginning roboticists.",
            "score": 0.32401991020658427,
            "section_title": "Figure 1 -Generalized block diagram of the mobile robot control system",
            "char_start_offset": 6362,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 185
                },
                {
                    "start": 188,
                    "end": 347
                },
                {
                    "start": 348,
                    "end": 492
                },
                {
                    "start": 493,
                    "end": 579
                },
                {
                    "start": 580,
                    "end": 702
                },
                {
                    "start": 705,
                    "end": 828
                },
                {
                    "start": 829,
                    "end": 907
                },
                {
                    "start": 908,
                    "end": 1105
                },
                {
                    "start": 1106,
                    "end": 1204
                },
                {
                    "start": 1205,
                    "end": 1285
                },
                {
                    "start": 1286,
                    "end": 1381
                },
                {
                    "start": 1382,
                    "end": 1395
                },
                {
                    "start": 1398,
                    "end": 1411
                },
                {
                    "start": 1414,
                    "end": 1494
                },
                {
                    "start": 1495,
                    "end": 1563
                },
                {
                    "start": 1564,
                    "end": 1669
                },
                {
                    "start": 1670,
                    "end": 1767
                },
                {
                    "start": 1768,
                    "end": 1841
                },
                {
                    "start": 1842,
                    "end": 1910
                },
                {
                    "start": 1911,
                    "end": 1984
                },
                {
                    "start": 1985,
                    "end": 2065
                },
                {
                    "start": 2066,
                    "end": 2159
                },
                {
                    "start": 2162,
                    "end": 2259
                },
                {
                    "start": 2260,
                    "end": 2366
                },
                {
                    "start": 2367,
                    "end": 2424
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.76123046875
        },
        {
            "corpus_id": "259139422",
            "title": "SCLang: Graphical Domain-Specific Modeling Language for Stream Cipher",
            "text": "DSML is a type of Domain-Specific Language (DSL), a programming language approach that focuses on a particular domain but has restricted expressiveness [18]. This type of programming language is developed for a particular domain and specific problems. DSL development can be classified in three categories based on specific characteristics. Internal/external DSL determines whether the generated language depends on the host language or was created entirely from scratch [19]. A textual/graphical DSL is based on a compiler approach (textual) and a projection approach (graphical) [20]. Domain-Specific Visual Language (DSVL), Domain-Specific Model Language (DSML), and Domain-Specific Embedded Language (DSEL) represent the three categories of DSL. These classifications are interconnected [19]. \n\nModels seem to be the current orientation of language development rather than traditional technologies [20,21]. Model definition, and conversions from one model to another, and from a model to text are essential components in creating automated systems. In this context, a model is a condensed portrayal of a certain reality with the intention of better comprehending it. Whether the model is expressed graphically or textually, this abstraction requires the removal of irrelevant features from the model [19]. In this study, a graphical approach has been used, as it is simple and easily learned. Models are created using DSMLs and consist of three distinct parts [22]: the abstract syntax, which consists of fundamental concepts of a specific domain and relationships between them; the concrete syntax, or DSML notation, which is a collection of helpful graphical symbols for drawing diagrams; and the semantic definition, which is a validation rule to determine whether a model is well-formed according to the domain rules. The advantages of creating and using such a particular language type include reduced size of potential errors, increased productivity, improved communication with subject matter experts, easier adaptation to changes, allowing users to specify what the system should do but not how it is carried out [22]. The field of modeling and meta-modeling is too wide to be discussed in detail here [23]. The design and implementation of DSML have recently been considered in different research areas [24]. Some research areas that have designed and implemented DSML as a solution for domain difficulties are presented.",
            "score": 0.3237993521480277,
            "section_title": "Domain-Specific Modeling Language (DSML)",
            "char_start_offset": 5500,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 157
                },
                {
                    "start": 158,
                    "end": 251
                },
                {
                    "start": 252,
                    "end": 340
                },
                {
                    "start": 341,
                    "end": 476
                },
                {
                    "start": 477,
                    "end": 586
                },
                {
                    "start": 587,
                    "end": 749
                },
                {
                    "start": 750,
                    "end": 796
                },
                {
                    "start": 799,
                    "end": 910
                },
                {
                    "start": 911,
                    "end": 1052
                },
                {
                    "start": 1053,
                    "end": 1170
                },
                {
                    "start": 1171,
                    "end": 1309
                },
                {
                    "start": 1310,
                    "end": 1396
                },
                {
                    "start": 1397,
                    "end": 1825
                },
                {
                    "start": 1826,
                    "end": 2130
                },
                {
                    "start": 2131,
                    "end": 2219
                },
                {
                    "start": 2220,
                    "end": 2321
                },
                {
                    "start": 2322,
                    "end": 2434
                }
            ],
            "ref_mentions": [
                {
                    "start": 152,
                    "end": 156,
                    "matchedPaperCorpusId": "249960526"
                },
                {
                    "start": 471,
                    "end": 475,
                    "matchedPaperCorpusId": "228976947"
                },
                {
                    "start": 791,
                    "end": 795,
                    "matchedPaperCorpusId": "228976947"
                },
                {
                    "start": 1304,
                    "end": 1308,
                    "matchedPaperCorpusId": "228976947"
                },
                {
                    "start": 1464,
                    "end": 1468,
                    "matchedPaperCorpusId": "234275159"
                },
                {
                    "start": 2125,
                    "end": 2129,
                    "matchedPaperCorpusId": "234275159"
                },
                {
                    "start": 2214,
                    "end": 2218,
                    "matchedPaperCorpusId": "209387581"
                },
                {
                    "start": 2316,
                    "end": 2320,
                    "matchedPaperCorpusId": "52978421"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.444580078125
        },
        {
            "corpus_id": "249297813",
            "title": "Collaborative learning with block-based programming: investigating human-centered artificial intelligence in education",
            "text": "Weintrop and Wilensky (2017) emphasise that blockbased programming is a useful programming language to use in an educational context, as it has several key features that differentiate it from text-based programming and other visual programming languages. Most notable is the jigsaw-puzzle-piece metaphor, which is used to provide visual cues to the learner about which commands to use. The main advantage of block-based programming is that it reduces pupils' challenges in learning programming language syntax and renders programming more accessible to novices (Sengupta et al. 2013). Other researchers have highlighted microworlds and puzzles as metaphors connected with block-based programming and explored the potential of teaching introductory programming from a design science perspective, focusing on design guidelines and data analysis methods that can be used for designing and improving block-based programming (Pel\u00e1nek and Effenberger 2022). Namli and Aybek (2022) investigated the effect of block-based programming and unplugged coding on fifth graders' computational thinking skills, self-efficacy, and academic performance. The study included 82 fifth graders in middle school. The authors concluded that block-based programming activities had a moderate effect on computational thinking skills. Jiang et al. (2022) explored the programming trajectories, postulating that block-based programming languages provide effective scaffolding for K-12 students to learn computational thinking. Their main finding was identifying four different roles of blockbased programming learners in school: quitters, approachers, solvers, and knowers. \n\nIn this study, we used Microsoft's MakeCode for a micro:bit, a block-based programming environment used with a small computer (micro:bit). Combined, Microsoft MakeCode and micro:bit provide an accessible high-level programming environment for embedded devices without sacrificing performance and efficiency (Devine et al. 2019). Programming a micro:bit with MakeCode also allows learners to design and programme physical components, such as servo motors, sensors, actuators, and lamps, which are components of a makerspace. These components can form part of more complex visual artifacts composed of software and hardware.",
            "score": 0.32376307991952846,
            "section_title": "Block-based programming in education",
            "char_start_offset": 9444,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 254
                },
                {
                    "start": 255,
                    "end": 385
                },
                {
                    "start": 386,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 951
                },
                {
                    "start": 952,
                    "end": 1136
                },
                {
                    "start": 1137,
                    "end": 1190
                },
                {
                    "start": 1191,
                    "end": 1308
                },
                {
                    "start": 1309,
                    "end": 1499
                },
                {
                    "start": 1500,
                    "end": 1646
                },
                {
                    "start": 1649,
                    "end": 1787
                },
                {
                    "start": 1788,
                    "end": 1977
                },
                {
                    "start": 1978,
                    "end": 2172
                },
                {
                    "start": 2173,
                    "end": 2271
                }
            ],
            "ref_mentions": [
                {
                    "start": 561,
                    "end": 583,
                    "matchedPaperCorpusId": "14084830"
                },
                {
                    "start": 920,
                    "end": 950,
                    "matchedPaperCorpusId": "228943426"
                },
                {
                    "start": 952,
                    "end": 974,
                    "matchedPaperCorpusId": "245642958"
                },
                {
                    "start": 1309,
                    "end": 1328,
                    "matchedPaperCorpusId": "201134629"
                },
                {
                    "start": 1956,
                    "end": 1976,
                    "matchedPaperCorpusId": "47018308"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.69775390625
        },
        {
            "corpus_id": "15203327",
            "title": "A comparative study of linear and region based diagrams",
            "text": "Therearetwo categoriesof objects spatialinformation science investigates: actual objects and their spatial properties, such as in geography, and abstract objects which are employed metaphorically, as for visual languages. A prominent example of the latter are diagrams that model knowledge of some domain. Different aspects of diagrams are of in- terest, including their formal properties or how human users work with them, for example, with diagrams representing sets. The literature about diagrammatic systems for the repre- sentation of sets shows a dominance of region-based diagrams like Euler circles and Venn diagrams. The effectiveness of these diagrams, however, is limited because region-based diagrams become quite complex for more then three sets. By contrast, linear diagrams are not equally prevalent but enable the representation of a greater number of sets with- out getting cluttered. Cluttered diagrams exhibit inherent complexity due to overlapping objects, irrelevant details, or other reasons that impinge upon their legibility. This study contrasts both types of diagrammatic systems and investigates whether the performance of users differs for both kinds of diagrams. A significant difference can be shown regard- ing the number of diagrams that can be drawn within a fixed period of time and regarding the number of errors made. The results indicate that linear diagrams are more effective by being more restrictive and because region based diagrams show much clutter due to overlapping, coincident, and tangentially touching contours, as well as an overwhelming number of empty zones. Linear diagrams are less prone to errors and do not suffer from clutter.",
            "score": 0.3234775494662738,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.16259765625
        },
        {
            "corpus_id": "5790643",
            "title": "Block Shelves for Visual Programming Languages",
            "text": "The blocks editor, such as the editor in Scratch, is widely applied for visual programming languages (VPL) nowadays. Despite it's friendly for non-programmers, it exists three main limitations while displaying block codes: (1) the readability, (2) the program structure, and (3) the re-use. To cope with these issues, we introduce a novel formatting tool, block shelves, into the editor for organizing blocks. A user could utilize shelves to constitute a user-defined structure for the VPL projects. Based on the experiment results, block shelves improves the block code navigating and searching significantly. Besides, for achieving code re-use, users could use shelf export/import to share/re-use their block codes between projects in the file format of eXtensible Markup Language (xml.) All functions were demonstrated on MIT App inventor 2, while all modifications were made in Google Blockly.",
            "score": 0.32345148423365794,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8037109375
        },
        {
            "corpus_id": "199002134",
            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
            "text": "In this section, we first discuss the major problems and difficulties related to learning to program, particularly by novice programmers or primary and secondary pupils. As previously referred to, nowadays, pupils are starting to learn programming early in schools and it is important to identify and to understand their difficulties and select the most adequate programming tool to support their learning. The literature has recurrently shown that block-based and visual programming environments are powerful tools to support novices and pupils in the process of learning to program. Thus, in the second part of this section, we analyse some aspects related to these environments and how they could help pupils overcome the difficulties of the traditionally text-based languages.",
            "score": 0.32330478674696145,
            "section_title": "Background",
            "char_start_offset": 4699,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 169
                },
                {
                    "start": 170,
                    "end": 406
                },
                {
                    "start": 407,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 780
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7548828125
        },
        {
            "corpus_id": "5559880",
            "title": "Scratch Community Blocks: Supporting Children as Data Scientists",
            "text": "The Scratch Community Blocks system is tightly integrated with the Scratch interface and community, extends the list of programming primitives in Scratch, and uses the same visual block-based drag-and-drop editing paradigm as the core Scratch language. In addition to using a block-base editing paradigm, we tried to make Scratch Community Blocks consistent with the rest of the Scratch programming environment by (i) using programming constructs already known to Scratch users (e.g., \"accessor\" blocks, which we describe below) and by (ii) avoiding a large number of blocks or block parameters, as Scratch has traditionally avoided having complex blocks, or a large number of blocks, to avoid intimidating novice users [16]. This approach prevented us from considering alternate paradigms of interacting with data programmatically, such the read-eval-print loop (REPL) that is often seen in data-focused programming languages. One design that we considered involved the use of the list data structure in Scratch. We ended up not using this approach because research has shown that list are used infrequently in Scratch [2] and also because lists are not \"first class\" (i.e., they cannot be used as input to an outer block or inserted into another list). \n\nScratch Community Blocks was designed as an extension to the Scratch language and was made available directly inside the Scratch editor. To use the systems, a user clicks on an \"Add Extension\" button in the \"More Blocks\" category. This shows a dialog box listing several available extensions that the user can pick from including the Community Blocks system. When Figure 2: Accessor method block for Scratch sprites, with a dropdown to select the appropriate property. The shape of the block indicates it is a \"reporter\" block, and that it can be used as an input to another blocks (e.g., the \"say\" block). users choose the extension, a new palette of programming blocks, shown in Figure 3, appears in the programming editor. \n\nAlthough the Scratch language does not meet all the criteria necessary to be an object-oriented language (e.g., there is no inheritance mechanism), the model of programming in Scratch can be described as object-centered.",
            "score": 0.32230707887929944,
            "section_title": "DESIGN",
            "char_start_offset": 14546,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 252
                },
                {
                    "start": 253,
                    "end": 725
                },
                {
                    "start": 726,
                    "end": 927
                },
                {
                    "start": 928,
                    "end": 1013
                },
                {
                    "start": 1014,
                    "end": 1254
                },
                {
                    "start": 1257,
                    "end": 1393
                },
                {
                    "start": 1394,
                    "end": 1487
                },
                {
                    "start": 1488,
                    "end": 1615
                },
                {
                    "start": 1616,
                    "end": 1725
                },
                {
                    "start": 1726,
                    "end": 1863
                },
                {
                    "start": 1864,
                    "end": 1982
                },
                {
                    "start": 1985,
                    "end": 2205
                }
            ],
            "ref_mentions": [
                {
                    "start": 720,
                    "end": 724,
                    "matchedPaperCorpusId": "17452915"
                },
                {
                    "start": 1120,
                    "end": 1123,
                    "matchedPaperCorpusId": "13520484"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.4384765625
        },
        {
            "corpus_id": "212579568",
            "title": "AN EXTENSIBLE APPROACH TO GENERATE FLOWCHARTS FROM SOURCE CODE",
            "text": "Programming can be considered both as a science and as an art (Knuth D. E., 1974). Programming languages are built to instruct a computer to perform a sequence of computations. The syntax used by different programming language may vary from a language to language. However, irrespective of the programming language used to code an algorithm, there is only a finite number of abstract constructs that can be used to develop a program. How these constructs are combined to produce the expected result is an art and can be done in many different ways in different programming languages based on the software development maturity and the programming language knowledge of the developer. \n\nThe statements of a program define a logical flow of instructions. For a computer what matters is the sequence in which the instructions are to be executed. However, for a developer, who is writing or reading the code, what is important is the logical flow of the program instructions. It is hard for a developer to conceptualize the logic defined by a program just by reading the code. Even an experienced programmer may find it difficult to understand the logic of a program encoded by him/her at a later time. This is also an inherent problem in distributed software development environments. In a distributed software development environment original author of the code is not the only one responsible in maintaining the code, rather the same code may have to modified by some others. \n\nVisualization is proved to be a good way for understanding a program. Different types of diagrams such as class diagrams, entity-relationship diagrams and Unified Modelling Language (UML) are widely used in application development. Flowchart is a diagram which depicts a complex process by dissecting it into simple steps. Flowcharts are widely used across various disciplines (Wijayasiriwardhane, Wijayarathna, & Karunarathna, \"An automated tool to generate test cases for performing basis path testing\", 2011) (Wijayasiriwardhane, Wijayarathna, & Karunarathna, \"A Method to Generate Test Cases for Performing Basis Path Testing\", 2016) (Nassi & Shneiderman, 1973). In Computer Science (CS) flowchart is primarily used to explain algorithms. Thus, flowcharts is an ideal tool for depicting what a particular software source-code is supposed to do.",
            "score": 0.3222323145749151,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 82
                },
                {
                    "start": 83,
                    "end": 176
                },
                {
                    "start": 177,
                    "end": 264
                },
                {
                    "start": 265,
                    "end": 433
                },
                {
                    "start": 434,
                    "end": 682
                },
                {
                    "start": 685,
                    "end": 751
                },
                {
                    "start": 752,
                    "end": 841
                },
                {
                    "start": 842,
                    "end": 970
                },
                {
                    "start": 971,
                    "end": 1071
                },
                {
                    "start": 1072,
                    "end": 1197
                },
                {
                    "start": 1198,
                    "end": 1280
                },
                {
                    "start": 1281,
                    "end": 1473
                },
                {
                    "start": 1476,
                    "end": 1545
                },
                {
                    "start": 1546,
                    "end": 1707
                },
                {
                    "start": 1708,
                    "end": 1798
                },
                {
                    "start": 1799,
                    "end": 2142
                },
                {
                    "start": 2143,
                    "end": 2218
                },
                {
                    "start": 2219,
                    "end": 2324
                }
            ],
            "ref_mentions": [
                {
                    "start": 62,
                    "end": 81,
                    "matchedPaperCorpusId": "62312650"
                },
                {
                    "start": 2114,
                    "end": 2141,
                    "matchedPaperCorpusId": "38436079"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2010498046875
        },
        {
            "corpus_id": "60941791",
            "title": "Reflections on Using Robots and Visual Programming Environments for Project-Based Teaching",
            "text": "Visual programming is a method to specify a program in a two (or more) dimensional fashion [4], whereas in a textual language a programmer writes and a compiler or interpreter processes a program as a one-dimensional stream of symbols. Visual programming language uses meaningful graphic representation and manipulates visual information or supports visual interaction [5] in the process of programming. Visual elements based on imagery thinking provide a more natural approach for specifying a program than textual languages and the 2D representation is more suitable for representing parallel behaviour of complex systems consisting of multiple components such as robots. Visual languages are especially important in education, because their do not require formal knowledge of programming language syntax, are visually appealing and attractive to their users, and can be combined with additional engagement-enhancing concepts such as gamification [6]. \n\nThe Cognitive Dimensions introduced by Green and Petre [7] provide a framework for assessment of a programming system as follows: Closeness of mapping (closeness of programming structures to problem domain), Consistency (similar semantics are expressed in similar forms to allow inference), Error-proneness (possibility of making mistakes because of poor notational design), Hard mental operations (thought processes required to formulate an expression made difficult by the notation), Hidden Dependencies (important relationships between entities are not visible), Progressive evaluation (ability to execute the program partially, before all of it is put together), Role-expressiveness (purpose and role of each component is easily inferred), Secondary Other comparison criteria have been formulated by Howard [8]: Intended audience, Paradigm, Ease of use, Visual representation, Reusability, Data structures and types, Effective use of screen area, Effective use of colours, Clarity of graphical symbols, Interactive capabilities. \n\nNext we analyse a subset of visual languages used in educational setting for teaching robot programming.",
            "score": 0.3213007535264759,
            "section_title": "body",
            "char_start_offset": 1,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 235
                },
                {
                    "start": 236,
                    "end": 403
                },
                {
                    "start": 404,
                    "end": 673
                },
                {
                    "start": 674,
                    "end": 953
                },
                {
                    "start": 956,
                    "end": 1988
                },
                {
                    "start": 1991,
                    "end": 2095
                }
            ],
            "ref_mentions": [
                {
                    "start": 91,
                    "end": 94,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 949,
                    "end": 952,
                    "matchedPaperCorpusId": "220866115"
                },
                {
                    "start": 1011,
                    "end": 1014,
                    "matchedPaperCorpusId": "11750514"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9033203125
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "The paper presents an approach to learning and an environment for working with a hybrid visual - text programming language with a special emphasis on the training for future programmers at an early stage. An overview of other visual programming environments and languages is made and the advantages of the hybrid visual - text approach offered in this article are highlighted. Emphasis is placed on the practical implementation of a proprietary environment for the development of sample programs in the author's hybrid visual programming language. An example of the use of the environment is presented and perspectives for its development are formulated.",
            "score": 0.3213007535264759,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.79052734375
        },
        {
            "corpus_id": "234423886",
            "title": "Leveraging Graphical User Interface Automation for Generic Robot Programming",
            "text": "The widely used Google Blockly [31] tool has been shown to provide an easier entry for novice programmers than traditional programming environments, such as UR's Polyscope [19] and has been integrated into ABB's RobotStudio platform [32]. By offering more flexibility and a complete palette of control structures and statements, block-based programming presents some advantages over similar app-oriented approaches, such as Franka Emika Desk, which are often limited in terms of the program structures that can be used [33]. The VDI 2680 automated function symbols have also been used to decorate and guide the design of function blocks in an experimental constraint-based programming environment [26]. The way in which blocks are connected and parameterized differs from one block-based model to another. Whereas in Blockly, each block has a correspondent in textual programming, in Choregraph [34]-the programming tool provided with Pepper and other humanoid robots-blocks are connected with each other using lines and ports in a way that is reminiscent of function block programming [35]. While line-based connections between (function) blocks facilitate the representation of parallel computation and make data flow explicit, some researchers note that Choregraph and other similar visual programming models result in \"spaghetti code\", which is difficult to decipher [36]. \n\nList-based programming is a simple \"no-code\" programming model used by some proprietary (generic) programming environments (e.g., [8,37]) as an alternative to text-based programming. List-based programming is similar to block-based programming, with the difference that blocks are represented as indented, fixed-size rows in a list. In addition, each statement (i.e., row) is usually displayed including arguments and parameter values and provides icons for reordering and deletion. \n\nA comprehensive review of visual programming environments for end-user robot programming is provided in [36].",
            "score": 0.3213007535264759,
            "section_title": "Graphical Robot Programming",
            "char_start_offset": 14013,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 238
                },
                {
                    "start": 239,
                    "end": 524
                },
                {
                    "start": 525,
                    "end": 702
                },
                {
                    "start": 703,
                    "end": 805
                },
                {
                    "start": 806,
                    "end": 1091
                },
                {
                    "start": 1092,
                    "end": 1376
                },
                {
                    "start": 1379,
                    "end": 1561
                },
                {
                    "start": 1562,
                    "end": 1711
                },
                {
                    "start": 1712,
                    "end": 1861
                },
                {
                    "start": 1864,
                    "end": 1973
                }
            ],
            "ref_mentions": [
                {
                    "start": 31,
                    "end": 35,
                    "matchedPaperCorpusId": "44698743"
                },
                {
                    "start": 233,
                    "end": 237,
                    "matchedPaperCorpusId": "206371885"
                },
                {
                    "start": 519,
                    "end": 523,
                    "matchedPaperCorpusId": "198478410"
                },
                {
                    "start": 895,
                    "end": 899,
                    "matchedPaperCorpusId": "21256976"
                },
                {
                    "start": 1371,
                    "end": 1375,
                    "matchedPaperCorpusId": "219455753"
                },
                {
                    "start": 1968,
                    "end": 1972,
                    "matchedPaperCorpusId": "219455753"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.85986328125
        },
        {
            "corpus_id": "237977073",
            "title": "The Role of distance learning via the Internet in Learning Programming: Learners' Point of View",
            "text": "The latter adopted the presentation of the content in those lessons, and it does not include rearranging, synthesis, or formulation of its topics. Rather, it was adopted and based on the explanatory texts accompanying the practicalsoftware application designed as a video that is shown to them in a series of computerized lessons. \n\nThe second axis: Visual Basic 6.0 programming \n\nThe programming language (Visual Basic) in its sixth edition is considered one of the most prominent programming languages with a graphical interface, according to which the programmer can design programs with great capabilities in many areas of life, whether educational, application or even administrative, and it is produced by Microsoft, the leader in the production of software of wide variety, popularity,meticulous design, and implementation. the programmer in general and students, in particular, can design a variety of programs within them, ranging in level of difficulty from simple to more complex with detailed serving various fields. Halverson (1999) stated that Visual Basic is a program that works to perform tasks It enables users to write effective programs that are compatible with Windows operating system, and it works according to some basic instructions and commands and programming procedures in it (p. 27). Currently, a group of newer versions of this programming language has appeared, noting that this language was fully compatible with the versions of many operating systems, but there havebeen changesforthe stop of support, after the launch of several newer versions of it, which led to the difficulty of the work and practically applying it by many students on their modern personal computers, incompatible with these versions. This programming language consists of the main interface that includes implicit tapes and commands, and a toolbox with severalcharacteristics of each object, and it is operated in several ways that have been demonstrated within the lessons intended to learn the topic of the current study, as well as it featured of accuracy and ease of design, implementation, and tracking of outcomes.",
            "score": 0.32116147176422427,
            "section_title": "Interaction between learners.",
            "char_start_offset": 12709,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 330
                },
                {
                    "start": 333,
                    "end": 378
                },
                {
                    "start": 381,
                    "end": 830
                },
                {
                    "start": 831,
                    "end": 1028
                },
                {
                    "start": 1029,
                    "end": 1307
                },
                {
                    "start": 1308,
                    "end": 1312
                },
                {
                    "start": 1313,
                    "end": 1739
                },
                {
                    "start": 1740,
                    "end": 2126
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.11163330078125
        },
        {
            "corpus_id": "230607306",
            "title": "Teacher Perspectives on Introducing Programming Constructs through Coding Mobile-Based Games to Secondary School Students",
            "text": "Text-based programming languages rely heavily on typing of commands. In the case of Java such commands are case sensitive. Students must not only focus on the logical construction of programs but also keep an eye on the necessary syntax to end statements or to enclose commands within conditional, looping and method structures. All of these syntax rules can hinder learners from focusing on the main aim of programming, that is, problem solving. On the other hand, text-based programming languages can help the learner to write programs very quickly. This can only occur once the syntax and problem-solving processes have been mastered. \n\nVisual Programming Languages (VPLs) can overcome the shortcomings of textbased programming languages. The majority of VPLs, such as Scratch, Alice, and Kodu, use blockly coding (Howland & Good, 2015;Kalelio\u011flu, 2015). This means that the typing of commands is eliminated and instead all of the available commands are shown on screen and the user simply clicks and drags the command needed onto the instruction screen in order to create a program (Kalelio\u011flu, 2015), as shown in Fig. 1. This eliminates the possibility of syntax errors, a problem that occurs all the time when using text-based programming languages (Mladenovi\u0107 et al., 2017;Shapiro & Ahrens, 2016). Furthermore, it offers learners several hints such as the types of blocks that fit in certain parameters or commands (Shapiro & Ahrens, 2016). This is very useful for students who have just started studying programming -programming novices -and hence are still new to this area (Howland & Good, 2015;Shapiro & Ahrens, 2016). \n\nWhile VPLs offer many advantages as well as supporting an active learning pedagogy whereby students are active learners in an environment that stimulates \"fun, motivation, enthusiasm, and commitment from the student\" (S\u00e1ez-L\u00f3pez et al., 2016), they also offer some limitations especially for intermediate and advanced learners. Blocks do not give the desired freedom to these learners to edit rapidly, something which can only be done when using a keyboard. Moreover, with more complex programs, the programming commands seem to take up more space on screen when using a VPL (Shapiro & Ahrens, 2016).",
            "score": 0.32036114055717557,
            "section_title": "Visual Programming Languages",
            "char_start_offset": 6190,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 68
                },
                {
                    "start": 69,
                    "end": 122
                },
                {
                    "start": 123,
                    "end": 328
                },
                {
                    "start": 329,
                    "end": 446
                },
                {
                    "start": 447,
                    "end": 551
                },
                {
                    "start": 552,
                    "end": 637
                },
                {
                    "start": 640,
                    "end": 741
                },
                {
                    "start": 742,
                    "end": 857
                },
                {
                    "start": 858,
                    "end": 1125
                },
                {
                    "start": 1126,
                    "end": 1304
                },
                {
                    "start": 1305,
                    "end": 1447
                },
                {
                    "start": 1448,
                    "end": 1629
                },
                {
                    "start": 1632,
                    "end": 1959
                },
                {
                    "start": 1960,
                    "end": 2089
                },
                {
                    "start": 2090,
                    "end": 2232
                }
            ],
            "ref_mentions": [
                {
                    "start": 817,
                    "end": 839,
                    "matchedPaperCorpusId": "15817917"
                },
                {
                    "start": 839,
                    "end": 856,
                    "matchedPaperCorpusId": "34426855"
                },
                {
                    "start": 1086,
                    "end": 1104,
                    "matchedPaperCorpusId": "34426855"
                },
                {
                    "start": 1280,
                    "end": 1303,
                    "matchedPaperCorpusId": "187365431"
                },
                {
                    "start": 1422,
                    "end": 1446,
                    "matchedPaperCorpusId": "187365431"
                },
                {
                    "start": 1583,
                    "end": 1605,
                    "matchedPaperCorpusId": "15817917"
                },
                {
                    "start": 1605,
                    "end": 1628,
                    "matchedPaperCorpusId": "187365431"
                },
                {
                    "start": 1849,
                    "end": 1874,
                    "matchedPaperCorpusId": "27633066"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.83642578125
        },
        {
            "corpus_id": "232417326",
            "title": "Visuality in a Cross-disciplinary Battleground: Analysis of Inscriptions in Digital Humanities Journal Publications",
            "text": "Textual display of digitalization or computational procedures (e.g., algorithms, programming codes) Equations Mathematical expressions that were set off from the body of the text in the style of a block quotation (Arsenault et al., 2006) Tables Arrays of information consisting of rows and columns and set off from the body of the text (Arsenault et al., 2006) Texts Encoded representation of textual information (e.g., HTML, XML) \n\nWe retained most of the categories in Arsenault et al.'s (2006) original scheme, including the most frequently used inscriptions based on previous studies, tables and graphs (Caissie et al., 2017), as they also apply to our paper sample and more generally fit the humanistic approaches to inscriptions. Moreover, we also retained the top-level categories, i.e., graphs, non-graph illustrations, and non-visual illustrations, as a general organizing framework even though they are not used in our analysis. Like how the category is treated in classic literature, graphs refer to the broad family of information visualization as graphic representations of empirical data (Azzam et al., 2013), comparing to some other similar visual displays in the category of nongraph illustrations. This definition is especially helpful in our distinctions between graphs on the one hand, and maps and diagrams on the other hand, as both of which share some visual components that are central to their functions. \n\nMoreover, we added a few categories to the classification scheme to better accommodate the domain of digital humanities and our paper sample. Our changes are along two directions: (1) inscription types that are emerging and recent and (2) those that are specific to DH research. \n\nIn the first category, we added simulations (under NGI) and codes (under NVIs). With the rise of new visual technologies and techniques such as the virtual and augmented realities, simulations are frequently applied in papers on virtual cultural heritage and archaeology to showcase the design of a virtual program or the re-modelling of a physical site (Pujol-Tost, 2017). Similarly, as the demonstration of computational procedures of a task (e.g., algorithms or blocks of programming codes; Hsiang et al., 2012), a frequent use of codes suggests the increasing emphasis on computational methods in DH.",
            "score": 0.31956730642878367,
            "section_title": "Codes",
            "char_start_offset": 19428,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 430
                },
                {
                    "start": 433,
                    "end": 735
                },
                {
                    "start": 736,
                    "end": 938
                },
                {
                    "start": 939,
                    "end": 1214
                },
                {
                    "start": 1215,
                    "end": 1428
                },
                {
                    "start": 1431,
                    "end": 1572
                },
                {
                    "start": 1573,
                    "end": 1709
                },
                {
                    "start": 1712,
                    "end": 1791
                },
                {
                    "start": 1792,
                    "end": 2085
                },
                {
                    "start": 2086,
                    "end": 2316
                }
            ],
            "ref_mentions": [
                {
                    "start": 213,
                    "end": 237,
                    "matchedPaperCorpusId": "59107432"
                },
                {
                    "start": 336,
                    "end": 360,
                    "matchedPaperCorpusId": "59107432"
                },
                {
                    "start": 607,
                    "end": 629,
                    "matchedPaperCorpusId": "24582049"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.03155517578125
        },
        {
            "corpus_id": "231715481",
            "title": "Towards a Modular and Distributed End-User Development Framework for Human-Robot Interaction",
            "text": "Nodes in a BT can be of two types: (i) composite nodes or operators, which control the execution flow in the tree, and (ii) leaf nodes, which define the tasks composing the behaviors as well as the conditions triggering their execution. The BT execution algorithm assigns a status to each active node, which can be success if the task is completed without errors, or failure otherwise, or running during task execution. Composite nodes use these three possible statuses to perform behavior composition. For a deeper explanation of BTs the reader is referred to [38], [41]. Compared with FSM, BTs are known to be more modular: portions of code, denoted as ''sub-BTs'', can be easily re-used to create more complex tasks. \n\nThe main objective of RIZE is to provide a set of conceptual and operative tools that facilitate the integration of robot behavioral modules, specifically robot social skills, organized in a full-fledged software architecture. Rather than only focus on some specific programming or behavior modeling approach, RIZE was designed to enable the exploration of novel, structured, modular, reactive and advanced behavioral modeling methods and visual languages. This perspective represents the main difference with respect to previous EUP/EUD tools for robotics [1]. In the next sections, we present an example of a programming interface built on top of RIZE framework denoted as Open RIZE which uses a combination of FSMs and BTs for enabling decision-making. This interface integrates a programming environment extending the functionalities of Google Blockly to enable the intuitive creation of robot behaviors by novice end-users as well as the rapid prototyping and integration of robot-based applications. \n\nMost approaches in the literature employing a block-based Visual Programming Language (VPL), such as Google Blockly, allow for the direct translation of block definitions to code in a text-based programming language. We explored this approach in an early prototype of RIZE [42]. The programming environment proposed in [42] translates the structure developed in Google Blockly to text-based code in Python. The resulting Python code consists of a set of robot-agnostic functions, i.e., those able to connect and be used with different robots and to abstract low-level details and hardware instances [14].",
            "score": 0.31923830411140885,
            "section_title": "II. RELATED WORK AND CONTRIBUTIONS",
            "char_start_offset": 11440,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 236
                },
                {
                    "start": 237,
                    "end": 419
                },
                {
                    "start": 420,
                    "end": 502
                },
                {
                    "start": 503,
                    "end": 572
                },
                {
                    "start": 573,
                    "end": 719
                },
                {
                    "start": 722,
                    "end": 948
                },
                {
                    "start": 949,
                    "end": 1178
                },
                {
                    "start": 1179,
                    "end": 1283
                },
                {
                    "start": 1284,
                    "end": 1477
                },
                {
                    "start": 1478,
                    "end": 1727
                },
                {
                    "start": 1730,
                    "end": 1946
                },
                {
                    "start": 1947,
                    "end": 2008
                },
                {
                    "start": 2009,
                    "end": 2136
                },
                {
                    "start": 2137,
                    "end": 2334
                }
            ],
            "ref_mentions": [
                {
                    "start": 567,
                    "end": 571,
                    "matchedPaperCorpusId": "208121216"
                },
                {
                    "start": 1279,
                    "end": 1282,
                    "matchedPaperCorpusId": "212750787"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7939453125
        },
        {
            "corpus_id": "264371146",
            "title": "Core competencies of K-12 computer science education from the perspectives of college faculties and K-12 teachers",
            "text": "Regarding specific programming languages that should be taught in K-12, eight out of 13 interviewees suggest starting from block-based visual programming tools, such as Scratch and code.org. For example, Aiden says, \"so something like scratch will be very effective for young children. As for these young children, say grade six or below this kind of range. The priority should be about engagement, making it fun for them so they can see the problems can be solved for older children like high school children, then yes, absolutely.\" (Aiden, a CS associate professor) Eli, a K-12 teacher, says, \"I used code.org or scratch. That's all block-based programming. I want something to be manageable or something to be user-friendly, and I want whenever they come up with a solution.\" Similarly, Kate, Lucy, Arthur, and Diego echo the idea of using Block-based programming tools to teach K-12 students CS subjects. \n\nIn addition, four interviewees also mention that it might be better to start with block-based visual programming tools, such as Scratch, then transit to syntax-based programming languages, such as Python and other languages. For example, David says, \"I would say that if you start with a simple [programming language]. For elementary school, you have to choose something graphical. There are a lot of environments out there, like maybe Scratch and Alice, and there are a lot of others. And as you go up, let's say, middle school, you can start introducing nonvisual programming environments. And you can go, you know, it doesn't really matter, if Java or Python or C++ will be more difficult to learn, I think Python is good enough.\" (David, a CS associate professor) This idea is separately advanced by other interviewees. Per, Kash, \"for the sixth graders, definitely you know, it's good to introduce block-based (visual) programming ideas, but for a high school again, my opinion is to introduce Python.\" (Kash, a CS associate professor). Daxton holds a similar opinion: \"They're going to have to know how to do sequence selection iteration, whether it's graphical or not.",
            "score": 0.31833127260276145,
            "section_title": "Code I: From Block-Based Programming to Syntax-Based Languages",
            "char_start_offset": 30224,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 190
                },
                {
                    "start": 191,
                    "end": 285
                },
                {
                    "start": 286,
                    "end": 357
                },
                {
                    "start": 358,
                    "end": 533
                },
                {
                    "start": 534,
                    "end": 611
                },
                {
                    "start": 612,
                    "end": 623
                },
                {
                    "start": 624,
                    "end": 659
                },
                {
                    "start": 660,
                    "end": 778
                },
                {
                    "start": 779,
                    "end": 908
                },
                {
                    "start": 911,
                    "end": 1135
                },
                {
                    "start": 1136,
                    "end": 1229
                },
                {
                    "start": 1230,
                    "end": 1292
                },
                {
                    "start": 1293,
                    "end": 1396
                },
                {
                    "start": 1397,
                    "end": 1502
                },
                {
                    "start": 1503,
                    "end": 1644
                },
                {
                    "start": 1645,
                    "end": 1734
                },
                {
                    "start": 1735,
                    "end": 1918
                },
                {
                    "start": 1919,
                    "end": 1952
                },
                {
                    "start": 1953,
                    "end": 2086
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.49951171875
        },
        {
            "corpus_id": "62545126",
            "title": "The Art of Computer Graphics Programming: Translating Pioneer Programs",
            "text": "The first part of The Art of Computer Graphics Programming, \"Introduction to the Medium\", presents information about hardware and software. The final part of the book, again very technical, discusses graphic packages for 2D and 3D--modeling, and for rendering still images and animations. In Part 2, \"Elementary Graphics Program\", after a brief introduction to Pascal syntax basics, the book introduces computational design concepts along with programming techniques, all of which are illustrated with sample codes. The codes on Chapters 5 through 15 were translated in the present research. The main computational concepts presented in the book are described below. \n\nChapter 8, \"Graphic Vocabularies\", introduces the \"distinction between the essential and accidental properties of an object\" (p. 167), i.e., between the general description of an object (its type) and its actual instantiation. The same chapter describes the \"Parameterization of Graphic Elements\" (p. 166), including a discussion about ranges of parameters, and the degrees of freedom of a parameterized element. The chapter ends with a section called \"Defining vocabularies\" of graphic elements\". Chapter 9, \"Repetition\", introduces \"Principles of regular composition\" (p. 201), and proceeds with the \"Use of Control Structures to Express Compositional Rules\" (p. 202), which means looping through code with statements such as For/Next, While/Do and Repeat/Until. This chapter ends with a discussion about generate--and--test--procedures. \n\nChapter 11, \"Conditionals\", presents structures that allows \"to vary conditionally, according to context\" (p. 273): If/Then/Else and Boolean variables. This concept is exemplified by many design situations, such as choosing among many design alternatives (state--action diagrams), exterior and interior conditions, conditional insertion of architectural elements to generate rhythms, and generate--and--test--procedures. \n\nChapter 12, \"Hierarchical structures\", shows how to create subsystems and spatial relations by specifying \"the relation between its constituent vocabulary elements\" (p. 324). It also introduces the concepts of recursion and recursive subdivision.",
            "score": 0.31815208617474316,
            "section_title": "Structure of the Book",
            "char_start_offset": 3993,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 139
                },
                {
                    "start": 140,
                    "end": 288
                },
                {
                    "start": 289,
                    "end": 515
                },
                {
                    "start": 516,
                    "end": 591
                },
                {
                    "start": 592,
                    "end": 666
                },
                {
                    "start": 669,
                    "end": 797
                },
                {
                    "start": 798,
                    "end": 895
                },
                {
                    "start": 896,
                    "end": 969
                },
                {
                    "start": 970,
                    "end": 1081
                },
                {
                    "start": 1082,
                    "end": 1166
                },
                {
                    "start": 1167,
                    "end": 1242
                },
                {
                    "start": 1243,
                    "end": 1333
                },
                {
                    "start": 1334,
                    "end": 1433
                },
                {
                    "start": 1434,
                    "end": 1508
                },
                {
                    "start": 1511,
                    "end": 1620
                },
                {
                    "start": 1621,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1931
                },
                {
                    "start": 1934,
                    "end": 2102
                },
                {
                    "start": 2103,
                    "end": 2108
                },
                {
                    "start": 2109,
                    "end": 2180
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1820068359375
        },
        {
            "corpus_id": "261582331",
            "title": "Identifying Defect-Inducing Changes in Visual Code",
            "text": "The most related work to visual code is the SZZ variant introduced by Sinha et al. [27] that performs graph-based differencing of Program Dependence Graphs [35] regions in textual code. In our work, we also perform tree-based differencing to identify changes in a tree-based intermediate representation of visual code. \n\nTo the best of our knowledge, none of the SZZ variants have accounted for changes in visual programming languages since changes in graphical elements such as nodes and edges are different from changes in lines of code and naturally cannot be compared line-by-line even if visual code is stored in a textual format like JSON.",
            "score": 0.31815208617474316,
            "section_title": "II. BACKGROUND -SZZ ALGORITHM",
            "char_start_offset": 7210,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 185
                },
                {
                    "start": 186,
                    "end": 318
                },
                {
                    "start": 321,
                    "end": 645
                }
            ],
            "ref_mentions": [
                {
                    "start": 83,
                    "end": 87,
                    "matchedPaperCorpusId": "43741178"
                },
                {
                    "start": 156,
                    "end": 160,
                    "matchedPaperCorpusId": "17846352"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.39013671875
        },
        {
            "corpus_id": "267616931",
            "title": "LLMs for Coding and Robotics Education",
            "text": "In the realm of Visual Programming Code Generation, research has explored innovative approaches to translating visual inputs into executable code. Among these approaches, leveraging multimodal models to interpret and generate code from visual diagrams, such as the FIRST LEGO League (FLL) block diagrams, represents a cutting-edge frontier. ChainCoder introduces a multi-pass code generation framework that uses a unique syntax hierarchy to enhance stepwise reasoning in LLMs, aiming to improve code accuracy and syntactic coherence. It employs a syntax-aware tokenizer and a specialized transformer to leverage structured, syntactically aligned data for progressive, multi-level code generation [46]. VISPROG is a system that leverages the in-context learning capabilities of language models to transform natural language instructions into visual programs for complex visual tasks, enabling the creation of sophisticated visual solutions directly from user inputs [18]. However, our investigations reveal that not all multimodal models are equally proficient at generating high-quality code from such visual inputs. For instance, while GPT-4V demonstrates remarkable capability in this domain, another model, Copilot, falls short. This discrepancy may stem from several factors. First, Copilot might struggle with prompts not written in English, highlighting a potential language bias. Second, its generation and evaluation modules, primarily trained on natural images, may not effectively interpret visual diagrams, which are fundamentally different in structure and content from typical photographic imagery. \n\nIn light of these challenges, our research pivoted towards leveraging textual prompts to generate pseudocode as an intermediary step. This approach capitalizes on the superior textual processing capabilities of multimodal models over their visual processing counterparts. By instructing the model to generate step-by-step, finely represented pseudocode instead of a coarse overview, we harness the model's linguistic strengths. Our prompts are meticulously crafted to guide the model in this process, resulting in more accurate and functional code generation. \n\nOur testing, conducted in a zero-shot learning context, underscores the potential of these models. However, it also opens avenues for further exploration into few-shot learning and fine-tuning strategies. Such enhancements could significantly improve the models' code generation capabilities, especially when dealing with complex visual inputs or domain-specific requirements.",
            "score": 0.31815208617474316,
            "section_title": "Visual Programming Code Generation",
            "char_start_offset": 24668,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 146
                },
                {
                    "start": 147,
                    "end": 340
                },
                {
                    "start": 341,
                    "end": 533
                },
                {
                    "start": 534,
                    "end": 701
                },
                {
                    "start": 702,
                    "end": 970
                },
                {
                    "start": 971,
                    "end": 1116
                },
                {
                    "start": 1117,
                    "end": 1231
                },
                {
                    "start": 1232,
                    "end": 1279
                },
                {
                    "start": 1280,
                    "end": 1386
                },
                {
                    "start": 1387,
                    "end": 1611
                },
                {
                    "start": 1614,
                    "end": 1747
                },
                {
                    "start": 1748,
                    "end": 1885
                },
                {
                    "start": 1886,
                    "end": 2041
                },
                {
                    "start": 2042,
                    "end": 2173
                },
                {
                    "start": 2176,
                    "end": 2274
                },
                {
                    "start": 2275,
                    "end": 2380
                },
                {
                    "start": 2381,
                    "end": 2552
                }
            ],
            "ref_mentions": [
                {
                    "start": 965,
                    "end": 969,
                    "matchedPaperCorpusId": "253734854"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.70166015625
        },
        {
            "corpus_id": "235234208",
            "title": "Collaborative Coding in a Robotic Visual Language",
            "text": "Visual Programming reduces the need to write lond textual programs. Program thus have multiple dimensions not only the text (Burnett and McIntyre, 1995). The idea is that with visual constructs, it could have a better learning curve and be more appealing. \n\nFor example, with a robotic visual programming language, users can program the robot without writing a textual code and without significant knowledge of any programming language. Examples include Make Block1 and Open Roberta2 for programming different hardware systems using blocks. \n\nVisual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990).",
            "score": 0.31815208617474316,
            "section_title": "VISUAL PROGRAMMING",
            "char_start_offset": 2075,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 67
                },
                {
                    "start": 68,
                    "end": 153
                },
                {
                    "start": 154,
                    "end": 255
                },
                {
                    "start": 258,
                    "end": 436
                },
                {
                    "start": 437,
                    "end": 540
                },
                {
                    "start": 543,
                    "end": 682
                }
            ],
            "ref_mentions": [
                {
                    "start": 124,
                    "end": 152,
                    "matchedPaperCorpusId": "14994189"
                },
                {
                    "start": 668,
                    "end": 681,
                    "matchedPaperCorpusId": "7335020"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.94482421875
        },
        {
            "corpus_id": "245877528",
            "title": "JSOL: JavaScript Open-source Library for Grammar of Graphics",
            "text": "Visualization libraries are of a distinct number of architectures' types: \n\n\u2022 Hierarchical: Layers and components are implemented in a hierarchical view, so that when a new scene graph introduced, authors build it in layers employing the components. In case that the graphic depends on the same component they will be linked. \n\n\u2022 Parallel: Building layers and components in two parallel independent levels, so when a scene graph proposed users use the component given by the system to implement it or to customize their graphics. \u2022 Hybrid: It is a combination of the previous couple of types. The compiler and layers are hierarchical; however, layers' design is parallel (JSOL adopts this type). \n\nThe compiler added on the top layer makes JSOL a declarative domain specific language (DSL) for visualization design; by decoupling specification from execution details, declarative systems allow users to focus on specifying their application domain without limiting their abilities to customize. \n\n[6] and [4] followed the same approach of the DSL compilation criterion; however, they use a declarative framework for mapping data to visual elements. Nevertheless, JSOL does not strictly impose a toolkit-specific lexicon of graphical marks; instead, JSOL directly maps data attributes to the HTML5 canvas element.",
            "score": 0.31815208617474316,
            "section_title": "Specification",
            "char_start_offset": 8153,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 73
                },
                {
                    "start": 76,
                    "end": 249
                },
                {
                    "start": 250,
                    "end": 325
                },
                {
                    "start": 328,
                    "end": 529
                },
                {
                    "start": 530,
                    "end": 592
                },
                {
                    "start": 593,
                    "end": 695
                },
                {
                    "start": 698,
                    "end": 994
                },
                {
                    "start": 997,
                    "end": 1148
                },
                {
                    "start": 1149,
                    "end": 1312
                }
            ],
            "ref_mentions": [
                {
                    "start": 1005,
                    "end": 1008,
                    "matchedPaperCorpusId": "6868591"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.62744140625
        },
        {
            "corpus_id": "149925230",
            "title": "Approaches to Assess Computational Thinking Competences Based on Code Analysis in K-12 Education: A Systematic Mapping Study",
            "text": "In this article, we present the state of the art on approaches to assess computer programs developed by students using block-based visual programming languages in K-12 education. We identified 23 relevant articles, describing 14 different approaches. The majority of the approaches focuses on the assessment of Scratch, Snap! or App Inventor programs, with only singular solutions for other block-based programming languages. By focusing on performance-based assessments based on the analysis of the code created by the students, the approaches infer computational thinking competencies, specifically related to the concept of algorithms and programming, using static, dynamic or manual code analysis. Most approaches analyze concepts directly related to algorithms and programming, while some approaches analyze also other topics such as design and creativity. Eight approaches have been automated in order to support the teacher, while some also provide feedback directly to the students. The approaches typically provide feedback in form of a score based on the analysis of the code, including dichotomous or polytomous scores for single areas/concepts as well as composite scores providing a general result. Only few approaches explicitly provide suggestions or tips on how to improve the code and/or use gamification elements, such as badges. As result of the analysis, a lack of consensus on the assessment criteria and instructional feedback has become evident as well as the need of such support to a wider variety of block-based programming languages. We also observed a lack of contextualization of these approaches within the educational setting, indicating for example on how the approaches can be completed by alternative assessment methods such as observations or interviews in order to provide a more comprehensive feedback covering also concepts and practices that may be difficult to be assessed automatically. These results indicate the need for further research in order to support a wide application of computing education in K-12 schools.",
            "score": 0.3181248293000112,
            "section_title": "Conclusions",
            "char_start_offset": 39453,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 178
                },
                {
                    "start": 179,
                    "end": 250
                },
                {
                    "start": 251,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 701
                },
                {
                    "start": 702,
                    "end": 861
                },
                {
                    "start": 862,
                    "end": 990
                },
                {
                    "start": 991,
                    "end": 1211
                },
                {
                    "start": 1212,
                    "end": 1347
                },
                {
                    "start": 1348,
                    "end": 1560
                },
                {
                    "start": 1561,
                    "end": 1927
                },
                {
                    "start": 1928,
                    "end": 2059
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.693359375
        },
        {
            "corpus_id": "19673407",
            "title": "Towards a First Implementation of the WLIMES Approach in Living System Studies Advancing the Diagnostics and Therapy in Personalized Medicine",
            "text": "The idea of having a visual modeling system for mathematics based on AI/ML, computer graphics and animation analogous to a sophisticated combination of the open source Processing 26 software sketchbook/language for coding in the visual arts and Wolfram Mathematica\u2122 27 for technical calculations and plotting in the sciences is a powerful one. It can allow maximal illustration and exploration of abstract concepts and objects e.g. through haptic interaction. Of particular interest here is the visual representation of the formal semantics of mappings to compute emerging and evolving properties in multi-level systems/categories, which is the focus of the present project. Category theory (Mac Lane, 1998;Awodey, 2006) has been used as universal modelling tool to resolve complex problems not only in physics, engineering and design, but also in life sciences (Ehresmann and Vanbremeersch, 1987;Rosen, 1991Rosen, , 1999Ehresmann and Vanbremeersch, 2007;Louie, 2009Louie, , 2013Ehresmann, 2017b). A number of higher-order logics, calculi and functional programming languages for categories have been also designed or adopted (e.g. Haskell, ML, Coq, OBJ, OCaml, CAM, Idris, Agda, as well as LISP/SCHEME/Clojure and Scala). Globular is perhaps the newest development in the field. The system 28 developed by Bar and Vicary at Oxford University ) is a very sophisticated tool 29 for visual modelling of higher category theory. Higher-order categories, today a well-studied domain, were initially introduced by Charles Ehresmann in 1963 and developed in several papers along with his wife Andr\u00e9e until his death in 1979. Globular is tailored to visually represent complex computations in higher order (or 'multiple') categories such as 2-or 3-categories or monoidal categories which allow a simultaneous planar (2D) handling of several composition laws. Andr\u00e9e C. Ehresmann has thought of introducing multiple categories in her formal theory MES, but she argues that they are not suitable for addressing the main questions, which WLIMES raises with using conventional categories for modelling living systems. Another approach of this work plan considers linking parts of this research to the one suggested by Goranson, known as Two-Sorted Logic (",
            "score": 0.31807559266222896,
            "section_title": "Related Work",
            "char_start_offset": 74804,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 862,
                    "end": 897,
                    "matchedPaperCorpusId": "26959302"
                },
                {
                    "start": 979,
                    "end": 996,
                    "matchedPaperCorpusId": "90539947"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.11358642578125
        },
        {
            "corpus_id": "269157125",
            "title": "PyTorchGeoNodes: Enabling Differentiable Shape Programs for 3D Shape Reconstruction",
            "text": "Procedural modelling is an attractive way of generating 3D shapes in computer graphics, and as such it is an interesting feature of different 3D modelling software. In general, procedural modelling is a family of techniques that generate 3D content by abiding to a set of rules. A variety of methods were proposed that combine procedural modeling with machine learning approaches, summarized in detail in [30]. For example, [35] introduced a procedural language that enables the generation of a variety of shapes in form of so called shape programs. In [35], shape programs are written in Domain Specific Language (DSL) for shapes with two types of statements. \"Draw\" statements describes shape primitive, such as cuboid or a cylinder, together with its geometric and semantic properties. \"For\" statements represent loops of sub-programs including parameters that indicate how the sub-program should be repeatedly executed. \n\n[35] also showed that it is possible to learn to infer shape programs that describe input 3D shapes. However, as it is based on basic geometric primitives, it becomes difficult to model more complex geometries, and resulting shapes can be non-representative of the target category. Other methods suffer from the same limitations [15,16]. \n\nGeoCode [27] recently introduced hand-designed shape programs as a mapping between 3D shapes of a specific object category and human-interpretable parameter space. The language used for developing shape programs is based on the geometry node feature of Blender, an open-source modeling software, which, in contrast to [35], allows designing of more expressive shape programs that can represent and interpolate between a variety of shapes by simply modifying human-interpretable program's parameters. \n\nSome nodes define a shape primitive or pre-designed more complex shapes, e.g., chair seat or chair leg. Other nodes represent geometric transformations on individual shapes, or how two shapes should be connected, e.g., legs should always be connected to the bottom of the seat. There are nodes representing mathematical operations such as addition and multiplication, and there are nodes that are used to replicate specific shapes, e.g., in case of chair legs we can add a replicator node to create four instances of a chair leg of the same shape.",
            "score": 0.31788275295998963,
            "section_title": "Shape Programs",
            "char_start_offset": 9053,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 164
                },
                {
                    "start": 165,
                    "end": 278
                },
                {
                    "start": 279,
                    "end": 410
                },
                {
                    "start": 411,
                    "end": 549
                },
                {
                    "start": 550,
                    "end": 660
                },
                {
                    "start": 661,
                    "end": 788
                },
                {
                    "start": 789,
                    "end": 923
                },
                {
                    "start": 926,
                    "end": 1026
                },
                {
                    "start": 1027,
                    "end": 1207
                },
                {
                    "start": 1208,
                    "end": 1263
                },
                {
                    "start": 1266,
                    "end": 1429
                },
                {
                    "start": 1430,
                    "end": 1765
                },
                {
                    "start": 1768,
                    "end": 1871
                },
                {
                    "start": 1872,
                    "end": 2045
                },
                {
                    "start": 2046,
                    "end": 2315
                }
            ],
            "ref_mentions": [
                {
                    "start": 405,
                    "end": 409,
                    "matchedPaperCorpusId": "258236273"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1873779296875
        },
        {
            "corpus_id": "232257861",
            "title": "Towards a Systematic Engineering of Industrial Domain-Specific Languages",
            "text": "Our approach, summarized in Fig. 1 as a conceptual model, starts from a classical domain-driven approach where users define the business requirements such as number of states and transitions in a state machine. The systematic approach to developing graphical DSLs is based on domain-driven design [29], allowing developers to create graphical DSLs aimed at better modelling software and system architectures. These business requirements, specific to each project, are first translated into a DSL Building Block that primarily consists of three parts: (1) the language, which defines the abstract syntax, graphical concrete syntax and semantics of the language; (2) the method, which describes how to reach a modelling goal; and (3) the nucleus, which describes the visual representations and notations for better UX on model elements. In our example, defining these parts leads to a structured definition of a state machine DSL Building Block, which is then extended to specific industrial examples such as different traffic signalling systems, an oven or a heater, or systems that require sequential control logic. The outcome of this developmental approach is to prevent the reinvention of the same method, language and nucleus parts of similar graphical DSLs more than once. \n\nThe development and usage of a graphical DSL based on DSL Building Blocks is segregated into three logical levels and is performed by three actors whose tasks and activities are described in Fig. 2. At the concept level, a DSL Building Block Developer, who is a modelling expert with additional expertise in UX, and language engineering (such as key expert engineers in software and systems research units at Siemens), describes the constraints and method of use of the DSL, the abstract syntax, the graphical concrete syntax along with a structured documentation of model elements and the nucleus consisting of visual notations and representations of the model elements in accordance with the requirements specified by users. As well as defining the parts generically, such as for a state machine, they also identify and define project specific DSL Building Block requirements, such as for a traffic signal system. The tool-specific implementation level is where a DSL Developer, equipped with sufficient programming skills needed for building graphical DSLs, selects the relevant graphical modelling tool in accordance to their organization and develops the DSL Building Block and its corresponding DSL.",
            "score": 0.3178164320197611,
            "section_title": "A. DSL Building Block Structure",
            "char_start_offset": 9153,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 210
                },
                {
                    "start": 211,
                    "end": 408
                },
                {
                    "start": 409,
                    "end": 834
                },
                {
                    "start": 835,
                    "end": 1115
                },
                {
                    "start": 1116,
                    "end": 1277
                },
                {
                    "start": 1280,
                    "end": 2006
                },
                {
                    "start": 2007,
                    "end": 2195
                },
                {
                    "start": 2196,
                    "end": 2485
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.61572265625
        },
        {
            "corpus_id": "253660127",
            "title": "Incorporating Multimedia Teaching Methods and Computational Thinking into the Baking Dessert Course",
            "text": "According to Alberts and Stevenson (2017), \"multimedia\" materials are merely forms of media that combine two or more types of media to digitally exchange information or content [40]. Computers lie at the core of multimedia materials, as they can simultaneously present text, images, audio and animation. Students significantly improved their foodrelated knowledge, attitudes and intentions after receiving multimedia-based education. \n\nTraditional, text-based program design is largely rooted in abstract conceptions that are difficult to learn, resulting in low interest and even a fear of the topic among students [41]. Thus, visual programming languages have been specially designed to reduce the difficulty of learning programming. Kelleher and Pausch (2005) identify three common features of visual programming environments: a simplified program-design process, the provision of instructional material support to students and an emphasis on students' learning motivations [42]. Selby and Wollard (2013) assert that program-design activities are associated with computational capabilities, as the process of learning programming enables students to develop holistic computational thinking skills, such as debugging, pattern recognition and abstraction [43]. Hsu and Chien (2015), having applied web-based multimedia technology to a culinary course, show that this approach enhances students' culinary skills [44]. Malan and Leitner (2007) show that, when learning visual programming, students often perceive themselves to be playing a game rather than writing programs, enhancing their understanding of programming concepts [45]. The use of visual programming languages in education and block-based narrative programming enables students to progressively develop their thinking skills, avoid spelling and grammar errors, and concentrate on the logical and structural elements of program design [46]. In recent years, the ADDIE and ASSURE teaching models have been extensively used in the development of multimedia strategies in education. The models are described below: \n\n1. \n\nSystemized ADDIE teaching model According to Ismail et al. (2018), the ADDIE model primarily encompasses three concepts: what to learn, how to learn and how to determine that the student has achieved the desired learning outcomes [47]. ADDIE is an acronym covering five stages: Analysis, Design, Development, Implementation and Evaluation.",
            "score": 0.31733678482853733,
            "section_title": "Motion Media-Based Teaching",
            "char_start_offset": 11607,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 182
                },
                {
                    "start": 183,
                    "end": 303
                },
                {
                    "start": 304,
                    "end": 433
                },
                {
                    "start": 436,
                    "end": 621
                },
                {
                    "start": 622,
                    "end": 735
                },
                {
                    "start": 736,
                    "end": 982
                },
                {
                    "start": 983,
                    "end": 1261
                },
                {
                    "start": 1262,
                    "end": 1417
                },
                {
                    "start": 1418,
                    "end": 1633
                },
                {
                    "start": 1634,
                    "end": 1903
                },
                {
                    "start": 1904,
                    "end": 2042
                },
                {
                    "start": 2043,
                    "end": 2074
                },
                {
                    "start": 2077,
                    "end": 2079
                },
                {
                    "start": 2082,
                    "end": 2317
                },
                {
                    "start": 2318,
                    "end": 2421
                }
            ],
            "ref_mentions": [
                {
                    "start": 13,
                    "end": 41,
                    "matchedPaperCorpusId": "151987094"
                },
                {
                    "start": 177,
                    "end": 181,
                    "matchedPaperCorpusId": "151987094"
                },
                {
                    "start": 616,
                    "end": 620,
                    "matchedPaperCorpusId": "70424"
                },
                {
                    "start": 736,
                    "end": 762,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 977,
                    "end": 981,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 1262,
                    "end": 1282,
                    "matchedPaperCorpusId": "58938566"
                },
                {
                    "start": 1412,
                    "end": 1416,
                    "matchedPaperCorpusId": "58938566"
                },
                {
                    "start": 1418,
                    "end": 1442,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 1628,
                    "end": 1632,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 1898,
                    "end": 1902,
                    "matchedPaperCorpusId": "67714046"
                },
                {
                    "start": 2127,
                    "end": 2147,
                    "matchedPaperCorpusId": "56051537"
                },
                {
                    "start": 2312,
                    "end": 2316,
                    "matchedPaperCorpusId": "56051537"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.455078125
        },
        {
            "corpus_id": "229358825",
            "title": "Enhancing Confidence in Using Computational Thinking Skills via Playing a Serious Game: A Case Study to Increase Motivation in Learning Computer Programming",
            "text": "Instead they define it as the process of making abstractions [21], [24] whereby the data and various CS concepts (i.e. computer programming constructs) are presented without clarifying any implementation details, in a form similar to the description of semantics [52]. Thus, if CT is defined as the ability to develop high-level conceptual design skills, then students with CT abilities can find computer programming much easier than others as learning computer programming requires the ability to select the appropriate symbolic and numerical data to produce computational solutions. Therefore, CT is related to conceptualizing and modelling solutions at an abstract, context-free level, whereas computer programming is directly related to the context rather than the concept of a solution and consequently focuses on the logical and physical realization of a solution within that context. \n\nOwing to their easy engagement and motivational nature, games and game-based tools have been proposed by many studies both to increase the motivation in computer programming classes and also as a method to practice skills in CT [54]- [57]. As discussed above, there is an overwhelming number of works in this area which can be classified into three main categories as game development with visual tools [58], [59], extensive game development [60], [61] and learning through game-play [17], [62]- [64]. All three approaches reported success with a radical increase in students' motivation to learn programming, hence this provided some evidence that integrating games into the education of introductory computer programming is a promising strategy. \n\nIn game development with visual tools, students are exposed to create visual abstractions without the need to write excessive programming code or have a background in games programming via visual programming tools such as Scratch [26] or Alice [27]. Complex scenarios can be created in these environments by combining character behaviors which inevitably requires an understanding of programming sequence, conditionals, iterations and methods. Furthermore, visual programming tools remove the syntax rules of actual programming languages and present programmatic representations as blocks through a simple drag and drop interface. This cleverly separates the programming logic from programming grammar and syntax, allowing students to focus on developing programming strategies with little or no programming background.",
            "score": 0.31723208836665995,
            "section_title": "II. RESEARCH BACKGROUND",
            "char_start_offset": 10956,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 268
                },
                {
                    "start": 269,
                    "end": 584
                },
                {
                    "start": 585,
                    "end": 890
                },
                {
                    "start": 893,
                    "end": 1132
                },
                {
                    "start": 1133,
                    "end": 1394
                },
                {
                    "start": 1395,
                    "end": 1640
                },
                {
                    "start": 1643,
                    "end": 1892
                },
                {
                    "start": 1893,
                    "end": 2086
                },
                {
                    "start": 2087,
                    "end": 2273
                },
                {
                    "start": 2274,
                    "end": 2462
                }
            ],
            "ref_mentions": [
                {
                    "start": 61,
                    "end": 65,
                    "matchedPaperCorpusId": "8291636"
                },
                {
                    "start": 1127,
                    "end": 1131,
                    "matchedPaperCorpusId": "37121295"
                },
                {
                    "start": 1302,
                    "end": 1306,
                    "matchedPaperCorpusId": "20505878"
                },
                {
                    "start": 1335,
                    "end": 1339,
                    "matchedPaperCorpusId": "845473"
                },
                {
                    "start": 1341,
                    "end": 1345,
                    "matchedPaperCorpusId": "206721106"
                },
                {
                    "start": 1377,
                    "end": 1381,
                    "matchedPaperCorpusId": "31224931"
                },
                {
                    "start": 1383,
                    "end": 1387,
                    "matchedPaperCorpusId": "17756429"
                },
                {
                    "start": 1389,
                    "end": 1393,
                    "matchedPaperCorpusId": "69496254"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6982421875
        },
        {
            "corpus_id": "242076483",
            "title": "Tooee: A Novel Scratch Extension for K-12 Big Data and Artificial Intelligence Education Using Text-Based Visual Blocks",
            "text": "There are many programming environments that allow K-12 students to learn the basic concepts of big data and artificial intelligence (AI) [1]- [10]. Through these environments, young students can implement basic-level big data and AI programs; for example, students can (1) visualize national cabbage production data [11], (2) perform a sentiment analysis using Twitter data [2], (3) train a machine learning model that distinguishes between a dog and a cat [3], and (4) create a game program using a pre-trained model that recognizes the position of a face [1]. In order to implement these types of programs, students often use block-based programming \n\nThe associate editor coordinating the review of this manuscript and approving it for publication was Anandakumar Haldorai . languages such as Scratch. By using these programming languages, they can implement programs as easily as assembling LEGO blocks by dragging and dropping ''visual blocks.'' However, a limitation of these approaches is that because the provided visual blocks are designed to perform only specific types of tasks, it is not easy for students to create various types of big data and AI programs based on these blocks. For example, when using [1] or [2], while students can acquire Twitter data using ''Twitter blocks,'' it's difficult for them to crawl data from Facebook, Instagram or other websites because the corresponding visual blocks are not provided. As another example, while students can train a machine learning model using ''machine learning blocks,'' changing the corresponding neural network structures based on these types of blocks is challenging. An illustrative example of our approach: (1) For Weather Forecast, Scratch asks Tooee for weather information for a specific city, and if Tooee returns ''sunny,'' the sunny icon is then displayed on the screen. (2) For Color Classification, if a user presses the ''r'' key, Scratch teaches Tooee that the current screen is red. After that, if the user presses the space key when a new screen appears, Scratch asks Tooee what color the current screen is, and if Tooee answers red, a red object appears on the screen.",
            "score": 0.31716716781837373,
            "section_title": "I. INTRODUCTION",
            "char_start_offset": 18,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 148
                },
                {
                    "start": 149,
                    "end": 562
                },
                {
                    "start": 563,
                    "end": 652
                },
                {
                    "start": 655,
                    "end": 778
                },
                {
                    "start": 779,
                    "end": 805
                },
                {
                    "start": 806,
                    "end": 951
                },
                {
                    "start": 952,
                    "end": 1193
                },
                {
                    "start": 1194,
                    "end": 1434
                },
                {
                    "start": 1435,
                    "end": 1639
                },
                {
                    "start": 1640,
                    "end": 1850
                },
                {
                    "start": 1851,
                    "end": 1967
                },
                {
                    "start": 1968,
                    "end": 2155
                }
            ],
            "ref_mentions": [
                {
                    "start": 458,
                    "end": 461,
                    "matchedPaperCorpusId": "218482766"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.34130859375
        },
        {
            "corpus_id": "62770711",
            "title": "Islay3D\u2014A Programming Environment for Authoring Interactive 3D Animations in Terms of State-Transition Diagram",
            "text": "An educational programming language is a programming language that is designed primarily as a learning instrument and not so much as a tool for writing programs for production. An example is Scratch [1], which allows users to create interactive animations by arranging programming statements made up of reed-shape building blocks, without the worry of making syntax error. \n\nThree-dimensional (3D) interactive animations provide an effective means to engage the attention of the audience to learn programming language, as the vast availability of gaming consoles such as Xbox, PlayStation, and Nintendo's 3DS allows children to get exposure to 3D games from an early age. Educational programming language based on 3D interactive animations is an attractive feature for children who want to learn how to create and play their own computer games. \n\nTraditionally, creating 3D games had been difficult as it requires specialized programming skills. However, it had been proven that the state-transition diagram, which is the most fundamental principle for automata, is intuitively so comprehensive that even children can create programs for interactive animations and video games in the two-dimensional world [2]. Islay3D is a programming environment for authoring interactive 3D animations based on this concept. \n\nIslay3D was first developed on the MFC framework and run on Microsoft Windows. To reach a wider user base, it was rewritten for use on the web using JavaScript and WebGL. In this paper, the Islay3D animation language is introduced, where a character is modeled as an object, and its behavior is defined in term of a set of state-transition diagrams. The interpretation of the state-transition diagrams to JavaScript is also presented. Finally, the web-based programming environment is introduced.",
            "score": 0.31710829305818156,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 176
                },
                {
                    "start": 177,
                    "end": 372
                },
                {
                    "start": 375,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 844
                },
                {
                    "start": 847,
                    "end": 945
                },
                {
                    "start": 946,
                    "end": 1210
                },
                {
                    "start": 1211,
                    "end": 1310
                },
                {
                    "start": 1313,
                    "end": 1391
                },
                {
                    "start": 1392,
                    "end": 1483
                },
                {
                    "start": 1484,
                    "end": 1662
                },
                {
                    "start": 1663,
                    "end": 1747
                },
                {
                    "start": 1748,
                    "end": 1809
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.203369140625
        },
        {
            "corpus_id": "256460447",
            "title": "Graph transformation in engineering design: an overview of the last decade",
            "text": "In their overview on generative grammars, Chakrabarti et al. (2011) identify graph and spatial grammars as the most common types of grammars used for engineering design. The category of spatial grammar, that is used by Chakrabarti et al., comes from the research of Krishnamurti and Stouffs (1993) and is not directly linked to the underlying representation but is used for grammars that define languages of spatial forms (Krishnamurti and Stouffs, 1993). Spatial grammars may use strings, sets, graphs, or shapes as underlying representation (Krishnamurti and Stouffs, 1993;Chakrabarti et al., 2011). An overview of different applications of generative grammars is given by Antonsson and Cagan (2001). The book by Antonsson and Cagan includes contributions by different authors on the topic of generative grammars. It includes chapters on the topic of shape grammars (Stiny, 2001) and the application of shape grammars for engineering design (Cagan, 2001). \n\nThis article focuses on graph-based representation approaches. Generally, the data representation are graphs, consisting of nodes, edges, and labels. Graph grammars, a type of generative grammar and graph-based design languages, share a graph as an underlying data structure and the fact that graph transformation is used to describe how the graph should be transformed to create a valid design. A closer examination shows that different terms are used to describe similar approaches. In this respect, \"graph grammar,\" \"graph rewriting,\" \"graph transformation,\" or \"graph-based design language\" describe approaches used for engineering design in the field of architecture and various subdomains of mechanical engineering. While it could be expected that each of these terms designates a clearly defined approach, this is not always the case. \n\nDespite the different designations, the approaches share some characteristics. The common characteristics of these approaches are the use of a vocabulary to describe the elements of the design and an associated set of rules to describe how the elements may be put together to form a valid design. The approaches differ on how the rules are processed.",
            "score": 0.3167305633686701,
            "section_title": "Introduction",
            "char_start_offset": 1889,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 169
                },
                {
                    "start": 170,
                    "end": 455
                },
                {
                    "start": 456,
                    "end": 601
                },
                {
                    "start": 602,
                    "end": 702
                },
                {
                    "start": 703,
                    "end": 815
                },
                {
                    "start": 816,
                    "end": 957
                },
                {
                    "start": 960,
                    "end": 1022
                },
                {
                    "start": 1023,
                    "end": 1109
                },
                {
                    "start": 1110,
                    "end": 1355
                },
                {
                    "start": 1356,
                    "end": 1444
                },
                {
                    "start": 1445,
                    "end": 1681
                },
                {
                    "start": 1682,
                    "end": 1801
                },
                {
                    "start": 1804,
                    "end": 1882
                },
                {
                    "start": 1883,
                    "end": 2100
                },
                {
                    "start": 2101,
                    "end": 2154
                }
            ],
            "ref_mentions": [
                {
                    "start": 42,
                    "end": 67,
                    "matchedPaperCorpusId": "110114105"
                },
                {
                    "start": 266,
                    "end": 297,
                    "matchedPaperCorpusId": "117011554"
                },
                {
                    "start": 422,
                    "end": 454,
                    "matchedPaperCorpusId": "117011554"
                },
                {
                    "start": 543,
                    "end": 575,
                    "matchedPaperCorpusId": "117011554"
                },
                {
                    "start": 575,
                    "end": 600,
                    "matchedPaperCorpusId": "110114105"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1063232421875
        },
        {
            "corpus_id": "192642663",
            "title": "Scaffolded Block-based Instructional Tool for Linear Data Structures: A Constructivist Design to Ease Data Structures' Understanding",
            "text": "Considering a possible lack of assistance between visual blocks programming (VBP) languages/tools to professional programming languages/technologies, Pencil Code was designed to help novice programmers bridge between a scaffolded drag-and-drop block-based language to text, introducing idioms used by professional web developers [13]. The latter, guiding the learners to be confident enough to build programs without the use of this tool [13]. \n\nWeintrop and Holbert conducted an interesting study to understand how learners use Pencil Code to work in either a blocks-based or text-based interface, analyzing what modality learners choose to work in, and the reasons why they move from one representation to the other within a single project [14]. The authors studied two sets of students consisting on 13 high school (HS) girls and six students at a graduate course (GC) on educational learning environments (four women and two men) [14]. The HS set worked three 100-minute classes to create an interactive website to promote the class they were taking, using features regarding images, user-inputs responses, and drawing [14]. The GC students took, first, a survey on previous programming experience, and then had an activity (\"create a quilt\") that was left as homework for a one-week doing, having all the actions with Pencil Code logged by the authors [14]. Weintrop and Holbert concluded that the dual-modality approach is effective for pro-gramming learning, considering that all the students could successfully complete the assessments [14]. Furthermore, they also concluded that blocks are useful to introduce a new programming environment, as well as support items for conceptual comprehension [14]. \n\nZumaytis and Karnalim designed a tool to help students understand better the Branch & Bound strategy and its characteristics. The AP-BB tool included four modules for Brute Force strategy visualization, Branch & Bound strategy visualization, Reduced Cost Matrix (RCM) visualization, and case-based performance comparison [15]. The authors evaluated the tool using a qualitative method with 20 students who answered a set of 13 questions, asking aspects related to the purpose of the tool and its usability [15].",
            "score": 0.31661761862584614,
            "section_title": "Academic background and similar technologies",
            "char_start_offset": 8932,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 334
                },
                {
                    "start": 335,
                    "end": 443
                },
                {
                    "start": 446,
                    "end": 747
                },
                {
                    "start": 748,
                    "end": 939
                },
                {
                    "start": 940,
                    "end": 1128
                },
                {
                    "start": 1129,
                    "end": 1362
                },
                {
                    "start": 1363,
                    "end": 1549
                },
                {
                    "start": 1550,
                    "end": 1709
                },
                {
                    "start": 1712,
                    "end": 1837
                },
                {
                    "start": 1838,
                    "end": 2038
                },
                {
                    "start": 2039,
                    "end": 2223
                }
            ],
            "ref_mentions": [
                {
                    "start": 329,
                    "end": 333,
                    "matchedPaperCorpusId": "207226917"
                },
                {
                    "start": 438,
                    "end": 442,
                    "matchedPaperCorpusId": "207226917"
                },
                {
                    "start": 742,
                    "end": 746,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 934,
                    "end": 938,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 1123,
                    "end": 1127,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 1357,
                    "end": 1361,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 1544,
                    "end": 1548,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 1704,
                    "end": 1708,
                    "matchedPaperCorpusId": "17563407"
                },
                {
                    "start": 2033,
                    "end": 2037,
                    "matchedPaperCorpusId": "56002529"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.5185546875
        },
        {
            "corpus_id": "67344764",
            "title": "Mosaicode and the visual programming of Web Application for Music and Multimedia",
            "text": "In addition, code abstraction by means of a diagram can bring practicality in changing the code making them quite suitable for rapid prototyping (HILS, 1992). This is a well-known approach in the arts due to the common use of tools like Pure Data, Max/MSP or Eyesweb. On Section 2, related works will be presented and these tools will be discussed in more detail. \n\nAnother way to simplify the development of computational systems is by using domain-specific languages (DSL) (GRONBACK, 2009). DSLs have the knowledge of the domain embedded in their structure and an abstraction level higher than general-purpose programming languages. It makes the process of developing systems within your domain easier and more efficient because DSLs require more knowledge about the domain than programming skills (MERNIK;HEERING;SLOANE, 2005). For this reason, the potential advantages of DSLs include reduced maintenance costs through re-use of built-in features and increased portability, reliability, optimization and testability (DEURSEN;KLINT, 2002). Domain Specific Languages are also common in art field since this approach was used to develop languages like Csound (VERCOE, 1981), Supercollider (MCCARTNEY, 2002) or RTCMix (GAR-TON;TOPPER, 1997). \n\nIn this paper we present Mosaicode (SCHIAVONI; GONCALVES, 2017a), a visual programming environment that can be used to develop systems in the specific domain of digital art combining the simplicity of visual programming with code reuse of DSLs. We propose in this work, the construction of a set of Blocks for audio application based on Ja-vaScript programming language and the Web Audio API. This work is organized as follows: Section 2 presents related works and the fundamentals to understand this work including the concepts of Visual Programming Languages, Specific Domain Languages for Music, Javascript and Web Audio and Code Generation; Section 3 presents the Mosaicode application, how it works and the basics of programming and code generation in this visual programming environment; Section 4 discusses the development of Web Audio applications with Mosaicode focusing on the features provided to programmers; Section 5 presents the initial results and some classic synthesis algorithms implemented in this environment. Finally, Section 6 presents the Conclusion and the Future Works.",
            "score": 0.31647665340022163,
            "section_title": "Introduction",
            "char_start_offset": 2238,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 158
                },
                {
                    "start": 159,
                    "end": 267
                },
                {
                    "start": 268,
                    "end": 363
                },
                {
                    "start": 366,
                    "end": 492
                },
                {
                    "start": 493,
                    "end": 634
                },
                {
                    "start": 635,
                    "end": 830
                },
                {
                    "start": 831,
                    "end": 1042
                },
                {
                    "start": 1043,
                    "end": 1241
                },
                {
                    "start": 1244,
                    "end": 1488
                },
                {
                    "start": 1489,
                    "end": 1636
                },
                {
                    "start": 1637,
                    "end": 2274
                },
                {
                    "start": 2275,
                    "end": 2339
                }
            ],
            "ref_mentions": [
                {
                    "start": 145,
                    "end": 157,
                    "matchedPaperCorpusId": "9597596"
                },
                {
                    "start": 800,
                    "end": 808,
                    "matchedPaperCorpusId": "207158373"
                },
                {
                    "start": 808,
                    "end": 816,
                    "matchedPaperCorpusId": "207158373"
                },
                {
                    "start": 816,
                    "end": 829,
                    "matchedPaperCorpusId": "207158373"
                },
                {
                    "start": 1227,
                    "end": 1240,
                    "matchedPaperCorpusId": "38207067"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.72509765625
        },
        {
            "corpus_id": "256022730",
            "title": "Integration of computational thinking in K-12 mathematics education: a systematic review on CT-based mathematics instruction and student learning",
            "text": "These script blocks constitute more natural and intuitive ways to operate a program while providing useful visual cues on how and where to use program commands (Fig. 4b). Unique to CT-based mathematics instruction is a geometrized programming language, which, as Sinclair and Patterson (2018) proposed, is a third screen-based programming language whose elements are geometric objects rather than texts or blocks. One typical example is the Geometer's Sketchpad, and another example is Lattice Land (see Pei et al., 2018), whose interface enables users to interact directly with dots to construct segments and polygons and investigate lattice geometry as a form of geometrized programming (Fig. 4c). \n\nTangible programming requires coders to use hardware objects with physical user interface to build programs, as opposed to \"write\" or \"drag-and-drop\" on the computer screen. With tangible programming, young coders can create procedural syntax to perform physical actions such as moving between two locations by scanning a code sequence (KIBO Robot), pressing command buttons on the machine (Bee-bot Robot; Fig. 4d), entering commands with an external remote (Botley), and placing the desired tiles on the programming board (Cubetto). \n\nOur review provides insights into the features of the programming tools and their implications for student learning, not only in terms of CT development in age-appropriate ways but also the quality of connections with learning content in mathematics. Often, the choice of programming tool in relation to students' characteristics, such as developmental stage, prior knowledge, and experience with the programming tool, were considerations taken by researchers in designing CT-based mathematics activities. For example, the study by S\u00e1ez-L\u00f3pez et al. (2019) acknowledged the use of block-based programming as attempts to instigate CT without tedious coding. As such, they support kindergarten and primary students to exercise CT through activities with embedded computational concepts, such as variable, sequence, iteration (or loops), conditional statements and event handling (Miller, 2019;Ng & Cui, 2021;S\u00e1ez-L\u00f3pez et al, 2019). These studies also caution that if the CT concepts and practices involved are not made explicit, it may be difficult to tell if students could transfer their knowledge gained to other problem-solving contexts.",
            "score": 0.31615837677338754,
            "section_title": "Tools",
            "char_start_offset": 22970,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 170
                },
                {
                    "start": 171,
                    "end": 413
                },
                {
                    "start": 414,
                    "end": 699
                },
                {
                    "start": 702,
                    "end": 875
                },
                {
                    "start": 876,
                    "end": 1235
                },
                {
                    "start": 1238,
                    "end": 1488
                },
                {
                    "start": 1489,
                    "end": 1743
                },
                {
                    "start": 1744,
                    "end": 1894
                },
                {
                    "start": 1895,
                    "end": 2168
                },
                {
                    "start": 2169,
                    "end": 2378
                }
            ],
            "ref_mentions": [
                {
                    "start": 1770,
                    "end": 1794,
                    "matchedPaperCorpusId": "86664257"
                },
                {
                    "start": 2144,
                    "end": 2167,
                    "matchedPaperCorpusId": "86664257"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.55517578125
        },
        {
            "corpus_id": "259050931",
            "title": "Visual design of art based on interactive technology and environment aware intelligent devices",
            "text": "The literature elaborated the inevitability and corresponding era value of the current need to use visual programming tools, and believed that the change of the existing traditional tools was not only the only need of the historical technological transformation in development, but also the difference of the effective competition between art designers and art teams [7][8]. The focus of its artistic creation is the inevitable change under the impact of the data era and mass production era. Visual programming will endow digital art design with many new values and possibilities [9]. From reality to virtual, from results to engineering, from concrete to abstract, it will also provide a new perspective for generating art and interactive art [10]. In order to improve the intuitiveness and interactivity of the art system, the literature has studied and implemented a set of node based art visual programming models, including the de nition of basic data structures, the implementation mechanism of nodes, scenarios, and the e ciency of analysis and scheduling models [11]. Through the above process, the visual programming logic can be determined. The document realizes the interaction between users and the system based on the development of interactive multimedia system [12]. The system includes multiple types of interfaces, such as le interface, operation interface and editing interface. The interactive system itself contains multiple subsystems, which can play different functions in different use environments [13]. It can realize image control design, system model construction and management for different controls, Users can directly operate on the system and output the target graphic object representation. The system structure is plug-in, and all functional modules realize the main system integration through plug-ins [14]. The literature describes the impact of the current big data era on all aspects of contemporary art production. \n\nFrom art training to changing creative thinking, etc [15]. For the traditional non visual programming art creation, it is different, irrational, and psychedelic. In art creation, it is often used as a thought direction of the way of thinking in art creation. The literature reviews the background of visual programming and digital art design, analyzes and compares the current popular application of visual programming in digital art design [16].",
            "score": 0.3159930439955251,
            "section_title": "Related work",
            "char_start_offset": 2004,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 374
                },
                {
                    "start": 375,
                    "end": 492
                },
                {
                    "start": 493,
                    "end": 585
                },
                {
                    "start": 586,
                    "end": 750
                },
                {
                    "start": 751,
                    "end": 1076
                },
                {
                    "start": 1077,
                    "end": 1151
                },
                {
                    "start": 1152,
                    "end": 1282
                },
                {
                    "start": 1283,
                    "end": 1397
                },
                {
                    "start": 1398,
                    "end": 1528
                },
                {
                    "start": 1529,
                    "end": 1724
                },
                {
                    "start": 1725,
                    "end": 1843
                },
                {
                    "start": 1844,
                    "end": 1954
                },
                {
                    "start": 1957,
                    "end": 2015
                },
                {
                    "start": 2016,
                    "end": 2118
                },
                {
                    "start": 2119,
                    "end": 2215
                },
                {
                    "start": 2216,
                    "end": 2403
                }
            ],
            "ref_mentions": [
                {
                    "start": 367,
                    "end": 370,
                    "matchedPaperCorpusId": "244731659"
                },
                {
                    "start": 581,
                    "end": 584,
                    "matchedPaperCorpusId": "157063390"
                },
                {
                    "start": 745,
                    "end": 749,
                    "matchedPaperCorpusId": "64158494"
                },
                {
                    "start": 1071,
                    "end": 1075,
                    "matchedPaperCorpusId": "239632662"
                },
                {
                    "start": 1277,
                    "end": 1281,
                    "matchedPaperCorpusId": "32622571"
                },
                {
                    "start": 1838,
                    "end": 1842,
                    "matchedPaperCorpusId": "20859689"
                },
                {
                    "start": 2010,
                    "end": 2014,
                    "matchedPaperCorpusId": "235496201"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.411865234375
        },
        {
            "corpus_id": "164831179",
            "title": "Students\u2019 Perceptions on Using a Dual Modality Programming Environment",
            "text": "The transition between these two systems is an educational challenge. Plain text, according to the authors, is the \"the norm for proficient and professional programmers and the accepted educational goal for programming in many countries\". The UK is a working example of the above situation. Computing National Curriculum for England states that children aged 7-11 should be capable of using \"sequence, selection and repetition in programs; work with variables and various forms of input and output\". This need is met by block-based programming, mostly with Scratch. 11-14 year-olds must \"use two or more programming languages, at least one of which is textual, to solve a variety of computational problems\". Python, Java, Visual Basic are used for the switch to text-based programming. At the age of 12 students face this transition. Researchers developed a frame-based editor that supports a new language called Stride, intergraded in the Greenfoot development environment, which is a Java-like language that causes significantly less frustration caused by unnecessary syntax errors. \n\nHomer and Noble [9] conducted an experiment using Tiled Grace and their results indicated that users find dual views helpful. They found that participants generally (76%) enjoyed using the environment; that enjoyment was lower for more experienced users, suggesting that these interfaces are suitable for novice programmers. According to Homer and Noble [9] Visual programming environments (Scratch, Blockly, Alice) \"present a limited language\" and programmers must move on a \"real\" textual programming. Researchers underline that in many cases programmers feel like they have to learn to program over again. Three years later, Homer and Noble [10] published their results. They found both positive and cautionary notes for block-based programming in the results. Two of the questions of their survey were: a. which tasks users preferred to perform as text and which as tiles and b. how these patterns vary by the experience level of the user. They ran a usability experiment trialling Tiled Grace with 33 participants and they focused on usability and engagement. They had the opportunity to examine which modality -blocks or text-is preferred for different tasks. One of their findings was that participants used the other view to work around limitations of the one they were using.",
            "score": 0.3158269255191334,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 17618,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 69
                },
                {
                    "start": 70,
                    "end": 238
                },
                {
                    "start": 239,
                    "end": 290
                },
                {
                    "start": 291,
                    "end": 499
                },
                {
                    "start": 500,
                    "end": 565
                },
                {
                    "start": 566,
                    "end": 707
                },
                {
                    "start": 708,
                    "end": 785
                },
                {
                    "start": 786,
                    "end": 833
                },
                {
                    "start": 834,
                    "end": 1084
                },
                {
                    "start": 1087,
                    "end": 1212
                },
                {
                    "start": 1213,
                    "end": 1411
                },
                {
                    "start": 1412,
                    "end": 1590
                },
                {
                    "start": 1591,
                    "end": 1695
                },
                {
                    "start": 1696,
                    "end": 1760
                },
                {
                    "start": 1761,
                    "end": 1850
                },
                {
                    "start": 1851,
                    "end": 2030
                },
                {
                    "start": 2031,
                    "end": 2151
                },
                {
                    "start": 2152,
                    "end": 2252
                },
                {
                    "start": 2253,
                    "end": 2371
                }
            ],
            "ref_mentions": [
                {
                    "start": 1103,
                    "end": 1106,
                    "matchedPaperCorpusId": "7906930"
                },
                {
                    "start": 1441,
                    "end": 1444,
                    "matchedPaperCorpusId": "7906930"
                },
                {
                    "start": 1731,
                    "end": 1735,
                    "matchedPaperCorpusId": "55399814"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.363525390625
        },
        {
            "corpus_id": "55564783",
            "title": "Comparing Elementary Students\u2019 Programming Success based on Programming Environment",
            "text": "This research was conducted during 2013/2014 school year and considered programming novices in 7th grade of elementary school; therefore all students were 13-14 years old. \n\nTeacher, the first author, was the same for both groups. The teacher had two years informatics teaching experience in elementary schools including experience in Logo and BASIC teaching and successfully preparing students for Logo and BASIC programming competitions, four years of computer science teaching experience at the undergraduate level, eight years of professional programming experience and Ph.D. candidate for educational research in CS field. Informatics is an elective course in elementary schools in the Republic of Croatia, so the student chose to enroll in Informatics course. Students were in two classes; one consisted of 10 students while the other consisted of 12 students. All students were novices in programming. Therefore, a pretest was not conducted, instead of that students were compared by math accomplishment because of a positive correlation between math and programming [26]. \n\nTables 1. and 2. are representing the research design. After that, both groups were tested for basic programming concepts understanding (basic instructions, loops). Tasks were almost equal, with the difference only in the programming language used for testing. After first three weeks of lecturing, programming languages between groups were interchanged, and tasks were kept the same as for the other group. After six weeks groups were tested again but using different programming language. \n\nAs mentioned in the introduction, Logo is considered first programming language that supports concrete to abstract paradigm, but students still have to struggle with the language syntax. Syntax problem is more highlighted when students are not native English speakers. BASIC language is procedural language, and the main problem for beginners is again language syntax, which is also a more serious problem for non-English speakers. Scratch presents commands in the form of visual blocks with localized titles (there is also a Croatian version), therefore eliminating syntax or language problem. For research purpose, Logo is chosen as one of the languages proposed by national curricula and on the other hand Scratch as visual language appropriate for elementary school children. Both languages are offering a concrete representation of program execution, and Scratch is also offering a concrete representation of instructions in the shape of color-coded puzzles. \n\nIn both cases, students were guided.",
            "score": 0.3157719044125268,
            "section_title": "B. Research Context and process",
            "char_start_offset": 9876,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 171
                },
                {
                    "start": 174,
                    "end": 230
                },
                {
                    "start": 231,
                    "end": 627
                },
                {
                    "start": 628,
                    "end": 765
                },
                {
                    "start": 766,
                    "end": 866
                },
                {
                    "start": 867,
                    "end": 908
                },
                {
                    "start": 909,
                    "end": 1079
                },
                {
                    "start": 1082,
                    "end": 1136
                },
                {
                    "start": 1137,
                    "end": 1246
                },
                {
                    "start": 1247,
                    "end": 1342
                },
                {
                    "start": 1343,
                    "end": 1489
                },
                {
                    "start": 1490,
                    "end": 1572
                },
                {
                    "start": 1575,
                    "end": 1761
                },
                {
                    "start": 1762,
                    "end": 1843
                },
                {
                    "start": 1844,
                    "end": 2006
                },
                {
                    "start": 2007,
                    "end": 2169
                },
                {
                    "start": 2170,
                    "end": 2354
                },
                {
                    "start": 2355,
                    "end": 2538
                },
                {
                    "start": 2541,
                    "end": 2577
                }
            ],
            "ref_mentions": [
                {
                    "start": 1074,
                    "end": 1078,
                    "matchedPaperCorpusId": "145338243"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2509765625
        },
        {
            "corpus_id": "256662722",
            "title": "On the Applicability of Language Models to Block-Based Programs",
            "text": "On the one hand, this difference can be interpreted as strong reaffirmation of just how much blockbased programming reduces the cognitive overhead compared to text-based programming languages [10]. On the other hand, it is unclear how this simplification changes the resulting language models. Even when removing \"syntactic\" tokens [11], the remaining tokens in the JAVA example are intuitively at a lower level of abstraction than the tokens of the SCRATCH program, which contains less technical details such as modifiers or types. Consequently, it is unclear how suitable language models are for program analysis tasks on block-based programs. \n\nIn order to investigate whether block-based programs can be modelled and analyzed using language models, we empirically investigate models based on programs written in the SCRATCH programming language [5], which is the most popular blockbased programming language and aims at young learners. There is a thriving community of millions of users who share their programs, thus providing large amounts of code, allowing us to perform an extrinsic evaluation of the language models. In detail, the contributions of this paper are as follows: \n\n\u2022 We describe and implement the process of creating n-gram models from SCRATCH programs. While there are various alternative neural models, n-gram models have been shown to perform well for many tasks, and a sound understanding requires interpretable models. \u2022 We evaluate the suitability of n-gram models for the common tasks of code completion, i.e., the prediction of which block will be used next in a token stream, using a dataset of publicly shared SCRATCH projects. \u2022 We evaluate the ability of n-gram models to identify erroneous solutions for SCRATCH programming assignments. \u2022 We investigate whether transformers, a popular deep learning model, can improve the performance of the completion task compared to n-gram models. Our experiments confirm that block-based programs differ fundamentally from text-based programs in a way that negatively affects their predictability. However, there nevertheless are elements of syntax and repetitiveness that make blocks sufficiently predictable to enable the use of natural language models for block-based programming languages.",
            "score": 0.3156098982633848,
            "section_title": "I. INTRODUCTION",
            "char_start_offset": 2203,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 197
                },
                {
                    "start": 198,
                    "end": 293
                },
                {
                    "start": 294,
                    "end": 532
                },
                {
                    "start": 533,
                    "end": 645
                },
                {
                    "start": 648,
                    "end": 939
                },
                {
                    "start": 940,
                    "end": 1125
                },
                {
                    "start": 1126,
                    "end": 1184
                },
                {
                    "start": 1187,
                    "end": 1275
                },
                {
                    "start": 1276,
                    "end": 1445
                },
                {
                    "start": 1446,
                    "end": 1659
                },
                {
                    "start": 1660,
                    "end": 1771
                },
                {
                    "start": 1772,
                    "end": 1919
                },
                {
                    "start": 1920,
                    "end": 2070
                },
                {
                    "start": 2071,
                    "end": 2266
                }
            ],
            "ref_mentions": [
                {
                    "start": 332,
                    "end": 336,
                    "matchedPaperCorpusId": "174799701"
                },
                {
                    "start": 849,
                    "end": 852,
                    "matchedPaperCorpusId": "9744698"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.219970703125
        },
        {
            "corpus_id": "257102909",
            "title": "Integrating Data Structures and Algorithms in K-12 Education using Block-based Programming",
            "text": "Research shows that several tools have been developed to make advanced programming ideas more accessible to young learners [12], [18], [19], [26]- [28]. Block-based learning methodologies are widely used in K-12 computer science educational context as these tools address difficulties associated with learning syntax in textual programming languages [24]. Many K-12 CS tools make use of simulation and gamified learning computer science concepts [20], [29]. Visualizations and simulations make complex concepts easier to understand and cater to the different cognitive abilities of young students. Visual programming environments such as Scratch, Blockly, and Snap provide block-based interfaces based on this philosophy. This research [30] raises awareness of the difficulties students face when learning data structures like ArrayList, LinkedList, and Trees in textual programming languages but provides no tools in particular. In addition, the authors recommend that the CS education community explores this topic further, noting that there is still a limited amount of literature on the topic. Topics such as data structures require a high level of abstraction. Research suggests that scaffolded learning tools are necessary [31], [32]. One of the main advantages of scaffolded instruction is that it fosters an environment of supportive learning. Students contribute their knowledge by asking questions, providing feedback, and helping their peers learn new material [32]. Environments such as Scratch foster Scaffolded learning opportunities for students. DStBlocks [31] is an example of a scaffolded visualization tool that extends Blockly to simulate advanced data structures.",
            "score": 0.31525162897504316,
            "section_title": "II. RELATED WORK",
            "char_start_offset": 7217,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 152
                },
                {
                    "start": 153,
                    "end": 355
                },
                {
                    "start": 356,
                    "end": 457
                },
                {
                    "start": 458,
                    "end": 597
                },
                {
                    "start": 598,
                    "end": 721
                },
                {
                    "start": 722,
                    "end": 929
                },
                {
                    "start": 930,
                    "end": 1097
                },
                {
                    "start": 1098,
                    "end": 1165
                },
                {
                    "start": 1166,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1351
                },
                {
                    "start": 1352,
                    "end": 1477
                },
                {
                    "start": 1478,
                    "end": 1561
                },
                {
                    "start": 1562,
                    "end": 1684
                }
            ],
            "ref_mentions": [
                {
                    "start": 123,
                    "end": 127,
                    "matchedPaperCorpusId": "209459334"
                },
                {
                    "start": 135,
                    "end": 139,
                    "matchedPaperCorpusId": "248699723"
                },
                {
                    "start": 147,
                    "end": 151,
                    "matchedPaperCorpusId": "210972328"
                },
                {
                    "start": 350,
                    "end": 354,
                    "matchedPaperCorpusId": "16554511"
                },
                {
                    "start": 446,
                    "end": 450,
                    "matchedPaperCorpusId": "60903435"
                },
                {
                    "start": 452,
                    "end": 456,
                    "matchedPaperCorpusId": "214716735"
                },
                {
                    "start": 736,
                    "end": 740,
                    "matchedPaperCorpusId": "51956348"
                },
                {
                    "start": 1229,
                    "end": 1233,
                    "matchedPaperCorpusId": "192642663"
                },
                {
                    "start": 1235,
                    "end": 1239,
                    "matchedPaperCorpusId": "203707561"
                },
                {
                    "start": 1472,
                    "end": 1476,
                    "matchedPaperCorpusId": "203707561"
                },
                {
                    "start": 1572,
                    "end": 1576,
                    "matchedPaperCorpusId": "192642663"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.759765625
        },
        {
            "corpus_id": "247597178",
            "title": "How Interest-Driven Content Creation Shapes Opportunities for Informal Learning in Scratch: A Case Study on Novices\u2019 Use of Data Structures",
            "text": "Scratch is a visual, block-based programming language designed for children [63].Scratch programming primitives are represented by visual blocks that control the behavior of on-screen graphical objects called sprites.Scratch programs (commonly called projects) are constructed by dragging and dropping blocks together.As a programming language, Scratch supports basic data structures in the form of scalar variables and vector lists (Figure 1a).\n\nPrimitives to operate on variables and lists fall under the category of \"data blocks\" in Scratch and their design are described in detail by Maloney et al. [54].When creating a variable or list, Scratch users assign a name to the variable or list through a free-form text entry field that is invoked through a \"make a variable\" or a \"make a list\" button in the Scratch user interface.We refer to these userdefined names as \"variable name\" or \"list name\" in this paper.When referring to the the variable or list within the Scratch program, users select the appropriate name from a dropdown list embedded in the block.Variables in Scratch have two forms which share a grammar: (1) conventional variables and lists which are local to each instance of a running project; and (2) cloud variables which are persistent across multiple executions of a project and shared across users [16].Cloud variables are only accessible to established members in the Scratch online community as established by an undocumented set of criteria [20].\n\nScratch is situated within an online community where anyone can sign up and share their projects, comment on, \"like, \" and bookmark others' works, and socialize in forums [59]. 1 As of 2021, the Scratch online community has over 65 million registered users, and over 68 million shared projects that span a diverse range of genres and themes.The large majority of Scratch users are between 8-16 years old and the median age for new contributors is around 12. 2Although our data might include adults, we follow other scholarly accounts and refer to Scratch users as \"kids\" [e.g., 38].We draw data from both the Scratch community itself and its discussion forums, shown in Figure 1b.",
            "score": 0.31524777472671717,
            "section_title": "EMPIRICAL SETTING",
            "char_start_offset": 10822,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 81
                },
                {
                    "start": 81,
                    "end": 217
                },
                {
                    "start": 217,
                    "end": 318
                },
                {
                    "start": 318,
                    "end": 445
                },
                {
                    "start": 447,
                    "end": 608
                },
                {
                    "start": 608,
                    "end": 831
                },
                {
                    "start": 831,
                    "end": 915
                },
                {
                    "start": 915,
                    "end": 1063
                },
                {
                    "start": 1063,
                    "end": 1328
                },
                {
                    "start": 1328,
                    "end": 1474
                },
                {
                    "start": 1476,
                    "end": 1817
                },
                {
                    "start": 1817,
                    "end": 2052
                },
                {
                    "start": 2052,
                    "end": 2058
                },
                {
                    "start": 2058,
                    "end": 2156
                }
            ],
            "ref_mentions": [
                {
                    "start": 1323,
                    "end": 1327,
                    "matchedPaperCorpusId": "623864"
                },
                {
                    "start": 1469,
                    "end": 1473,
                    "matchedPaperCorpusId": "5040565"
                },
                {
                    "start": 1647,
                    "end": 1651,
                    "matchedPaperCorpusId": "10637172"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6435546875
        },
        {
            "corpus_id": "236780515",
            "title": "Cognition of Graphical Notation for Processing Data in ERDAS IMAGINE",
            "text": "To introduce visual programming language, an overview of the terminology follows. VPL uses a set of graphical symbols (visual vocabulary) and a set of compositional rules (visual grammar). In addition, the definition of the meaning of each graphical symbol is visual semantics. All three together consist of a visual notation (or the equivalent terms; visual language, graphical notation, diagramming notation). A valid expression in a visual notation is called a visual sentence or diagram (or workflow diagram, process model). Diagrams are composed of symbol instances arranged according to the rules of visual grammar [27]. Graphical editors (such as software extensions, software components) are used for the design of workflow diagrams. \n\nThe functionalities of the visual component and the cognitive aspects of visual vocabulary are both important. The cognitive aspects of vocabulary influence the effective utilization of workflow diagrams by users. The aesthetic properties of workflow diagrams have importance from the point of view of the perception and cognition of the user. \n\nThe ERDAS Spatial Modeler simply uses the term model for workflow diagram. This term will be used in this article in the description of evaluation.",
            "score": 0.31503165799208427,
            "section_title": "Terminology of Visual Programming Languages",
            "char_start_offset": 8400,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 81
                },
                {
                    "start": 82,
                    "end": 188
                },
                {
                    "start": 189,
                    "end": 277
                },
                {
                    "start": 278,
                    "end": 411
                },
                {
                    "start": 412,
                    "end": 528
                },
                {
                    "start": 529,
                    "end": 626
                },
                {
                    "start": 627,
                    "end": 741
                },
                {
                    "start": 744,
                    "end": 854
                },
                {
                    "start": 855,
                    "end": 957
                },
                {
                    "start": 958,
                    "end": 1087
                },
                {
                    "start": 1090,
                    "end": 1164
                },
                {
                    "start": 1165,
                    "end": 1237
                }
            ],
            "ref_mentions": [
                {
                    "start": 621,
                    "end": 625,
                    "matchedPaperCorpusId": "18149322"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.859375
        },
        {
            "corpus_id": "14902110",
            "title": "Conceptual Understanding of Computer Program Execution: Application to C++",
            "text": "A visual programming language uses pictorial tools such as diagrams to represent its structural units and control stream. It is useful for enhancing understanding, maintenance, verification, testing, and parallelism. This paper proposes a diagrammatic methodology that produces a conceptual representation of instructions for programming source codes. Without loss of generality in the potential for using the methodology in a wider range of applications, this paper focuses on using these diagrams in teaching of C++ programming. C++ programming constructs are represented in the proposed method in order to show that it can provide a foundation for understanding the behavior of running programs. Applying the method to actual C++ classes demonstrates that it improves understanding of the activities in the computer system corresponding to a C++ program.",
            "score": 0.31503165799208427,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.84033203125
        },
        {
            "corpus_id": "164831179",
            "title": "Students\u2019 Perceptions on Using a Dual Modality Programming Environment",
            "text": "This very interesting paper includes a section called \"Measuring Learning Transfer\" which accumulates cases that support the hypothesis of effective learning transfer from block languages to traditional textual languages. A number of studies, in K12, Universities, Colleges and separate CS courses indicate that learning with blocks and using mediated transfer pedagogy improve students' engagement and student's grades along with the percentage of them that takes further CS courses. The paper mentions some state of the art programming alternatives that enable novice programmers to build programs even for domains such as 3D printing or Querying the Semantic Web [20]. Pencil Code is subject to researchers' addition in order to improve tool's debugging process and users' understanding [21]. \n\nIn a small scale research in Japan, comparing the programming education for primary schoolchildren with VPLs (Visual Programming Languages) and that with TPLs (Textual Programming Languages), the VPL approach proved to be more suitable for increasing the motivation of the learners [22]. \n\nThe new tendency is to study the use of block-based and hybrid-based environments and the way they support transferring student's programming skills to text-based ones. This produces the following research questions: 1. Does hybrid-based allow students to understand programming concepts (Variables, Looping, Procedures, and Conditional Logic) easier when they turn to text-based programming? 2. Will the hybrid-based environment reduce the shock of transferring to a text-based environment? \n\nWeintrop [23] used Pencil Code to compare the programming skills that have been acquired by three groups of students who used the environment differently. The first group used only blocks, the second only text and the third one used hybrid-based environment. All students followed the same curriculum for 5 weeks and afterwards they moved to java and text-based programming. His findings were very interesting: 92% of students consider block-based programming is easier to learn and includes less commands to memorize, but on the other hand is difficult to build a project complex enough [23]. \n\nWeintrop and Wilensky [24] report \"a proliferation of introductory programming environments\" for the past ten years. Scratch, Alice, and other block-based programs are popular for novice programmers. Recently, block-based and text-based environments have stopped being separate.",
            "score": 0.31466899087455336,
            "section_title": "II. BACKGROUND",
            "char_start_offset": 13015,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 221
                },
                {
                    "start": 222,
                    "end": 484
                },
                {
                    "start": 485,
                    "end": 671
                },
                {
                    "start": 672,
                    "end": 795
                },
                {
                    "start": 798,
                    "end": 1085
                },
                {
                    "start": 1088,
                    "end": 1256
                },
                {
                    "start": 1257,
                    "end": 1307
                },
                {
                    "start": 1308,
                    "end": 1480
                },
                {
                    "start": 1481,
                    "end": 1579
                },
                {
                    "start": 1582,
                    "end": 1736
                },
                {
                    "start": 1737,
                    "end": 1840
                },
                {
                    "start": 1841,
                    "end": 1956
                },
                {
                    "start": 1957,
                    "end": 2175
                },
                {
                    "start": 2178,
                    "end": 2294
                },
                {
                    "start": 2295,
                    "end": 2377
                },
                {
                    "start": 2378,
                    "end": 2456
                }
            ],
            "ref_mentions": [
                {
                    "start": 790,
                    "end": 794,
                    "matchedPaperCorpusId": "28418313"
                },
                {
                    "start": 1080,
                    "end": 1084,
                    "matchedPaperCorpusId": "5106626"
                },
                {
                    "start": 1591,
                    "end": 1595,
                    "matchedPaperCorpusId": "19152833"
                },
                {
                    "start": 2170,
                    "end": 2174,
                    "matchedPaperCorpusId": "19152833"
                },
                {
                    "start": 2200,
                    "end": 2204,
                    "matchedPaperCorpusId": "223424"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51708984375
        },
        {
            "corpus_id": "221711567",
            "title": "Generating NURBS cladding and structures with parametric programming and BIM",
            "text": "Sometimes it is assumed that form-forming-process systems lack something, while construction-function-oriented systems have everything, which is not true. They contain different information. \n\nBoth paradigms are essential for designing and building the forms we will describe later in this paper. Indeed, none of the mainstream architectural design applications is based solely on one of these two paradigms. Systems that were originally based predominantly in one paradigm have gradually, though often modestly, incorporated resources that are based on the other one. \n\nParametric programming (TERZIDIS, 2009, p.19-22) may be understood as the design process that takes place using parametric representations and its properties' controls as nodes in propagation-based systems (AISH; WOODBURY, 2005;WOODBURY, 2010, p. 12-22). Some authors use parametric programming as a synonym to parametric modeling or parametric design (WOODBURY, 2011, p. 12-15). However, for the sake of clarity, we will use only parametric programming in this paper. \n\nVisual programming is a very important implementation of parametric programming, with interfaces directly derived from graph theory. The Rhinoceros-Grasshopper programming environment is one of them, and we will describe how it was used in the experiment reported in this paper. \n\nWe want to stress that parametric models and parametric programming should not be confused with parametricism. This expression was coined by Patrik Schumacher and meant a new architectural style in succession to the post-modernism, the modernism, the art nouveau, the historicism, the baroque, etc. (SCHUMACHER, 2011, p. 35). \n\nThis might suggest that the use of parametric programming leads necessarily to one style. However, this sounds restricting, since parametric techniques can lead to greater diversity, not to conversion. Also, any architectural language can be modeled in a parametric system, not just the contemporary ones. However, we will not go deeper into this discussion, but only stress that we do not use parametric programming as a synonym to parametricism. \n\nAnother important concept used in this paper is the algorithm. Berlinski uses a simple way to define what is an algorithm:",
            "score": 0.31457633321853545,
            "section_title": "Introduction",
            "char_start_offset": 5770,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 154
                },
                {
                    "start": 155,
                    "end": 190
                },
                {
                    "start": 193,
                    "end": 296
                },
                {
                    "start": 297,
                    "end": 408
                },
                {
                    "start": 409,
                    "end": 568
                },
                {
                    "start": 571,
                    "end": 825
                },
                {
                    "start": 826,
                    "end": 950
                },
                {
                    "start": 951,
                    "end": 1039
                },
                {
                    "start": 1042,
                    "end": 1174
                },
                {
                    "start": 1175,
                    "end": 1320
                },
                {
                    "start": 1323,
                    "end": 1433
                },
                {
                    "start": 1434,
                    "end": 1648
                },
                {
                    "start": 1651,
                    "end": 1740
                },
                {
                    "start": 1741,
                    "end": 1852
                },
                {
                    "start": 1853,
                    "end": 1956
                },
                {
                    "start": 1957,
                    "end": 2098
                },
                {
                    "start": 2101,
                    "end": 2163
                },
                {
                    "start": 2164,
                    "end": 2223
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.35205078125
        },
        {
            "corpus_id": "231992121",
            "title": "Exploring the first experiences of computer programming of older people with low levels of formal education: A participant observational case study",
            "text": "A recent (2018) systematic review of programming with young students points out that \"it is clear that visual programming languages present many benefits over traditional text-based programming languages (emphasis ours)\" (Noone and Mooney, 2018). Our results present a different perspective. On the one hand, having introduced Scratch near the end of Course A, when participants had already interacted with a tool that was perceived to be for 'professionals', determined to a great extent their refusal. \n\nOn the other hand, when participants experienced a number of different programming languages, Scratch was not rejected. This shows that how and when visual programming languages are introduced in courses with a certain profile of participants, who are often regarded as 'the others' in society (Riddell and Watson, 2014), matters, and that the presumed benefits of block-based programming might not always be so clear. \n\nWe do not consider that the language issue had a strong impact on the participants' perspective of Scratch. As stated above, participants did not complain about programming languages or environments being in English-only or in other languages, although they admitted, as one might expect, that Spanish was easier for them than English. The reasons for setting Scratch in Catalan were related to personal preferences, and this resonates with some of the reasons for young students to set Scratch in different languages (Vogel, 2020). From the reactions of the participants, the refusal stemmed from a clash with their identity in the courses. After having spent 3 months in a course programming with a tool targeted at professional software development, the visually appealing nature of Scratch made the process of learning programming appear toy-like and inauthentic (DiSalvo, 2014). This was at odds with what the participants are, or aspire to be (and to be regarded by others): socially included and competent citizens. This strong rejection did not happen in Courses B and C because the participants were introduced to different programming realities and tools.",
            "score": 0.3141404563134388,
            "section_title": "Commentary",
            "char_start_offset": 53014,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 246
                },
                {
                    "start": 247,
                    "end": 291
                },
                {
                    "start": 292,
                    "end": 503
                },
                {
                    "start": 506,
                    "end": 625
                },
                {
                    "start": 626,
                    "end": 924
                },
                {
                    "start": 927,
                    "end": 1034
                },
                {
                    "start": 1035,
                    "end": 1262
                },
                {
                    "start": 1263,
                    "end": 1459
                },
                {
                    "start": 1460,
                    "end": 1568
                },
                {
                    "start": 1569,
                    "end": 1810
                },
                {
                    "start": 1811,
                    "end": 1949
                },
                {
                    "start": 1950,
                    "end": 2092
                }
            ],
            "ref_mentions": [
                {
                    "start": 221,
                    "end": 245,
                    "matchedPaperCorpusId": "4039308"
                },
                {
                    "start": 1794,
                    "end": 1809,
                    "matchedPaperCorpusId": "2325557"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3095703125
        },
        {
            "corpus_id": "216288427",
            "title": "Visual Language-Aided Construction Fire Safety Planning Approach in Building Information Modeling",
            "text": "This subsection focuses on fire protection and leverages the visual language approach to acquire BIM-based portable firefighting equipment safety planning in construction. The script is initiated with the extraction of geometric data as input from the 2D plan. As depicted in Figure 3, the method allows the user to define the following four (U1, U2, U3 and U4) conditions: U1 is importing building borderlines (BL) as a 2D plan geometry, U2 is to determine the plan interior walls (IW) as a 2D line geometry, U3 is to define stair locations (SL) as pick points, and U4 is intended to choose fire extinguisher type from the dropdown list that includes type 2A and 10B. According to the OSHA rules, 1926.150(c)(1)(i) A fire extinguisher, rated not less than 2A, shall be provided for every 3,000 square feet of the protected building area, or significant fraction thereof. Travel distance from any point of the protected area to the nearest fire extinguisher shall not exceed 100 feet. Where the Dividing Distance of 2A (DDA) fire extinguisher type is 100ft, and the area is 3000 square feet. Similarly, The OSHA article 1926.150(c)(1)(vi) revealed the Dividing Distance of rated not less than 10B (DDB) fire extinguisher type is 50 feet. \n\navailed to achieve the task of rule conversion. Visual programming is employed in this research study due to several reasons. It is relatively convenient to use as compared with other programming languages [19] such as python, java, and many more. This language effectively represents the information flow through visual symbols (nodes and connections) [42] with precise inputs and outputs. Therefore, this paper proposed a visual language approach for the translation of fire safety rules, which is established from the subpart F (Fire Protection and Prevention) of the OSHA-1926. This module further contains three submodules of the proposed approach.",
            "score": 0.31382134525636685,
            "section_title": "Design for Firefighting Equipment Installation (FEI) Module",
            "char_start_offset": 27400,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 171
                },
                {
                    "start": 172,
                    "end": 260
                },
                {
                    "start": 261,
                    "end": 668
                },
                {
                    "start": 669,
                    "end": 715
                },
                {
                    "start": 716,
                    "end": 871
                },
                {
                    "start": 872,
                    "end": 984
                },
                {
                    "start": 985,
                    "end": 1091
                },
                {
                    "start": 1092,
                    "end": 1237
                },
                {
                    "start": 1240,
                    "end": 1287
                },
                {
                    "start": 1288,
                    "end": 1365
                },
                {
                    "start": 1366,
                    "end": 1487
                },
                {
                    "start": 1488,
                    "end": 1630
                },
                {
                    "start": 1631,
                    "end": 1821
                },
                {
                    "start": 1822,
                    "end": 1893
                }
            ],
            "ref_mentions": [
                {
                    "start": 1446,
                    "end": 1450,
                    "matchedPaperCorpusId": "145853456"
                },
                {
                    "start": 1593,
                    "end": 1597,
                    "matchedPaperCorpusId": "115199205"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.3564453125
        },
        {
            "corpus_id": "245981957",
            "title": "eLuna: A Co-Design Framework for Narrative Digital Game-Based Learning that Support STEAM",
            "text": "Objects are drawn as orange boxes and labelled to indicate what they represent. In the eLuna visual language objects can serve four purposes. Two objects can be combined to form a new object (such as adding a seed to soil to get a sprout), or an object can be inserted into another object to alter the purpose (such as changing the bore or screwing bit on an electric drill). Objects can also be  Figure 2C shows the visual language elements available for the modifiable objects category. In the co-design phase objects are listed using the elements, and in the cospecification phase the object elements are further used in combination with agents and other objects to specify their exact usage in quests tasks. \n\nAs Figure 2C shows, in the visual language objects have a base shape and four features that describe how they can be employed in the narrative DGBL: objects can be combined to form another object; they can be inserted into other objects; parameterized to provide a special functionality; or they can provide information.",
            "score": 0.3136080054639228,
            "section_title": "The eLuna Visual Language: Objects",
            "char_start_offset": 24510,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 79
                },
                {
                    "start": 80,
                    "end": 141
                },
                {
                    "start": 142,
                    "end": 375
                },
                {
                    "start": 376,
                    "end": 488
                },
                {
                    "start": 489,
                    "end": 711
                },
                {
                    "start": 714,
                    "end": 1034
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.287353515625
        },
        {
            "corpus_id": "6455062",
            "title": "Visual Representation of 3D Language Constructs Specified by Generic Depictions",
            "text": "The generator system DEViL3D [Wol12] allows to generate 3D structure editors, supporting the direct manipulation paradigm [Shn83] and, therefore, prevent the user from constructing syntactically incorrect programs. DEViL3D combines approved concepts of the predecessor system DEViL [SKC06, SCK07, SK03] and new aspects necessary to construct three-dimensional programs. This section gives a brief overview on the steps elementary to generate a structure editor with DEViL3D. It includes an overview on several specification parts and, additionally, a brief outline on 3D-specific aspects that are applicable in all generated editors. \n\nFigure 2 visualizes the specification process. It is layered into three parts. The upper area shows specification parts a language designer has to formulate: the abstract structure, visual representations, and code generators. The area in the middle illustrates our generator framework DEViL3D. As input, DEViL3D gets a language specification and generates a language processor which has a dedicated 3D graphi-  cal structure editor as its front-end. Domain experts use such editors to construct three-dimensional programs of their domain, e.g., molecular models. The abstract structure describes the language constructs and how they are connected, without defining a concrete representation. For such purpose, a specifically tailored textual domain specific language is used, which is strongly related to object oriented programming languages. It is based on well known concepts like classes, inheritance, attributes, and references. \n\nThe specification of the visual representation is based on attribute grammars, which are translated into computations of the graphical representation and arrange objects in 3D space. The attribute grammars are based on a context-free grammar that is generated from the abstract structure. The arrows in Figure 2 indicate this dependency. DEViL3D provides a library of visual patterns that encapsulate common representation arrangements like three-dimensional sets, lists, line connections, or cone-trees. They are defined as visual roles, which can be assigned to symbols of the grammar in a declarative way. The visual patterns automatically contribute layout and interaction properties. The generic depictions, which define the visual representation of a language construct, are referenced by visual patterns. For the generation of a molecular editor with DEViL3D, amongst others, generic depictions for kinds of atoms and for bonds are needed.",
            "score": 0.3133861023567286,
            "section_title": "DEViL3D",
            "char_start_offset": 5611,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 214
                },
                {
                    "start": 215,
                    "end": 369
                },
                {
                    "start": 370,
                    "end": 474
                },
                {
                    "start": 475,
                    "end": 633
                },
                {
                    "start": 636,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 714
                },
                {
                    "start": 715,
                    "end": 862
                },
                {
                    "start": 863,
                    "end": 930
                },
                {
                    "start": 931,
                    "end": 1086
                },
                {
                    "start": 1087,
                    "end": 1199
                },
                {
                    "start": 1200,
                    "end": 1328
                },
                {
                    "start": 1329,
                    "end": 1480
                },
                {
                    "start": 1481,
                    "end": 1570
                },
                {
                    "start": 1573,
                    "end": 1755
                },
                {
                    "start": 1756,
                    "end": 1861
                },
                {
                    "start": 1862,
                    "end": 1910
                },
                {
                    "start": 1911,
                    "end": 2077
                },
                {
                    "start": 2078,
                    "end": 2181
                },
                {
                    "start": 2182,
                    "end": 2261
                },
                {
                    "start": 2262,
                    "end": 2384
                },
                {
                    "start": 2385,
                    "end": 2519
                }
            ],
            "ref_mentions": [
                {
                    "start": 29,
                    "end": 36,
                    "matchedPaperCorpusId": "18383411"
                },
                {
                    "start": 122,
                    "end": 129,
                    "matchedPaperCorpusId": "14942172"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51171875
        },
        {
            "corpus_id": "15820022",
            "title": "ECCE Toolkit: Prototyping Sensor-Based Interaction",
            "text": "As reported by Lieberman et al. [24], techniques to support end users in the programming task include: scripting languages, domain-specific languages, programming-by-demonstration, tailoring, configurability, visual languages and natural programming environments. Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification [25] and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming [24] (p. 3). d.tools [26] is one of the first attempts to introduce End-User Programming (EUP) techniques for authoring ubiquitous interaction. It supports visual programming via a visual state chart editor. The system was later extended by Exemplar [11], which exploits the programming-by-demonstration technique to enable interaction via sensor data. iStuff mobile [27] is built on top of iStuff [21] and it provides a software architecture and visual language to prototype interactions between physical objects, enhanced with sensors and actuators, and mobile devices. The project pushes forward the vision of interweaved devices, but no information is provided about (i) the implementation effort required to program cross-device interactions; (ii) how the system bridges communication among heterogeneous devices; or (iii) how the system could be extended to include new devices. Other environments have embraced visual programming for prototyping physical interaction. For instance, Scratch4Arduino [28] exploits the Scratch visual environment and visual syntax [29] to program the Arduino hardware through the composition of logical blocks on the screen. However, Scratch4Arduino is meant for educational purposes and to ease the transition to a classical textual programming language, thus it does not provide support for building complex device ecosystems. More advanced tools for this task are Node-RED [30] and MIT App Inventor [31]. Node-RED implements a visual data-flow language to interweave smart things. It provides high configurability and extensibility and it is powered by crowd-based development that enables people to reuse code created by others.",
            "score": 0.3130935495611387,
            "section_title": "End-User Programming for Ubiquitous Interaction",
            "char_start_offset": 93200,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 263
                },
                {
                    "start": 264,
                    "end": 598
                },
                {
                    "start": 599,
                    "end": 602
                },
                {
                    "start": 603,
                    "end": 733
                },
                {
                    "start": 734,
                    "end": 797
                },
                {
                    "start": 798,
                    "end": 942
                },
                {
                    "start": 943,
                    "end": 1161
                },
                {
                    "start": 1162,
                    "end": 1474
                },
                {
                    "start": 1475,
                    "end": 1564
                },
                {
                    "start": 1565,
                    "end": 1751
                },
                {
                    "start": 1752,
                    "end": 1955
                },
                {
                    "start": 1956,
                    "end": 2034
                },
                {
                    "start": 2035,
                    "end": 2110
                },
                {
                    "start": 2111,
                    "end": 2259
                }
            ],
            "ref_mentions": [
                {
                    "start": 32,
                    "end": 36,
                    "matchedPaperCorpusId": "15559793"
                },
                {
                    "start": 425,
                    "end": 429,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 590,
                    "end": 594,
                    "matchedPaperCorpusId": "15559793"
                },
                {
                    "start": 611,
                    "end": 615,
                    "matchedPaperCorpusId": "3004251"
                },
                {
                    "start": 840,
                    "end": 844,
                    "matchedPaperCorpusId": "6092270"
                },
                {
                    "start": 957,
                    "end": 961,
                    "matchedPaperCorpusId": "1532919"
                },
                {
                    "start": 988,
                    "end": 992,
                    "matchedPaperCorpusId": "16903963"
                },
                {
                    "start": 1595,
                    "end": 1599,
                    "matchedPaperCorpusId": "10384172"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.87548828125
        },
        {
            "corpus_id": "238419475",
            "title": "DRAFT-What you always wanted to know but could not find about block-based environments",
            "text": "This category contains different papers that present languages and proceedings that study block-based environments usage in software engineering. Therefore, the reader will find various topics such as code smells in block-based programs, security, testing, refactoring, debugging facilities, and specialized tools for developing block-based languages. \n\nIn this category, we have grouped some papers that present a more theoretical view of the application of block-based languages. Hermans and Aivaloglou [61]   findings after analyzing and trying out each of the tools resulting from the search process. Likewise, it also contains a set of features empirically collected by the first author after testing each language or tool. The process to collect these features was by trying each tool and collecting its features in a spreadsheet. Since all block-based environments do not offer the same features, a few tools had to be tested more than once because some features were included in the spreadsheet after testing the tool. The table is divided into seven columns, and all columns except the first one are subdivided into other columns. \n\n(i) Name represents the name of the tool or the language, (ii) Editor represents the different components present in a code editor (e.g., mode, error marking, and stage), (iii) Focus represents whether the tool is an application, a language that supports the developing block-based environments, or both, (iv) Deployment shows the different models in which the tools are being offered, namely as standalone, mobile, or as Software as a Service (SaaS), (v) Domain represents the application domain where the tool is used, (vi) Execution is how the tool executes an application. We identified mainly two modes: live and pressing an execution button (manual), and (vii) Licensing shows the three main types in which the tools are offered. \n\nAs the reader might have noticed, these features were used as a basis for the definition of the feature diagram of block-based environments in Section 3.2. Using this manual exploration of all available tools we discovered most of the features of block-based environments. The other features were discovered after the systematic literature review process described earlier. As described in the methodology, all tools listed in the table were tested by the first author.",
            "score": 0.31263955945403343,
            "section_title": "Category 7 Software engineering",
            "char_start_offset": 53856,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 145
                },
                {
                    "start": 146,
                    "end": 351
                },
                {
                    "start": 354,
                    "end": 481
                },
                {
                    "start": 482,
                    "end": 604
                },
                {
                    "start": 605,
                    "end": 728
                },
                {
                    "start": 729,
                    "end": 836
                },
                {
                    "start": 837,
                    "end": 1026
                },
                {
                    "start": 1027,
                    "end": 1139
                },
                {
                    "start": 1142,
                    "end": 1718
                },
                {
                    "start": 1719,
                    "end": 1877
                },
                {
                    "start": 1880,
                    "end": 2035
                },
                {
                    "start": 2036,
                    "end": 2152
                },
                {
                    "start": 2153,
                    "end": 2253
                },
                {
                    "start": 2254,
                    "end": 2349
                }
            ],
            "ref_mentions": [
                {
                    "start": 505,
                    "end": 509,
                    "matchedPaperCorpusId": "24280317"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1728515625
        },
        {
            "corpus_id": "271710016",
            "title": "WaitGPT: Monitoring and Steering Conversational LLM Agent in Data Analysis with On-the-Fly Code Visualization",
            "text": "Our goal is to transform the LLM-generated code into easily interpretable visualizations, facilitating user inspection of the data analysis process (DC2). To this end, we have developed a suite of visual primitives, which present the details of each operation and their internal runtime states. These primitives are chained together, collectively offering an overview of the data analysis process. \n\nVisual primitives for the static code. We utilize a diagram to represent the graph-based data processing procedure for individual code snippets. The table node, operation node, and result node are visualized as blocks, color-encoded in yellow, pink, and white. A node-style visualization is chosen for its familiarity to general users (DC2) and flexibility in displaying layered information, expanding with the code stream, and implying the operation order (DC4). As LLMs sometimes synthesize long variable names for clarification, we considered a rectangular block beneficial for encapsulating this information. For simplicity, a table node only shows the corresponding variable name, and a result node shows a thumbnail. For an operation node, we use a bold font style to prioritize the communication of its type (e.g., filter, group, etc.). And we visually differentiate its parameters' names and values through typography. \n\nAn operation chain spans from top to bottom, following its procedure. For a table node, there can be multiple associated operation chains. These chains are aligned from left to right with respect to the execution order. A code snippet depends on preexisting code as the runtime environment is shared throughout a conversation. Therefore, a table node may trace back to previous snippets. To reflect such a relationship, a copy is made in such a situation, which is linked to its previous occurrence with a cross-conversation curve. \n\nVisual primitives for the runtime states. The diagram is further enriched by visual glyphs that encode the runtime status of table variables. A table glyph takes a common visual representation for tables-a 2D matrix. The number of matrix columns is the same as the column number of the table. The number of matrix rows per column is proportional to the number of table rows to roughly indicate changes in data size and scale to different data sizes.",
            "score": 0.3125317875604966,
            "section_title": "Visualizing Data Operation Chains",
            "char_start_offset": 27256,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 154
                },
                {
                    "start": 155,
                    "end": 294
                },
                {
                    "start": 295,
                    "end": 397
                },
                {
                    "start": 400,
                    "end": 438
                },
                {
                    "start": 439,
                    "end": 544
                },
                {
                    "start": 545,
                    "end": 660
                },
                {
                    "start": 661,
                    "end": 863
                },
                {
                    "start": 864,
                    "end": 1012
                },
                {
                    "start": 1013,
                    "end": 1122
                },
                {
                    "start": 1123,
                    "end": 1243
                },
                {
                    "start": 1244,
                    "end": 1326
                },
                {
                    "start": 1329,
                    "end": 1398
                },
                {
                    "start": 1399,
                    "end": 1467
                },
                {
                    "start": 1468,
                    "end": 1548
                },
                {
                    "start": 1549,
                    "end": 1655
                },
                {
                    "start": 1656,
                    "end": 1716
                },
                {
                    "start": 1717,
                    "end": 1860
                },
                {
                    "start": 1863,
                    "end": 1904
                },
                {
                    "start": 1905,
                    "end": 2004
                },
                {
                    "start": 2005,
                    "end": 2079
                },
                {
                    "start": 2080,
                    "end": 2155
                },
                {
                    "start": 2156,
                    "end": 2312
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.287841796875
        },
        {
            "corpus_id": "271993454",
            "title": "Developing Programming Competencies in School-Students With Block-Based Tools in Chile, Ecuador, and Peru",
            "text": "Block-based programming simplifies coding by representing programming constructs as blocks with a defined algorithmic purpose that can be manipulated and connected to create program code [6]. These blocks often use a drag-anddrop interface, making it accessible to beginners, especially children and people with without or little programming experience [30]. Block-based programming languages, such as Scratch1 and Blockly,2 provide a structured way to learn the basics of coding and computational thinking. \n\nAs [31], [32] remark, a primary benefit of block-based programming is its ability to foster computational thinking competencies. Computational thinking involves problem-solving techniques that draw from the principles of computer science [7]. Block-based programming helps individuals develop these competencies by breaking down complex problems into smaller, manageable parts [33]. Users must think logically, sequentially, and algorithmically when arranging these blocks to create functional code. \n\nDesign tools complement block-based programming by allowing users to create graphical user interfaces (GUIs) for their programs [34]. These tools, like App Inventor3 or Thunkable, 4 often employ a visual interface that encourages creativity and problem-solving. They enable users to design interactive and user-friendly applications, crucial for teaching user experience (UX) design principles and problem-solving in a real-world context [35]. TinkerCAD Arduino circuits5 is a mix of a design and block-based programming tool because it permits coding previous Arduino design circuits by using a block-based interface of style-C textual code programming language [10], [36]. \n\nBlock-based programming and design tools are invaluable in nurturing computational thinking competencies for their user-friendly, visually intuitive approach to coding and design, making them accessible to learners of all ages and backgrounds [37]. As technology becomes increasingly integral to daily life, we can say that these skills are essential for navigating a rapidly changing world. Figure 1 shows the primary examples of using those programming and design tools, like 'Hello World.' Figure 1a shows a Scratch code example in which the main character will move ten steps and then play the sound 'meow.' Figure 1b shows a Blockly Games code example in which the main character will reach the red balloon or goal.",
            "score": 0.31213651522957697,
            "section_title": "II. BACKGROUND A. BLOCK-BASED PROGRAMMING AND DESIGN",
            "char_start_offset": 7255,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 191
                },
                {
                    "start": 192,
                    "end": 358
                },
                {
                    "start": 359,
                    "end": 507
                },
                {
                    "start": 510,
                    "end": 638
                },
                {
                    "start": 639,
                    "end": 752
                },
                {
                    "start": 753,
                    "end": 892
                },
                {
                    "start": 893,
                    "end": 1009
                },
                {
                    "start": 1012,
                    "end": 1145
                },
                {
                    "start": 1146,
                    "end": 1273
                },
                {
                    "start": 1274,
                    "end": 1455
                },
                {
                    "start": 1456,
                    "end": 1686
                },
                {
                    "start": 1689,
                    "end": 1937
                },
                {
                    "start": 1938,
                    "end": 2080
                },
                {
                    "start": 2081,
                    "end": 2409
                }
            ],
            "ref_mentions": [
                {
                    "start": 187,
                    "end": 190,
                    "matchedPaperCorpusId": "243789016"
                },
                {
                    "start": 353,
                    "end": 357,
                    "matchedPaperCorpusId": "227140030"
                },
                {
                    "start": 513,
                    "end": 517,
                    "matchedPaperCorpusId": "249476630"
                },
                {
                    "start": 519,
                    "end": 523,
                    "matchedPaperCorpusId": "264315284"
                },
                {
                    "start": 748,
                    "end": 751,
                    "matchedPaperCorpusId": "238850591"
                },
                {
                    "start": 1140,
                    "end": 1144,
                    "matchedPaperCorpusId": "252417497"
                },
                {
                    "start": 1675,
                    "end": 1679,
                    "matchedPaperCorpusId": "253880901"
                },
                {
                    "start": 1932,
                    "end": 1936,
                    "matchedPaperCorpusId": "247731455"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7060546875
        },
        {
            "corpus_id": "229307220",
            "title": "Educational Robotics: Platforms, Competitions and Expected Learning Outcomes",
            "text": "This section presents and categorizes the most common Educational Robotics kits and platforms. Most manufacturers recommend using their educational robotics tools based on students' ages and the capabilities and difficulties an age group will face when building or programming them. However, when implementing them, those age boundaries are vague as most of the ER kits offer more than one option of programming, like onboard buttons and visual or textual programming, making them suitable for more age groups. Moreover, the programming background of students and their general cognitive skills, in combination with an ER kit that can maintain their interest, can affect their motivation and engagement in learning [17], [112], [113]. \n\nFollowing the above, we have chosen to categorize the ER kits based on the prior knowledge and programming skills a student must have to use them efficiently. In this paper, we propose three categories of robotics: No Code, Basic Code, and Advanced Code. \n\nThe 'No Code' category includes all the educational robotic kits programmed with a Tangible Programming Language (TaPL). The program flow can be specified by haptic programmable onboard buttons or physical code cards or bricks that correspond to programming elements and commands. Although no specific programming language or platform is used, students can compose instructions and learn basic programming concepts [114]. Tangible programming languages rely on real-world interaction where students don't use a computer, a mouse, or a keyboard to create their program. In this way, tangible programming languages evoke growth in students' intuitive, everyday knowledge and human abilities to manipulate physical materials to combine objects and program their robot [114], [115]. \n\nIn the 'Basic Code' category, we categorize the robotics platforms that can be programmed through a Visual Programming Language (VPL). With the VPL, the amount of traditional hand-code writing is reduced as pictures replace the commands. The robotic kits can be programmed through a friendly graphical user interface, with visual programming blocks, a student can drag and drop to compose a program. While VPLs are free of language syntax and semantics, students must still follow some visual form rules. Moreover, students can experiment with their program by merely changing the order or the parameters' values in the graphical blocks [115], [116]. \n\n'Advanced Code' Robotics consist of robotics kits that can be programmed with Textual Programming Languages (TPLs).",
            "score": 0.3121325854512186,
            "section_title": "IV. EDUCATIONAL PLATFORMS",
            "char_start_offset": 39317,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 94
                },
                {
                    "start": 95,
                    "end": 282
                },
                {
                    "start": 283,
                    "end": 510
                },
                {
                    "start": 511,
                    "end": 734
                },
                {
                    "start": 737,
                    "end": 895
                },
                {
                    "start": 896,
                    "end": 991
                },
                {
                    "start": 994,
                    "end": 1114
                },
                {
                    "start": 1115,
                    "end": 1274
                },
                {
                    "start": 1275,
                    "end": 1415
                },
                {
                    "start": 1416,
                    "end": 1562
                },
                {
                    "start": 1563,
                    "end": 1772
                },
                {
                    "start": 1775,
                    "end": 1909
                },
                {
                    "start": 1910,
                    "end": 2012
                },
                {
                    "start": 2013,
                    "end": 2174
                },
                {
                    "start": 2175,
                    "end": 2279
                },
                {
                    "start": 2280,
                    "end": 2425
                },
                {
                    "start": 2428,
                    "end": 2543
                }
            ],
            "ref_mentions": [
                {
                    "start": 715,
                    "end": 719,
                    "matchedPaperCorpusId": "1474985"
                },
                {
                    "start": 728,
                    "end": 733,
                    "matchedPaperCorpusId": "5106626"
                },
                {
                    "start": 1409,
                    "end": 1414,
                    "matchedPaperCorpusId": "1125742"
                },
                {
                    "start": 1759,
                    "end": 1764,
                    "matchedPaperCorpusId": "1125742"
                },
                {
                    "start": 1766,
                    "end": 1771,
                    "matchedPaperCorpusId": "10699253"
                },
                {
                    "start": 2412,
                    "end": 2417,
                    "matchedPaperCorpusId": "10699253"
                },
                {
                    "start": 2419,
                    "end": 2424,
                    "matchedPaperCorpusId": "62524830"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82275390625
        },
        {
            "corpus_id": "19897341",
            "title": "Visual Syntax of UML Class and Package Diagram Constructs as an Ontology",
            "text": "In Computer Science (CS), diagrams are studied as visual languages, where diagrams in a given visual language follow a common syntactical structure (Drewes and Klempien-Hinrichs, 2000). When studying a visual language in CS, researchers are faced with two main tasks; symbolic specification of its visual syntax and semantics in a suitable formalism, and the study of the use of such specifications in technical applications (Marriott et al., 1998). The work in this paper only focuses on the specification of the visual syntax of a selected set of UML class and package diagram constructs. \n\nAlthough the visual syntax specification prescribes the visual structure of valid diagrams, more than one correct specification is possible for a given visual language. These variations occur because a spatial structure can be modeled in different ways (G Costagliola and Tortora, 1997) based on the chosen spatial relationships and the granularity of primitive elements. Thus in view of these variations there can be numerous visual syntax specifications for a visual language like UML. \n\nNumerous techniques in grammatical, logical, algebraic formalisms have been explored for visual language specifications. Such specifications have also been used in numerous diagram processing applications as well. The paper by (Marriott et al., 1998) includes an overview of the various visual syntax specification techniques and applications. The specification formalism used in this work is logic with ontology as the specification technique.",
            "score": 0.311939090775342,
            "section_title": "Visual Languages",
            "char_start_offset": 5546,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 185
                },
                {
                    "start": 186,
                    "end": 449
                },
                {
                    "start": 450,
                    "end": 590
                },
                {
                    "start": 593,
                    "end": 761
                },
                {
                    "start": 762,
                    "end": 964
                },
                {
                    "start": 965,
                    "end": 1080
                },
                {
                    "start": 1083,
                    "end": 1203
                },
                {
                    "start": 1204,
                    "end": 1296
                },
                {
                    "start": 1297,
                    "end": 1426
                },
                {
                    "start": 1427,
                    "end": 1527
                }
            ],
            "ref_mentions": [
                {
                    "start": 148,
                    "end": 184,
                    "matchedPaperCorpusId": "18891148"
                },
                {
                    "start": 846,
                    "end": 879,
                    "matchedPaperCorpusId": "15962975"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.6103515625
        },
        {
            "corpus_id": "236336244",
            "title": "Hybrid Visual Programming Language Environment for Programming Training",
            "text": "In computer science, a visual programming language (VPL) is any programming language that lets users create programs by manipulating program elements graphically rather than by specifying them textually [1]. A VPL allows programming with visual expressions, spatial arrangements of text and graphic symbols, used either as syntax elements or secondary notation. \n\nMany VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations. \n\nVPLs are not something new. Initially, the idea behind their development was to awake the passion for programming in children from an early age. For this reason, Feurzeig, Seymour and Cynthia Solomon designed the programming language Logo in 1967 [3]. Logo is famous for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on a screen or with a small robot termed a turtle. Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding. Although Scratch is for beginners in programming, it is not as simple as functionality language. Other known VPLs for Scratch for Android are: Ardublock, GraspIO, ReactiveBlocks and AT&T Flow Designer. \n\nEach of these VPLs is built on a text-based programming language (such as ActionScript, JavaScript, C #, Java, etc.), which the user does not need to know to compile a program from the blocks of the VPL. \n\nMost VPLs are considered to be mainly for children's education or use by non-specialists. No approach is specially adapted to the initial training of future programmers. Weintrop and Wilensky [6] review earliest found study for Hybrid Visual Programming Languages as mentioned in [7], which also reviews several other attempts for Hybrid approach, such as [8] and [9]. These Hybrid approaches, however, are very bound to specific well-known text programming languages and do not provide more language independent approaches.",
            "score": 0.311939090775342,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 207
                },
                {
                    "start": 208,
                    "end": 361
                },
                {
                    "start": 364,
                    "end": 544
                },
                {
                    "start": 547,
                    "end": 574
                },
                {
                    "start": 575,
                    "end": 691
                },
                {
                    "start": 692,
                    "end": 798
                },
                {
                    "start": 799,
                    "end": 980
                },
                {
                    "start": 981,
                    "end": 1017
                },
                {
                    "start": 1018,
                    "end": 1036
                },
                {
                    "start": 1037,
                    "end": 1148
                },
                {
                    "start": 1149,
                    "end": 1245
                },
                {
                    "start": 1246,
                    "end": 1350
                },
                {
                    "start": 1353,
                    "end": 1556
                },
                {
                    "start": 1559,
                    "end": 1648
                },
                {
                    "start": 1649,
                    "end": 1728
                },
                {
                    "start": 1729,
                    "end": 1927
                },
                {
                    "start": 1928,
                    "end": 2083
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.92236328125
        },
        {
            "corpus_id": "12337509",
            "title": "Exploiting XPG for Visual Languages: Definition, Analysis and Development",
            "text": "It is widely recognized that a visual language can be effectively used only if it is supported by a visual environment within which it is embedded and tightly integrated. This has motivated the research for tools which generate visual environments starting from formal specifications of visual languages [2,5,6,8,17,18,9,22].\n\nThe Visual Language Compiler-Compiler (VLCC) is a visual environment generation system based on the XPG model that inherits, and extends to the visual field, concepts and techniques of compiler generation tools like YACC [6,13]. Such tool assists the visual language designer in the definition of the language by assisting him/her in the specification of the symbols, the syntax and the semantics of the language, and automatically generates a visual environment starting from the supplied language specification.  The architecture of VLCC is shown in Fig. 9. The designer creates the terminal and the non-terminal symbols of the grammar by using the Symbol Editor. This editor works in two modes, the drawing mode and the symbol mode. In drawing mode the designer can create or modify images using the usual graphical editor facilities. In symbol mode the designer can transform an image into a grammar symbol (terminal or non-terminal) by adding the syntactic and the semantic attributes, or can modify the syntactic or semantic attributes of a symbol.",
            "score": 0.311939090775342,
            "section_title": "An XPG-based Generator of Visual Environments",
            "char_start_offset": 23003,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 304,
                    "end": 307,
                    "matchedPaperCorpusId": "5985096"
                },
                {
                    "start": 307,
                    "end": 309,
                    "matchedPaperCorpusId": "3023909"
                },
                {
                    "start": 309,
                    "end": 311,
                    "matchedPaperCorpusId": "812535"
                },
                {
                    "start": 311,
                    "end": 313,
                    "matchedPaperCorpusId": "36814067"
                },
                {
                    "start": 313,
                    "end": 316,
                    "matchedPaperCorpusId": "18590433"
                },
                {
                    "start": 316,
                    "end": 319,
                    "matchedPaperCorpusId": "5686426"
                },
                {
                    "start": 319,
                    "end": 321,
                    "matchedPaperCorpusId": "41440675"
                },
                {
                    "start": 321,
                    "end": 324,
                    "matchedPaperCorpusId": "11930938"
                },
                {
                    "start": 548,
                    "end": 551,
                    "matchedPaperCorpusId": "812535"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.78125
        },
        {
            "corpus_id": "276961580",
            "title": "InstructPipe: Generating Visual Blocks Pipelines with Human Instructions and LLMs",
            "text": "A computer program defines the operation of computer systems. However, \"the program given to a computer for solving a problem need not be in a written format\" [73]. This future-looking statement, dating back to the 1960s, inspired several generations of researchers to design and build visual programming systems. Today, visual programming systems (e.g., LabView [39], Unity Graph Editor [76], PromptChainer [84], ComfyUI [13] and Visual Blocks [18]) typically feature a node graph editor, providing users with a visual workspace to \"write\" their program using \"building blocks\" [28,68,89]. Recent work further explored the application of visual programming in education [9,35,40], XR creativity support [88,91,93], and robotics [14,30,31]. For example, Zhang et al. [93] connected the visual programming tool to the concept of teaching by demonstration [44,49,99], allowing users to rapidly customize AR effects in video creation. FlowMatic [91] extended traditional visual programming interfaces into 3D virtual environments, providing users with immersive authoring experiences. \n\nAdvancements in AI have introduced many repositories of advanced ML models [33,66], and an increasing number of researchers are exploring AI chains [41,86]. This progress has motivated HCI researchers to design and build a range of visual programming interfaces to support the AI development process [13,43,84]. For example, ChainForge is a web-based platform for developers to explore various LLM-related configuration and designs in a wide range of applications [4]. Visual Blocks enables creation and interaction of advanced ML pipelines that can leverage state-of-the-art computer vision and computer graphics models in the browser [18]. \n\nThis work contributes the technical system, implementation and evaluation of a novel AI assistant that enables the use of text-based instructions in visual programming of ML pipelines. Compared to typical workflows in which people manually build their pipelines, InstructPipe has the potential to accelerate ML pipeline prototyping in visual programming.",
            "score": 0.311939090775342,
            "section_title": "Related Work 2.1 Visual Programming",
            "char_start_offset": 6886,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 61
                },
                {
                    "start": 62,
                    "end": 164
                },
                {
                    "start": 165,
                    "end": 313
                },
                {
                    "start": 314,
                    "end": 590
                },
                {
                    "start": 591,
                    "end": 740
                },
                {
                    "start": 741,
                    "end": 931
                },
                {
                    "start": 932,
                    "end": 1081
                },
                {
                    "start": 1084,
                    "end": 1240
                },
                {
                    "start": 1241,
                    "end": 1395
                },
                {
                    "start": 1396,
                    "end": 1552
                },
                {
                    "start": 1553,
                    "end": 1725
                },
                {
                    "start": 1728,
                    "end": 1912
                },
                {
                    "start": 1913,
                    "end": 2082
                }
            ],
            "ref_mentions": [
                {
                    "start": 408,
                    "end": 412,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 445,
                    "end": 449,
                    "matchedPaperCorpusId": "258216977"
                },
                {
                    "start": 579,
                    "end": 583,
                    "matchedPaperCorpusId": "1529669"
                },
                {
                    "start": 583,
                    "end": 586,
                    "matchedPaperCorpusId": "259376453"
                },
                {
                    "start": 586,
                    "end": 589,
                    "matchedPaperCorpusId": "269753286"
                },
                {
                    "start": 671,
                    "end": 674,
                    "matchedPaperCorpusId": "267523023"
                },
                {
                    "start": 674,
                    "end": 677,
                    "matchedPaperCorpusId": "258217657"
                },
                {
                    "start": 677,
                    "end": 680,
                    "matchedPaperCorpusId": "220885043"
                },
                {
                    "start": 704,
                    "end": 708,
                    "matchedPaperCorpusId": "269717820"
                },
                {
                    "start": 708,
                    "end": 711,
                    "matchedPaperCorpusId": "222799772"
                },
                {
                    "start": 711,
                    "end": 714,
                    "matchedPaperCorpusId": "264350354"
                },
                {
                    "start": 729,
                    "end": 733,
                    "matchedPaperCorpusId": "16198810"
                },
                {
                    "start": 733,
                    "end": 736,
                    "matchedPaperCorpusId": "207237260"
                },
                {
                    "start": 736,
                    "end": 739,
                    "matchedPaperCorpusId": "23415794"
                },
                {
                    "start": 767,
                    "end": 771,
                    "matchedPaperCorpusId": "264350354"
                },
                {
                    "start": 854,
                    "end": 858,
                    "matchedPaperCorpusId": "1504689"
                },
                {
                    "start": 858,
                    "end": 861,
                    "matchedPaperCorpusId": "12628167"
                },
                {
                    "start": 861,
                    "end": 864,
                    "matchedPaperCorpusId": "251252905"
                },
                {
                    "start": 942,
                    "end": 946,
                    "matchedPaperCorpusId": "222799772"
                },
                {
                    "start": 1163,
                    "end": 1166,
                    "matchedPaperCorpusId": "257833781"
                },
                {
                    "start": 1236,
                    "end": 1239,
                    "matchedPaperCorpusId": "238353829"
                },
                {
                    "start": 1391,
                    "end": 1394,
                    "matchedPaperCorpusId": "247447133"
                },
                {
                    "start": 1548,
                    "end": 1551,
                    "matchedPaperCorpusId": "262044762"
                },
                {
                    "start": 1720,
                    "end": 1724,
                    "matchedPaperCorpusId": "258216977"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.79541015625
        },
        {
            "corpus_id": "231725028",
            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
            "text": "Nevertheless, the study did not cover all VPL classifications discussed in the introduction. Further, the majority of the articles surveyed in the study were conference articles, and only a few journal articles were from journals relevant to visual programming such as the Journal of Visual Languages and Computing. \n\nTo sum up, despite the variety of review studies that targeted EUD in general, none of these studies focused specifically on visual programming with all its classifications (e.g. diagrammatic, iconic, block-based). Instead, it was partially covered in some of the studies as a subset of EUD.",
            "score": 0.3117667326215907,
            "section_title": "A. END-USER DEVELOPMENT REVIEW STUDIES",
            "char_start_offset": 15197,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 92
                },
                {
                    "start": 93,
                    "end": 315
                },
                {
                    "start": 318,
                    "end": 496
                },
                {
                    "start": 497,
                    "end": 532
                },
                {
                    "start": 533,
                    "end": 609
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.8076171875
        },
        {
            "corpus_id": "195848772",
            "title": "Are There Differences in Learning Gains When Programming a Tangible Object or a Simulation?",
            "text": "We have developed a programming Web interface to program the micro:bit (see Figure 2). This interface implements Blockly3 , a library that allows users to write code using a block-based visual programming language. Two versions of this interface were also developed: one for programming the tangible micro:bit and one for programming its simulation. However these two interfaces differ in only a small part as described later in this section. Figure 2 illustrates the interface designed to program the micro:bit simulation. It can be divided in 3 main zones of interest. \n\nZone 1 displays some identification information related to the current user and a drop down menu which can be used to select a programming exercise out of all the proposed ones. The wording of the currently selected exercise is displayed beneath this drop down menu. These exercises are the same whether the user is programming the tangible or simulated micro:bit. The design of these exercises will be detailed in Section 4.2. \n\nZone 2 corresponds to the code edition area. The left-hand part in grey displays all the categories of blocks that can be used with this programming interface. For this experiment, we proposed five different categories: Display, Math, Variables, Logic, and Loops. Each category contains blocks that are specific to their theme. As an example, we will explain in details the \"Display\" category showed in Figure 2. This category contains three different blocks: \n\n\u2022 the first one must be completed with another block in order to display a number on the micro:bit; \u2022 the second block of this category allows the user to design a shape and to display it on the board; \u2022 the last block can be used to display a pre-configured pictograph. \n\nA user can build a program by dragging and dropping blocks from whichever category into the workspace (with the white background). A user can also create more complex programs by combining several different blocks like shown in Figure 3. Zone 3 is the only zone of the programming interface that is different between the tangible and the simulation case. If the user programs the simulated micro:bit, Zone 3 displays the simulation which is updated each time the program is executed. If the user programs the tangible micro:bit, the simulation is replaced with instructions on how to execute a program on the tangible device.",
            "score": 0.31162080977404916,
            "section_title": "Programming Interface",
            "char_start_offset": 9801,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 86
                },
                {
                    "start": 87,
                    "end": 214
                },
                {
                    "start": 215,
                    "end": 349
                },
                {
                    "start": 350,
                    "end": 442
                },
                {
                    "start": 443,
                    "end": 523
                },
                {
                    "start": 524,
                    "end": 570
                },
                {
                    "start": 573,
                    "end": 750
                },
                {
                    "start": 751,
                    "end": 839
                },
                {
                    "start": 840,
                    "end": 937
                },
                {
                    "start": 938,
                    "end": 1000
                },
                {
                    "start": 1003,
                    "end": 1047
                },
                {
                    "start": 1048,
                    "end": 1162
                },
                {
                    "start": 1163,
                    "end": 1266
                },
                {
                    "start": 1267,
                    "end": 1330
                },
                {
                    "start": 1331,
                    "end": 1415
                },
                {
                    "start": 1416,
                    "end": 1462
                },
                {
                    "start": 1465,
                    "end": 1735
                },
                {
                    "start": 1738,
                    "end": 1868
                },
                {
                    "start": 1869,
                    "end": 2092
                },
                {
                    "start": 2093,
                    "end": 2221
                },
                {
                    "start": 2222,
                    "end": 2363
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.82763671875
        },
        {
            "corpus_id": "267523855",
            "title": "A Block-Based Programming Environment for Teaching Low-Level Computing (Discussion Paper)",
            "text": "A significant feature of software visualizations is their ability to make choices regarding the displayed information, its presentation, and what information is excluded.These different ways of displaying information are evident when comparing tools such as the Postroom Computer with EasyCPU.Whereas the Postroom Computer avoids the binary representation of numbers (addresses, register values, etc.) by using a base ten address schema, the EasyCPU tool decides to offer different ways of displaying values (binary, hex, and decimal) to foster an understanding that values can be represented in different ways.Another representation method used by tools like Francis is using arrows and colored blocks.Arrows are used to visually indicate the location to which the registers point (e.g., an arrow is used that points from the stack pointer to the area in memory to which the respective address points).Another aspect of presentation methods involves how code is represented within the various tools.Most tools choose a text-based representation based on mnemonics [10] or numeric opcodes [19].In addition to all the text-based tools, one tool stands out, developed by Beaumont and Jackson [1997], which uses visual templates to emphasize the semantics of machine commands.While this approach ensures that the tool only accepts syntactically correct instructions, which is a benefit of block-based programming languages as well, it overlooks other advantages of block-based programming tools, such as the ability to assemble code blocks through drag-and-drop.\n\nScope of Operation.Concerning this category, a distinction is made based on the environment in which each tool operates.Due to the publication years of the works above, most of the tools are applications designed for desktop PCs, as at the time of their publication, web technologies were not yet widely spread.However, some exceptions, such as SIMPLESAM [7] and Frances [21], utilize web application technologies.These web-based tools offer the advantage of accessibility, allowing students to use them when software installation on individual computers is impossible.Furthermore, it will enable students to use the tools outside lab environments.",
            "score": 0.3114205991282861,
            "section_title": "Tools for Teaching Low-Level Computing",
            "char_start_offset": 9180,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 170
                },
                {
                    "start": 170,
                    "end": 293
                },
                {
                    "start": 293,
                    "end": 611
                },
                {
                    "start": 611,
                    "end": 703
                },
                {
                    "start": 703,
                    "end": 903
                },
                {
                    "start": 903,
                    "end": 1000
                },
                {
                    "start": 1000,
                    "end": 1094
                },
                {
                    "start": 1094,
                    "end": 1273
                },
                {
                    "start": 1273,
                    "end": 1559
                },
                {
                    "start": 1561,
                    "end": 1580
                },
                {
                    "start": 1580,
                    "end": 1681
                },
                {
                    "start": 1681,
                    "end": 1872
                },
                {
                    "start": 1872,
                    "end": 1975
                },
                {
                    "start": 1975,
                    "end": 2130
                },
                {
                    "start": 2130,
                    "end": 2209
                }
            ],
            "ref_mentions": [
                {
                    "start": 1065,
                    "end": 1069,
                    "matchedPaperCorpusId": "36260092"
                },
                {
                    "start": 1089,
                    "end": 1093,
                    "matchedPaperCorpusId": "37900766"
                },
                {
                    "start": 1169,
                    "end": 1196,
                    "matchedPaperCorpusId": "61676657"
                },
                {
                    "start": 1916,
                    "end": 1919,
                    "matchedPaperCorpusId": "1857006"
                },
                {
                    "start": 1932,
                    "end": 1936,
                    "matchedPaperCorpusId": "3209657"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.50048828125
        },
        {
            "corpus_id": "221340525",
            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
            "text": "Programming nowadays is considered an essential skill and has been introduced in a novice level for different ages. Moreover, visual programming languages make programming more accessible for young people, which open more opportunities to innovate and explore. Scratch [1]; a visual programming environment developed by MIT, is one of the most popular block-based visual programming languages that allows users to create interactive and media-rich projects. On the other hand, deep learning is one of the trending computer science fields during the last years, and it acquired interest and focus in many different fields. Deep learning has a profound impact on our daily life and it is important that young people are aware of how our world works. However, it is not an easy task to understand the concepts of a deep learning as it requires deep understanding of mathematics and calculus. Understanding and applying deep learning requires spending hundreds of hours learning and debugging code, which is mostly frustrating for juniors. \n\nThe aim of this research is to extend the vocabulary of Scratch programming language to help young people designing and implementing deep learning applications. Deep learning has a profound impact on society. It has many applications in finance, healthcare, customer experience, weather prediction, etc. Nowadays, it is important that kids are aware of how the world works and understand the capabilities of deep learning. This paper presents DeepScratch, a new programming language extension to Scratch that provides powerful language elements to facilitate deep learning concepts to allow kids and high schoolers to understand and develop deep learning applications. This research is an extension of the paper: \"Extending Scratch: New Pathways into Programming\" [2]. \n\nDeepScratch provides two options to implement deep learning models: training a neural network based on built-in datasets, or using pre-trained deep learning models. The two options are provided to serve different age groups and educational stages. This paper introduces two main contributions: \n\n\u2022 Extend the vocabulary of Scratch visual programming language to enable developing deep learning applications using Scratch, which opens an opportunity for researchers to continue and expand our work. \n\n\u2022 A tool for educators to teach kids basic deep learning concepts (different neural networks architectures, hyper-parameters tuning, and classification metrics). \n\nBeing able to build deep learning application with visual programming language should be very useful for kids.",
            "score": 0.3114024434838929,
            "section_title": "I. INTRODUCTION",
            "char_start_offset": 18,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 115
                },
                {
                    "start": 116,
                    "end": 260
                },
                {
                    "start": 261,
                    "end": 457
                },
                {
                    "start": 458,
                    "end": 621
                },
                {
                    "start": 622,
                    "end": 747
                },
                {
                    "start": 748,
                    "end": 888
                },
                {
                    "start": 889,
                    "end": 1035
                },
                {
                    "start": 1038,
                    "end": 1198
                },
                {
                    "start": 1199,
                    "end": 1246
                },
                {
                    "start": 1247,
                    "end": 1460
                },
                {
                    "start": 1461,
                    "end": 1706
                },
                {
                    "start": 1707,
                    "end": 1806
                },
                {
                    "start": 1809,
                    "end": 1973
                },
                {
                    "start": 1974,
                    "end": 2056
                },
                {
                    "start": 2057,
                    "end": 2102
                },
                {
                    "start": 2105,
                    "end": 2306
                },
                {
                    "start": 2309,
                    "end": 2470
                },
                {
                    "start": 2473,
                    "end": 2583
                }
            ],
            "ref_mentions": [
                {
                    "start": 269,
                    "end": 272,
                    "matchedPaperCorpusId": "9744698"
                },
                {
                    "start": 1802,
                    "end": 1805,
                    "matchedPaperCorpusId": "17452915"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.81640625
        },
        {
            "corpus_id": "53282492",
            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
            "text": "Brunett et al. [Burnett and Baker 1994] were one of the first to define a list of eleven main paradigms present in VPL that include the traditional paradigms in programming but also others. Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).",
            "score": 0.31069681289542206,
            "section_title": "Visual Metaphors.",
            "char_start_offset": 48894,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 189
                },
                {
                    "start": 190,
                    "end": 515
                },
                {
                    "start": 516,
                    "end": 552
                }
            ],
            "ref_mentions": [
                {
                    "start": 15,
                    "end": 39,
                    "matchedPaperCorpusId": "1426814"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.9140625
        },
        {
            "corpus_id": "10304140",
            "title": "Object-Oriented Programming for non-IT Students: Starting from Scratch",
            "text": "A new trend in teaching programming skills is the development of an environment created especially for learning. These are graphical tools, such as Scratch [8], Snap! [9], Blockly [10], which make the learning process much easier for the beginners especially for non-IT, who have not any experience in programming. \n\nIn our course we use Scratch as the supporting tool before creating applications in VBA or Python. After a few years of practice, we came to the conclusion that a graphical environment, such as Scratch, is an effective introductory tool to understand both the object-oriented approach and the functionality of a program. \n\nIn addition, syntax errors are impossible in Scratch, which is a great help for students. It is easy to discover and correct run-time errors as well, because Scratch works as an interpreter. \n\nGraphical command blocks give a visual picture of the different controls (selections, loops), used in the program. They create the necessary associations when students start coding in a text-based programming language. \n\nScratch is not designed to solve complicated tasks, but it is simple, very expressive, and makes understanding the behaviour of objects easier. \n\nIt should be mentioned that according the annual students' feedback Scratch is the most popular module in the course. \n\nCreation of objects is solved by importing or drawing graphics. Combining the blocks for each object creates the methods. Some of the blocks are used to show the reaction of the object to some events. We see here the main aspects of object-oriented programming resulting in an attractive animation. \n\nFurther, we will briefly review the main programming concepts that are usually complicated for non-IT learners.",
            "score": 0.3105173814089631,
            "section_title": "IV. VISUAL PROGRAMMING WITH SCRATCH",
            "char_start_offset": 7747,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 112
                },
                {
                    "start": 113,
                    "end": 314
                },
                {
                    "start": 317,
                    "end": 415
                },
                {
                    "start": 416,
                    "end": 637
                },
                {
                    "start": 640,
                    "end": 729
                },
                {
                    "start": 730,
                    "end": 830
                },
                {
                    "start": 833,
                    "end": 947
                },
                {
                    "start": 948,
                    "end": 1051
                },
                {
                    "start": 1054,
                    "end": 1197
                },
                {
                    "start": 1200,
                    "end": 1317
                },
                {
                    "start": 1320,
                    "end": 1383
                },
                {
                    "start": 1384,
                    "end": 1441
                },
                {
                    "start": 1442,
                    "end": 1520
                },
                {
                    "start": 1521,
                    "end": 1618
                },
                {
                    "start": 1621,
                    "end": 1732
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.51123046875
        },
        {
            "corpus_id": "225476845",
            "title": "Plugged or Unplugged Teaching: A Case Study of Students' Preferences in the Teaching of Programming",
            "text": ", 2010), which makes learning programming is quite challenging (Helminen and Malmi, 2010), and students have an overall lower level of achievement in this subject (Robins, Rountree, and Rountree, 2003). In order to increase the success of teaching programming and to facilitate students' understanding, it is necessary to first teach the logic of algorithms to students (Ala-Mutka, 2004). For this purpose, interesting and entertaining visual programming tools have been developed in order to facilitate learning for beginners in programming education (Schwartz, Stagner, and Morrison, 2006).\n\nTeaching programming entails challenges in selecting suitable activities for a group of learners (\u00c7atlak, Tekdal, and Baz, 2015), helping students understand and apply algorithms (Futschek and Moschitz, 2010), and helping them use programming languages in writing codes (Arabac\u0131o\u011flu, B\u00fclb\u00fcl, and Filiz, 2007). The syntax of textbased programming is considered as one of the most challenging issues for students (Mannila, Peltomaki, and Salakoski, 2006;\u00d6zmen and Altun, 2014), while the code blocks presented in visual programming are easier for beginning level programmers to understand and apply (Wilson and Moffat, 2010). Calder (2010) argues that working with the block-based visual tools of programming software increases students' satisfaction and motivation to persist. In many studies, it was noted that the use of visual programming accelerates comprehension of the process (Naharro-Berrocal, Pareja-Flores, Urquiza-Fuentes, and Velazquez-Iturbide, 2002). For beginning learners, therefore, elementary level software programs such as Scratch (Malan and Leitner, 2007;Wu, Chang and He, 2010), Kodu (Stolee and Fristoe, 2011), StarLogo (Klopfer and Yoon, 2005), and Alice (Kelleher, Pausch, and Kiesler, 2007) are recommended as they allow students to perform coding by placing code blocks in order through drag and drop functions. In this way, the frequently faced problem of syntactic errors in text-based programming can be largely overcome.\n\nIn addition, attitudes toward programming (Gomes and Mendes",
            "score": 0.3090666023235024,
            "section_title": "Introduction",
            "char_start_offset": 1904,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 63,
                    "end": 89,
                    "matchedPaperCorpusId": "2011847"
                },
                {
                    "start": 163,
                    "end": 201,
                    "matchedPaperCorpusId": "10565822"
                },
                {
                    "start": 552,
                    "end": 591,
                    "matchedPaperCorpusId": "604956"
                },
                {
                    "start": 1046,
                    "end": 1068,
                    "matchedPaperCorpusId": "55080386"
                },
                {
                    "start": 1191,
                    "end": 1216,
                    "matchedPaperCorpusId": "14969243"
                },
                {
                    "start": 1218,
                    "end": 1231,
                    "matchedPaperCorpusId": "111179390"
                },
                {
                    "start": 1510,
                    "end": 1556,
                    "matchedPaperCorpusId": "8752964"
                },
                {
                    "start": 1644,
                    "end": 1669,
                    "matchedPaperCorpusId": "982597"
                },
                {
                    "start": 1669,
                    "end": 1692,
                    "matchedPaperCorpusId": "60583992"
                },
                {
                    "start": 1699,
                    "end": 1725,
                    "matchedPaperCorpusId": "3344110"
                },
                {
                    "start": 1772,
                    "end": 1809,
                    "matchedPaperCorpusId": "3910027"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.4443359375
        },
        {
            "corpus_id": "270293322",
            "title": "A Layout-to-Generator Conversion Framework With Graphical User Interface for Visual Programming of Analog Layout Generators",
            "text": "We adopted a program tree to conveniently describe and edit a hierarchically complex layout generator via visual programming. The tree structure can store/access hierarchical data efficiently and is also efficient in inserting or removing sorted data. Therefore, the program tree is advantageous in hierarchically describing a layout generator and editing the flow of layout generation. The program tree consists of program blocks (Fig. 7). The program block is a basic unit for visual programming, which can perform a specific operation. For example, by creating a program block of boundary class and passing arguments, it can generate code that creates a boundary layout instance. The program tree can be compiled into a generator while each program block corresponds to a unit piece of generator code that can be easily added to or removed from the generator source code. Using the generator view, a designer can easily add a program block to or remove it from a program tree, like playing with Lego blocks. Therefore, a designer can easily describe a complex hierarchy of a layout generator by putting the appropriate program blocks in the appropriate locations in the program tree according to the generator's design hierarchy (Fig. 7). A layout program block class can be compiled into a piece of source code that can generate a layout element. A boundary block, a path block, a sref block, an array block, and a hard macro cell block belong to this class. A boundary block has argument fields of layer, width, height as well as coordinates of the position to describe the boundary to be generated (Fig. 5a and Fig. 7). An sref block is used to describe a sub-cell, and therefore, it has argument fields of position coordinates as well as the name and input variables of the sub-cell's generator (Fig. 5a and Fig. 7). A hard macro cell block is used to refer to an existing sub-cell layout with fixed dimensions, which can be seamlessly integrated into a layout generator. For example, a phantom cell that hides detailed layout information for security purpose belongs to this type. An array block provides a convenient way to describe an array of layout elements instead of using many other layout program blocks. Because a usual layout has many arrays, a designer can much more efficiently describe arrays with array blocks. \n\nFunctional program block class helps a designer easily describe parametric expressions and logical statements.",
            "score": 0.30887401304497075,
            "section_title": "A. VISUAL PROGRAMMING",
            "char_start_offset": 27212,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 125
                },
                {
                    "start": 126,
                    "end": 251
                },
                {
                    "start": 252,
                    "end": 386
                },
                {
                    "start": 387,
                    "end": 440
                },
                {
                    "start": 441,
                    "end": 538
                },
                {
                    "start": 539,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 874
                },
                {
                    "start": 875,
                    "end": 1010
                },
                {
                    "start": 1011,
                    "end": 1241
                },
                {
                    "start": 1242,
                    "end": 1350
                },
                {
                    "start": 1351,
                    "end": 1462
                },
                {
                    "start": 1463,
                    "end": 1625
                },
                {
                    "start": 1626,
                    "end": 1823
                },
                {
                    "start": 1824,
                    "end": 1978
                },
                {
                    "start": 1979,
                    "end": 2088
                },
                {
                    "start": 2089,
                    "end": 2220
                },
                {
                    "start": 2221,
                    "end": 2332
                },
                {
                    "start": 2335,
                    "end": 2445
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.7490234375
        },
        {
            "corpus_id": "15115049",
            "title": "Procedural Content Graphs for Urban Modeling",
            "text": "The visual nature of our approach makes the flow of data easier to follow and does not require the user to come up with rule symbols (highlighted in blue) or geometric labels [6,7], which generally make management difficult and error-prone. \n\nhigh-level primitives are defined in a \"Professional mode,\" which still requires editing a complex text-based grammar, but interactive customization and combination was possible within a \"high-level mode.\" Interactive design frameworks have also been investigated to simplify grammar definitions [18], but they were still tied to the rule-based structure of the underlying grammar. \n\nA different interactive alternative is the exploration of shape variations, layouts, and components [19,20] and processing [21]. Grammars can also be derived from existing models [22,23] and then interactively controlled [24]. However, these approaches have a different focus compared to our work; we provide a framework to guide and support content creation. \n\nA popular alternative for the textual rule definition is the visual programming language paradigm [25], especially the one based on dataflow graphs [26]. Application examples include generation of terrain [27], trees [28,29], textures/images [30,31], animations [31,32], or geometry in general [6,32], all featuring their own specific manipulation metaphor. A framework that aimed at integrating several types of content was proposed in [33]. \n\nThe work of Patow [7] is a general system with the goal of making shape grammars more comprehensive by employing a visualization in the form of a node-based system. Nonetheless, the use of the Houdini engine [6] makes it impossible to create cycles and therefore recursive procedures (an essential basis in grammars). In addition, this approach does not allow more than one output port, which could be used to control flow divergence. Instead, it resorts to label filtering, which introduces manageability issues for longer graphs, some of which have been alleviated by [34]. Also, while it is possible to create high-level digital assets, it is not possible to introduce new types of semantic entities and their high-level nodes inherit the same (and other) port limitations.",
            "score": 0.30887401304497075,
            "section_title": "Previous Work",
            "char_start_offset": 7366,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 240
                },
                {
                    "start": 243,
                    "end": 448
                },
                {
                    "start": 449,
                    "end": 624
                },
                {
                    "start": 627,
                    "end": 755
                },
                {
                    "start": 756,
                    "end": 853
                },
                {
                    "start": 854,
                    "end": 986
                },
                {
                    "start": 989,
                    "end": 1142
                },
                {
                    "start": 1143,
                    "end": 1346
                },
                {
                    "start": 1347,
                    "end": 1431
                },
                {
                    "start": 1434,
                    "end": 1598
                },
                {
                    "start": 1599,
                    "end": 1751
                },
                {
                    "start": 1752,
                    "end": 1868
                },
                {
                    "start": 1869,
                    "end": 2009
                },
                {
                    "start": 2010,
                    "end": 2210
                }
            ],
            "ref_mentions": [
                {
                    "start": 178,
                    "end": 180,
                    "matchedPaperCorpusId": "10143178"
                },
                {
                    "start": 539,
                    "end": 543,
                    "matchedPaperCorpusId": "2825415"
                },
                {
                    "start": 727,
                    "end": 731,
                    "matchedPaperCorpusId": "108094333"
                },
                {
                    "start": 731,
                    "end": 734,
                    "matchedPaperCorpusId": "8842841"
                },
                {
                    "start": 750,
                    "end": 754,
                    "matchedPaperCorpusId": "11374916"
                },
                {
                    "start": 806,
                    "end": 810,
                    "matchedPaperCorpusId": "14691501"
                },
                {
                    "start": 810,
                    "end": 813,
                    "matchedPaperCorpusId": "5646134"
                },
                {
                    "start": 848,
                    "end": 852,
                    "matchedPaperCorpusId": "18175965"
                },
                {
                    "start": 1087,
                    "end": 1091,
                    "matchedPaperCorpusId": "58744159"
                },
                {
                    "start": 1137,
                    "end": 1141,
                    "matchedPaperCorpusId": "5257722"
                },
                {
                    "start": 1206,
                    "end": 1210,
                    "matchedPaperCorpusId": "21118559"
                },
                {
                    "start": 1426,
                    "end": 1430,
                    "matchedPaperCorpusId": "741480"
                },
                {
                    "start": 1452,
                    "end": 1455,
                    "matchedPaperCorpusId": "10143178"
                },
                {
                    "start": 2004,
                    "end": 2008,
                    "matchedPaperCorpusId": "21743521"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.740234375
        },
        {
            "corpus_id": "261992658",
            "title": "Spatial configuration by rules: an experimental parametric shape rules by shape grammar method",
            "text": "Other than TPL, there is another programming method known as Visual Programming Language (VPL), which according to Ferruci et al. (2002), allows users to communicate with the computer system by visually arranging programmable objects on the computer screen. Figure 1 shows a simple shapes composition in Rhinoceros 3D generated by an algorithm in grasshopper, shown in figure 2.  Although the composition is simple, the algorithm to generate it has a few components that, to an inexperienced programmer, would be pretty challenging to arrange. The ideal, as shown in figure 3, is an architect that, as an inexperienced programmer, only focuses on the creative process of defining the shape rules and constructing the shape grammar method and allows the generation of shapes and their transformation procedures to be automated process through a set of modular and parametric instructions.",
            "score": 0.30887401304497075,
            "section_title": "Introduction",
            "char_start_offset": 4297,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 257
                },
                {
                    "start": 258,
                    "end": 543
                },
                {
                    "start": 544,
                    "end": 887
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.73291015625
        },
        {
            "corpus_id": "239179809",
            "title": "Is Mathematics Required for Cooking? An Interdisciplinary Approach to Integrating Computational Thinking in a Culinary and Restaurant Management Course",
            "text": "Alberts and Stevenson [38] stated that digital media refers to interactive information exchange and communication media that uses multiple media or a combination of two or more media in computer application systems. Digital media is computer-centric and can simultaneously present text, images, audio and animations. When instruction is delivered through digital media, students make obvious gains in terms of knowledge, attitudes and intentions in relation to food. \n\nTraditional text-based programming design focuses mainly on abstract concepts. For many students, this learning method is challenging and it can easily lead to low interest and fear in learning situations [39]. In comparison, the emergence of the E-visual programming language lowers the threshold of programming learning. Kelleher and Pausch [40] revealed the three common characteristics of the E-visual programming environment: simplifying the programming design process, providing support for students' learning and stimulating students' learning motivation. Selby and Woollard [41] proposed that programming design activities are related to computational thinking ability. While learning programming, students can achieve a complete understanding and application of computational thinking and elements such as disassembly, pattern recognition and abstraction can be included. Regarding the use of E-visualization development tools to learn computational thinking, Schnotz and Bannert [42] and Holmqvist and Wartenberg [43] stated that it is much easier to read graphics than reading texts, which is helpful for the mastery of the entire program structure. Learning with E-visualization is more natural than learning with text only. \n\nHsu et al. [44] applied visualized E-learning with digital media to teaching culinary courses and found that it improved students' culinary skills during training. Malan and Leitner [45] pointed out that, while learning E-visual programming, students feel like they are playing games instead of writing programs, which can help them understand the concept of programming. In teaching, it is possible to program E-visual language and teach using program blocks to guide students in step-by-step thinking; in this way, students do not have to worry about spelling or grammatical errors and can concentrate on the logic and structure of programming [46].",
            "score": 0.3087581180975336,
            "section_title": "Teaching with Digital Media",
            "char_start_offset": 14452,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 215
                },
                {
                    "start": 216,
                    "end": 316
                },
                {
                    "start": 317,
                    "end": 466
                },
                {
                    "start": 469,
                    "end": 547
                },
                {
                    "start": 548,
                    "end": 679
                },
                {
                    "start": 680,
                    "end": 791
                },
                {
                    "start": 792,
                    "end": 1031
                },
                {
                    "start": 1032,
                    "end": 1146
                },
                {
                    "start": 1147,
                    "end": 1349
                },
                {
                    "start": 1350,
                    "end": 1629
                },
                {
                    "start": 1630,
                    "end": 1705
                },
                {
                    "start": 1708,
                    "end": 1871
                },
                {
                    "start": 1872,
                    "end": 2079
                },
                {
                    "start": 2080,
                    "end": 2359
                }
            ],
            "ref_mentions": [
                {
                    "start": 22,
                    "end": 26,
                    "matchedPaperCorpusId": "151987094"
                },
                {
                    "start": 674,
                    "end": 678,
                    "matchedPaperCorpusId": "70424"
                },
                {
                    "start": 812,
                    "end": 816,
                    "matchedPaperCorpusId": "9916677"
                },
                {
                    "start": 1458,
                    "end": 1462,
                    "matchedPaperCorpusId": "6820370"
                },
                {
                    "start": 1719,
                    "end": 1723,
                    "matchedPaperCorpusId": "58938566"
                },
                {
                    "start": 1890,
                    "end": 1894,
                    "matchedPaperCorpusId": "982597"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.397216796875
        },
        {
            "corpus_id": "199408820",
            "title": "Engaging Primary School Children in Computational Thinking: Designing and Developing Videogames",
            "text": "Starting from the primary school age, the art of programming changes the children perspectives from application users to application creators. \n\nToday coding has become a more accessible and funny activity thanks to the visual and block languages paradigm (Bau, Gray, Kelleher, Sheldon, & Turbak, 2017). It opens up new opportunities for programming without struggling with the text-based coding. Scratch (Resnick et al., 2009), Code. org (Code, 2017), Blocky Games, Gameblox, Kodu Game Lab (Fowler, Fristce, & MacLauren, 2012) are learning environments where beginners, supported by visual programming, speed up their developing skills to build complex and exciting applications. Visual programming languages allow school teachers to organize innovative educational activities aimed at promoting Computational Thinking processes and facilitating the learning of programming concepts (Harms, Balzuweit, Chen, & Kelleher, 2016;Akinola, Akinkunmi, & Alo, 2012). In particular, Kodu Game Lab includes features that we identify as specifically suitable in primary school context. In fact, it enables children to image 3D virtual worlds and to program characters in a virtual stage by composing instructions through a language based on visual tiles (Chiazzese & Lagan\u00e0, 2011). The visual tiles have the affordance of the semantic meaning of the instruction. For example, tiles represent the sensory capabilities (e.g. to see, hear, touch) or actions (e.g. move, take, fire) of the characters. Moreover, Kodu Game Lab provides an easy to use, enjoyable, creative and highly accessible programming environment. From a teaching perspective, Kodu Game Lab provides interesting opportunities to design learning activities able to foster Computational Thinking processes (Touretzky, Marghitu, Ludi, Bernstein, & Ni, 2013). \n\nRepenning, Basawapatna, & Escherle (2017) identify three stages of the Computational Thinking process that a Computational Thinking tool must elicit: \n\n\u2022 Problem formulation (abstraction); \n\n\u2022 Solution expression (automation);",
            "score": 0.3085211339359638,
            "section_title": "Introduction",
            "char_start_offset": 4478,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 142
                },
                {
                    "start": 145,
                    "end": 303
                },
                {
                    "start": 304,
                    "end": 396
                },
                {
                    "start": 397,
                    "end": 680
                },
                {
                    "start": 681,
                    "end": 959
                },
                {
                    "start": 960,
                    "end": 1075
                },
                {
                    "start": 1076,
                    "end": 1271
                },
                {
                    "start": 1272,
                    "end": 1352
                },
                {
                    "start": 1353,
                    "end": 1450
                },
                {
                    "start": 1451,
                    "end": 1487
                },
                {
                    "start": 1488,
                    "end": 1603
                },
                {
                    "start": 1604,
                    "end": 1811
                },
                {
                    "start": 1814,
                    "end": 1963
                },
                {
                    "start": 1966,
                    "end": 2002
                },
                {
                    "start": 2005,
                    "end": 2040
                }
            ],
            "ref_mentions": [
                {
                    "start": 491,
                    "end": 527,
                    "matchedPaperCorpusId": "18713650"
                },
                {
                    "start": 884,
                    "end": 926,
                    "matchedPaperCorpusId": "18084520"
                },
                {
                    "start": 1244,
                    "end": 1270,
                    "matchedPaperCorpusId": "57070770"
                },
                {
                    "start": 1760,
                    "end": 1810,
                    "matchedPaperCorpusId": "3127969"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.75146484375
        },
        {
            "corpus_id": "213335907",
            "title": "Design of Multi-channel data acquisition system based on single Chip computer and LabVIEW",
            "text": "Labview is a program development environment, developed by the National instrument Company, similar to C and BASIC development environment. But the obvious difference between Labview and other computer languages is that other computer languages use text-based languages to generate code. Labview uses the graphical editing language G to write the program, and the generated program is in the form of block diagram. \n\nFigure2. Like C language and BASIC language, LabVIEW is also a general programming system Like C language and BASIC language, LabVIEW is also a general programming system. There is a huge function library. LabVIEW includes data acquisition. GPIB. serial port control, data analysis, data display and data storage. LabVIEW also has traditional debugging tools, such as setting breakpoints, displaying data and the results of its sub-programs in animation. Single-step execution and so on, easy to debug the program. \n\nLabview is a graphical programming language that uses icons instead of text lines to create applications. Traditional text programming languages determine the order of program execution according to the order of statements and instructions. In Labview, the data flow direction between nodes in the program block diagram determines the execution order of VI and function. VI refers to virtual instrument, which is the program module of Labview. \n\nLabview provides a number of controls that look similar to traditional instruments and can be used to easily create user interfaces. The user interface is called the front panel in Labview, using icons and wires. Objects on the front panel can be controlled by programming. This is the graphical source code, also known as G code. LabVIEW graphical source code in a way similar to the flow chart. Therefore, it is also called program block diagram code. \n\nThis semester through the study of Labview for the Labview has a certain understanding, on the basis of this, we according to the requirements of the teacher. The small device of sound and color lamp based on Labview is made. Through the combination of Labview and PCI6221 DAQ data acquisition card, the effect of collecting sound signal and controlling the flicker of color lamp is achieved. \n\nThe second major difference is that G code developed by LabVIEW follows the rule of data flow when executed.",
            "score": 0.3084560015564686,
            "section_title": "Figure1. Isolation function isolation means to avoid direct electrical connection by means of light",
            "char_start_offset": 10723,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 139
                },
                {
                    "start": 140,
                    "end": 287
                },
                {
                    "start": 288,
                    "end": 414
                },
                {
                    "start": 417,
                    "end": 425
                },
                {
                    "start": 426,
                    "end": 588
                },
                {
                    "start": 589,
                    "end": 622
                },
                {
                    "start": 623,
                    "end": 657
                },
                {
                    "start": 658,
                    "end": 663
                },
                {
                    "start": 664,
                    "end": 730
                },
                {
                    "start": 731,
                    "end": 871
                },
                {
                    "start": 872,
                    "end": 931
                },
                {
                    "start": 934,
                    "end": 1039
                },
                {
                    "start": 1040,
                    "end": 1174
                },
                {
                    "start": 1175,
                    "end": 1304
                },
                {
                    "start": 1305,
                    "end": 1377
                },
                {
                    "start": 1380,
                    "end": 1512
                },
                {
                    "start": 1513,
                    "end": 1592
                },
                {
                    "start": 1593,
                    "end": 1653
                },
                {
                    "start": 1654,
                    "end": 1710
                },
                {
                    "start": 1711,
                    "end": 1776
                },
                {
                    "start": 1777,
                    "end": 1833
                },
                {
                    "start": 1836,
                    "end": 1994
                },
                {
                    "start": 1995,
                    "end": 2061
                },
                {
                    "start": 2062,
                    "end": 2228
                },
                {
                    "start": 2231,
                    "end": 2339
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.52685546875
        },
        {
            "corpus_id": "258417926",
            "title": "Visual Diagrammatic Queries in ViziQuer: Overview and Implementation",
            "text": "(Cerans et al., 2019(Cerans et al., , 2021b))) reported. \n\nThe experience with the visual query creation in ViziQuer has shown, however, some necessary improvements and extensions of the notation, if compared to (Cerans et al., 2017) and (Cerans et al., 2018a), including, e.g., (i) explicit existence-checking edges, (ii) compartment-related filters, (iii) explicit grouping compartments, (iv) distinction among simple and non-duplicated condition implementation and (v) explicit support for Wikidata (Vrande\u010di\u0107 and Kr\u00f6tzsch, 2014) language services. This paper is the first one to provide an integrated account of the ViziQuer visual language with the extended features. The principal point of the paper, however, is to explain the principles and solutions behind the implementation of the ViziQuer visual query language, including the structures, techniques and algorithms used for the actual mapping of its complex visual structures into text-based ones of the SPARQL language. \n\nThe query translation uses the query abstract syntax tree (AST) that presents the query structure in accordance with the conceptual visual query components as nodes, links, data fields and conditions, as well as parsed textual expressions and resolved names of the data schema elements. When the AST is built from the technical query format natively supported by the diagramming engine, it is further on transformed into a scaffolding model for SPARQL query generation, from which the textual SPARQL query form is obtained. \n\nThe presented visual query implementation can be viewed as an experience story of applying a model-based conceptualization to a complex transformation task among radically different notations (a visual diagrammatic and a textual one) describing the same computational artefact (a query to retrieve the data from a knowledge graph). \n\nRegarding the visual query notation itself, the provided query translation account can be seen as a \"semantics by implementation\" description that is provided here for the first time and includes details as visibility scope for introduced names and the order of blocks in the generated SPARQL query that, while being important for a wide range of queries, except the simplest ones, also has not been described before.",
            "score": 0.30806296705111996,
            "section_title": "Introduction",
            "char_start_offset": 5016,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 56
                },
                {
                    "start": 59,
                    "end": 551
                },
                {
                    "start": 552,
                    "end": 672
                },
                {
                    "start": 673,
                    "end": 981
                },
                {
                    "start": 984,
                    "end": 1270
                },
                {
                    "start": 1271,
                    "end": 1507
                },
                {
                    "start": 1510,
                    "end": 1841
                },
                {
                    "start": 1844,
                    "end": 2261
                }
            ],
            "ref_mentions": [
                {
                    "start": 20,
                    "end": 45,
                    "matchedPaperCorpusId": "236180507"
                },
                {
                    "start": 238,
                    "end": 260,
                    "matchedPaperCorpusId": "67866305"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.47705078125
        },
        {
            "corpus_id": "237091848",
            "title": "Data-driven Analysis of Gender Differences and Similarities in Scratch Programs",
            "text": "At the level of code, we aim to investigate which programming blocks girls and boys prefer, which programming concepts they cover with these blocks, and how complex the resulting programs are. To investigate the distribution of covered programming statements and concepts, we extracted the opcodes of the blocks used directly from the JSON files. The blocks are organized into categories such as looks and motion based on the \"drawers\" they are contained in within Scratch. We compare projects in terms of the individual opcodes as well as these categories. To sort blocks into the programming concepts they represent, we used the classification applied by Funke and Geldreich [17]. In contrast to their manual analysis, our procedure is automated and includes the additional metrics of code complexity and code smells. \n\nIn order to measure the complexity of the programs we used LitterBox [16], which parses the JSON files into an abstract syntax tree, on which various metrics can be extracted. In particular we consider complexity in terms of the common Halstead and McCabe metrics. The Halstead metrics are based on the total and unique number of operators (e.g., keywords and tokens of the programming language) and operands (e.g., variables, literals, function names) in a program. The Halstead length represents the total number of operator occurrences and the total number of operand occurrences, the Halstead size (also known as vocabulary) is the total number of unique operators and operands. The volume represents the size (in bits) of space necessary for storing the program; the difficulty is proportional to the ratio of the total number of operands to the number of unique operands based on the intuition that if the same operands are used many times in a program, that program is more prone to errors. Finally, the Halstead effort measures the elementary mental discriminations. We implemented Halstead metrics for LitterBox while interpreting operators and operands as in previous work [28]. The McCabe complexity (cyclomatic complexity) measures the number of linearly independent paths through a program's control flow graph. Since Scratch programs often consist of many small, parallel scripts, we implemented an interprocedural version of cyclomatic complexity (ICC) based on the interprocedural control-flow graph provided by LitterBox.",
            "score": 0.30795578917462985,
            "section_title": "RQ2.",
            "char_start_offset": 14977,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 192
                },
                {
                    "start": 193,
                    "end": 346
                },
                {
                    "start": 347,
                    "end": 473
                },
                {
                    "start": 474,
                    "end": 557
                },
                {
                    "start": 558,
                    "end": 682
                },
                {
                    "start": 683,
                    "end": 819
                },
                {
                    "start": 822,
                    "end": 997
                },
                {
                    "start": 998,
                    "end": 1086
                },
                {
                    "start": 1087,
                    "end": 1288
                },
                {
                    "start": 1289,
                    "end": 1504
                },
                {
                    "start": 1505,
                    "end": 1819
                },
                {
                    "start": 1820,
                    "end": 1896
                },
                {
                    "start": 1897,
                    "end": 2010
                },
                {
                    "start": 2011,
                    "end": 2146
                },
                {
                    "start": 2147,
                    "end": 2360
                }
            ],
            "ref_mentions": [
                {
                    "start": 677,
                    "end": 681,
                    "matchedPaperCorpusId": "6422541"
                },
                {
                    "start": 891,
                    "end": 895,
                    "matchedPaperCorpusId": "219181425"
                },
                {
                    "start": 2005,
                    "end": 2009,
                    "matchedPaperCorpusId": "27835998"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1273193359375
        },
        {
            "corpus_id": "278400806",
            "title": "A Graphical Interface for Category Theory Proofs in Coq",
            "text": "Category theory is an active domain in both computer science and mathematics research, with applications ranging from algebraic geometry to programming language design. Its ability to reason abstractly over generic structures has enabled it to become a unifying language for mathematics, creating bridges between previously unconnected mathematical developments [4]. \n\nThe transversal nature of category theory means that once one is familiar with its vocabulary, it can be used to understand concepts in several other mathematical theories. However, its abstract nature makes it famously difficult to understand. A particularly effective tool for managing the abstract nature of category theory is diagrammatic reasoning. \n\nIndeed, many graphical languages have been developed to represent objects and proofs in different families of categories. Arguably, the most famous of these is the language of string diagrams for monoidal categories, which has seen applications ranging from physics to logic [2]. However, the first graphical language usually used when learning categories is that of commutative diagrams, which require only the basic axioms of category theory. \n\nWhile domain specific tools already exists for creating and reasoning about both string diagrams [3] and commutative diagrams, 1 they use their own internal representation of categorical objects, and as such are not linked to any proof assistant. We propose an approach based on a Coq2 plugin3 that enables the user to view and progress the proof graphically using commutative diagrams. Integration in a generic proof assistant means that the user can gain familiarity with diagram proofs through any specific mathematical domain with which they are most familiar. Ambroise Lafont's tool [6] is another tool to work with commutative diagrams integrated with Coq with a similar scope to our own. Its development Integrating graphical reasoning in proof assistants is not a novel idea, and previous experiments include Actema [5] and Lean widgets [1]. Lean widgets actually include a specific widget to visualize the current proof state as a commutative diagram, but is limited to visualization. \n\nWe well begin by demonstrating how our tool is used and what it looks like in section Section 2.",
            "score": 0.30781335889468875,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 168
                },
                {
                    "start": 169,
                    "end": 366
                },
                {
                    "start": 369,
                    "end": 541
                },
                {
                    "start": 542,
                    "end": 613
                },
                {
                    "start": 614,
                    "end": 722
                },
                {
                    "start": 725,
                    "end": 846
                },
                {
                    "start": 847,
                    "end": 1004
                },
                {
                    "start": 1005,
                    "end": 1169
                },
                {
                    "start": 1172,
                    "end": 1418
                },
                {
                    "start": 1419,
                    "end": 1558
                },
                {
                    "start": 1559,
                    "end": 1736
                },
                {
                    "start": 1737,
                    "end": 1866
                },
                {
                    "start": 1867,
                    "end": 2021
                },
                {
                    "start": 2022,
                    "end": 2165
                },
                {
                    "start": 2168,
                    "end": 2264
                }
            ],
            "ref_mentions": [
                {
                    "start": 1269,
                    "end": 1272,
                    "matchedPaperCorpusId": "4429562"
                },
                {
                    "start": 1996,
                    "end": 1999,
                    "matchedPaperCorpusId": "245501324"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1507568359375
        },
        {
            "corpus_id": "60934130",
            "title": "Automated program recognition by graph parsing",
            "text": "avoided by using a graph representation, such as ours, as the base upon which to attach the functional information (see [4], Section 7.4). Adam and Laurent's LAURA [2] represents programs as graphs, thereby allowing some syntactic variability. However, the graph representation differs from ours in that dataflow is represented implicitly in the graph structure. Nodes represent assignments, tests, and input/output statements, rather than simply operations; arcs represent only control flow. Because of this, LAURA must rely on the use of program transformations to \"standardize\" the dataflow. (GILASPR need not perform these transformations, since the flow graph representation shows net dataflow explicitly.) LAURA debugs a program by comparing it to a given correct implementation, called the program model, of the algorithm which the program is supposed to be using. Only the program model's implementation is recognizable in the program; no implementational variation is allowed.\n\nThe system proposed by Fickas and Brooks [43] uses a Plan Calculus-like notation, called program building blocks (pbbs), for clich&. Each pbb specifies inputs, outputs, postconditions, and pre-conditions. (Pbbs are equivalent to Water's segments [137].) The structure of the library is provided by implementation plans, which are like implementation overlays in the Plan Calculus. They decompose non-primitive pbbs into smaller pbbs, linked by dataflow and purpose descriptions. However, on the lowest level of their library (unlike that used by GRASPR), the pbbs are mapped to language-specific code fragments which are matched directly against the program text. Thus, this system also falls prey to the syntactic variation problem.\n\nMurray's Talus [95] uses an abstract frame representation (called an E-frame) for programs. The slots of an E-frame contain information about the program, including the type of recursion used, the termination criteria, and the data types of the inputs and outputs.\n\nThis representation helps abstract away from the syntactic code structure by extracting semantic features from the program, allowing greater syntactic variability. However, listing all characteristics of the code in E-frame slots fails to expose constraints (such as dataflow constraints) in a way that facilitates recognition.",
            "score": 0.30738085073670485,
            "section_title": "Related Work",
            "char_start_offset": 384577,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 164,
                    "end": 167,
                    "matchedPaperCorpusId": "29854737"
                },
                {
                    "start": 1233,
                    "end": 1238,
                    "matchedPaperCorpusId": "60954216"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1666259765625
        },
        {
            "corpus_id": "252063657",
            "title": "Tendencies towards Computational Thinking: A Content Analysis Study",
            "text": "The common CT subskills demonstrated by the results of this research are similar to the CT subskills mentioned earlier in the literature. In addition to CT basic skills, the concepts, practices, and approaches model introduced by Brennan and Resnick (2012) were used in block-based programming activities. While Kong (2016) stated that this framework covered CT comprehensively, Nouri, Zhang, Mannila, and Nor\u00e9n (2020) stated that this framework provided a theoretical basis for the block-based visual programming language. In programming and robotics education, tools with a block-based coding interface are generally preferred. Scratch has become a software frequently used by all age groups. However, it is widely preferred in primary and secondary school levels. Scratch, which can work on mobile devices with different operating systems apart from computers, is used in 150 different countries and more than 60 languages around the world (Scratch, 2021). The Scratch program was used for CT development in previous years and positive results were obtained after the applications (Brennan & Resnick, 2012;Moreno-Le\u00f3n et al., 2015). In robotic programming applications, mBot, Lego Mindstorms, Arduino and Bee-Bot robotic kits, which could be coded as block-based, were used. Arduino, which can also be coded as text-based, is preferred because it is an open-source software and easy for use, is open to access to different projects and many different electronic parts, especially different sensors (Arduino, 2021). Lego Mindstorms' NXT and EV3 series are among the robotics kits that are widely used in different education levels (Oluk & Korkmaz, 2018;\u00dc\u00e7g\u00fcl, 2018). Since mBot Scratch can be used with a coding interface, it can be used easily in primary and secondary school age levels, while Bee-Bot is mostly used in preschool student groups because it has an icon-based visual coding interface without the need for reading and writing knowledge. \n\nWith the increasing importance of CT, research has focused more on primary and secondary school students. While the research conducted by organizing courses for teachers to introduce CT is increasing, the research conducted for pre-school students is quite limited.",
            "score": 0.30731866909555583,
            "section_title": "Discussion",
            "char_start_offset": 17023,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 137
                },
                {
                    "start": 138,
                    "end": 305
                },
                {
                    "start": 306,
                    "end": 523
                },
                {
                    "start": 524,
                    "end": 629
                },
                {
                    "start": 630,
                    "end": 694
                },
                {
                    "start": 695,
                    "end": 766
                },
                {
                    "start": 767,
                    "end": 959
                },
                {
                    "start": 960,
                    "end": 1135
                },
                {
                    "start": 1136,
                    "end": 1277
                },
                {
                    "start": 1278,
                    "end": 1517
                },
                {
                    "start": 1518,
                    "end": 1668
                },
                {
                    "start": 1669,
                    "end": 1952
                },
                {
                    "start": 1955,
                    "end": 2060
                },
                {
                    "start": 2061,
                    "end": 2220
                }
            ],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.56103515625
        },
        {
            "corpus_id": "277781477",
            "title": "Draw with Thought: Unleashing Multimodal Reasoning for Scientific Diagram Generation",
            "text": "Scientific diagrams, such as model architectures, system workflows, and algorithmic flowcharts, are foundational to scholarly communication, providing compact visual representations of structured ideas [25]. However, most diagrams are published as rasterized PDF or PNG images [61], discarding their underlying symbolic structure and making them non-editable, non-executable, and difficult to interpret or reuse programmatically [12,17,52]. Recovering structured representations from such diagrams entails mapping raw visual inputs to symbolic layouts comprising nodes, edges, spatial relations, and logical groupings [9]-a task that lies at the intersection of visual perception and structured abstraction. While Vision-Language Models (VLMs) have shown strong capabilities in aligning images with structured outputs, as demonstrated in captioning [31,14], visual QA [47], and diagram layout prediction [43], their application to scientific diagram parsing remains nascent and largely limited to visually regular or low-complexity inputs. Existing studies have adopted various target formats that differ in expressiveness and abstraction level, such as SVG for vector rendering [44,61], TikZ for LaTeX-integrated graphics [8,9], and Python-based code for chart generation [55]. While SVG enables resolution-independent rendering, its reliance on low-level geometric primitives limits semantic interpretability [9]; TikZ supports precise layout control but introduces parsing challenges due to procedural syntax and structural variability [8,9]; and although Python formats are effective for domain-specific plots, they lack the modularity and compositional flexibility needed to capture the heterogeneity of general-purpose scientific diagrams [55]. In contrast, XML-based formats such as mxGraph offer an explicit and editable graph abstraction, encoding diagrams as structured layouts with semantically grounded nodes, edges, and geometric constraints. This makes them particularly well-suited as target representations for recovering the symbolic structure of scientific diagrams from raw visual inputs [43].",
            "score": 0.30706003810357607,
            "section_title": "Introduction",
            "char_start_offset": 15,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 207
                },
                {
                    "start": 208,
                    "end": 440
                },
                {
                    "start": 441,
                    "end": 707
                },
                {
                    "start": 708,
                    "end": 1039
                },
                {
                    "start": 1040,
                    "end": 1278
                },
                {
                    "start": 1279,
                    "end": 1750
                },
                {
                    "start": 1751,
                    "end": 1955
                },
                {
                    "start": 1956,
                    "end": 2112
                }
            ],
            "ref_mentions": [
                {
                    "start": 429,
                    "end": 433,
                    "matchedPaperCorpusId": "269148770"
                },
                {
                    "start": 618,
                    "end": 621,
                    "matchedPaperCorpusId": "270045320"
                },
                {
                    "start": 849,
                    "end": 853,
                    "matchedPaperCorpusId": "256390509"
                },
                {
                    "start": 853,
                    "end": 856,
                    "matchedPaperCorpusId": "258615266"
                },
                {
                    "start": 868,
                    "end": 872,
                    "matchedPaperCorpusId": "247447209"
                },
                {
                    "start": 904,
                    "end": 908,
                    "matchedPaperCorpusId": "273695756"
                },
                {
                    "start": 1223,
                    "end": 1226,
                    "matchedPaperCorpusId": "263334353"
                },
                {
                    "start": 1226,
                    "end": 1228,
                    "matchedPaperCorpusId": "270045320"
                },
                {
                    "start": 1411,
                    "end": 1414,
                    "matchedPaperCorpusId": "270045320"
                },
                {
                    "start": 1539,
                    "end": 1542,
                    "matchedPaperCorpusId": "263334353"
                },
                {
                    "start": 1542,
                    "end": 1544,
                    "matchedPaperCorpusId": "270045320"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.2303466796875
        },
        {
            "corpus_id": "251402589",
            "title": "Behavior Trees and State Machines in Robotics Applications",
            "text": "In the robotics community, different control structures are used to coordinate agent behavior, including behavior trees, state machines, teleo-reactive architecture, subsumption architecture, sequential behavior composition, flowcharts, and decision trees [6], [7], [30]. Each of these structures has its own advantages and disadvantages [6], [30]. \n\nMany of these control structures are offered as domainspecific languages (DSLs) [31] to developers. For mobile robots, many of these DSLs are even end-user-oriented, offering a visual syntax, as seen in our previous study [32]. There, we observed that most of these DSLs are still imperative at a relatively low level of abstraction, similar to programming languages. Interestingly, we observed that many of these DSLs are realized by cutting down a real programming language and implementing a visual syntax for the remaining language concepts-expressions, declarations, and statements (including robot-specific library method calls). The visual syntax is often realized using Scratch or Blockly, offering a simple, block-based programming interface. These end-user-oriented DSLs target technically skilled users, while the other DSLs, especially the behaviortree and state-machine DSLs we study in the remainder, clarly target developers.",
            "score": 0.30701384258992054,
            "section_title": "BACKGROUND",
            "char_start_offset": 10316,
            "sentence_offsets": [
                {
                    "start": 0,
                    "end": 271
                },
                {
                    "start": 272,
                    "end": 348
                },
                {
                    "start": 351,
                    "end": 450
                },
                {
                    "start": 451,
                    "end": 578
                },
                {
                    "start": 579,
                    "end": 718
                },
                {
                    "start": 719,
                    "end": 986
                },
                {
                    "start": 987,
                    "end": 1102
                },
                {
                    "start": 1103,
                    "end": 1291
                }
            ],
            "ref_mentions": [
                {
                    "start": 261,
                    "end": 264,
                    "matchedPaperCorpusId": "91186965"
                },
                {
                    "start": 573,
                    "end": 577,
                    "matchedPaperCorpusId": "232029733"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.77294921875
        },
        {
            "corpus_id": "252355042",
            "title": "Not As Easy As You Think - Experiences and Lessons Learnt from Trying to Create a Bottom-Up Visualization Image Typology",
            "text": "Essentially, our coding experiment evaluated if visualizations (in academic publications) can be easily understood and categorized by experienced researchers. While we started with the intuition of finding categories based on data, tasks, and low-level encoding principles (characterization of the \"input space\"), we ended up scraping this and came up with a typology of the result or output space of images. Some of the original categories survived (point-based, line-based, and generalized area; surface-based and text-based; as well as node-link and glyph) and further new ones have emerged (bar representations, matrix/grid, continuous patterns, continuous color). Our typology also combines constructive features (low-level design space construction elements) with functional characteristics from the output space, especially for images that contained schematics and GUIs.\n\nThe design space elements are perhaps close to psychophysicsevaluations are well posed and hypotheses can be tested with an (oftenlab-controlled) experiment. Resulting images, on the other hand, have much more to do with the viewers' knowledge and context, and has its footing in vision science and even machine learning. What-we-see could heavily influence how we act to choose to see next, to provide another angle to understand visualization effectiveness in the future.\n\nFurthermore, implicit in teaching and learning tasks such as \"show me the node-link diagrams\" are much deeper issues involving the notion of what is meant by \"node-link diagrams\". This meaning would vary with spatial (e.g, topological connectivity) and non-spatial data (e.g., social networks), context of use, and observers. We found that student coders involved in the earlier stage of this project had dramatically different understandings of author keywords (often with misconceptions). Also, our initial exercise (which lasted for more than a year) of measuring visual design terms of authors or of low-level features has largely been challenged by low-level details of naming techniques rather than what the visualizations show us.",
            "score": 0.30680543082298256,
            "section_title": "From Specific Techniques to A General Typology",
            "char_start_offset": 57909,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.1715087890625
        },
        {
            "corpus_id": "221618092",
            "title": "Accessibility of Block-Based Introductory Programming Languages and a Tangible Programming Tool Prototype",
            "text": "Visual programming languages (VPLs) were designed to assist children in introductory programming courses. Unfortunately, despite the positive results in teaching, VPLs are believed to be inaccessible for children with visual impairments and low vision due to the dependency of visual graphics as both input and output methods. To identify the barriers that users with visual impairments and low vision face while using Block-based programming environments, as well as to acquire feedback regarding the design of a new tangible programming tool prototype, a usability study was conducted which involved nine adult participants with visual impairments and low vision. This paper presents the findings of this usability study and provides a list of features that are needed in order to make Block-based environments accessible. Furthermore, based on observations, interviews, and post-surveys this study demonstrates that our prototype can be used by users with visual impairments and low vision and provides a guideline for the design of tangible interfaces to teach programming concepts.",
            "score": 0.30663961253196004,
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.71923828125
        },
        {
            "corpus_id": "253239351",
            "title": "Can guided decomposition help end-users write larger block-based programs? a mobile robot experiment",
            "text": ". Grammar(s) of the programming language used in the proposed system. A program (left) can only contain calls to tasks at the top-level, and that task definitions (right) take place in a separate programming canvas with its own syntax. As Section 3.4 describes, there are some differences between the language's semantics shown here and its block-based presentation shown in Figure 3. Also note that locations are defined via a visual location picker that is not represented in this grammar.\n\ncreating programs structured like in Figure 2b, where functions can confuse inexperienced users more than they help them. Second, beginner programmers with no prior experience using functions may not see their benefit until it is too late [Hazzan 2008;Kramer 2007]. Novice programmers may perceive functions as requiring premature commitment, as they have an up-front cost in terms of adding blocks and the understanding program flow, and they must decide whether to use them before they know how large their program will ultimately become. Thus, users begin writing programs that have no structure, and as these programs grow they become unwieldy.\n\nBlock-based systems have a low viscosity in theory as they allow users to quickly re-arrange programs via drag-and-drop and have built-in hygiene for names. However, compared to refactorings that are found in professional development tools, these features provide little guidance to programmers. This is especially unhelpful for novices, who might not have a clear vision of how to improve a program's structure, even if they are aware of its current issues. As we will see in Section 5, inexperienced users tend to simply split programs into arbitrary chunks, which provides minor visibility benefits, but little benefit for their understanding of the code. For this reason, we also do not believe that simply highlighting overly long functions, nor restricting the maximum length of continuous code blocks, can be a solution for this problem.",
            "score": 0.3065663009661565,
            "section_title": "Why Do End-Users Not Use Functions?",
            "char_start_offset": 16616,
            "sentence_offsets": [],
            "ref_mentions": [
                {
                    "start": 732,
                    "end": 745,
                    "matchedPaperCorpusId": "15687226"
                },
                {
                    "start": 745,
                    "end": 757,
                    "matchedPaperCorpusId": "12481509"
                }
            ],
            "pdf_hash": "",
            "stype": "vespa",
            "rerank_score": 0.46826171875
        },
        {
            "paperId": "713027a463153638777804c4371ef529e9c34e19",
            "corpusId": 273376382,
            "title": "ALLI/O Diagram: An Action-based Visual Programming Language for Embedded System",
            "venue": "IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments",
            "year": 2024,
            "referenceCount": 25,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/VL/HCC60511.2024.00031?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/VL/HCC60511.2024.00031, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2297972654",
                    "name": "Nuntipat Narkthong"
                },
                {
                    "authorId": "18086059",
                    "name": "C. Jariyavajee"
                },
                {
                    "authorId": "2326245511",
                    "name": "Xiaolin Xu"
                }
            ],
            "abstract": "This paper introduces ALLI/O Diagram, an action-based visual programming language for embedded system programming used by the ALLI/O IDE. We illustrate the practicality of ALLI/O Diagram with various design examples and evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs. These results demonstrate that our proposed ALLI/O Diagram is the most compact, expressive, and portable across different hardware models. We open source the ALLI/O Diagram and all example programs at https://allio.build.",
            "corpus_id": "273376382",
            "text": "This paper introduces ALLI/O Diagram, an action-based visual programming language for embedded system programming used by the ALLI/O IDE. We illustrate the practicality of ALLI/O Diagram with various design examples and evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs. These results demonstrate that our proposed ALLI/O Diagram is the most compact, expressive, and portable across different hardware models. We open source the ALLI/O Diagram and all example programs at https://allio.build.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.90478515625
        },
        {
            "paperId": "3dde7400f558c2695af5371f0d9b908196e0582e",
            "corpusId": 272098962,
            "title": "Implementation of smart room system based PLC and block diagram function programming",
            "venue": "Journal Geuthee of Engineering and Energy (JOGE)",
            "year": 2024,
            "referenceCount": 0,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.52626/joge.v3i1.36",
                "status": "GOLD",
                "license": "CCBYSA",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.52626/joge.v3i1.36?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.52626/joge.v3i1.36, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "51909342",
                    "name": "S. Triwijaya"
                },
                {
                    "authorId": "2261553471",
                    "name": "Yuli Prasetyo"
                },
                {
                    "authorId": "2261553406",
                    "name": "Budi Triyono"
                },
                {
                    "authorId": "2317755673",
                    "name": "Dimas Nur Prakoso"
                },
                {
                    "authorId": "2105256737",
                    "name": "Teuku Multazam"
                }
            ],
            "abstract": "Technological developments have brought a revolution in the smart home concept, with smart rooms becoming the main focus to increase comfort, efficiency and security. This article explores the concept of a Programmable Logic Controller (PLC) based smart room with Function Block Diagram (FBD) programming. PLCs, which were originally used in industry, were introduced into the smart home environment as a central brain capable of managing and controlling electronic devices. FBD programming, with its visual approach, provides an intuitive programming solution by using function blocks to represent control logic. Through the use of FBD-based PLCs, smart rooms can be effectively automated, including lighting, temperature and security aspects. The advantages of this method include an easy-to-understand programming interface and the ability to design control logic without requiring a deep understanding of programming languages. The research results show that FBD-based PLCs provide an efficient and effective solution to improve the function of smart rooms. This implementation can provide significant benefits in terms of energy management, occupant comfort and home security. Thus, the PLC-based smart room concept with FBD programming marks a step forward in realizing a smart home that is responsive, connected, and can be adapted to the needs of residents.",
            "corpus_id": "272098962",
            "text": "Technological developments have brought a revolution in the smart home concept, with smart rooms becoming the main focus to increase comfort, efficiency and security. This article explores the concept of a Programmable Logic Controller (PLC) based smart room with Function Block Diagram (FBD) programming. PLCs, which were originally used in industry, were introduced into the smart home environment as a central brain capable of managing and controlling electronic devices. FBD programming, with its visual approach, provides an intuitive programming solution by using function blocks to represent control logic. Through the use of FBD-based PLCs, smart rooms can be effectively automated, including lighting, temperature and security aspects. The advantages of this method include an easy-to-understand programming interface and the ability to design control logic without requiring a deep understanding of programming languages. The research results show that FBD-based PLCs provide an efficient and effective solution to improve the function of smart rooms. This implementation can provide significant benefits in terms of energy management, occupant comfort and home security. Thus, the PLC-based smart room concept with FBD programming marks a step forward in realizing a smart home that is responsive, connected, and can be adapted to the needs of residents.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.701171875
        },
        {
            "paperId": "0113bfc89b54b2913786992e5986edb684a0400c",
            "corpusId": 258217657,
            "title": "Positional Control in Node-Based Programming",
            "venue": "CHI Extended Abstracts",
            "year": 2023,
            "referenceCount": 48,
            "citationCount": 4,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.1145/3544549.3585878",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3544549.3585878?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3544549.3585878, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2061281840",
                    "name": "Peiling Jiang"
                }
            ],
            "abstract": "Visual programming languages enable novices to code with a lowered barrier. These languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires. We propose integrating these two approaches by utilizing positional control in node-based programming to visualize and allow manipulation of both the execution order and data flow. A grid system organizes blocks and determines their sequence. Effect block is introduced, which controls other blocks within its effective range through positional constraints. As relocating blocks is easier than wiring that targets tiny inlets and outlets, we aim to shorten the feedback loop time and encourage exploration. We present b5, a web-based novel visual interface for creative coding, to demonstrate and evaluate this design.",
            "corpus_id": "258217657",
            "text": "Visual programming languages enable novices to code with a lowered barrier. These languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires. We propose integrating these two approaches by utilizing positional control in node-based programming to visualize and allow manipulation of both the execution order and data flow. A grid system organizes blocks and determines their sequence. Effect block is introduced, which controls other blocks within its effective range through positional constraints. As relocating blocks is easier than wiring that targets tiny inlets and outlets, we aim to shorten the feedback loop time and encourage exploration. We present b5, a web-based novel visual interface for creative coding, to demonstrate and evaluate this design.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.94921875
        },
        {
            "paperId": "61cb8c5982aad0d2afbddaa1c2af0b835050bec8",
            "corpusId": 265054665,
            "title": "Comparison of Biometric Information During Learning of Visual- and Text-Based Programming Languages",
            "venue": "2023 8th International STEM Education Conference (iSTEM-Ed)",
            "year": 2023,
            "referenceCount": 5,
            "citationCount": 2,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/iSTEM-Ed59413.2023.10305730?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/iSTEM-Ed59413.2023.10305730, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "3096544",
                    "name": "K. Umezawa"
                },
                {
                    "authorId": "48365793",
                    "name": "M. Nakazawa"
                },
                {
                    "authorId": "2265669626",
                    "name": "Shigeichi Hirasawa"
                }
            ],
            "abstract": "Novice programmers often start with visual-based programming languages, such as Blockly or Scratch, whereas experts tend to use text-based programming languages, such as C, C++, Java, or Python. However, a seamless transition from a visual- to a text-based language is yet to be established. Our study proposes an approach for this transition by introducing intermediate content with features that bridge the gap between visual- and text-based languages, as demonstrated in our previous study. We also show that incorporating this intermediate content enhances understanding of the text-based language. In this study, we measure learners' biometric information during their course of learning of both visual- and text-based languages, aiming to identify any differences in the biometric information during the training process.",
            "corpus_id": "265054665",
            "text": "Novice programmers often start with visual-based programming languages, such as Blockly or Scratch, whereas experts tend to use text-based programming languages, such as C, C++, Java, or Python. However, a seamless transition from a visual- to a text-based language is yet to be established. Our study proposes an approach for this transition by introducing intermediate content with features that bridge the gap between visual- and text-based languages, as demonstrated in our previous study. We also show that incorporating this intermediate content enhances understanding of the text-based language. In this study, we measure learners' biometric information during their course of learning of both visual- and text-based languages, aiming to identify any differences in the biometric information during the training process.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.57373046875
        },
        {
            "paperId": "aaa161560a85a0339b1251c343159e03f185e45d",
            "corpusId": 270594234,
            "title": "Opening the Valve on Pure-Data: Usage Patterns and Programming Practices of a Data-Flow Based Visual Programming Language",
            "venue": "IEEE Working Conference on Mining Software Repositories",
            "year": 2024,
            "referenceCount": 18,
            "citationCount": 4,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3643991.3644865?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3643991.3644865, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2223110142",
                    "name": "Anisha Islam"
                },
                {
                    "authorId": "71278583",
                    "name": "Kalvin Eng"
                },
                {
                    "authorId": "145369636",
                    "name": "Abram Hindle"
                }
            ],
            "abstract": "Pure Data (PD), a data-flow based visual programming language utilized for music and sound synthesis, remains underexplored in software engineering research. Existing literature fails to address the nuanced programming practices within PD, prompting the need to investigate how end-users manipulate nodes and edges in this visual language. This paper systematically extracts and analyzes 6,534 publicly available PD projects from GitHub. Employing source code parsing, pattern matching, and statistical analysis, we unveil usage patterns of PD by the end-user programmers. We found that most revisions of the PD files are small and simple, with fewer than 64 nodes, 51 connections, and 3 revisions. Most PD projects have less than 17 PD files, 31 commits, and only 1 author working on the PD files. The median differences in the number of nodes and edges between each commit and its parents, modifying the same file, are 3 and 0, respectively, implying small changes across various revisions of a PD file. Our findings contribute a valuable dataset for future studies, addressing the dearth of research in PD. By unraveling usage patterns, we provide insights that empower scholars and practitioners to optimize the programming experience for end-users in the realm of visual programming languages.CCS CONCEPTS\u2022 Software and its engineering \u2192 Visual languages.",
            "corpus_id": "270594234",
            "text": "Pure Data (PD), a data-flow based visual programming language utilized for music and sound synthesis, remains underexplored in software engineering research. Existing literature fails to address the nuanced programming practices within PD, prompting the need to investigate how end-users manipulate nodes and edges in this visual language. This paper systematically extracts and analyzes 6,534 publicly available PD projects from GitHub. Employing source code parsing, pattern matching, and statistical analysis, we unveil usage patterns of PD by the end-user programmers. We found that most revisions of the PD files are small and simple, with fewer than 64 nodes, 51 connections, and 3 revisions. Most PD projects have less than 17 PD files, 31 commits, and only 1 author working on the PD files. The median differences in the number of nodes and edges between each commit and its parents, modifying the same file, are 3 and 0, respectively, implying small changes across various revisions of a PD file. Our findings contribute a valuable dataset for future studies, addressing the dearth of research in PD. By unraveling usage patterns, we provide insights that empower scholars and practitioners to optimize the programming experience for end-users in the realm of visual programming languages.CCS CONCEPTS\u2022 Software and its engineering \u2192 Visual languages.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.77734375
        },
        {
            "paperId": "06173df23b4600e624e01d07f9611eea8b134f5f",
            "corpusId": 221561080,
            "title": "ConCodeIt! A Comparison of Concurrency Interfaces in Block-Based Visual Robot Programming",
            "venue": "IEEE International Symposium on Robot and Human Interactive Communication",
            "year": 2020,
            "referenceCount": 23,
            "citationCount": 1,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/RO-MAN47096.2020.9223337?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/RO-MAN47096.2020.9223337, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2677547",
                    "name": "M. Chung"
                },
                {
                    "authorId": "1996238216",
                    "name": "Mino Nakura"
                },
                {
                    "authorId": "1996208754",
                    "name": "Sai Harshita Neti"
                },
                {
                    "authorId": "2055010844",
                    "name": "Anthony Lu"
                },
                {
                    "authorId": "1995815396",
                    "name": "Elana Hummel"
                },
                {
                    "authorId": "35096370",
                    "name": "M. Cakmak"
                }
            ],
            "abstract": "Concurrency makes robot programming challenging even for professional programmers, yet it is essential for rich, interactive social robot behaviors. Visual programming aims to lower the barrier for robot programming but does not support rich concurrent behavior for meaningful robotics applications. In this paper, we explore extensions to block-based visual languages to enable programming of concurrent behavior with (1) asynchronous procedure calls, which encourage imperative programming, (2) callbacks, which encourage event-driven programming, and (3) promise, which also encourages imperative programming by providing event synchronization utilities. We compare these approaches through a systematic analysis of social robot programs with representative concurrency patterns, as well as a user study (N=23) in which participants authored such programs. Our work identifies characteristic differences between these approaches and demonstrates that the promise-based concurrency interface enables more concise programs with fewer errors.",
            "corpus_id": "221561080",
            "text": "Concurrency makes robot programming challenging even for professional programmers, yet it is essential for rich, interactive social robot behaviors. Visual programming aims to lower the barrier for robot programming but does not support rich concurrent behavior for meaningful robotics applications. In this paper, we explore extensions to block-based visual languages to enable programming of concurrent behavior with (1) asynchronous procedure calls, which encourage imperative programming, (2) callbacks, which encourage event-driven programming, and (3) promise, which also encourages imperative programming by providing event synchronization utilities. We compare these approaches through a systematic analysis of social robot programs with representative concurrency patterns, as well as a user study (N=23) in which participants authored such programs. Our work identifies characteristic differences between these approaches and demonstrates that the promise-based concurrency interface enables more concise programs with fewer errors.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.833984375
        },
        {
            "paperId": "e0dc108809593ed07b7f748882bc5d5f7185b9b8",
            "corpusId": 271758470,
            "title": "Extending Unit Test Cases with Graphical Comparison in Blocks-based Programming Languages",
            "venue": "International Computing Education Research Workshop",
            "year": 2024,
            "referenceCount": 9,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3632621.3671428?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3632621.3671428, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1949960492",
                    "name": "Herart Dominggus Nurue"
                },
                {
                    "authorId": "2298811961",
                    "name": "Jeff Gray"
                }
            ],
            "abstract": "Blocks-based programming languages (BBPLs) are widely used for their visual approach, particularly in educational settings [1]. However, testing graphical outputs in these languages presents unique challenges that traditional unit testing does not adequately address [3]. Traditional unit tests focus on verifying textual or numerical results, which is insufficient for the visual nature of BBPLs [5, 7]. This poster introduces an idea to extend unit testing concepts for BBPLs by incorporating graphical comparison as a core verification method. The concept allows educators and students to define expected graphical outcomes and automatically compare them with actual outputs generated by the program. The process utilizes image processing techniques to automate graphical comparisons, ensuring accurate and reliable test results even with variations in screen resolutions and rendering environments [8, 9]. This idea can potentially integrate with existing BBPL environments, providing an interface for creating and managing graphical test cases. Users may define expected images or screenshots, which would then be compared to the program\u2019s output using image similarity metrics, making the testing process automated and more efficient. Traditional testing methods often focus on code correctness, overlooking the visual outcomes of the program [4]. In BBPLs, these visual outcomes are important. The motivation of our work is to enhance the accuracy of testing visual elements and streamline the development process by quickly identifying discrepancies between expected and actual graphical outputs. We address a significant gap in current testing methodologies by incorporating graphical comparison into unit testing for BBPLs. This work supports the development of more reliable and robust visual programs, benefiting the educational uses of BBPLs. Our initial implementation involves comparing two-dimensional (2-D) images using Selenium [2] for browser automation with OpenCV [6] for image processing. We apply SSIM (Structural Similarity Index), a metric used to measure the similarity between two images [8, 9]. Unlike traditional methods that only consider pixel differences, SSIM evaluates the structural information of the images by comparing luminance, contrast, and texture [8, 9]. This makes it particularly useful for assessing perceived image quality and similarity, as it closely aligns with human visual perception. SSIM produces a score between -1 and 1, where 1 indicates perfect similarity, 0 indicates no similarity, and negative indicates dissimilarity. This visual comparison technique provides a straightforward way to assess whether a BBPL program\u2019s output meets the expected criteria, facilitating more accurate and expedited unit testing in an educational context.",
            "corpus_id": "271758470",
            "text": "Blocks-based programming languages (BBPLs) are widely used for their visual approach, particularly in educational settings [1]. However, testing graphical outputs in these languages presents unique challenges that traditional unit testing does not adequately address [3]. Traditional unit tests focus on verifying textual or numerical results, which is insufficient for the visual nature of BBPLs [5, 7]. This poster introduces an idea to extend unit testing concepts for BBPLs by incorporating graphical comparison as a core verification method. The concept allows educators and students to define expected graphical outcomes and automatically compare them with actual outputs generated by the program. The process utilizes image processing techniques to automate graphical comparisons, ensuring accurate and reliable test results even with variations in screen resolutions and rendering environments [8, 9]. This idea can potentially integrate with existing BBPL environments, providing an interface for creating and managing graphical test cases. Users may define expected images or screenshots, which would then be compared to the program\u2019s output using image similarity metrics, making the testing process automated and more efficient. Traditional testing methods often focus on code correctness, overlooking the visual outcomes of the program [4]. In BBPLs, these visual outcomes are important. The motivation of our work is to enhance the accuracy of testing visual elements and streamline the development process by quickly identifying discrepancies between expected and actual graphical outputs. We address a significant gap in current testing methodologies by incorporating graphical comparison into unit testing for BBPLs. This work supports the development of more reliable and robust visual programs, benefiting the educational uses of BBPLs. Our initial implementation involves comparing two-dimensional (2-D) images using Selenium [2] for browser automation with OpenCV [6] for image processing. We apply SSIM (Structural Similarity Index), a metric used to measure the similarity between two images [8, 9]. Unlike traditional methods that only consider pixel differences, SSIM evaluates the structural information of the images by comparing luminance, contrast, and texture [8, 9]. This makes it particularly useful for assessing perceived image quality and similarity, as it closely aligns with human visual perception. SSIM produces a score between -1 and 1, where 1 indicates perfect similarity, 0 indicates no similarity, and negative indicates dissimilarity. This visual comparison technique provides a straightforward way to assess whether a BBPL program\u2019s output meets the expected criteria, facilitating more accurate and expedited unit testing in an educational context.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.7548828125
        },
        {
            "paperId": "2e91e87ce291c21a946a2f97b393bfdc97071a3f",
            "corpusId": 243130567,
            "title": "VISUAL-GRAPHIC PROGRAMMING SYSTEM BASED ON DEVELOPMENT OF BLOCK DIAGRAMS OF ALGORITHMS. CONVERTING PROGRAMS TEXTS IN DIFFERENT PROGRAMMING LANGUAGES INTO BLOCK DIAGRAMS AND BACK",
            "venue": "\u042e\u0436\u043d\u043e-\u0421\u0438\u0431\u0438\u0440\u0441\u043a\u0438\u0439 \u043d\u0430\u0443\u0447\u043d\u044b\u0439 \u0432\u0435\u0441\u0442\u043d\u0438\u043a",
            "year": 2021,
            "referenceCount": 1,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://doi.org/10.25699/sssb.2021.37.3.013",
                "status": "BRONZE",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.25699/sssb.2021.37.3.013?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.25699/sssb.2021.37.3.013, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2138047908",
                    "name": "\u0410.\u0410. \u0412\u043e\u0445\u043c\u0438\u043d"
                },
                {
                    "authorId": "2137774731",
                    "name": "\u041e.\u0410. \u0415\u0432\u0434\u043e\u043a\u0438\u043c\u043e\u0432\u0430"
                },
                {
                    "authorId": "2138021401",
                    "name": "\u0410.\u0410. \u041c\u0430\u043b\u044f\u0432\u043a\u043e"
                }
            ],
            "abstract": "\u0412 \u0440\u0430\u0431\u043e\u0442\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u0439 \u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u0432 \u0432\u0438\u0434\u0435 \u0431\u043b\u043e\u043a-\u0441\u0445\u0435\u043c \u0432 \u0446\u0435\u043b\u043e\u043c \u0438, \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u043d\u043e\u0439 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b \u0442\u0430\u043a\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u2013 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u043e\u0440\u0430 \u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043d\u043e-\u0432\u043b\u043e\u0436\u0435\u043d\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438 \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0432 \u0442\u0435\u043a\u0441\u0442\u044b.\n\u0412\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u043b\u0443\u0447\u0448\u0435 \u0432\u043e\u0441\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u043e\u043c-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c, \u0447\u0435\u043c \u0442\u0440\u0430\u0434\u0438\u0446\u0438\u043e\u043d\u043d\u043e\u0435 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0440\u0430\u0437\u0432\u0438\u0442\u0438\u044e \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0443\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435. \u041e\u0434\u043d\u0430\u043a\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0443\u0434\u043e\u0431\u043d\u044b\u0445 \u0434\u043b\u044f \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u043b\u043e\u043a-\u0441\u0445\u0435\u043c \u0441\u043e\u043f\u0440\u044f\u0436\u0435\u043d\u0430 \u0441 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c\u044e \u0440\u0435\u0448\u0435\u043d\u0438\u044f \u0440\u044f\u0434\u0430 \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0430\u0434\u0435\u043a\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043d \u0430\u043d\u0430\u043b\u0438\u0437 \u0442\u0430\u043a\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440 \u0434\u043b\u044f \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u043f\u043e \u0440\u0430\u0437\u043d\u044b\u043c \u043c\u0435\u0442\u0440\u0438\u043a\u0430\u043c \u044f\u0437\u044b\u043a\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0435\u0433\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d \u0441\u043f\u043e\u0441\u043e\u0431 \u0432\u044b\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440\u0430. \u041e\u043f\u0438\u0441\u0430\u043d\u044b \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u044b \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u043e\u0440\u0430 \u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u043a\u0430\u043a \u0432 \u043f\u0440\u044f\u043c\u043e\u043c, \u0442\u0430\u043a \u0438 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f\u0445.\n The paper presents the results of research and development of tools for visual and graphic design of complex algorithms in the form of block diagrams in general and, in particular, the interface component of such tools - a converter of programs texts in various programming languages \u200b\u200binto an internal structurally nested representation and back into texts.\nThe visual-graphical representation of algorithms is better perceived by a human developer than the traditional textual representation, therefore, some attention has been paid to the development of such programming systems in recent years. However, the implementation of the most human-friendly technologies for creating and editing block diagrams is associated with the need to solve a number of complex problems of forming and adequately displaying control structures used in popular programming languages. The analysis of such structures for the most popular programming languages \u200b\u200bin terms of various metrics is carried out, its results are presented, and a method for identifying and transforming control structures into an internal representation of a visual-graphic editor is proposed. The main algorithms for the operation of the program text converter both in forward and backward directions are described.",
            "corpus_id": "243130567",
            "text": "\u0412 \u0440\u0430\u0431\u043e\u0442\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u0439 \u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u0432 \u0432\u0438\u0434\u0435 \u0431\u043b\u043e\u043a-\u0441\u0445\u0435\u043c \u0432 \u0446\u0435\u043b\u043e\u043c \u0438, \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u043d\u043e\u0439 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b \u0442\u0430\u043a\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u2013 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u043e\u0440\u0430 \u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043d\u043e-\u0432\u043b\u043e\u0436\u0435\u043d\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438 \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0432 \u0442\u0435\u043a\u0441\u0442\u044b.\n\u0412\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u043b\u0443\u0447\u0448\u0435 \u0432\u043e\u0441\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u043e\u043c-\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c, \u0447\u0435\u043c \u0442\u0440\u0430\u0434\u0438\u0446\u0438\u043e\u043d\u043d\u043e\u0435 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0440\u0430\u0437\u0432\u0438\u0442\u0438\u044e \u043f\u043e\u0434\u043e\u0431\u043d\u044b\u0445 \u0441\u0438\u0441\u0442\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0443\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435. \u041e\u0434\u043d\u0430\u043a\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0443\u0434\u043e\u0431\u043d\u044b\u0445 \u0434\u043b\u044f \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0438 \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u043b\u043e\u043a-\u0441\u0445\u0435\u043c \u0441\u043e\u043f\u0440\u044f\u0436\u0435\u043d\u0430 \u0441 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c\u044e \u0440\u0435\u0448\u0435\u043d\u0438\u044f \u0440\u044f\u0434\u0430 \u0441\u043b\u043e\u0436\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0430\u0434\u0435\u043a\u0432\u0430\u0442\u043d\u043e\u0433\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0432 \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043d \u0430\u043d\u0430\u043b\u0438\u0437 \u0442\u0430\u043a\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440 \u0434\u043b\u044f \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u043f\u043e \u0440\u0430\u0437\u043d\u044b\u043c \u043c\u0435\u0442\u0440\u0438\u043a\u0430\u043c \u044f\u0437\u044b\u043a\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u044b \u0435\u0433\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d \u0441\u043f\u043e\u0441\u043e\u0431 \u0432\u044b\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440 \u0432\u043e \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432\u0438\u0437\u0443\u0430\u043b\u044c\u043d\u043e-\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0440\u0435\u0434\u0430\u043a\u0442\u043e\u0440\u0430. \u041e\u043f\u0438\u0441\u0430\u043d\u044b \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u044b \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u043e\u0440\u0430 \u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u043a\u0430\u043a \u0432 \u043f\u0440\u044f\u043c\u043e\u043c, \u0442\u0430\u043a \u0438 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f\u0445.\n The paper presents the results of research and development of tools for visual and graphic design of complex algorithms in the form of block diagrams in general and, in particular, the interface component of such tools - a converter of programs texts in various programming languages \u200b\u200binto an internal structurally nested representation and back into texts.\nThe visual-graphical representation of algorithms is better perceived by a human developer than the traditional textual representation, therefore, some attention has been paid to the development of such programming systems in recent years. However, the implementation of the most human-friendly technologies for creating and editing block diagrams is associated with the need to solve a number of complex problems of forming and adequately displaying control structures used in popular programming languages. The analysis of such structures for the most popular programming languages \u200b\u200bin terms of various metrics is carried out, its results are presented, and a method for identifying and transforming control structures into an internal representation of a visual-graphic editor is proposed. The main algorithms for the operation of the program text converter both in forward and backward directions are described.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.6943359375
        },
        {
            "paperId": "a9c6d66e83edc329e0026924c74036f5ef88af9d",
            "corpusId": 276618982,
            "title": "Block and Text Programming: What do Students know on Their First and Last Day of Upper-Secondary School?",
            "venue": "Frontiers in Education Conference",
            "year": 2024,
            "referenceCount": 14,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/FIE61694.2024.10892970?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/FIE61694.2024.10892970, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2192860154",
                    "name": "J. Snider"
                },
                {
                    "authorId": "1692928",
                    "name": "Anna Eckerdal"
                }
            ],
            "abstract": "This full research paper investigates upper-secondary students programming skills. In 2021, an initial survey assessed the programming skills of first-year upper-secondary school students, focusing on their ability to solve problems using block and text-based programming languages. The survey revealed significant differences between students with mandatory programming education (Group TECH) and those without (Group SCI), with Group TECH outperforming Group SCI across all categories. The follow-up survey in 2024 evaluated the same cohort to measure longitudinal changes in their programming knowledge and skills. The results showed marked improvements in Group TECH's performance, particularly in more complex programming tasks involving loops and embedded conditional statements, while Group SCI also showed progress, albeit to a lesser extent. The study found that students who engaged more frequently in programming activities outside of school demonstrated higher average scores. Overall, students in the study entered upper-secondary mostly prepared for programming topics mostly related to math like variables and conditionals in block programming languages. Students that left upper-secondary, after introductory programming, were better prepared to understand loops and complex problems in text.",
            "corpus_id": "276618982",
            "text": "This full research paper investigates upper-secondary students programming skills. In 2021, an initial survey assessed the programming skills of first-year upper-secondary school students, focusing on their ability to solve problems using block and text-based programming languages. The survey revealed significant differences between students with mandatory programming education (Group TECH) and those without (Group SCI), with Group TECH outperforming Group SCI across all categories. The follow-up survey in 2024 evaluated the same cohort to measure longitudinal changes in their programming knowledge and skills. The results showed marked improvements in Group TECH's performance, particularly in more complex programming tasks involving loops and embedded conditional statements, while Group SCI also showed progress, albeit to a lesser extent. The study found that students who engaged more frequently in programming activities outside of school demonstrated higher average scores. Overall, students in the study entered upper-secondary mostly prepared for programming topics mostly related to math like variables and conditionals in block programming languages. Students that left upper-secondary, after introductory programming, were better prepared to understand loops and complex problems in text.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.1121826171875
        },
        {
            "paperId": "f237f439e873e9eaba9ff463f90969e21229deb9",
            "corpusId": 278603391,
            "title": "A Platform-Independent Software-Intensive Workflow Modeling Language And An Open-Source Visual Programming Tool: A Bottom-Up Approach Using Ontology Integration Of Industrial Workflow Engines",
            "venue": "ACM Symposium on Applied Computing",
            "year": 2025,
            "referenceCount": 21,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3672608.3707840?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3672608.3707840, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2362297710",
                    "name": "Yong-Jun Shin"
                },
                {
                    "authorId": "2342058307",
                    "name": "Wilfrid Utz"
                }
            ],
            "abstract": "Many contemporary software-intensive services are developed as workflows of collaborative and interdependent tasks. Industrial workflow platforms (i.e., engines) such as Airflow and Kubeflow automatically execute and monitor the workflow specified in platform-specific code. The code-based workflow specification becomes complex and error-prone as services grow in complexity. Furthermore, differences in platform-specific workflow specifications cause inefficiencies when porting workflows between platforms, even if the different platforms handle semantically the same workflow. In this paper, we propose a bottom-up approach for developing a platform-independent software-intensive workflow modeling language. The approach systematically extends the UML activity diagram by building platform-independent ontologies of the workflow specification from the given target industrial workflow engines. Based on the approach, we develop a platform-independent Workflow Modeling Language (WorkflowML) that covers four famous workflow engines (Airflow, Kubeflow, Argo workflow, and Metaflow). Furthermore, we implement an open-source visual programming tool for WorkflowML using the ADOxx metamodeling platform. We validate our approach by evaluating the expressiveness of WorkflowML based on modeling case studies of 42 simple workflows and two real-case workflow-based services. The evaluation results validate that WorkflowML serves as an effective common visual language for target workflow engines, supported by an open-source visual programming tool.",
            "corpus_id": "278603391",
            "text": "Many contemporary software-intensive services are developed as workflows of collaborative and interdependent tasks. Industrial workflow platforms (i.e., engines) such as Airflow and Kubeflow automatically execute and monitor the workflow specified in platform-specific code. The code-based workflow specification becomes complex and error-prone as services grow in complexity. Furthermore, differences in platform-specific workflow specifications cause inefficiencies when porting workflows between platforms, even if the different platforms handle semantically the same workflow. In this paper, we propose a bottom-up approach for developing a platform-independent software-intensive workflow modeling language. The approach systematically extends the UML activity diagram by building platform-independent ontologies of the workflow specification from the given target industrial workflow engines. Based on the approach, we develop a platform-independent Workflow Modeling Language (WorkflowML) that covers four famous workflow engines (Airflow, Kubeflow, Argo workflow, and Metaflow). Furthermore, we implement an open-source visual programming tool for WorkflowML using the ADOxx metamodeling platform. We validate our approach by evaluating the expressiveness of WorkflowML based on modeling case studies of 42 simple workflows and two real-case workflow-based services. The evaluation results validate that WorkflowML serves as an effective common visual language for target workflow engines, supported by an open-source visual programming tool.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.428955078125
        },
        {
            "paperId": "6f87289b936baee60ba48eb51cdaa18a9a6ee33f",
            "corpusId": 246211811,
            "title": "Patterns for visual programming: With a focus on flow-based programming inspired systems",
            "venue": "European Conference on Pattern Languages of Programs",
            "year": 2021,
            "referenceCount": 10,
            "citationCount": 6,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3489449.3489977?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3489449.3489977, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2115764553",
                    "name": "Mark Schmidt"
                }
            ],
            "abstract": "Software plays an increasingly important role in our daily lives. The development of this software is complex and hard to understand by non-professionals. Fundamental knowledge about programming languages and software structure is required to change it. By changing the logical complexity represented in software code in something more intuitively understandable, like graphical elements, even non-professionals can understand and learn to design software. Systems that are inspired by flow-based programming offer an interesting approach to this problem. This paper presents two pattern and five pattern candidates, which are a distillation from practices that are already in use. The presented pattern are Functions as building blocks and Connect building blocks. These pattern are used in established products like Node-Red[3] or n8n[2].",
            "corpus_id": "246211811",
            "text": "Software plays an increasingly important role in our daily lives. The development of this software is complex and hard to understand by non-professionals. Fundamental knowledge about programming languages and software structure is required to change it. By changing the logical complexity represented in software code in something more intuitively understandable, like graphical elements, even non-professionals can understand and learn to design software. Systems that are inspired by flow-based programming offer an interesting approach to this problem. This paper presents two pattern and five pattern candidates, which are a distillation from practices that are already in use. The presented pattern are Functions as building blocks and Connect building blocks. These pattern are used in established products like Node-Red[3] or n8n[2].",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.7529296875
        },
        {
            "paperId": "3b35c84dc6a446fd4675c07b67d1b8dbaf725e6c",
            "corpusId": 265369698,
            "title": "A Visual Programming Environment for Describing Complex Big Data Functions",
            "venue": "International Conferences on Information Science and System",
            "year": 2023,
            "referenceCount": 10,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://dl.acm.org/doi/pdf/10.1145/3625156.3625166",
                "status": "BRONZE",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3625156.3625166?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3625156.3625166, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2173313968",
                    "name": "Andreas Karabetian"
                },
                {
                    "authorId": "3403940",
                    "name": "Athanasios Kiourtis"
                },
                {
                    "authorId": "3404011",
                    "name": "Argyro Mavrogiorgou"
                },
                {
                    "authorId": "1681006",
                    "name": "D. Kyriazis"
                }
            ],
            "abstract": "The rapid advancement of technology and the increasing reliance on computer systems have elevated the significance of programming skills in various domains. Traditional programming techniques, primarily text-based languages, have been the backbone of software development for decades. However, these techniques often require a steep learning curve, limiting their accessibility to individuals without technical backgrounds. To address this issue, Visual Programming Environments (VPEs) have emerged as a powerful alternative, offering intuitive interfaces, consisting of graphical components such as buttons, icons or moving elements. The simple visual layout of these building blocks makes programming more accessible to non-technical users, and enables them to understand, design, and explain complex big data pipelines. While VPE's offer significant benefits, they are not without their limitations. Firstly, these environments may impose constraints on the flexibility and expressiveness of programming constructs, limiting advanced programming techniques that require fine-grained control over complex algorithms. Additionally, the graphical nature of VPE's may result in less efficient coding practices, as users might prioritize visual aesthetics over performance optimization. It is also of great importance that these services can be containerized, in order to be easily deployed and scaled, when talking about big data scenario's requirements. In this study, a VPE named Pipeline Modeler is implemented, capable of translating visual graph representations into operations, which can be then executed in big data scenarios, such as analytics pipelines and flow management on finance datasets. With the use of node blocks, one can create a graph to declare a complex mathematical flow or a pipeline of linked operations that need to be executed on a given set of data. After proper evaluation and experimentation, it is identified that this service is ideal for multiple big data and microservices scenarios, considering pipeline management cases, and that is why the Pipeline Modeler can be a great solution in the pursuit of inclusive and efficient software development and data management.",
            "corpus_id": "265369698",
            "text": "The rapid advancement of technology and the increasing reliance on computer systems have elevated the significance of programming skills in various domains. Traditional programming techniques, primarily text-based languages, have been the backbone of software development for decades. However, these techniques often require a steep learning curve, limiting their accessibility to individuals without technical backgrounds. To address this issue, Visual Programming Environments (VPEs) have emerged as a powerful alternative, offering intuitive interfaces, consisting of graphical components such as buttons, icons or moving elements. The simple visual layout of these building blocks makes programming more accessible to non-technical users, and enables them to understand, design, and explain complex big data pipelines. While VPE's offer significant benefits, they are not without their limitations. Firstly, these environments may impose constraints on the flexibility and expressiveness of programming constructs, limiting advanced programming techniques that require fine-grained control over complex algorithms. Additionally, the graphical nature of VPE's may result in less efficient coding practices, as users might prioritize visual aesthetics over performance optimization. It is also of great importance that these services can be containerized, in order to be easily deployed and scaled, when talking about big data scenario's requirements. In this study, a VPE named Pipeline Modeler is implemented, capable of translating visual graph representations into operations, which can be then executed in big data scenarios, such as analytics pipelines and flow management on finance datasets. With the use of node blocks, one can create a graph to declare a complex mathematical flow or a pipeline of linked operations that need to be executed on a given set of data. After proper evaluation and experimentation, it is identified that this service is ideal for multiple big data and microservices scenarios, considering pipeline management cases, and that is why the Pipeline Modeler can be a great solution in the pursuit of inclusive and efficient software development and data management.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.87353515625
        },
        {
            "paperId": "74a624a092ec0672051652a7d9f07bf26b0a7e13",
            "corpusId": 242281246,
            "title": "Comparison of flow-based versus block-based programming for naive programmers",
            "venue": "",
            "year": 0,
            "referenceCount": 0,
            "citationCount": 2,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://rshare.library.torontomu.ca/articles/thesis/Comparison_of_flow-based_versus_block-based_programming_for_naive_programmers/14652246/2/files/28134006.pdf",
                "status": "GREEN",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.32920/ryerson.14652246?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.32920/ryerson.14652246, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2071526509",
                    "name": "Kruti Dave"
                }
            ],
            "abstract": "There is general agreement that most people should have some programming ability, whether\nto investigate the vast amount of data around them or for professional purposes. Visual\nProgramming Languages comprise two broad categories: Flow-based, functional programming\nor Block-based, imperative programming. However, there has been a lack of empirical studies\nin the visual programming domain to evaluate the relative benefits of the two categories. This\nresearch provides an empirical study to analyze the effects of the comparison between Flowbased\nand Block-based paradigm, to determine which of the two representations is easier for\nnon-programmers or novice programmers. Each user is given a random, simple problem to\nprogram in a random environment. Both of the environments, Flow-based and Block-based\nare designed to be as similar as possible to make the comparison useful. The results indicate\nthat Flow and Block are equivalent environments for non-programmers or novice programmers\nin terms of usability and effectiveness.",
            "corpus_id": "242281246",
            "text": "There is general agreement that most people should have some programming ability, whether\nto investigate the vast amount of data around them or for professional purposes. Visual\nProgramming Languages comprise two broad categories: Flow-based, functional programming\nor Block-based, imperative programming. However, there has been a lack of empirical studies\nin the visual programming domain to evaluate the relative benefits of the two categories. This\nresearch provides an empirical study to analyze the effects of the comparison between Flowbased\nand Block-based paradigm, to determine which of the two representations is easier for\nnon-programmers or novice programmers. Each user is given a random, simple problem to\nprogram in a random environment. Both of the environments, Flow-based and Block-based\nare designed to be as similar as possible to make the comparison useful. The results indicate\nthat Flow and Block are equivalent environments for non-programmers or novice programmers\nin terms of usability and effectiveness.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.92041015625
        },
        {
            "paperId": "c2f4586cedafcbc9f9c7097311b41c6d266fd149",
            "corpusId": 247882811,
            "title": "Test Case Generation for Arduino Programming Instructions using Functional Block Diagrams",
            "venue": "TRENDS IN THE SCIENCES",
            "year": 2022,
            "referenceCount": 24,
            "citationCount": 4,
            "influentialCitationCount": 0,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://tis.wu.ac.th/index.php/tis/article/download/3472/214",
                "status": "HYBRID",
                "license": "CCBYNCND",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.48048/tis.2022.3472?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.48048/tis.2022.3472, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "49895807",
                    "name": "Mani Padmanabhan"
                }
            ],
            "abstract": "Interconnecting different wireless sensor and actuator network in the real-time systems are more demanding for testing. High capability is needed to enable efficient methodologies for testing. The major source of effective testing is the identification of test cases. Programming instruction based test case generation has not well suitable for Arduino real-time systems, that an open statement in the research community. This paper introduces a functional block diagram based test case generation framework to facilitate the functional evaluation of Arduino real-time systems. It makes from the functional block diagram. First, block diagrams are converted to the Event Sequence Graph, then the event node is minimized, the test cases are generated minimized event. The presented methodology has validated with the Arduino programming language. This proposed approach quantified with five sensors based Arduino real-time system experiments shows that based on the validated test cases; the development time and cost of the Arduino real-time systems have dynamically reduced. \nHIGHLIGHTS \n \nSoftware testing results ensure the quality of the developed software. Programming instruction based testing has not well suitable for Arduino real-time systems \nArduino functional block diagrams are converted to the event node for test case generation. Event Sequence Graph conversion algorithm provide the event direction \nValidation of Arduino software programming based on Arduino functional block diagrams identify the new fault detection capability \n \nGRAPHICAL ABSTRACT",
            "corpus_id": "247882811",
            "text": "Interconnecting different wireless sensor and actuator network in the real-time systems are more demanding for testing. High capability is needed to enable efficient methodologies for testing. The major source of effective testing is the identification of test cases. Programming instruction based test case generation has not well suitable for Arduino real-time systems, that an open statement in the research community. This paper introduces a functional block diagram based test case generation framework to facilitate the functional evaluation of Arduino real-time systems. It makes from the functional block diagram. First, block diagrams are converted to the Event Sequence Graph, then the event node is minimized, the test cases are generated minimized event. The presented methodology has validated with the Arduino programming language. This proposed approach quantified with five sensors based Arduino real-time system experiments shows that based on the validated test cases; the development time and cost of the Arduino real-time systems have dynamically reduced. \nHIGHLIGHTS \n \nSoftware testing results ensure the quality of the developed software. Programming instruction based testing has not well suitable for Arduino real-time systems \nArduino functional block diagrams are converted to the event node for test case generation. Event Sequence Graph conversion algorithm provide the event direction \nValidation of Arduino software programming based on Arduino functional block diagrams identify the new fault detection capability \n \nGRAPHICAL ABSTRACT",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.1739501953125
        },
        {
            "paperId": "765423fc62c1646bb93f0528bf05cd8de3a8c876",
            "corpusId": 258990742,
            "title": "VAPE-3D: A 3D Visual Avatar-based Programming Environment",
            "venue": "Computer Science Education Research Conference",
            "year": 2022,
            "referenceCount": 8,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1145/3569173.3569181?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1145/3569173.3569181, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2218649267",
                    "name": "Wouter Brinksma"
                },
                {
                    "authorId": "2219317025",
                    "name": "Berber Bouma"
                }
            ],
            "abstract": "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well. Often, the visualization of creating programs with these tools is different from executing them. We present the design and prototype of a 3D Visual Avatar-based Programming Environment (VAPE-3D) in the form of a visual programming language with a syntonic Avatar as its central component, and a unified visualization to edit and execute a program.",
            "corpus_id": "258990742",
            "text": "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well. Often, the visualization of creating programs with these tools is different from executing them. We present the design and prototype of a 3D Visual Avatar-based Programming Environment (VAPE-3D) in the form of a visual programming language with a syntonic Avatar as its central component, and a unified visualization to edit and execute a program.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.90478515625
        },
        {
            "paperId": "9272b726a49b445e9d8227aff170012281616b6f",
            "corpusId": 255418183,
            "title": "Educational robotics with tangible programming: A digital circuit for blocks communication with code and visual feedback transfer capabilities",
            "venue": "Latin American Robotics Symposium",
            "year": 2022,
            "referenceCount": 19,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": null,
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.1109/LARS/SBR/WRE56824.2022.9996032?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.1109/LARS/SBR/WRE56824.2022.9996032, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2199260545",
                    "name": "Jessica Toledo Salles"
                },
                {
                    "authorId": "2199260555",
                    "name": "Cristiane Pelisolli Cabral"
                },
                {
                    "authorId": "2094221568",
                    "name": "Rosane Arag\u00f3n de Nevado"
                },
                {
                    "authorId": "2053970035",
                    "name": "A. S. Sim\u00f5es"
                }
            ],
            "abstract": "A large number of robotic kits is commercially available for children education nowadays. Regarding the programming possibilities of these kits, they are usually divided into three categories: i) textual languages based kits, ii) digital blocks based kits and iii) tangible blocks based kits. In tangible blocks kits, the programming instructions are represented by physical - touchable - elements like blocks, cards or buttons. Since these are concrete objects, they are usually more playful and accessible for young children mainly in the concrete operational stage. Another relevant aspect in robotic kits is the possibility for children to follow the code execution at runtime. This process may be crucial for comprehending the programming process and for developing debugging abilities. In tangible programming based kits, this visual tracking is far more complex than in textual or digital blocks based kits since it typically requires the transmission of information between a lot of distinct physical pieces. The present work proposes and discusses the implementation of a digital electronic circuit with bluetooth communication designed for educational robotics kit and capable to provide a visual feedback. Results demonstrate that the proposed circuit is functional and feasible for embedding in robotic kits at a low cost.",
            "corpus_id": "255418183",
            "text": "A large number of robotic kits is commercially available for children education nowadays. Regarding the programming possibilities of these kits, they are usually divided into three categories: i) textual languages based kits, ii) digital blocks based kits and iii) tangible blocks based kits. In tangible blocks kits, the programming instructions are represented by physical - touchable - elements like blocks, cards or buttons. Since these are concrete objects, they are usually more playful and accessible for young children mainly in the concrete operational stage. Another relevant aspect in robotic kits is the possibility for children to follow the code execution at runtime. This process may be crucial for comprehending the programming process and for developing debugging abilities. In tangible programming based kits, this visual tracking is far more complex than in textual or digital blocks based kits since it typically requires the transmission of information between a lot of distinct physical pieces. The present work proposes and discusses the implementation of a digital electronic circuit with bluetooth communication designed for educational robotics kit and capable to provide a visual feedback. Results demonstrate that the proposed circuit is functional and feasible for embedding in robotic kits at a low cost.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.36181640625
        },
        {
            "paperId": "eeb0ce6dacf135487a0016b57c53de580e3724cd",
            "corpusId": 149743899,
            "title": "Making Programming Accessible to Learners with Visual Impairments: A Literature Review",
            "venue": "International Journal of Computer Science Education in Schools",
            "year": 2018,
            "referenceCount": 141,
            "citationCount": 35,
            "influentialCitationCount": 4,
            "isOpenAccess": true,
            "openAccessPdf": {
                "url": "https://www.ijcses.org/index.php/ijcses/article/download/25/41",
                "status": "HYBRID",
                "license": "CCBY",
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.21585/IJCSES.V2I2.25?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.21585/IJCSES.V2I2.25, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "1417430248",
                    "name": "Alex Hadwen-Bennett"
                },
                {
                    "authorId": "1709307",
                    "name": "Sue Sentance"
                },
                {
                    "authorId": "121927341",
                    "name": "C. Morrison"
                }
            ],
            "abstract": "Programming can be challenging to learn and for visually impaired (VI) learners there are numerous additional barriers to the learning process. Many modern programming environments are inaccessible to VI learners, being difficult or impossible to interface with using a screen reader. A review of the literature has identified a number of strategies that have been employed in the quest to make learning to program accessible to VI learners. These can be broadly divided into the following categories; auditory and haptic feedback, making text-based langauges (TBLs) accessible, making block-based languages (BBLs) accessible and physical artefacts.A common theme among the literature is the difficulty VI learners have in gaining an understanding of the overall structure of their code. Much of the research carried out in this space to date focuses on the evaluation of interventions aimed at VI high-school and undergraduate students, with limited attention given to the learning processes of VI learners. Additionally, the majority of the research deals with (TBLs), this is despite the fact that most introductory programming courses for primary learners use (BBLs). Therefore, further research is urgently needed to investigate potential strategies for introducing VI children in primary education to programming and the learning processes involved.",
            "corpus_id": "149743899",
            "text": "Programming can be challenging to learn and for visually impaired (VI) learners there are numerous additional barriers to the learning process. Many modern programming environments are inaccessible to VI learners, being difficult or impossible to interface with using a screen reader. A review of the literature has identified a number of strategies that have been employed in the quest to make learning to program accessible to VI learners. These can be broadly divided into the following categories; auditory and haptic feedback, making text-based langauges (TBLs) accessible, making block-based languages (BBLs) accessible and physical artefacts.A common theme among the literature is the difficulty VI learners have in gaining an understanding of the overall structure of their code. Much of the research carried out in this space to date focuses on the evaluation of interventions aimed at VI high-school and undergraduate students, with limited attention given to the learning processes of VI learners. Additionally, the majority of the research deals with (TBLs), this is despite the fact that most introductory programming courses for primary learners use (BBLs). Therefore, further research is urgently needed to investigate potential strategies for introducing VI children in primary education to programming and the learning processes involved.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.2646484375
        },
        {
            "paperId": "cd540b9b3fde709681b540a709712bd4e84ebcac",
            "corpusId": 276062541,
            "title": "Teaching Reform and Exploration of Python Programming Course Based on Knowledge Graph",
            "venue": "Journal of Educational Research and Policies",
            "year": 2025,
            "referenceCount": 23,
            "citationCount": 0,
            "influentialCitationCount": 0,
            "isOpenAccess": false,
            "openAccessPdf": {
                "url": "",
                "status": "CLOSED",
                "license": null,
                "disclaimer": "Notice: Paper or abstract available at https://api.unpaywall.org/v2/10.53469/jerp.2025.07(01).06?email=<INSERT_YOUR_EMAIL> or https://doi.org/10.53469/jerp.2025.07(01).06, which is subject to the license by the author or copyright owner provided with this content. Please go to the source to verify the license and copyright information for your use."
            },
            "authors": [
                {
                    "authorId": "2343746710",
                    "name": "Jinliang Liang"
                }
            ],
            "abstract": "This paper explores the application of knowledge graphs in the reform and exploration of Python programming education, using a case study from Nanfang College Guangzhou. The study investigates the impact of knowledge graphs on student learning outcomes in a Python programming course, comparing an experimental group (EG) that utilized an interactive knowledge graph-based learning tool with a control group (CG) that followed traditional teaching methods. A mixed-methods approach was adopted, combining quantitative assessments (pre- and post-course quiz, final exams, and practical coding assignments) with qualitative feedback from students through surveys. The results reveal that the EG outperformed the CG in all assessment categories, showing a significant increase in quiz scores, final exam performance, and practical coding assignments. Specifically, the EG demonstrated a 13% improvement in quiz scores, a 15% increase in final exam scores, and an 18% improvement in coding assignments compared to the CG. Statistical analysis confirmed the significance of these differences, with p-values below 0.05 for all measures. Qualitative feedback from the EG also highlighted the effectiveness of the knowledge graphs in enhancing understanding of abstract programming concepts, improving problem-solving skills, and boosting confidence in applying Python programming to real-world problems. These findings suggest that knowledge graphs can serve as a powerful teaching tool in programming education, offering students a visual and interactive method to comprehend complex relationships between programming concepts. The study highlights the potential for integrating KGs into computer science curricula to foster deeper learning, reduce cognitive load, and improve student outcomes. Further research is recommended to explore the long-term impact of knowledge graphs on programming education and their applicability across different programming languages and educational contexts.",
            "corpus_id": "276062541",
            "text": "This paper explores the application of knowledge graphs in the reform and exploration of Python programming education, using a case study from Nanfang College Guangzhou. The study investigates the impact of knowledge graphs on student learning outcomes in a Python programming course, comparing an experimental group (EG) that utilized an interactive knowledge graph-based learning tool with a control group (CG) that followed traditional teaching methods. A mixed-methods approach was adopted, combining quantitative assessments (pre- and post-course quiz, final exams, and practical coding assignments) with qualitative feedback from students through surveys. The results reveal that the EG outperformed the CG in all assessment categories, showing a significant increase in quiz scores, final exam performance, and practical coding assignments. Specifically, the EG demonstrated a 13% improvement in quiz scores, a 15% increase in final exam scores, and an 18% improvement in coding assignments compared to the CG. Statistical analysis confirmed the significance of these differences, with p-values below 0.05 for all measures. Qualitative feedback from the EG also highlighted the effectiveness of the knowledge graphs in enhancing understanding of abstract programming concepts, improving problem-solving skills, and boosting confidence in applying Python programming to real-world problems. These findings suggest that knowledge graphs can serve as a powerful teaching tool in programming education, offering students a visual and interactive method to comprehend complex relationships between programming concepts. The study highlights the potential for integrating KGs into computer science curricula to foster deeper learning, reduce cognitive load, and improve student outcomes. Further research is recommended to explore the long-term impact of knowledge graphs on programming education and their applicability across different programming languages and educational contexts.",
            "section_title": "abstract",
            "char_start_offset": 0,
            "sentence_offsets": [],
            "ref_mentions": [],
            "score": 0.0,
            "stype": "public_api",
            "pdf_hash": "",
            "rerank_score": 0.15966796875
        }
    ],
    "quotes": {
        "cost": 0.19601699999999997,
        "quotes": [
            {
                "idx": 0,
                "key": "[116768063 | Ariza | 2019 | Citations: 7]",
                "snippets": "Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "\u2022",
                        "pdf_hash": "",
                        "start": 120,
                        "end": 322,
                        "sentence_offsets": [
                            {
                                "start": 120,
                                "end": 322
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations."
                    }
                ]
            },
            {
                "idx": 1,
                "key": "[15820022 | Bellucci et al. | 2017 | Citations: 9]",
                "snippets": "Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification (Myers, 1986) and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming (Lieberman et al., 2006) (p. 3).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "End-User Programming for Ubiquitous Interaction",
                        "pdf_hash": "",
                        "start": 264,
                        "end": 602,
                        "sentence_offsets": [
                            {
                                "start": 264,
                                "end": 598
                            },
                            {
                                "start": 599,
                                "end": 602
                            }
                        ],
                        "ref_mentions": [
                            "12628167",
                            "15559793"
                        ],
                        "quote": "Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification (Myers, 1986) and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming (Lieberman et al., 2006) (p. 3)."
                    }
                ]
            },
            {
                "idx": 2,
                "key": "[199002134 | Joao et al. | 2019 | Citations: 23]",
                "snippets": "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program (Cheng, 2019). In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming (Lye et al., 2014). Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together (Weintrop et al., 2018).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual and Block-based Programming Environment",
                        "pdf_hash": "",
                        "start": 401,
                        "end": 1871,
                        "sentence_offsets": [
                            {
                                "start": 401,
                                "end": 547
                            },
                            {
                                "start": 548,
                                "end": 674
                            },
                            {
                                "start": 675,
                                "end": 679
                            },
                            {
                                "start": 680,
                                "end": 973
                            },
                            {
                                "start": 974,
                                "end": 1205
                            },
                            {
                                "start": 1208,
                                "end": 1409
                            },
                            {
                                "start": 1410,
                                "end": 1624
                            },
                            {
                                "start": 1625,
                                "end": 1871
                            }
                        ],
                        "ref_mentions": [
                            "7335020",
                            "59528289",
                            "11994747",
                            "51750550"
                        ],
                        "quote": "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program (Cheng, 2019). In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming (Lye et al., 2014). Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together (Weintrop et al., 2018)."
                    }
                ]
            },
            {
                "idx": 3,
                "key": "[202566030 | Zikas et al. | 2019 | Citations: 1]",
                "snippets": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities...On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual Programming as an authoring tool",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 475,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 111
                            },
                            {
                                "start": 112,
                                "end": 476
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities"
                    },
                    {
                        "section_title": "Visual Programming as an authoring tool",
                        "pdf_hash": "",
                        "start": 1492,
                        "end": 1774,
                        "sentence_offsets": [
                            {
                                "start": 1492,
                                "end": 1642
                            },
                            {
                                "start": 1643,
                                "end": 1773
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow."
                    }
                ]
            },
            {
                "idx": 4,
                "key": "[209056321 | Amorim et al. | 2019 | Citations: 1]",
                "snippets": "According to S. Chang and M. Erwing, a visual programming language (VLP) is one language that allows the users to develop programs using graphic elements in the place of specifying them textually. To built this language we used the library Blockly, which allowed us to create a visual language based on blocks [4], (Erwig et al., 2017).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "C. Visual programming language",
                        "pdf_hash": "",
                        "start": 365,
                        "end": 684,
                        "sentence_offsets": [
                            {
                                "start": 365,
                                "end": 561
                            },
                            {
                                "start": 562,
                                "end": 684
                            }
                        ],
                        "ref_mentions": [
                            "10570737"
                        ],
                        "quote": "According to S. Chang and M. Erwing, a visual programming language (VLP) is one language that allows the users to develop programs using graphic elements in the place of specifying them textually. To built this language we used the library Blockly, which allowed us to create a visual language based on blocks [4], (Erwig et al., 2017)."
                    }
                ]
            },
            {
                "idx": 5,
                "key": "[20991852 | Kahanwal | 2013 | Citations: 9]",
                "snippets": "Visual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "e)",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 737,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 98
                            },
                            {
                                "start": 99,
                                "end": 299
                            },
                            {
                                "start": 300,
                                "end": 434
                            },
                            {
                                "start": 435,
                                "end": 580
                            },
                            {
                                "start": 581,
                                "end": 674
                            },
                            {
                                "start": 675,
                                "end": 737
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages."
                    }
                ]
            },
            {
                "idx": 6,
                "key": "[221340525 | Alturayeif et al. | 2020 | Citations: 19]",
                "snippets": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text...There is a rich history of different visual programming tools designed for novices comprehensively surveyed in (Lye et al., 2014). AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language (Repenning, 2017). Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch (Repenning, 2017)...Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets (Repenning, 2017). According to (Repenning, 2017), Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[41867280 | Repenning | 2017 | Citations: 50]": "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                },
                "metadata": [
                    {
                        "section_title": "II. BACKGROUND",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 136,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 137
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text"
                    },
                    {
                        "section_title": "II. BACKGROUND",
                        "pdf_hash": "",
                        "start": 563,
                        "end": 1013,
                        "sentence_offsets": [
                            {
                                "start": 563,
                                "end": 678
                            },
                            {
                                "start": 679,
                                "end": 808
                            },
                            {
                                "start": 809,
                                "end": 894
                            },
                            {
                                "start": 895,
                                "end": 1013
                            }
                        ],
                        "ref_mentions": [
                            "11994747",
                            "41867280",
                            "41867280"
                        ],
                        "quote": "There is a rich history of different visual programming tools designed for novices comprehensively surveyed in (Lye et al., 2014). AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language (Repenning, 2017). Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch (Repenning, 2017)"
                    },
                    {
                        "section_title": "II. BACKGROUND",
                        "pdf_hash": "",
                        "start": 1533,
                        "end": 1926,
                        "sentence_offsets": [
                            {
                                "start": 1533,
                                "end": 1662
                            },
                            {
                                "start": 1663,
                                "end": 1789
                            },
                            {
                                "start": 1790,
                                "end": 1925
                            }
                        ],
                        "ref_mentions": [
                            "41867280",
                            "41867280"
                        ],
                        "quote": "Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets (Repenning, 2017). According to (Repenning, 2017), Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language."
                    }
                ]
            },
            {
                "idx": 7,
                "key": "[221802417 | McDaid et al. | 2020 | Citations: 4]",
                "snippets": "Visual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose.\n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[158715 | Andrade | 2015 | Citations: 34]": "Due to hardware limitations at the origin of the video game industry, each new game was generally coded from the ground up. Years later, from the evolution of hardware and the need for quick game development cycles, spawned the concept of game engine. A game engine is a reusable software layer allowing the separation of common game concepts from the game assets (levels, graphics, etc.). This paper surveys fourteen different game engines relevant today, ranging from the industry-level to the newcomer-friendlier ones.",
                    "[30037917 | Ray | 2017 | Citations: 60]": "Visual programming has transformed the art of programming in recent years. Several organizations are in race to develop novel ideas to run visual programming in multiple domains with Internet of Things. IoT, being the most emerging area of computing, needs substantial contribution from the visual programming paradigm for its technological propagation. This paper surveys visual programming languages being served for application development, especially in Internet of Things field. 13 such languages are visited from several popular research-electronic databases (e.g., IEEE Xplore, Science Direct, Springer Link, Google Scholar, Web of Science, and Postscapes) and compared under four key attributes such as programming environment, license, project repository, and platform supports. Grouped into two segments, open source and proprietary platform, these visual languages pertain few crucial challenges that have been elaborated in this literature. The main goal of this paper is to present existing VPLs per their parametric proforma to enable naive developers and researchers in the field of IoT to choose appropriate variant of VPL for particular type of application. It is also worth validating the usability and adaptability of VPLs that is essential for selection of beneficiary in terms of IoT.",
                    "[561505 | Modugno et al. | 1994 | Citations: 35]": "We present a new visual programming language and environment that serves as a form of feedback and representation in a Programming by Demonstration system The language di ers from existing visual languages because it explicitly represents data objects and implicitly represents operations by changes in data objects The system was designed to provide non programmers with programming support for common repetitive tasks and incorporates some principles of cognition to assist these users in learning to use it With this in mind we analyzed the language and its editor along cognitive dimensions The assessment provided insight into both strengths and weaknesses of the system prompting a number of design changes This demonstrates how useful such an analysis can be"
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming",
                        "pdf_hash": "",
                        "start": 530,
                        "end": 1144,
                        "sentence_offsets": [
                            {
                                "start": 415,
                                "end": 555
                            },
                            {
                                "start": 556,
                                "end": 615
                            },
                            {
                                "start": 616,
                                "end": 687
                            },
                            {
                                "start": 690,
                                "end": 798
                            },
                            {
                                "start": 799,
                                "end": 887
                            },
                            {
                                "start": 890,
                                "end": 927
                            },
                            {
                                "start": 930,
                                "end": 973
                            },
                            {
                                "start": 976,
                                "end": 1015
                            },
                            {
                                "start": 1018,
                                "end": 1160
                            }
                        ],
                        "ref_mentions": [
                            "7335020",
                            "5257722",
                            "9744698",
                            "44279097",
                            "30037917",
                            "158715",
                            "425881",
                            "561505"
                        ],
                        "quote": "Visual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose.\n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users."
                    }
                ]
            },
            {
                "idx": 8,
                "key": "[231725028 | Kuhail et al. | 2021 | Citations: 39]",
                "snippets": "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program.",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 9,
                "key": "[232029733 | Dragule et al. | 2021 | Citations: 15]",
                "snippets": "Block-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Environments with block-based languages",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 469,
                        "sentence_offsets": [],
                        "ref_mentions": [],
                        "quote": "Block-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45]."
                    }
                ]
            },
            {
                "idx": 10,
                "key": "[235234208 | Dawoud et al. | 2021 | Citations: 1]",
                "snippets": "Visual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "VISUAL PROGRAMMING",
                        "pdf_hash": "",
                        "start": 543,
                        "end": 682,
                        "sentence_offsets": [
                            {
                                "start": 543,
                                "end": 682
                            }
                        ],
                        "ref_mentions": [
                            "7335020"
                        ],
                        "quote": "Visual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990)."
                    }
                ]
            },
            {
                "idx": 11,
                "key": "[236336244 | Daskalov et al. | 2021 | Citations: 2]",
                "snippets": "Many VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations...Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Introduction",
                        "pdf_hash": "",
                        "start": 364,
                        "end": 543,
                        "sentence_offsets": [
                            {
                                "start": 364,
                                "end": 544
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Many VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations"
                    },
                    {
                        "section_title": "Introduction",
                        "pdf_hash": "",
                        "start": 981,
                        "end": 1149,
                        "sentence_offsets": [
                            {
                                "start": 981,
                                "end": 1017
                            },
                            {
                                "start": 1018,
                                "end": 1036
                            },
                            {
                                "start": 1037,
                                "end": 1148
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding."
                    }
                ]
            },
            {
                "idx": 12,
                "key": "[236447670 | Ikarashi et al. | 2021 | Citations: 9]",
                "snippets": "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes (Repenning et al., 2000). Alice (Cooper et al., 2000) and Scratch (273180521) are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[62491646 | Cooper et al. | 2000 | Citations: 591]": "In learning to program, many students struggle with developing algorithms, figuring out how to apply problem solving techniques in their programs, and with how to use common programming constructs. In this paper, we present a new tool that provides a possible approach to actively engage students in increasing their knowledge and skills in these areas. The tool is Alice, a 3-D interactive animation environment."
                },
                "metadata": [
                    {
                        "section_title": "E. Visual Programming Language",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 349,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 115
                            },
                            {
                                "start": 116,
                                "end": 198
                            },
                            {
                                "start": 199,
                                "end": 349
                            }
                        ],
                        "ref_mentions": [
                            "34589974",
                            "62491646",
                            "273180521"
                        ],
                        "quote": "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes (Repenning et al., 2000). Alice (Cooper et al., 2000) and Scratch (273180521) are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks."
                    }
                ]
            },
            {
                "idx": 13,
                "key": "[236566925 | Aldhlan et al. | 2021 | Citations: 2]",
                "snippets": "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23)",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Some visual programming languages:",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 1337,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 79
                            },
                            {
                                "start": 82,
                                "end": 265
                            },
                            {
                                "start": 266,
                                "end": 591
                            },
                            {
                                "start": 594,
                                "end": 769
                            },
                            {
                                "start": 770,
                                "end": 901
                            },
                            {
                                "start": 902,
                                "end": 1111
                            },
                            {
                                "start": 1112,
                                "end": 1337
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23)"
                    }
                ]
            },
            {
                "idx": 14,
                "key": "[238126162 | Lutalo et al. | 2020 | Citations: 0]",
                "snippets": "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts.\n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13].\n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[4039308 | Noone et al. | 2017 | Citations: 95]": "It is well documented and has been the topic of much research as well that Computer Science courses tend to have higher than average drop-out rates at third level, particularly so, for students advancing from first year to second year. This is a problem that needs to be addressed not only with urgency but also with caution. The required number of Computer Science graduates is growing every year, but the number of graduates is not meeting this demand, and one way that this problem can be alleviated is to encourage students, at an early age, towards studying Computer Science courses. This paper presents a systematic literature review that examines the role of visual and textual programming languages when learning to program, particularly as a First Programming Language. The approach is systematic in that a structured search of electronic resources has been conducted, and the results are presented and quantitatively analysed. This study will provide insight into whether or not the current approaches to teaching young learners programming are viable, and examines what we can do to increase the interest and retention of these students as they progress through their education."
                },
                "metadata": [
                    {
                        "section_title": "Programming Complexity: Visual Programming Interfaces and Languages Simplifying Software Construction",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 1020,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 190
                            },
                            {
                                "start": 191,
                                "end": 335
                            },
                            {
                                "start": 336,
                                "end": 554
                            },
                            {
                                "start": 557,
                                "end": 636
                            },
                            {
                                "start": 637,
                                "end": 916
                            },
                            {
                                "start": 919,
                                "end": 1022
                            }
                        ],
                        "ref_mentions": [
                            "4039308",
                            "4039308",
                            "17653432"
                        ],
                        "quote": "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts.\n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13].\n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages."
                    }
                ]
            },
            {
                "idx": 15,
                "key": "[242281246 | Dave | 0 | Citations: 2]",
                "snippets": "Visual Programming Languages comprise two broad categories: Flow-based, functional programming or Block-based, imperative programming.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual Programming Languages comprise two broad categories: Flow-based, functional programming or Block-based, imperative programming.",
                        "section_title": "abstract",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 16,
                "key": "[246022597 | Pongthanisorn et al. | 2022 | Citations: 0]",
                "snippets": "This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990). There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7]8] which employ a concept of representing computer instruction into a block called block-based programming.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Introduction",
                        "pdf_hash": "",
                        "start": 693,
                        "end": 1566,
                        "sentence_offsets": [
                            {
                                "start": 693,
                                "end": 801
                            },
                            {
                                "start": 802,
                                "end": 852
                            },
                            {
                                "start": 853,
                                "end": 907
                            },
                            {
                                "start": 908,
                                "end": 1069
                            },
                            {
                                "start": 1070,
                                "end": 1273
                            },
                            {
                                "start": 1274,
                                "end": 1566
                            }
                        ],
                        "ref_mentions": [
                            "7335020"
                        ],
                        "quote": "This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990). There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7]8] which employ a concept of representing computer instruction into a block called block-based programming."
                    }
                ]
            },
            {
                "idx": 17,
                "key": "[248524774 | Hirzel | 2022 | Citations: 21]",
                "snippets": "Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Palette Code canvas Stage",
                        "pdf_hash": "",
                        "start": 266,
                        "end": 591,
                        "sentence_offsets": [
                            {
                                "start": 266,
                                "end": 412
                            },
                            {
                                "start": 413,
                                "end": 591
                            }
                        ],
                        "ref_mentions": [
                            "2385464"
                        ],
                        "quote": "Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions."
                    }
                ]
            },
            {
                "idx": 18,
                "key": "[248845951 | Chen et al. | 2022 | Citations: 2]",
                "snippets": "Block-based programming is a visual expression of VPLs that uses block-stack behavior to construct program content.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "II. RELATED WORK",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 115,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 115
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Block-based programming is a visual expression of VPLs that uses block-stack behavior to construct program content."
                    }
                ]
            },
            {
                "idx": 19,
                "key": "[253043422 | Baena-Perez et al. | 2022 | Citations: 3]",
                "snippets": "VPLs can be classified into two categories: imperative languages and flow-based languages (Mason et al., 2017). With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others (Garc\u00eda-Borgo\u00f1\u00f3n et al., 2014).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual programming languages",
                        "pdf_hash": "",
                        "start": 1131,
                        "end": 1992,
                        "sentence_offsets": [
                            {
                                "start": 1131,
                                "end": 1226
                            },
                            {
                                "start": 1227,
                                "end": 1365
                            },
                            {
                                "start": 1366,
                                "end": 1432
                            },
                            {
                                "start": 1433,
                                "end": 1516
                            },
                            {
                                "start": 1517,
                                "end": 1682
                            },
                            {
                                "start": 1683,
                                "end": 1871
                            },
                            {
                                "start": 1872,
                                "end": 1992
                            }
                        ],
                        "ref_mentions": [
                            "20439639",
                            "6927128"
                        ],
                        "quote": "VPLs can be classified into two categories: imperative languages and flow-based languages (Mason et al., 2017). With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others (Garc\u00eda-Borgo\u00f1\u00f3n et al., 2014)."
                    }
                ]
            },
            {
                "idx": 20,
                "key": "[253049931 | Mayr-Dorn et al. | 2022 | Citations: 3]",
                "snippets": "A block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Block-based programming languages",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 884,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 76
                            },
                            {
                                "start": 77,
                                "end": 253
                            },
                            {
                                "start": 254,
                                "end": 378
                            },
                            {
                                "start": 379,
                                "end": 511
                            },
                            {
                                "start": 512,
                                "end": 737
                            },
                            {
                                "start": 738,
                                "end": 884
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "A block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled."
                    }
                ]
            },
            {
                "idx": 21,
                "key": "[258217657 | Jiang | 2023 | Citations: 4]",
                "snippets": "Visual programming languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual programming languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires.",
                        "section_title": "abstract",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 22,
                "key": "[258990742 | Brinksma et al. | 2022 | Citations: 0]",
                "snippets": "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well.",
                        "section_title": "abstract",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 23,
                "key": "[259335765 | DeLozier et al. | 2023 | Citations: 6]",
                "snippets": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018).",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[235383033 | Papadakis | 2021 | Citations: 90]": "Data that shows that young children can learn and acquire Computational Thinking (CT) skills has led governments and policymakers internationally to integrate CT into the curriculum, starting in the earliest grades. Researchers support the idea that this introduction must not solely focus on a problem-solving process skill (CT) but instead provide children with new ways to express themselves, supporting their cognitive, language, and socio-emotional development (Computational Fluency-CF). Coupled with the media and government\u2019s rhetoric and an increasing number of apps offering various programming lessons, puzzles, and challenges, educators have been responsible for introducing young children to CT and CF using touchscreen technology. This paper presents a literature review (N = 21) of empirical studies on applying four coding apps to support young children\u2019s learning of CT and CF. The main conclusion is that all apps positively affect the development of children\u2019s CT skills. None of the apps can ultimately support the development of CF, although ScratchJr, with a \u201csandbox\u201d approach, can better help students express themselves.",
                    "[253196672 | Timur et al. | 2021 | Citations: 6]": "\"Abstract: In this study, it was aimed to examine the pre-service pre-school teachers\u2019 opinions about using block-based coding/Scratch in education. 28 pre-service pre-school teachers were participated studying at a public university in a Marmara province region. Within the scope of the study, pre-service teachers were trained on the block-based coding Scratch program for four weeks. A semi-structured interview form consisting of 12 questions was used to determine the opinions of the participants. The data of the study were analyzed using the descriptive analysis method. As a result of the study, 85.71% of pre-school teacher candidates stated that block-based coding education should start at an early age like a language education, this education is important as a necessity of the technology age and all students should benefit from this education in order to provide an effective education, 14.25% of teacher candidates specified that this education is untimely for younger age levels and should not be given to everyone. In addition, the pre-service teachers stated that the block-based coding/Scratch program training helped them gain new ideas in terms of creating materials, improved their creativity and contributed to design abstract material in addition to concrete ones. Additionally, 46.42% of pre-service teachers stated that block-based coding education should start between the ages of 5-7. In this context, it is recommended to provide coding education both in pre-school and undergraduate education.\"",
                    "[35735491 | Urness et al. | 2011 | Citations: 2]": "In this paper we describe several techniques that have helped increase enrollment in the computer science program from 23 computer science majors in 2008 to 42 computer science majors in 2010 - an increase of 82.6%. We discuss issues related to curriculum, programming assignments, and professor-student interactions that have made the discipline more attractive and manageable to a variety of students within the setting of a small liberal arts college."
                },
                "metadata": [
                    {
                        "section_title": "Visual Programming",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 788,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 76
                            },
                            {
                                "start": 77,
                                "end": 187
                            },
                            {
                                "start": 188,
                                "end": 278
                            },
                            {
                                "start": 279,
                                "end": 425
                            },
                            {
                                "start": 426,
                                "end": 548
                            },
                            {
                                "start": 549,
                                "end": 696
                            },
                            {
                                "start": 697,
                                "end": 788
                            }
                        ],
                        "ref_mentions": [
                            "253196672",
                            "235383033",
                            "10976181",
                            "35735491",
                            "51750550"
                        ],
                        "quote": "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018)."
                    }
                ]
            },
            {
                "idx": 24,
                "key": "[264306865 | Avishahar-Zeira et al. | 2023 | Citations: 4]",
                "snippets": "Both No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code.\n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {
                    "[27376867 | Weintrop et al. | 2017 | Citations: 10]": "The ability to express ideas in a computationally meaningful way is becoming increasingly important in our technological world. In response to the growing importance of computational literacy skills, new intuitive and accessible programming environments are being designed. This paper presents a framework for classifying the ways that block-based introductory programming environments support novices. We identify four distinct roles that these graphical languages play in the activity of programming: (1) serving as a means for expressing ideas to the computer, (2) providing a record of previously articulated intentions, (3) acting as a source of ideas for construction, and (4) mediating the meaning-making process. Using data from a study of novices programming with a custom designed block-based language, we provide examples of each role along with a discussion of the design implications of these findings. In doing so, we contribute to our understanding of the relationship between the design of programming representations and their ability to support computational literacy. The paper concludes with a discussion of the potential for this framework beyond block-based environments to programming languages more broadly."
                },
                "metadata": [
                    {
                        "section_title": "Discussion and Related Work",
                        "pdf_hash": "",
                        "start": 246,
                        "end": 930,
                        "sentence_offsets": [
                            {
                                "start": 77,
                                "end": 303
                            },
                            {
                                "start": 306,
                                "end": 462
                            },
                            {
                                "start": 463,
                                "end": 524
                            },
                            {
                                "start": 527,
                                "end": 699
                            },
                            {
                                "start": 700,
                                "end": 820
                            },
                            {
                                "start": 821,
                                "end": 991
                            }
                        ],
                        "ref_mentions": [
                            "9744698",
                            "27376867",
                            "2701916"
                        ],
                        "quote": "Both No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code.\n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code."
                    }
                ]
            },
            {
                "idx": 25,
                "key": "[268272915 | Kodytek et al. | 2024 | Citations: 1]",
                "snippets": "Graphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Introduction",
                        "pdf_hash": "",
                        "start": 0,
                        "end": 507,
                        "sentence_offsets": [
                            {
                                "start": 0,
                                "end": 227
                            },
                            {
                                "start": 228,
                                "end": 507
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Graphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements."
                    }
                ]
            },
            {
                "idx": 26,
                "key": "[269747039 | Lin et al. | 2023 | Citations: 18]",
                "snippets": "There are primarily two main paradigms for VPIs. The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph. Pioneering work in this area includes Prograph [17] and LabVIEW [27]. The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together. Notable works in this area include Scratch [35] and Blockly [19].",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual Programming Interfaces",
                        "pdf_hash": "",
                        "start": 215,
                        "end": 684,
                        "sentence_offsets": [
                            {
                                "start": 187,
                                "end": 266
                            },
                            {
                                "start": 266,
                                "end": 314
                            },
                            {
                                "start": 314,
                                "end": 455
                            },
                            {
                                "start": 455,
                                "end": 524
                            },
                            {
                                "start": 524,
                                "end": 666
                            },
                            {
                                "start": 666,
                                "end": 731
                            }
                        ],
                        "ref_mentions": [
                            "18983760",
                            "9693598"
                        ],
                        "quote": "There are primarily two main paradigms for VPIs. The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph. Pioneering work in this area includes Prograph [17] and LabVIEW [27]. The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together. Notable works in this area include Scratch [35] and Blockly [19]."
                    }
                ]
            },
            {
                "idx": 27,
                "key": "[273376382 | Narkthong et al. | 2024 | Citations: 0]",
                "snippets": "We evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "We evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs.",
                        "section_title": "abstract",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 28,
                "key": "[4793447 | Vithana et al. | 2017 | Citations: 0]",
                "snippets": "These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "WORK DEVELOPED",
                        "pdf_hash": "",
                        "start": 1427,
                        "end": 2230,
                        "sentence_offsets": [
                            {
                                "start": 1427,
                                "end": 1477
                            },
                            {
                                "start": 1478,
                                "end": 1540
                            },
                            {
                                "start": 1541,
                                "end": 1650
                            },
                            {
                                "start": 1651,
                                "end": 1810
                            },
                            {
                                "start": 1811,
                                "end": 1850
                            },
                            {
                                "start": 1851,
                                "end": 1936
                            },
                            {
                                "start": 1937,
                                "end": 2045
                            },
                            {
                                "start": 2046,
                                "end": 2161
                            },
                            {
                                "start": 2162,
                                "end": 2230
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks."
                    }
                ]
            },
            {
                "idx": 29,
                "key": "[53282492 | Dias et al. | 2018 | Citations: 14]",
                "snippets": "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "quote": "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms.",
                        "pdf_hash": ""
                    }
                ]
            },
            {
                "idx": 30,
                "key": "[64771513 | Ben-Ari et al. | 2018 | Citations: 96]",
                "snippets": "Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Software Development Environments",
                        "pdf_hash": "",
                        "start": 177,
                        "end": 858,
                        "sentence_offsets": [
                            {
                                "start": 177,
                                "end": 298
                            },
                            {
                                "start": 301,
                                "end": 411
                            },
                            {
                                "start": 412,
                                "end": 518
                            },
                            {
                                "start": 519,
                                "end": 656
                            },
                            {
                                "start": 659,
                                "end": 730
                            },
                            {
                                "start": 731,
                                "end": 858
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes."
                    }
                ]
            },
            {
                "idx": 31,
                "key": "[67344764 | Schiavoni et al. | 2018 | Citations: 7]",
                "snippets": "The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "About the Mosaicode",
                        "pdf_hash": "",
                        "start": 379,
                        "end": 1337,
                        "sentence_offsets": [
                            {
                                "start": 379,
                                "end": 466
                            },
                            {
                                "start": 467,
                                "end": 546
                            },
                            {
                                "start": 547,
                                "end": 655
                            },
                            {
                                "start": 656,
                                "end": 825
                            },
                            {
                                "start": 826,
                                "end": 914
                            },
                            {
                                "start": 915,
                                "end": 1016
                            },
                            {
                                "start": 1017,
                                "end": 1107
                            },
                            {
                                "start": 1108,
                                "end": 1191
                            },
                            {
                                "start": 1192,
                                "end": 1337
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator."
                    }
                ]
            },
            {
                "idx": 32,
                "key": "[86787308 | Hamzabegovic | 2019 | Citations: 0]",
                "snippets": "Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools.",
                "model": "claude-3-7-sonnet-20250219",
                "inline_citations": {},
                "metadata": [
                    {
                        "section_title": "Visual programming and parametrization",
                        "pdf_hash": "",
                        "start": 749,
                        "end": 1062,
                        "sentence_offsets": [
                            {
                                "start": 749,
                                "end": 1062
                            }
                        ],
                        "ref_mentions": [],
                        "quote": "Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools."
                    }
                ]
            }
        ]
    },
    "cluster": {
        "cost": 0.030954,
        "cot": "For this query about visual programming languages (VPLs) and their categories, I need to create dimensions that will clearly explain the different types of VPLs and how they differ from each other.\n\nFirst, I'll need an introduction/background section to explain what visual programming languages are in general, their purpose, and basic characteristics. This will set the stage for the more specific categories that follow.\n\nAfter analyzing the quotes, I can see several main categories of VPLs mentioned repeatedly:\n1. Block-based languages - mentioned in many quotes as using puzzle-like pieces that snap together\n2. Node/diagram/flow-based languages - mentioned as using boxes/nodes connected by arrows or lines\n3. Form-based languages - mentioned in several quotes\n4. Icon-based languages - mentioned in a few quotes\n\nAdditionally, I need dimensions that address:\n5. Characteristics and differences between categories - to address the \"how do they differ\" part of the query\n6. Examples of VPLs - to provide concrete instances of each category\n\nFor format choices:\n- \"Introduction to Visual Programming Languages\" should be synthesis format to provide a coherent explanation of what VPLs are\n- \"Block-based Visual Programming Languages\" should be synthesis to explain this important category comprehensively\n- \"Node/Diagram/Flow-based Visual Programming Languages\" should be synthesis to explain this important category\n- \"Form-based Visual Programming Languages\" should be synthesis as it's less prominent but still important\n- \"Icon-based Visual Programming Languages\" should be synthesis as it's mentioned in fewer quotes\n- \"Characteristics and Differences Between VPL Categories\" should be synthesis to coherently compare the categories\n- \"Examples of Visual Programming Languages\" should be a list format to clearly present specific VPL examples by category\n\nThis organization will allow me to comprehensively address the query about VPL categories and their differences in a structured way.",
        "plan": {
            "Introduction to Visual Programming Languages (synthesis)": [
                0,
                1,
                2,
                4,
                5,
                6,
                14,
                25
            ],
            "Block-based Visual Programming Languages (synthesis)": [
                2,
                3,
                6,
                8,
                9,
                10,
                11,
                12,
                14,
                16,
                18,
                20,
                21,
                23,
                24,
                26,
                28
            ],
            "Node/Diagram/Flow-based Visual Programming Languages (synthesis)": [
                3,
                8,
                11,
                15,
                17,
                19,
                21,
                26,
                29,
                30,
                31
            ],
            "Form-based Visual Programming Languages (synthesis)": [
                8,
                13,
                29
            ],
            "Icon-based Visual Programming Languages (synthesis)": [
                8,
                10,
                13
            ],
            "Other Visual Programming Language Categories (synthesis)": [
                13,
                22,
                29,
                32
            ],
            "Characteristics and Differences Between VPL Categories (synthesis)": [
                7,
                8,
                15,
                17,
                19,
                27,
                29
            ],
            "Examples of Visual Programming Languages (list)": [
                6,
                11,
                12,
                14,
                16,
                19,
                24,
                26,
                30
            ]
        },
        "model": "claude-3-7-sonnet-20250219"
    },
    "summary": {
        "sections": [
            {
                "title": "Introduction to Visual Programming Languages",
                "tldr": "Visual Programming Languages (VPLs) allow users to create programs by manipulating graphical elements rather than writing textual code. They use various visual representations such as blocks, diagrams, icons, and spatial arrangements to make programming more accessible, especially for novices. (9 sources)",
                "text": "\nVisual Programming Languages (VPLs) represent a departure from traditional text-based programming by enabling users to develop programs through graphical manipulation rather than textual specification <Paper corpusId=\"15820022\" paperTitle=\"(Bellucci et al., 2017)\" isShortName></Paper> <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper>. In a foundational definition from 1990, Myers described visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion\" and distinguished it from program visualization, where graphics are used to visualize the execution of text-based programs <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper>. This multidimensional approach utilizes spatial associations and time-based dimensions to describe semantic relationships between programming elements <Paper corpusId=\"20991852\" paperTitle=\"(Kahanwal, 2013)\" isShortName></Paper>.\n\nVPLs are characterized by several key features, including the ability to drag blocks around the screen, construct flow diagrams, wire different blocks together, and use icons or other non-textual representations <Paper corpusId=\"116768063\" paperTitle=\"(Ariza, 2019)\" isShortName></Paper>. Unlike traditional programming, where code is written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements <Paper corpusId=\"268272915\" paperTitle=\"(Kodytek et al., 2024)\" isShortName></Paper>. This approach makes programming more accessible, particularly for novices, by lowering barriers to entry.\n\nBlock-based programming has emerged as one of the most prominent forms of visual programming. In these environments, users select appropriate blocks of code and snap them together to create programs <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper>. A significant milestone in this field was the introduction of blocks programming by AgentSheets in 1995, which marked a substantial advancement in visual programming languages <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper> <Paper corpusId=\"41867280\" paperTitle=\"(Repenning, 2017)\" isShortName></Paper>. This approach has since been adopted by popular environments such as Scratch and Blockly, which incorporated key properties from AgentSheets to become widely used block programming languages <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper>.\n\nWhen discussing software construction using non-textual methods, two primary approaches exist: Visual Programming Languages (VPL) and Visual Programming Interfaces (VPI). While VPLs involve program specification through graphical artifact manipulation, VPIs don't completely eliminate textual programming but offer graphical interfaces that generate code automatically <Paper corpusId=\"238126162\" paperTitle=\"(Lutalo et al., 2020)\" isShortName></Paper> <Paper corpusId=\"4039308\" paperTitle=\"(Noone et al., 2017)\" isShortName></Paper>. Notable examples of VPLs include RAPTOR (a flowchart-based VPL), Alice, and Scratch, where programs themselves can be considered executable graphical artifacts <Paper corpusId=\"238126162\" paperTitle=\"(Lutalo et al., 2020)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Bellucci et al., 2017)",
                        "snippets": [
                            "Relevant for this research is visual programming, which allow end-users to create programs by manipulating graphic elements rather than by textual specification (Myers, 1986) and programming-by-demonstration, in which \"users provide example interactions and the system infers a routine from them\" without requiring textual programming (Lieberman et al., 2006) (p. 3)."
                        ],
                        "paper": {
                            "corpus_id": 15820022,
                            "title": "ECCE Toolkit: Prototyping Sensor-Based Interaction",
                            "authors": [
                                {
                                    "authorId": "145582592",
                                    "name": "Andrea Bellucci"
                                },
                                {
                                    "authorId": "1708076",
                                    "name": "I. Aedo"
                                },
                                {
                                    "authorId": "145429731",
                                    "name": "P. D\u00edaz"
                                }
                            ],
                            "year": 2017,
                            "venue": "Italian National Conference on Sensors",
                            "n_citations": 9
                        },
                        "score": 0.87548828125
                    },
                    {
                        "id": "(Alturayeif et al., 2020)",
                        "snippets": [
                            "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text",
                            "There is a rich history of different visual programming tools designed for novices comprehensively surveyed in (Lye et al., 2014). AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language (Repenning, 2017). Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch (Repenning, 2017)",
                            "Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets (Repenning, 2017). According to (Repenning, 2017), Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language."
                        ],
                        "paper": {
                            "corpus_id": 221340525,
                            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                            "authors": [
                                {
                                    "authorId": "2315312012",
                                    "name": "Nora S. Alturayeif"
                                },
                                {
                                    "authorId": "2023398349",
                                    "name": "Nouf Alturaief"
                                },
                                {
                                    "authorId": "2023401654",
                                    "name": "Zainab Alhathloul"
                                }
                            ],
                            "year": 2020,
                            "venue": "International Journal of Advanced Computer Science and Applications",
                            "n_citations": 19
                        },
                        "score": 0.9208984375
                    },
                    {
                        "id": "(Joao et al., 2019)",
                        "snippets": [
                            "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program (Cheng, 2019). In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming (Lye et al., 2014). Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together (Weintrop et al., 2018)."
                        ],
                        "paper": {
                            "corpus_id": 199002134,
                            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
                            "authors": [
                                {
                                    "authorId": "2157028104",
                                    "name": "Piedade Jo\u00e3o"
                                },
                                {
                                    "authorId": "72582337",
                                    "name": "Dorotea Nuno"
                                },
                                {
                                    "authorId": "2157024771",
                                    "name": "Sampaio Ferrentini F\u00e1bio"
                                },
                                {
                                    "authorId": "144370033",
                                    "name": "P. ana"
                                }
                            ],
                            "year": 2019,
                            "venue": "Education sciences",
                            "n_citations": 23
                        },
                        "score": 0.94384765625
                    },
                    {
                        "id": "(Kahanwal, 2013)",
                        "snippets": [
                            "Visual programming language (VPL): So many dimensions are utilized here to describe the semantics. Such type of added dimensions uses the multi-dimensional objects, the spatial associations are utilized, or the time based dimensions are utilized to describe the \"before-after\" semantic associations. All these multi-dimensional objects or associations are the tokens and the collection these tokens are the visually based expressions. The visual expressions utilized in these may have a diagram, a free-hand sketch, an icon, or revelation of actions achieved by graphical objects. Where the visual expressions are involved, those are called the visual programming languages. These are also know as the object-based programming languages."
                        ],
                        "paper": {
                            "corpus_id": 20991852,
                            "title": "Abstraction Level Taxonomy of Programming Language Frameworks",
                            "authors": [
                                {
                                    "authorId": "2145585",
                                    "name": "Brijender Kahanwal"
                                }
                            ],
                            "year": 2013,
                            "venue": "arXiv.org",
                            "n_citations": 9
                        },
                        "score": 0.91845703125
                    },
                    {
                        "id": "(Ariza, 2019)",
                        "snippets": [
                            "Several features identify Visual Programming Languages (VPL), e.g., drag blocks around the screen, flow diagrams or any mechanism for wiring different blocks and using icons or non-text representations."
                        ],
                        "paper": {
                            "corpus_id": 116768063,
                            "title": "DSCBlocks: An Open-Source Platform for Learning Embedded Systems Based on Algorithm Visualizations and Digital Signal Controllers",
                            "authors": [
                                {
                                    "authorId": "102148671",
                                    "name": "Jonathan \u00c1lvarez Ariza"
                                }
                            ],
                            "year": 2019,
                            "venue": "Electronics",
                            "n_citations": 7
                        },
                        "score": 0.896484375
                    },
                    {
                        "id": "(Kodytek et al., 2024)",
                        "snippets": [
                            "Graphical programming refers to a category of programming languages that use visual representations, such as icons, symbols, diagrams, or other graphical elements, to facilitate the design and creation of software applications. Unlike traditional text-based programming languages, where the code, i.e., textual commands, are written in text editors or integrated development environments, graphical programming allows users to interactively create programs by manipulating and connecting graphical elements."
                        ],
                        "paper": {
                            "corpus_id": 268272915,
                            "title": "Automated code development based on genetic programming in graphical programming language: A pilot study",
                            "authors": [
                                {
                                    "authorId": "100971028",
                                    "name": "Pavel Kodytek"
                                },
                                {
                                    "authorId": "1910708525",
                                    "name": "Alexandra Bodzas"
                                },
                                {
                                    "authorId": "2290253497",
                                    "name": "Jan Zidek"
                                }
                            ],
                            "year": 2024,
                            "venue": "PLoS ONE",
                            "n_citations": 1
                        },
                        "score": 0.9091796875
                    },
                    {
                        "id": "(Repenning, 2017)",
                        "snippets": [
                            "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                        ],
                        "paper": {
                            "corpus_id": 41867280,
                            "title": "Moving Beyond Syntax: Lessons from 20 Years of Blocks Programing in AgentSheets",
                            "authors": [
                                {
                                    "authorId": "1782080",
                                    "name": "A. Repenning"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Visual Languages and Sentient Systems",
                            "n_citations": 50
                        },
                        "score": 0
                    },
                    {
                        "id": "(Lutalo et al., 2020)",
                        "snippets": [
                            "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts.\n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13].\n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages."
                        ],
                        "paper": {
                            "corpus_id": 238126162,
                            "title": "DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology",
                            "authors": [
                                {
                                    "authorId": "2007576185",
                                    "name": "Joseph Willrich Lutalo"
                                },
                                {
                                    "authorId": "2041303630",
                                    "name": "Odongo Steven Eyobu"
                                },
                                {
                                    "authorId": "1774407",
                                    "name": "Benjamin Kanagwa"
                                }
                            ],
                            "year": 2020,
                            "venue": "",
                            "n_citations": 0
                        },
                        "score": 0.931640625
                    },
                    {
                        "id": "(Noone et al., 2017)",
                        "snippets": [
                            "It is well documented and has been the topic of much research as well that Computer Science courses tend to have higher than average drop-out rates at third level, particularly so, for students advancing from first year to second year. This is a problem that needs to be addressed not only with urgency but also with caution. The required number of Computer Science graduates is growing every year, but the number of graduates is not meeting this demand, and one way that this problem can be alleviated is to encourage students, at an early age, towards studying Computer Science courses. This paper presents a systematic literature review that examines the role of visual and textual programming languages when learning to program, particularly as a First Programming Language. The approach is systematic in that a structured search of electronic resources has been conducted, and the results are presented and quantitatively analysed. This study will provide insight into whether or not the current approaches to teaching young learners programming are viable, and examines what we can do to increase the interest and retention of these students as they progress through their education."
                        ],
                        "paper": {
                            "corpus_id": 4039308,
                            "title": "Visual and textual programming languages: a systematic review of the literature",
                            "authors": [
                                {
                                    "authorId": "2056455701",
                                    "name": "Mark Noone"
                                },
                                {
                                    "authorId": "12733217",
                                    "name": "Aidan Mooney"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Computers in Education",
                            "n_citations": 95
                        },
                        "score": 0
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Block-based Visual Programming Languages",
                "tldr": "Block-based visual programming languages use interlocking, puzzle-like blocks that can be dragged and dropped to create programs, preventing syntax errors while visually representing programming structures. Blocks typically have distinctive shapes, colors, and connectors that provide visual cues about how program elements can be combined to create syntactically valid code. (12 sources)",
                "text": "\nBlock-based programming is one of the most prominent forms of visual programming languages (VPLs), allowing users to create programs by dragging and dropping predefined \"blocks\" into a development area and connecting them together like puzzle pieces <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper>. This approach was pioneered by AgentSheets in 1995, marking a substantial step forward in the field of visual programming languages <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper> <Paper corpusId=\"41867280\" paperTitle=\"(Repenning, 2017)\" isShortName></Paper>.\n\nIn block-based environments, blocks represent the atomic conceptual elements of a programming language and are typically organized into colored categories that help users identify and select appropriate blocks <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper> <Paper corpusId=\"253049931\" paperTitle=\"(Mayr-Dorn et al., 2022)\" isShortName></Paper>. These blocks have characteristic shapes with dents or nobs (following the puzzle piece metaphor) that provide visual cues about which blocks can connect with each other <Paper corpusId=\"253049931\" paperTitle=\"(Mayr-Dorn et al., 2022)\" isShortName></Paper>. If two blocks cannot form a valid syntactic statement, the interface prevents them from snapping together, thereby eliminating syntax errors <Paper corpusId=\"199002134\" paperTitle=\"(Joao et al., 2019)\" isShortName></Paper> <Paper corpusId=\"259335765\" paperTitle=\"(DeLozier et al., 2023)\" isShortName></Paper>.\n\nBlocks in these languages can be categorized into different types based on their function:\n1. Holders or control structures (loops, conditionals)\n2. Task execution blocks that perform specific actions\n3. Result-returning blocks used in conditions for control blocks <Paper corpusId=\"4793447\" paperTitle=\"(Vithana et al., 2017)\" isShortName></Paper>\n\nThe visual representation in block-based languages often uses color-coding to signify functionality, such as yellow for actions and green for sensor usage <Paper corpusId=\"232029733\" paperTitle=\"(Dragule et al., 2021)\" isShortName></Paper>. Most block-based environments also include descriptive text and/or icons within blocks, as well as editable fields to allow users to provide additional input <Paper corpusId=\"253049931\" paperTitle=\"(Mayr-Dorn et al., 2022)\" isShortName></Paper>.\n\nBlock-based programming has become particularly valuable for education, as it lowers barriers to entry by allowing users to focus on programming concepts rather than implementation details or syntax <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper> <Paper corpusId=\"259335765\" paperTitle=\"(DeLozier et al., 2023)\" isShortName></Paper>. This paradigm has proven effective for teaching programming across various age groups, from preschool to college <Paper corpusId=\"259335765\" paperTitle=\"(DeLozier et al., 2023)\" isShortName></Paper> <Paper corpusId=\"235383033\" paperTitle=\"(Papadakis, 2021)\" isShortName></Paper> <Paper corpusId=\"253196672\" paperTitle=\"(Timur et al., 2021)\" isShortName></Paper>.\n\nProminent block-based programming environments include Scratch, Blockly, and App Inventor, which adopted key properties from AgentSheets to become widely used programming tools <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper> <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper> <Paper corpusId=\"264306865\" paperTitle=\"(Avishahar-Zeira et al., 2023)\" isShortName></Paper>. These platforms form part of the second major paradigm for Visual Programming Interfaces, which utilizes block-based function representations and allows users to create programs by connecting compatible components <Paper corpusId=\"269747039\" paperTitle=\"(Lin et al., 2023)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Joao et al., 2019)",
                        "snippets": [
                            "In 1990, Myers (Myers, 1990) defined visual programming as \"any system that allows the user to specify a program in a two (or more) dimensional fashion (p. 2)\" and visual languages as \"all systems that use graphics, including visual programming and program visualization systems (p. 3)\". According to Myers's perspective, in 'visual programming' applications, the graphics are used to create the programs, and in 'program visualization applications', the program is created in the traditional text-based way and the graphics are used to visualize the program execution and outputs. In this paper, we understand VPE to be a block-based or visual text-based or hybrid (block + text) programming environment, where the focus is on the core characteristics of each environment in order to improve the pupils\u00b4learning. \n\nBlock-based programming is one form of visual programming and refers to a software or application where pupils can select the appropriate blocks of code and snap them together to create a program (Cheng, 2019). In this kind of introductory programming tool, blocks of coding are organized in coloured categories that can help pupils understand how to select the correct block, thus lowering some barriers to programming (Lye et al., 2014). Programming in these environments takes the form of drag-and-drop blocks that can be snapped together to create programs; if two blocks cannot be joined to form a valid syntactic statement, the interface prevents them from snapping together (Weintrop et al., 2018)."
                        ],
                        "paper": {
                            "corpus_id": 199002134,
                            "title": "A Cross-analysis of Block-based and Visual Programming Apps with Computer Science Student-Teachers",
                            "authors": [
                                {
                                    "authorId": "2157028104",
                                    "name": "Piedade Jo\u00e3o"
                                },
                                {
                                    "authorId": "72582337",
                                    "name": "Dorotea Nuno"
                                },
                                {
                                    "authorId": "2157024771",
                                    "name": "Sampaio Ferrentini F\u00e1bio"
                                },
                                {
                                    "authorId": "144370033",
                                    "name": "P. ana"
                                }
                            ],
                            "year": 2019,
                            "venue": "Education sciences",
                            "n_citations": 23
                        },
                        "score": 0.94384765625
                    },
                    {
                        "id": "(Alturayeif et al., 2020)",
                        "snippets": [
                            "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text",
                            "There is a rich history of different visual programming tools designed for novices comprehensively surveyed in (Lye et al., 2014). AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language (Repenning, 2017). Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch (Repenning, 2017)",
                            "Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets (Repenning, 2017). According to (Repenning, 2017), Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language."
                        ],
                        "paper": {
                            "corpus_id": 221340525,
                            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                            "authors": [
                                {
                                    "authorId": "2315312012",
                                    "name": "Nora S. Alturayeif"
                                },
                                {
                                    "authorId": "2023398349",
                                    "name": "Nouf Alturaief"
                                },
                                {
                                    "authorId": "2023401654",
                                    "name": "Zainab Alhathloul"
                                }
                            ],
                            "year": 2020,
                            "venue": "International Journal of Advanced Computer Science and Applications",
                            "n_citations": 19
                        },
                        "score": 0.9208984375
                    },
                    {
                        "id": "(Repenning, 2017)",
                        "snippets": [
                            "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                        ],
                        "paper": {
                            "corpus_id": 41867280,
                            "title": "Moving Beyond Syntax: Lessons from 20 Years of Blocks Programing in AgentSheets",
                            "authors": [
                                {
                                    "authorId": "1782080",
                                    "name": "A. Repenning"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Visual Languages and Sentient Systems",
                            "n_citations": 50
                        },
                        "score": 0
                    },
                    {
                        "id": "(Mayr-Dorn et al., 2022)",
                        "snippets": [
                            "A block-based programming language is a type of visual programming language. It uses blocks to represent statements, i.e. the atomic conceptual elements of a programming language, in contrast to text-based languages where statements are mapped to words. Usually, an instruction is expressed by a block representation that has a specific shape and color-code related to its type. Blocks also contain a describing text and/or an icon as well as optional editable fields to allow users to provide additional input. Most blocks have characteristic dents or nobs (following the metaphor of puzzle pieces) that provide visual clues to the user about where matching blocks can be connected to combine elements to syntactically correct programs. Furthermore, the resulting programs appear as larger blocks themselves, containing groups of aligned (nested) blocks from which they are compiled."
                        ],
                        "paper": {
                            "corpus_id": 253049931,
                            "title": "Assessing industrial end-user programming of robotic production cells: A controlled experiment",
                            "authors": [
                                {
                                    "authorId": "1412106655",
                                    "name": "Christoph Mayr-Dorn"
                                },
                                {
                                    "authorId": "39590163",
                                    "name": "M. Winterer"
                                },
                                {
                                    "authorId": "153704508",
                                    "name": "Christian Salomon"
                                },
                                {
                                    "authorId": "2120343508",
                                    "name": "Doris Hohensinger"
                                },
                                {
                                    "authorId": "1730456",
                                    "name": "Harald F\u00fcrschu\u00df"
                                }
                            ],
                            "year": 2022,
                            "venue": "Journal of Systems and Software",
                            "n_citations": 3
                        },
                        "score": 0.94677734375
                    },
                    {
                        "id": "(DeLozier et al., 2023)",
                        "snippets": [
                            "Visual block-based programming is an effective way to introduce programming. It is used at all levels of introductory programming from preschool (Timur et al., 2021)(Papadakis, 2021), to high school (Weintrop et al., 2017), to college (Urness et al., 2011). The wide range of ages and skill levels highlights the flexibility of visual programmin g. Visual block-based programming lowers the initial entry hurdles of many conventional programming languages using drag-and-drop puzzle blocks [11]. These languages appeal to novice programmers as they are often browser-based and do not require the installation of tools. Additionally, these programming languages use visual cues, such as puzzle tabs, to indicate to the programmer how blocks can be connected together. This allows blocks to only be connected in particular ways and prevents syntax errors (Weintrop et al., 2018)."
                        ],
                        "paper": {
                            "corpus_id": 259335765,
                            "title": "Using Visual Programming Games to Study Novice Programmers",
                            "authors": [
                                {
                                    "authorId": "39722092",
                                    "name": "Christian DeLozier"
                                },
                                {
                                    "authorId": "38203562",
                                    "name": "James Shey"
                                }
                            ],
                            "year": 2023,
                            "venue": "Int. J. Serious Games",
                            "n_citations": 6
                        },
                        "score": 0.91162109375
                    },
                    {
                        "id": "(Vithana et al., 2017)",
                        "snippets": [
                            "These blocks can be divided into three categories. One category is holders that represent programming structures. These include single task blocks, blocks with a task and terminating condition, loops and conditional blocks. They alone do not result in any useful output but need to be utilized in the process of creating a program combining the other two types of programming blocks. These can be even nested when required. The second category is the programming blocks that represent the execution of a task. Each task that the modules are capable of doing, but do not return a result results in this type of a block. The third category is the blocks that request the modules to return a result with or without doing a specific task. These are the blocks that are used in conditions for control blocks."
                        ],
                        "paper": {
                            "corpus_id": 4793447,
                            "title": "Extensible Visual Programming Model for Modular Systems Targeting Novices",
                            "authors": [
                                {
                                    "authorId": "9346844",
                                    "name": "Yasura Vithana"
                                },
                                {
                                    "authorId": "40894841",
                                    "name": "Hashini Senaratne"
                                }
                            ],
                            "year": 2017,
                            "venue": "British Computer Society Conference on Human-Computer Interaction",
                            "n_citations": 0
                        },
                        "score": 0.94091796875
                    },
                    {
                        "id": "(Dragule et al., 2021)",
                        "snippets": [
                            "Block-based languages use visual blocks to represent the language syntax. Such blocks have various shapes and colors for the various language constructs. Typically, the block shapes visualize constraints, e.g., where, in the mission specification the language concept represented by the block can be used. Block colors often depict a particular kind of functionality, such as yellow for actions and green for sensor usages, as seen in the environment Open Roberta [45]."
                        ],
                        "paper": {
                            "corpus_id": 232029733,
                            "title": "A survey on the design space of end-user-oriented languages for specifying robotic missions",
                            "authors": [
                                {
                                    "authorId": "23203814",
                                    "name": "Swaib Dragule"
                                },
                                {
                                    "authorId": "39565422",
                                    "name": "T. Berger"
                                },
                                {
                                    "authorId": "144341567",
                                    "name": "C. Menghi"
                                },
                                {
                                    "authorId": "2909166",
                                    "name": "Patrizio Pelliccione"
                                }
                            ],
                            "year": 2021,
                            "venue": "Journal of Software and Systems Modeling",
                            "n_citations": 15
                        },
                        "score": 0.90234375
                    },
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9921875
                    },
                    {
                        "id": "(Papadakis, 2021)",
                        "snippets": [
                            "Data that shows that young children can learn and acquire Computational Thinking (CT) skills has led governments and policymakers internationally to integrate CT into the curriculum, starting in the earliest grades. Researchers support the idea that this introduction must not solely focus on a problem-solving process skill (CT) but instead provide children with new ways to express themselves, supporting their cognitive, language, and socio-emotional development (Computational Fluency-CF). Coupled with the media and government\u2019s rhetoric and an increasing number of apps offering various programming lessons, puzzles, and challenges, educators have been responsible for introducing young children to CT and CF using touchscreen technology. This paper presents a literature review (N = 21) of empirical studies on applying four coding apps to support young children\u2019s learning of CT and CF. The main conclusion is that all apps positively affect the development of children\u2019s CT skills. None of the apps can ultimately support the development of CF, although ScratchJr, with a \"sandbox\" approach, can better help students express themselves."
                        ],
                        "paper": {
                            "corpus_id": 235383033,
                            "title": "The Impact of Coding Apps to Support Young Children in Computational Thinking and Computational Fluency. A Literature Review",
                            "authors": [
                                {
                                    "authorId": "31818512",
                                    "name": "Stamatis Papadakis"
                                }
                            ],
                            "year": 2021,
                            "venue": "Frontiers in Education",
                            "n_citations": 90
                        },
                        "score": 0
                    },
                    {
                        "id": "(Timur et al., 2021)",
                        "snippets": [
                            "\"Abstract: In this study, it was aimed to examine the pre-service pre-school teachers\u2019 opinions about using block-based coding/Scratch in education. 28 pre-service pre-school teachers were participated studying at a public university in a Marmara province region. Within the scope of the study, pre-service teachers were trained on the block-based coding Scratch program for four weeks. A semi-structured interview form consisting of 12 questions was used to determine the opinions of the participants. The data of the study were analyzed using the descriptive analysis method. As a result of the study, 85.71% of pre-school teacher candidates stated that block-based coding education should start at an early age like a language education, this education is important as a necessity of the technology age and all students should benefit from this education in order to provide an effective education, 14.25% of teacher candidates specified that this education is untimely for younger age levels and should not be given to everyone. In addition, the pre-service teachers stated that the block-based coding/Scratch program training helped them gain new ideas in terms of creating materials, improved their creativity and contributed to design abstract material in addition to concrete ones. Additionally, 46.42% of pre-service teachers stated that block-based coding education should start between the ages of 5-7. In this context, it is recommended to provide coding education both in pre-school and undergraduate education.\""
                        ],
                        "paper": {
                            "corpus_id": 253196672,
                            "title": "Pre-service pre-school teachers' opinions about using block-based coding/scratch",
                            "authors": [
                                {
                                    "authorId": "2057521942",
                                    "name": "Serkan Timur"
                                },
                                {
                                    "authorId": "70546556",
                                    "name": "Bet\u00fcl Timur"
                                },
                                {
                                    "authorId": "2129327879",
                                    "name": "Elif G\u00fcven\u00e7"
                                },
                                {
                                    "authorId": "2189176196",
                                    "name": "\u0130lknur Us"
                                },
                                {
                                    "authorId": "1712266999",
                                    "name": "Eylem Yal\u00e7\u0131nkaya-\u00d6nder"
                                }
                            ],
                            "year": 2021,
                            "venue": "Acta Didactica Napocensia",
                            "n_citations": 6
                        },
                        "score": 0
                    },
                    {
                        "id": "(Avishahar-Zeira et al., 2023)",
                        "snippets": [
                            "Both No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code.\n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code."
                        ],
                        "paper": {
                            "corpus_id": 264306865,
                            "title": "Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers",
                            "authors": [
                                {
                                    "authorId": "2260344112",
                                    "name": "Assaf Avishahar-Zeira"
                                },
                                {
                                    "authorId": "2260344780",
                                    "name": "David H. Lorenz"
                                }
                            ],
                            "year": 2023,
                            "venue": "SIGPLAN symposium on New ideas, new paradigms, and reflections on programming and software",
                            "n_citations": 4
                        },
                        "score": 0.88671875
                    },
                    {
                        "id": "(Lin et al., 2023)",
                        "snippets": [
                            "There are primarily two main paradigms for VPIs. The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph. Pioneering work in this area includes Prograph [17] and LabVIEW [27]. The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together. Notable works in this area include Scratch [35] and Blockly [19]."
                        ],
                        "paper": {
                            "corpus_id": 269747039,
                            "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
                            "authors": [
                                {
                                    "authorId": "2106412318",
                                    "name": "David Chuan-En Lin"
                                },
                                {
                                    "authorId": "3111790",
                                    "name": "Nikolas Martelaro"
                                }
                            ],
                            "year": 2023,
                            "venue": "International Conference on Human Factors in Computing Systems",
                            "n_citations": 18
                        },
                        "score": 0.95263671875
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Node/Diagram/Flow-based Visual Programming Languages",
                "tldr": "Node/diagram/flow-based visual programming languages represent programs as directed graphs where nodes (typically boxes or other graphical objects) perform operations and are connected by arrows or lines that show data or control flow. These languages are particularly suited for representing data transformations, parallel processing, and system architecture. (10 sources)",
                "text": "\nNode-based visual programming languages, also known as diagram-based or flow-based languages, represent program structures and data flow using logical nodes linked with edges that reflect their correlation <Paper corpusId=\"202566030\" paperTitle=\"(Zikas et al., 2019)\" isShortName></Paper>. The resulting structure typically resembles a directed graph that provides users with a visual overview of data and program flow <Paper corpusId=\"202566030\" paperTitle=\"(Zikas et al., 2019)\" isShortName></Paper>. In these languages, boxes or other graphical objects are treated as entities, connected by arrows, lines, or arcs that represent relations between them <Paper corpusId=\"236336244\" paperTitle=\"(Daskalov et al., 2021)\" isShortName></Paper>.\n\nDiagram-based VPLs (also referred to as diagrammatic or data flow languages) are characterized by connecting graphical objects (e.g., boxes) using arrows, lines, or arcs that represent relationships <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. To understand a diagram-based program, users traverse the diagram, which uses different means of perceptual coding to represent the program's flow <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. These languages constitute one of the two prominent domain-independent visual representations, alongside block-based languages, where boxes represent instructions in the program and arrows between boxes represent how data and control flows between instructions <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>.\n\nIn the flow-based paradigm, models are created by joining different nodes and graphic lines representing data flow or transitions between different states <Paper corpusId=\"253043422\" paperTitle=\"(Baena-Perez et al., 2022)\" isShortName></Paper>. Notable examples in this category include BPMN, PetriNet, DRAKON, and UML activity diagrams <Paper corpusId=\"253043422\" paperTitle=\"(Baena-Perez et al., 2022)\" isShortName></Paper>. Node-based editing, exemplified by tools like Grasshopper, enables users to control the data flow through nodes and wires <Paper corpusId=\"258217657\" paperTitle=\"(Jiang, 2023)\" isShortName></Paper>.\n\nThe dataflow paradigm, one of the two main paradigms for Visual Programming Interfaces (VPIs), lets users specify how a program transforms data from step to step by connecting nodes in a directed graph <Paper corpusId=\"269747039\" paperTitle=\"(Lin et al., 2023)\" isShortName></Paper>. Pioneering work in this area includes Prograph and LabVIEW <Paper corpusId=\"269747039\" paperTitle=\"(Lin et al., 2023)\" isShortName></Paper>. According to Dias et al., graph-based approaches are among the most disseminated VPL development approaches, leveraging the metaphor of visual graphs with nodes and connections <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nSeveral subcategories exist within the node/diagram/flow-based paradigm:\n\n1. Data-flow languages: Computation is specified through graphs consisting of icons or similar visual representations that correspond to operational nodes, with lines connecting these nodes representing the flow of data between them <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\n2. Component-based languages: Based on the metaphor of networked computing devices or components, each component can perform various tasks in response to messages and data received from others <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\n3. Rule-based languages: These are based on the definition of triggering actions that happen upon changes, usually through visual if-then rules <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nSome visual programming environments combine aspects of both block-based and node-based approaches. For example, VPL (Visual Programming Language) for the Thymio robot uses event-action pairs represented by blocks, while the graphical software environment for the Dash robot uses events and actions represented by nodes and arrows between nodes <Paper corpusId=\"64771513\" paperTitle=\"(Ben-Ari et al., 2018)\" isShortName></Paper>. Similarly, Mosaicode uses a block metaphor where blocks have input/output ports, and connections between ports create a diagram\u2014resembling the node-based approach but generating code rather than being an interpreted environment like Pure Data or Max/MSP <Paper corpusId=\"67344764\" paperTitle=\"(Schiavoni et al., 2018)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Zikas et al., 2019)",
                        "snippets": [
                            "Visual programming is getting more publicity as more platforms and tools are emerging to enlarge the community. We can separate them into two categories according to their visual appearance and basic functionalities: a) block-based and b) node-based scripting languages Block-based visual languages consist of modular blocks that represent fundamental programming utilities (if else, while, for loops etc.) or even custom prototypes that describe more complex functionalities",
                            "On the other hand, node-based visual languages, represent structures and data flow using logical nodes linked with edges reflecting their correlation. The resulting structure looks like a directed graph that provides users with a visual overview of important data and program flow."
                        ],
                        "paper": {
                            "corpus_id": 202566030,
                            "title": "Scenior: An Immersive Visual Scripting system of Gamified Training based on VR Software Design Patterns",
                            "authors": [
                                {
                                    "authorId": "3419237",
                                    "name": "Paul Zikas"
                                },
                                {
                                    "authorId": "1388001839",
                                    "name": "Nick Lydatakis"
                                },
                                {
                                    "authorId": "19309698",
                                    "name": "Steve Kateros"
                                },
                                {
                                    "authorId": "2896538",
                                    "name": "G. Papagiannakis"
                                }
                            ],
                            "year": 2019,
                            "venue": "arXiv.org",
                            "n_citations": 1
                        },
                        "score": 0.9775390625
                    },
                    {
                        "id": "(Daskalov et al., 2021)",
                        "snippets": [
                            "Many VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations",
                            "Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding."
                        ],
                        "paper": {
                            "corpus_id": 236336244,
                            "title": "Hybrid Visual Programming Language Environment for Programming Training",
                            "authors": [
                                {
                                    "authorId": "2666781",
                                    "name": "R. Daskalov"
                                },
                                {
                                    "authorId": "94696738",
                                    "name": "G. Pashev"
                                },
                                {
                                    "authorId": "2299512",
                                    "name": "Silvia N. Gaftandzhieva"
                                }
                            ],
                            "year": 2021,
                            "venue": "TEM Journal",
                            "n_citations": 2
                        },
                        "score": 0.92236328125
                    },
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9921875
                    },
                    {
                        "id": "(Hirzel, 2022)",
                        "snippets": [
                            "Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions."
                        ],
                        "paper": {
                            "corpus_id": 248524774,
                            "title": "Low-Code Programming Models",
                            "authors": [
                                {
                                    "authorId": "1728836",
                                    "name": "Martin Hirzel"
                                }
                            ],
                            "year": 2022,
                            "venue": "Communications of the ACM",
                            "n_citations": 21
                        },
                        "score": 0.9423828125
                    },
                    {
                        "id": "(Baena-Perez et al., 2022)",
                        "snippets": [
                            "VPLs can be classified into two categories: imperative languages and flow-based languages (Mason et al., 2017). With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others (Garc\u00eda-Borgo\u00f1\u00f3n et al., 2014)."
                        ],
                        "paper": {
                            "corpus_id": 253043422,
                            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
                            "authors": [
                                {
                                    "authorId": "1411449483",
                                    "name": "Rub\u00e9n Baena-P\u00e9rez"
                                },
                                {
                                    "authorId": "1409150721",
                                    "name": "Iv\u00e1n Ruiz-Rube"
                                },
                                {
                                    "authorId": "32483651",
                                    "name": "Jos\u00e9 Miguel Mota"
                                },
                                {
                                    "authorId": "49031811",
                                    "name": "Anke Berns"
                                },
                                {
                                    "authorId": "144050001",
                                    "name": "Antonio Balderas"
                                }
                            ],
                            "year": 2022,
                            "venue": "Universal Access in the Information Society",
                            "n_citations": 3
                        },
                        "score": 0.958984375
                    },
                    {
                        "id": "(Jiang, 2023)",
                        "snippets": [
                            "Visual programming languages typically employ one of two popular design approaches \u2014 block-based editing (e.g. Scratch), which allows users to control the execution order of code blocks, and node-based editing (e.g. Grasshopper), which enables users to control the data flow through nodes and wires."
                        ],
                        "paper": {
                            "corpus_id": 258217657,
                            "title": "Positional Control in Node-Based Programming",
                            "authors": [
                                {
                                    "authorId": "2061281840",
                                    "name": "Peiling Jiang"
                                }
                            ],
                            "year": 2023,
                            "venue": "CHI Extended Abstracts",
                            "n_citations": 4
                        },
                        "score": 0.94921875
                    },
                    {
                        "id": "(Lin et al., 2023)",
                        "snippets": [
                            "There are primarily two main paradigms for VPIs. The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph. Pioneering work in this area includes Prograph [17] and LabVIEW [27]. The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together. Notable works in this area include Scratch [35] and Blockly [19]."
                        ],
                        "paper": {
                            "corpus_id": 269747039,
                            "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
                            "authors": [
                                {
                                    "authorId": "2106412318",
                                    "name": "David Chuan-En Lin"
                                },
                                {
                                    "authorId": "3111790",
                                    "name": "Nikolas Martelaro"
                                }
                            ],
                            "year": 2023,
                            "venue": "International Conference on Human Factors in Computing Systems",
                            "n_citations": 18
                        },
                        "score": 0.95263671875
                    },
                    {
                        "id": "(Dias et al., 2018)",
                        "snippets": [
                            "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms."
                        ],
                        "paper": {
                            "corpus_id": 53282492,
                            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                            "authors": [
                                {
                                    "authorId": "145745979",
                                    "name": "Jo\u00e3o Pedro Dias"
                                },
                                {
                                    "authorId": "144027277",
                                    "name": "H. Ferreira"
                                }
                            ],
                            "year": 2018,
                            "venue": "arXiv.org",
                            "n_citations": 14
                        },
                        "score": 0.98974609375
                    },
                    {
                        "id": "(Ben-Ari et al., 2018)",
                        "snippets": [
                            "Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes."
                        ],
                        "paper": {
                            "corpus_id": 64771513,
                            "title": "Robots and Their Applications",
                            "authors": [
                                {
                                    "authorId": "1398913278",
                                    "name": "M. Ben-Ari"
                                },
                                {
                                    "authorId": "1727799",
                                    "name": "F. Mondada"
                                }
                            ],
                            "year": 2018,
                            "venue": "",
                            "n_citations": 96
                        },
                        "score": 0.9033203125
                    },
                    {
                        "id": "(Schiavoni et al., 2018)",
                        "snippets": [
                            "The visual programming environment uses the Block metaphor to create computer programs. Blocks are organized into groups in our environment GUI, presented on Figure 1. A block is the minimal source code part and brings the abstraction of a functionality of our desired domain. Blocks have static properties, used to set up their functionality, presented in Figure 2. Blocks also have dynamic properties whose values can be set up by other blocks. This capability to exchange information is represented by the blocks input/output ports. The information exchange by different blocks is made creating a connection between two or more ports. A block port has a defined type and a connection can be done using ports of the same type. A Collection of Blocks and Connections creates a Diagram, as presented in Figure 3. In contrast with other visual programming languages, like Pure Data or Max/MSP, Mosaicode is not an interpreted environment but a code generator."
                        ],
                        "paper": {
                            "corpus_id": 67344764,
                            "title": "Mosaicode and the visual programming of Web Application for Music and Multimedia",
                            "authors": [
                                {
                                    "authorId": "2116792",
                                    "name": "F. Schiavoni"
                                },
                                {
                                    "authorId": "29793059",
                                    "name": "L. Goncalves"
                                },
                                {
                                    "authorId": "72875756",
                                    "name": "Jos\u00e9 Mauro da Silva Sandy"
                                }
                            ],
                            "year": 2018,
                            "venue": "",
                            "n_citations": 7
                        },
                        "score": 0.89306640625
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Form-based Visual Programming Languages",
                "tldr": "Form-based visual programming languages allow users to create programs by configuring forms where triggers and actions are added through drop-down menus or drag-and-drop interfaces. These languages are closely related to spreadsheet-based approaches, with the form serving as the primary visual element that enables programming without traditional code. (3 sources)",
                "text": "\nForm-based visual programming languages represent a distinct category of VPLs where users configure forms by adding triggers and actions through textual drop-down menus or visual drag-and-drop interfaces <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. These languages vary in their visual nature, with some approaches being predominantly visual while others incorporate textual specifications <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>.\n\nThe form-based paradigm is closely related to spreadsheet-based languages, which are considered the most widespread VPL paradigm <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>. In spreadsheet-based languages, a ledger-like sheet serves as the interface for entering and performing arithmetic operations on values. The sheet itself is the significant pictorial element that qualifies spreadsheets as visual programming languages. Form-based languages can be seen as a generalization of sheets into forms, expanding on this foundation <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nThis type of visual programming language is particularly evident in electronic tables and their applications, where users can influence groups of related cells. An example of a form-based language is Forms/3 <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. The form-based approach is one of several main paradigms for developing VPLs, alongside graph-based approaches that use nodes and connections <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nForm-based and spreadsheet-based languages offer a more structured approach to programming compared to other VPL categories. Rather than manipulating blocks or connecting nodes, users work within a predefined form structure, making these languages particularly suitable for certain types of applications, especially those involving data manipulation and calculations <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9921875
                    },
                    {
                        "id": "(Dias et al., 2018)",
                        "snippets": [
                            "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms."
                        ],
                        "paper": {
                            "corpus_id": 53282492,
                            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                            "authors": [
                                {
                                    "authorId": "145745979",
                                    "name": "Jo\u00e3o Pedro Dias"
                                },
                                {
                                    "authorId": "144027277",
                                    "name": "H. Ferreira"
                                }
                            ],
                            "year": 2018,
                            "venue": "arXiv.org",
                            "n_citations": 14
                        },
                        "score": 0.98974609375
                    },
                    {
                        "id": "(Aldhlan et al., 2021)",
                        "snippets": [
                            "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23)"
                        ],
                        "paper": {
                            "corpus_id": 236566925,
                            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                            "authors": [
                                {
                                    "authorId": "9207310",
                                    "name": "Kawther A. Aldhlan"
                                },
                                {
                                    "authorId": "2836785",
                                    "name": "Hamad Alreshidi"
                                }
                            ],
                            "year": 2021,
                            "venue": "Indian Journal of Science and Technology",
                            "n_citations": 2
                        },
                        "score": 0.935546875
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Icon-based Visual Programming Languages",
                "tldr": "Icon-based visual programming languages use graphical symbols to represent programming objects and actions, allowing users to create programs by arranging these icons spatially. These languages can employ elementary icons (representing simple objects or actions) or complex icons (composite objects and visual sentences), creating visual metaphors that help users understand programming concepts. (3 sources)",
                "text": "\nIcon-based (or iconic) visual programming languages distinguish themselves by leveraging graphical symbols or icons as their primary visual representation of programming elements. These languages capitalize on icons to represent both objects (such as files or data elements) and actions (such as delete or edit operations) <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. They form one of the major categories of visual programming languages alongside block-based, diagram-based, and form-based approaches <Paper corpusId=\"235234208\" paperTitle=\"(Dawoud et al., 2021)\" isShortName></Paper>.\n\nAccording to Chang's classification, icons in these languages can be categorized as either elementary or complex. Elementary icons represent basic programming objects or actions, while complex icons take two forms: composite object icons (assembled from elementary object icons) and visual sentences (spatial arrangements of elementary icons) <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>. This hierarchical structure allows icon-based languages to represent increasingly complex programming concepts while maintaining visual clarity.\n\nPure visual programming languages represent a subcategory that fully supports the programming process with pictures. In these environments, programs are produced entirely by manipulating icons and other graphics, and they can be compiled directly through their visual representation\u2014a concept sometimes linked to \"Executable Graphics\" <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. Examples of such purely visual programming environments include Cube Lab View, Prograph, and PICT/D <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>.\n\nIcon-based languages create a direct visual metaphor for programming concepts, which can make them particularly accessible to certain types of users. By representing programming elements as recognizable symbols, these languages can reduce the cognitive load associated with remembering syntax and instead allow users to focus on the logical flow and relationships between programming elements <Model name=\"Anthropic\" version=\"claude-3-7-sonnet-20250219\">.",
                "citations": [
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9921875
                    },
                    {
                        "id": "(Dawoud et al., 2021)",
                        "snippets": [
                            "Visual programming languages have different several classes including block-based, diagrammatic, and iconic visual languages (Myers, 1990)."
                        ],
                        "paper": {
                            "corpus_id": 235234208,
                            "title": "Collaborative Coding in a Robotic Visual Language",
                            "authors": [
                                {
                                    "authorId": "2106215024",
                                    "name": "Farah Yasser Dawoud"
                                },
                                {
                                    "authorId": "143859112",
                                    "name": "A. Adel"
                                },
                                {
                                    "authorId": "2730794",
                                    "name": "Nada Sharaf"
                                }
                            ],
                            "year": 2021,
                            "venue": "International Conference on Computer Supported Education",
                            "n_citations": 1
                        },
                        "score": 0.94482421875
                    },
                    {
                        "id": "(Aldhlan et al., 2021)",
                        "snippets": [
                            "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23)"
                        ],
                        "paper": {
                            "corpus_id": 236566925,
                            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                            "authors": [
                                {
                                    "authorId": "9207310",
                                    "name": "Kawther A. Aldhlan"
                                },
                                {
                                    "authorId": "2836785",
                                    "name": "Hamad Alreshidi"
                                }
                            ],
                            "year": 2021,
                            "venue": "Indian Journal of Science and Technology",
                            "n_citations": 2
                        },
                        "score": 0.935546875
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Other Visual Programming Language Categories",
                "tldr": "Beyond the major categories, visual programming languages include integrated textual-visual languages, programming-by-example languages, constraint-oriented languages, and 3D visual programming languages. These specialized categories address specific programming needs, from simulation design to learning environments, offering alternative visual approaches to code creation. (4 sources)",
                "text": "\nIn addition to the block-based, node/diagram/flow-based, form-based, and icon-based categories, several other significant visual programming language categories exist. These specialized approaches cater to different programming contexts and user needs.\n\nIntegrated Languages (Textual and Visual) represent a hybrid approach that combines textual code with visual elements. As the name suggests, these languages mix text and images, with examples including Rehearsal World, C, and C++ <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. This approach enables users to leverage the precision of textual programming alongside the intuitive nature of visual representations.\n\nProgramming-by-Example Languages allow users to demonstrate specific tasks rather than explicitly coding them. In these environments, users provide the system with a method or mechanism to perform a particular task. Examples include Rehearsal World and Pygmalion <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. These languages depend on the manipulation of visual objects, with tasks performed according to those manipulations rather than through explicit instructions or commands <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nConstraint-Oriented Languages deal with physical objects in the visual environment within specific constraints that are equivalent to natural laws. These languages are particularly suitable for simulation design processes, with examples including Thinklab and Alternate Reality Kit (ARK) <Paper corpusId=\"236566925\" paperTitle=\"(Aldhlan et al., 2021)\" isShortName></Paper>. By incorporating physics-like constraints, these languages can model real-world behaviors more effectively.\n\nThree-dimensional visual programming languages have also emerged as an extension of traditional two-dimensional approaches. While most VPLs use two-dimensional blocks or diagrams to structure programs, some 3D versions have been developed to provide additional spatial dimensions for program representation <Paper corpusId=\"258990742\" paperTitle=\"(Brinksma et al., 2022)\" isShortName></Paper>.\n\nFrom a tools perspective, visual programming and parameterization can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools using diagrams for describing data or process flows, and tools for graphical representation of program logic <Paper corpusId=\"86787308\" paperTitle=\"(Hamzabegovic, 2019)\" isShortName></Paper>. This classification highlights the diverse approaches to making programming more accessible through visual means.",
                "citations": [
                    {
                        "id": "(Aldhlan et al., 2021)",
                        "snippets": [
                            "Visual programming languages can be classified into several classes as follows: \n\n1. Form-based languages: This type is observed in dealing with electronic tables and their uses and is used to influence a group of related cells, for example, the Forms / 3 language. 2. Integrated Languages (Textual and Visual) As the name indicates, it mixes text and image, for example, Rehearsal World, C, C++. 3. Programming-by-Example Language: Through which the user provides the system with a method or mechanism to perform a specific task, for example, Rehearsal World, and the language of Pygmalion. \n\nhttps://www.indjst.org/ 4. Constraint-Oriented language This type deals with physical objects in the visual environment within specific constraints equivalent to natural laws. These languages fit the Simulation Design process, for example, the Thinklab language and the Alternate Reality Kit (ARK) language. 5. Pure visual programming languages: Matthew Revell (2019) illustrate that this type of language fully supports the programming process with pictures, for example (Cube Lab View, Prograph, PICT / D) software. It is worth mentioning that the program here is produced entirely by processing icons and other graphics, and it is compiled directly through visual representation and it is linked here to the term (Executable Graphics). (23)"
                        ],
                        "paper": {
                            "corpus_id": 236566925,
                            "title": "Using Scratch Program to Design Educational E-Games to raise Technological Awareness and Visual Programming Skills to Face Fatal E-Games",
                            "authors": [
                                {
                                    "authorId": "9207310",
                                    "name": "Kawther A. Aldhlan"
                                },
                                {
                                    "authorId": "2836785",
                                    "name": "Hamad Alreshidi"
                                }
                            ],
                            "year": 2021,
                            "venue": "Indian Journal of Science and Technology",
                            "n_citations": 2
                        },
                        "score": 0.935546875
                    },
                    {
                        "id": "(Dias et al., 2018)",
                        "snippets": [
                            "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms."
                        ],
                        "paper": {
                            "corpus_id": 53282492,
                            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                            "authors": [
                                {
                                    "authorId": "145745979",
                                    "name": "Jo\u00e3o Pedro Dias"
                                },
                                {
                                    "authorId": "144027277",
                                    "name": "H. Ferreira"
                                }
                            ],
                            "year": 2018,
                            "venue": "arXiv.org",
                            "n_citations": 14
                        },
                        "score": 0.98974609375
                    },
                    {
                        "id": "(Brinksma et al., 2022)",
                        "snippets": [
                            "Visual Programming Languages are a common vehicle to teach programming. Usually, these languages use two-dimensional blocks or diagrams to structure a program and some 3D versions have emerged as well."
                        ],
                        "paper": {
                            "corpus_id": 258990742,
                            "title": "VAPE-3D: A 3D Visual Avatar-based Programming Environment",
                            "authors": [
                                {
                                    "authorId": "2218649267",
                                    "name": "Wouter Brinksma"
                                },
                                {
                                    "authorId": "2219317025",
                                    "name": "Berber Bouma"
                                }
                            ],
                            "year": 2022,
                            "venue": "Computer Science Education Research Conference",
                            "n_citations": 0
                        },
                        "score": 0.90478515625
                    },
                    {
                        "id": "(Hamzabegovic, 2019)",
                        "snippets": [
                            "Research has shown that visual programming and parameterization tools can be classified into four sub-categories: graphical user interface tools, high-level parameterization software programs, tools that use diagrams for describing data flows or process flows, and graphical representation of program logic tools."
                        ],
                        "paper": {
                            "corpus_id": 86787308,
                            "title": "Development of application software without programming",
                            "authors": [
                                {
                                    "authorId": "30811658",
                                    "name": "J. Hamzabegovi\u0107"
                                }
                            ],
                            "year": 2019,
                            "venue": "IOP Conference Series: Materials Science and Engineering",
                            "n_citations": 0
                        },
                        "score": 0.92333984375
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Characteristics and Differences Between VPL Categories",
                "tldr": "Visual programming language categories differ in their representation style, level of abstraction, domain specialization, and programming paradigms. These differences make certain VPL categories more suitable for specific contexts such as education, data processing, or application development. (7 sources)",
                "text": "\nVisual programming languages can be characterized and evaluated across several key dimensions that highlight their differences and relative strengths. McDaid et al. identify three important characteristics: the spectrum from literal to abstract representation, the extent to which they provide a partial or complete programming language, and whether they target a specialist domain or are general purpose <Paper corpusId=\"221802417\" paperTitle=\"(McDaid et al., 2020)\" isShortName></Paper>. In literal languages, such as those resembling flowcharts, there is a clear correspondence between visual elements and conventional programming constructs, while abstract languages like use case diagrams may be more remote from the code they represent.\n\nA fundamental distinction exists in the programming paradigms employed by different VPL categories. Visual programming languages can be broadly divided into two categories: flow-based functional programming and block-based imperative programming <Paper corpusId=\"242281246\" paperTitle=\"(Dave, 0)\" isShortName></Paper>. This paradigmatic difference influences how programs are structured and executed in each category. Similarly, VPLs can be classified as imperative languages (block languages) where software is created by assembling puzzle pieces, or flow-based languages where models are created by connecting nodes with lines representing data flow or state transitions <Paper corpusId=\"253043422\" paperTitle=\"(Baena-Perez et al., 2022)\" isShortName></Paper>.\n\nThe visual representation used in different VPL categories serves as another distinguishing characteristic. Two prominent domain-independent visual representations are boxes-and-arrows (as in BPMN) and interlocking puzzle pieces (as in Scratch), where the visual elements represent instructions and their connections show how data and control flows between them <Paper corpusId=\"248524774\" paperTitle=\"(Hirzel, 2022)\" isShortName></Paper>. These different visual approaches affect how users interact with and understand the programming environment.\n\nWhen comparing the four main categories of VPLs\u2014block-based, diagram-based, form-based, and icon-based\u2014several distinct characteristics emerge. Block-based languages prevent syntax errors by using predefined blocks that fit together like puzzle pieces, reducing mental load and allowing users to focus on concepts rather than implementation details. Icon-based languages use graphical symbols to represent objects or actions, with elementary icons representing basic elements and complex icons created by combining elementary ones. Form-based languages allow configuration through dropdown menus or drag-and-drop interfaces, while diagram-based languages connect graphical objects with arrows or lines to represent relations and program flow <Paper corpusId=\"231725028\" paperTitle=\"(Kuhail et al., 2021)\" isShortName></Paper>.\n\nBeyond these four main categories, VPLs can also be evaluated based on additional programming approaches, such as event-based, device-based, and state-based programming, which affect characteristics like programming effort, readability, and portability <Paper corpusId=\"273376382\" paperTitle=\"(Narkthong et al., 2024)\" isShortName></Paper>.\n\nFrom a development perspective, there are two main approaches for creating VPLs: graph-based approaches that leverage the metaphor of visual graphs with nodes and connections, and box-based approaches that use the metaphor of boxes and sub-boxes. Within these approaches, several paradigms have become widespread, including data-flow languages (using graphs with operational nodes connected by data flow lines), component-based languages (based on networked computing devices), rule-based languages (using visual if-then rules), program-by-demonstration languages (relying on demonstrations rather than explicit instructions), and form-based/spreadsheet-based languages (the most widespread VPL paradigm) <Paper corpusId=\"53282492\" paperTitle=\"(Dias et al., 2018)\" isShortName></Paper>.\n\nThese varying characteristics make different VPL categories more suitable for specific contexts and user groups. Block-based languages excel in educational settings, diagram-based languages are valuable for visualizing complex data and control flows, form-based languages simplify data manipulation, and icon-based languages create intuitive visual metaphors for programming concepts.",
                "citations": [
                    {
                        "id": "(McDaid et al., 2020)",
                        "snippets": [
                            "Visual programming languages can be characterised and evaluated with respect to a number of dimensions [18]. In this paper we will focus on the following characteristics as being the most relevant: \n\n\u2022 Literal to abstract representation; \n\n\u2022 Partial to complete programming language; \n\n\u2022 Specialist domain or general purpose.\n\nLiteral languages such as those that resemble flow charts often have a clear correspondence between visual and conventional language elements. Abstract languages, such as use case diagrams, are more remote from the code they relate to and may include non-software elements such as users."
                        ],
                        "paper": {
                            "corpus_id": 221802417,
                            "title": "A Visual Language for Composable Inductive Programming",
                            "authors": [
                                {
                                    "authorId": "1420120235",
                                    "name": "Edward McDaid"
                                },
                                {
                                    "authorId": "4697495",
                                    "name": "S. McDaid"
                                }
                            ],
                            "year": 2020,
                            "venue": "arXiv.org",
                            "n_citations": 4
                        },
                        "score": 0.94140625
                    },
                    {
                        "id": "(Dave, 0)",
                        "snippets": [
                            "Visual Programming Languages comprise two broad categories: Flow-based, functional programming or Block-based, imperative programming."
                        ],
                        "paper": {
                            "corpus_id": 242281246,
                            "title": "Comparison of flow-based versus block-based programming for naive programmers",
                            "authors": [
                                {
                                    "authorId": "2071526509",
                                    "name": "Kruti Dave"
                                }
                            ],
                            "year": 0,
                            "venue": "",
                            "n_citations": 2
                        },
                        "score": 0.92041015625
                    },
                    {
                        "id": "(Baena-Perez et al., 2022)",
                        "snippets": [
                            "VPLs can be classified into two categories: imperative languages and flow-based languages (Mason et al., 2017). With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others (Garc\u00eda-Borgo\u00f1\u00f3n et al., 2014)."
                        ],
                        "paper": {
                            "corpus_id": 253043422,
                            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
                            "authors": [
                                {
                                    "authorId": "1411449483",
                                    "name": "Rub\u00e9n Baena-P\u00e9rez"
                                },
                                {
                                    "authorId": "1409150721",
                                    "name": "Iv\u00e1n Ruiz-Rube"
                                },
                                {
                                    "authorId": "32483651",
                                    "name": "Jos\u00e9 Miguel Mota"
                                },
                                {
                                    "authorId": "49031811",
                                    "name": "Anke Berns"
                                },
                                {
                                    "authorId": "144050001",
                                    "name": "Antonio Balderas"
                                }
                            ],
                            "year": 2022,
                            "venue": "Universal Access in the Information Society",
                            "n_citations": 3
                        },
                        "score": 0.958984375
                    },
                    {
                        "id": "(Hirzel, 2022)",
                        "snippets": [
                            "Two prominent domain-independent visual representations are boxes-and-arrows (e.g., BPMN (Ouyang et al., 2006)) or interlocking puzzle pieces (e.g., Scratch [30]). Here, boxes or puzzle pieces represent instructions in the program, and arrows between boxes or the interlock of pieces represent how data and control flows between instructions."
                        ],
                        "paper": {
                            "corpus_id": 248524774,
                            "title": "Low-Code Programming Models",
                            "authors": [
                                {
                                    "authorId": "1728836",
                                    "name": "Martin Hirzel"
                                }
                            ],
                            "year": 2022,
                            "venue": "Communications of the ACM",
                            "n_citations": 21
                        },
                        "score": 0.9423828125
                    },
                    {
                        "id": "(Kuhail et al., 2021)",
                        "snippets": [
                            "Combining the taxonomies developed by Myers [1] and Burnett and Baker [2], we divide VPLs into four categories: form-based languages, block-based languages, diagrambased languages, and icon-based languages. All categories (or subcategories), based on visual program representation, presented in both [1] and [2] are assigned to a category under our new categorization. For instance, block-based languages represent jigsaw puzzle pieces in [1], while diagram-based languages cover diagrammatic languages in [2], data flow graphs and directed graphs in [1].\n\nBlock-based languages allow users to drag and drop ''blocks'' (program elements) from a predefined list of commands into the development area. These blocks are pieced together to make a program. This paradigm prevents syntax errors, which reduces the mental load of end users allowing them to focus on concepts rather than implementation details. Many block-based languages such as Scratch [92] and App Inventor [93] have made application development accessible to numerous end users.\n\nIcon-based or Iconic languages capitalize on the use of icons, graphical symbols representing objects or action [14]. Chang [15] explained that icons can be classified as complex and elementary icons. Elementary icons represent objects (e.g., file) or actions (e.g., delete, edit), whereas complex icons are composite object icons and visual sentences. Composite object icons are the outcome of assembling elementary object icons. Visual sentences are spatial arrangements of elementary icons.\n\nForm-based visual programming languages allow end-user developers to configure a form, in which triggers and actions are added by textual drop-down menus or visual dragand-drop [19]. Some form-based approaches are mostly visual, whereas others use some textual specifications.\n\nDiagram-based visual programming languages, also known as diagrammatic or data flow languages, are characterized by connecting graphical objects ( e.g., boxes) by arrows, lines, or arcs that represent relations. To understand a diagram-based program, users traverse the diagram. Such a diagram uses different means of perceptual coding to represent the flow of the program."
                        ],
                        "paper": {
                            "corpus_id": 231725028,
                            "title": "Characterizing Visual Programming Approaches for End-User Developers: A Systematic Review",
                            "authors": [
                                {
                                    "authorId": "1980707",
                                    "name": "M. Kuhail"
                                },
                                {
                                    "authorId": "153238394",
                                    "name": "Shahbano Farooq"
                                },
                                {
                                    "authorId": "3083161",
                                    "name": "R. Hammad"
                                },
                                {
                                    "authorId": "8357681",
                                    "name": "Mohammed Bahja"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Access",
                            "n_citations": 39
                        },
                        "score": 0.9921875
                    },
                    {
                        "id": "(Narkthong et al., 2024)",
                        "snippets": [
                            "We evaluate it against block-based, event-based, device-based, and state-based programming approaches in terms of programming effort, readability, and portability of the result programs."
                        ],
                        "paper": {
                            "corpus_id": 273376382,
                            "title": "ALLI/O Diagram: An Action-based Visual Programming Language for Embedded System",
                            "authors": [
                                {
                                    "authorId": "2297972654",
                                    "name": "Nuntipat Narkthong"
                                },
                                {
                                    "authorId": "18086059",
                                    "name": "C. Jariyavajee"
                                },
                                {
                                    "authorId": "2326245511",
                                    "name": "Xiaolin Xu"
                                }
                            ],
                            "year": 2024,
                            "venue": "IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments",
                            "n_citations": 0
                        },
                        "score": 0.90478515625
                    },
                    {
                        "id": "(Dias et al., 2018)",
                        "snippets": [
                            "Based on their classification, we can consider that there are two main approaches for developing VPLs, namely: (1) graph-based, which are the most disseminated and in some way leverage the metaphor of visual graphs (nodes and connections), and, (2) box-based, which leverage the use of the metaphor of box and sub-boxes (e.g. User-Interfaces builders and Forms).\n\nWe can consider the next set of paradigms as the main paradigms as they are the most widespread in the literature [Burnett and Baker 1994;Diehl 2007; S. K. Chang 2002]: \n\n\u2022 Data-flow languages: Computation is specified by the means of graphs. This graph consists of icons (or similar visual representations) that correspond to operational nodes, being these nodes connected by lines that represent the flow of data between them. \n\n\u2022 Component-based languages (graph-based): These languages are based on the metaphor of networked computing devices or components. Each one of those components can perform a variety of tasks in response to messages and data received from others. \n\n\u2022 Rule-based languages: Language based on the definition of triggering actions that happen upon changes (e.g. the modification of a variable value can trigger an action). Usually, these mechanisms are based upon visual if-then rules. \n\n\u2022 Program-by-demonstration languages: Languages that, instead of relying on the specification of actions through instructions or commands, depend on demonstrations of the pretended task or objective. As so, the language bases itself on the manipulation of visual objects, and the tasks carried out are performed according to those manipulations. \n\n\u2022 Form-based & Spreadsheet-based languages: Spreadsheets are the most widespread VPL paradigm. These languages present a ledger-like sheet for entering and performing arithmetic on values. In these languages, the sheet is the single significant pictorial element that qualifies the original spreadsheet as a VPL. Form-based languages are somewhat similar in the scene that they result in a generalization of sheets into forms."
                        ],
                        "paper": {
                            "corpus_id": 53282492,
                            "title": "State of the Software Development Life-Cycle for the Internet-of-Things",
                            "authors": [
                                {
                                    "authorId": "145745979",
                                    "name": "Jo\u00e3o Pedro Dias"
                                },
                                {
                                    "authorId": "144027277",
                                    "name": "H. Ferreira"
                                }
                            ],
                            "year": 2018,
                            "venue": "arXiv.org",
                            "n_citations": 14
                        },
                        "score": 0.98974609375
                    }
                ],
                "format": "synthesis",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            },
            {
                "title": "Examples of Visual Programming Languages",
                "tldr": "Visual programming languages span a wide range of implementations, from educational tools like Scratch and Blockly to professional development environments like LabVIEW and MATLAB. Each language employs different visual paradigms that align with their intended purpose and target audience. (12 sources)",
                "text": "\n## Block-based Languages\n* **Scratch**: A widely popular block-based language targeted primarily at children aged 8-16 as an educational tool for coding <Paper corpusId=\"236336244\" paperTitle=\"(Daskalov et al., 2021)\" isShortName></Paper>. It allows novice programmers to create applications through an intuitive interface that prevents syntax errors <Paper corpusId=\"236447670\" paperTitle=\"(Ikarashi et al., 2021)\" isShortName></Paper>.\n\n* **Blockly**: A JavaScript library for building customized visual programming editors that use interlocking blocks to represent code elements <Paper corpusId=\"264306865\" paperTitle=\"(Avishahar-Zeira et al., 2023)\" isShortName></Paper>. Along with Scratch, it adopted key properties from AgentSheets to become one of the most popular block programming languages <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper>.\n\n* **Snap!**: A notable block-based language that falls into the category of imperative languages where users create software by assembling puzzle pieces intuitively <Paper corpusId=\"253043422\" paperTitle=\"(Baena-Perez et al., 2022)\" isShortName></Paper>.\n\n* **Alice**: A 3D interactive animation environment designed as a block-based VPL for novice programmers to learn basic programming principles <Paper corpusId=\"236447670\" paperTitle=\"(Ikarashi et al., 2021)\" isShortName></Paper> <Paper corpusId=\"62491646\" paperTitle=\"(Cooper et al., 2000)\" isShortName></Paper>. It's considered an example of a true VPL where the program itself can be thought of as an executable graphical artifact <Paper corpusId=\"238126162\" paperTitle=\"(Lutalo et al., 2020)\" isShortName></Paper>.\n\n* **AgentSheets**: The pioneering tool that introduced blocks programming in 1995 to create games and simulations, marking a substantial advancement in visual programming languages <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper> <Paper corpusId=\"41867280\" paperTitle=\"(Repenning, 2017)\" isShortName></Paper>.\n\n## Flow/Node-based Languages\n* **LabVIEW**: A flow-based programming environment used primarily for embedded applications that implements graphics of electronic devices and signs to represent systems <Paper corpusId=\"246022597\" paperTitle=\"(Pongthanisorn et al., 2022)\" isShortName></Paper>. It's considered pioneering work in the dataflow paradigm of visual programming interfaces <Paper corpusId=\"269747039\" paperTitle=\"(Lin et al., 2023)\" isShortName></Paper>.\n\n* **MATLAB Model-Based Design**: Represents equations in blocks and logic flow using a flow-based design approach <Paper corpusId=\"246022597\" paperTitle=\"(Pongthanisorn et al., 2022)\" isShortName></Paper>.\n\n* **Prograph**: A notable pioneering work in the dataflow paradigm that lets users specify how a program transforms data step by step by connecting nodes in a directed graph <Paper corpusId=\"269747039\" paperTitle=\"(Lin et al., 2023)\" isShortName></Paper>.\n\n* **BPMN, PetriNet, DRAKON, UML Activity Diagrams**: Examples of flow-based languages where models are created by joining different nodes and graphic lines representing data flow or transitions between different states <Paper corpusId=\"253043422\" paperTitle=\"(Baena-Perez et al., 2022)\" isShortName></Paper>.\n\n## Robot Programming VPLs\n* **VPL (Visual Programming Language) for Thymio**: A graphical software environment that uses event-action pairs where when the event represented by the block on the left occurs, the actions in the following blocks are performed <Paper corpusId=\"64771513\" paperTitle=\"(Ben-Ari et al., 2018)\" isShortName></Paper>.\n\n* **Dash Robot Environment**: A graphical software environment that also uses events and actions, but represents actions as nodes and events as arrows between nodes <Paper corpusId=\"64771513\" paperTitle=\"(Ben-Ari et al., 2018)\" isShortName></Paper>.\n\n## Other Notable VPLs\n* **RAPTOR**: A flowchart-based visual programming language <Paper corpusId=\"238126162\" paperTitle=\"(Lutalo et al., 2020)\" isShortName></Paper> <Paper corpusId=\"4039308\" paperTitle=\"(Noone et al., 2017)\" isShortName></Paper>.\n\n* **Squeak eToys**: A block-based programming language developed after AgentSheets <Paper corpusId=\"221340525\" paperTitle=\"(Alturayeif et al., 2020)\" isShortName></Paper>.\n\n* **MIT Blocks**: A block-based programming system that employs the concept of representing computer instructions as blocks <Paper corpusId=\"246022597\" paperTitle=\"(Pongthanisorn et al., 2022)\" isShortName></Paper>.",
                "citations": [
                    {
                        "id": "(Daskalov et al., 2021)",
                        "snippets": [
                            "Many VPLs [2] are based on the idea for boxes and arrows, where boxes or other screen objects are treated as entities, connected by arrows, lines or arcs which represent relations",
                            "Later, blockbased VPL appeared (e.g. Scratch) [4], [5]. Scratch is a block-based VPL and website targeted primarily at children 8-16 as an educational tool for coding."
                        ],
                        "paper": {
                            "corpus_id": 236336244,
                            "title": "Hybrid Visual Programming Language Environment for Programming Training",
                            "authors": [
                                {
                                    "authorId": "2666781",
                                    "name": "R. Daskalov"
                                },
                                {
                                    "authorId": "94696738",
                                    "name": "G. Pashev"
                                },
                                {
                                    "authorId": "2299512",
                                    "name": "Silvia N. Gaftandzhieva"
                                }
                            ],
                            "year": 2021,
                            "venue": "TEM Journal",
                            "n_citations": 2
                        },
                        "score": 0.92236328125
                    },
                    {
                        "id": "(Ikarashi et al., 2021)",
                        "snippets": [
                            "Visual programming languages (VPLs) use an interactive and graphical approach to help users avoid syntactic errors. Agentsheets utilizes a drag-and-drop mechanism to prevent syntactic mistakes (Repenning et al., 2000). Alice (Cooper et al., 2000) and Scratch (273180521) are block-based VPLs for novice programmers to learn the basic principles of programming by combining the provided blocks."
                        ],
                        "paper": {
                            "corpus_id": 236447670,
                            "title": "Guided Optimization for Image Processing Pipelines",
                            "authors": [
                                {
                                    "authorId": "2134665163",
                                    "name": "Yuka Ikarashi"
                                },
                                {
                                    "authorId": "1401885963",
                                    "name": "Jonathan Ragan-Kelley"
                                },
                                {
                                    "authorId": "33439074",
                                    "name": "Tsukasa Fukusato"
                                },
                                {
                                    "authorId": "153049675",
                                    "name": "Jun Kato"
                                },
                                {
                                    "authorId": "1717356",
                                    "name": "T. Igarashi"
                                }
                            ],
                            "year": 2021,
                            "venue": "IEEE Symposium on Visual Languages / Human-Centric Computing Languages and Environments",
                            "n_citations": 9
                        },
                        "score": 0.9375
                    },
                    {
                        "id": "(Avishahar-Zeira et al., 2023)",
                        "snippets": [
                            "Both No-Code and Low-Code are special cases of visual programming languages that use visual elements such as blocks, graphs, and owcharts to represent code. However, not every graphical language is necessarily No-Code.\n\nBlock-based coding languages [21] are visual programming languages that let end users create programs by connecting program elements graphically rather than textually [38]. For example, Scratch8 [28] is a popular visual programming language for children that uses blocks to represent commands. More generally, Blockly9 [25] is a JavaScript library for building a customized visual programming editor that uses interlocking blocks to represent elements of the code."
                        ],
                        "paper": {
                            "corpus_id": 264306865,
                            "title": "Could No-Code Be Code? Toward a No-Code Programming Language for Citizen Developers",
                            "authors": [
                                {
                                    "authorId": "2260344112",
                                    "name": "Assaf Avishahar-Zeira"
                                },
                                {
                                    "authorId": "2260344780",
                                    "name": "David H. Lorenz"
                                }
                            ],
                            "year": 2023,
                            "venue": "SIGPLAN symposium on New ideas, new paradigms, and reflections on programming and software",
                            "n_citations": 4
                        },
                        "score": 0.88671875
                    },
                    {
                        "id": "(Alturayeif et al., 2020)",
                        "snippets": [
                            "Visual programming languages allow users to develop programs by manipulating elements graphically instead of writing a program as a text",
                            "There is a rich history of different visual programming tools designed for novices comprehensively surveyed in (Lye et al., 2014). AgentSheets by Repenning and Sumner [5] is a tool that introduced the blocks programming in 1995 to create games and simulations. Their work marked a substantial step in the field of visual programming language (Repenning, 2017). Several block-based programming language were designed after AgentSheet, such as Squeak eToys, Alice, and Scratch (Repenning, 2017)",
                            "Blocks are end-user composable, editable, and can be arranged geometrically to represent tree structure and to define syntax [9]. The previous four keys form the properties of a highly accessible visual programming paradigm combined by the AgentSheets (Repenning, 2017). According to (Repenning, 2017), Scratch and Blockly adopted these properties to be in their core, and became the popular blocks programming language."
                        ],
                        "paper": {
                            "corpus_id": 221340525,
                            "title": "DeepScratch: Scratch Programming Language Extension for Deep Learning Education",
                            "authors": [
                                {
                                    "authorId": "2315312012",
                                    "name": "Nora S. Alturayeif"
                                },
                                {
                                    "authorId": "2023398349",
                                    "name": "Nouf Alturaief"
                                },
                                {
                                    "authorId": "2023401654",
                                    "name": "Zainab Alhathloul"
                                }
                            ],
                            "year": 2020,
                            "venue": "International Journal of Advanced Computer Science and Applications",
                            "n_citations": 19
                        },
                        "score": 0.9208984375
                    },
                    {
                        "id": "(Baena-Perez et al., 2022)",
                        "snippets": [
                            "VPLs can be classified into two categories: imperative languages and flow-based languages (Mason et al., 2017). With the imperative languages, namely, block languages, the user creates their software by assembling different puzzle pieces intuitively. Within this category, Scratch, Snap! and Google Blockly stand out. Scratch enables novice programmers to create apps through its block-based language. However, the purpose with which these languages were created entails some limitations when it comes to use the latest technological innovations as, for instance, VR. On the other hand, with the flow-based languages, the models are created by joining different nodes and graphic lines representing the data flow or the transition between different states. Within this category, languages such as BPMN, PetriNet, DRAKON or UML activity diagrams can be found, among others (Garc\u00eda-Borgo\u00f1\u00f3n et al., 2014)."
                        ],
                        "paper": {
                            "corpus_id": 253043422,
                            "title": "Visual authoring of virtual reality conversational scenarios for e-learning",
                            "authors": [
                                {
                                    "authorId": "1411449483",
                                    "name": "Rub\u00e9n Baena-P\u00e9rez"
                                },
                                {
                                    "authorId": "1409150721",
                                    "name": "Iv\u00e1n Ruiz-Rube"
                                },
                                {
                                    "authorId": "32483651",
                                    "name": "Jos\u00e9 Miguel Mota"
                                },
                                {
                                    "authorId": "49031811",
                                    "name": "Anke Berns"
                                },
                                {
                                    "authorId": "144050001",
                                    "name": "Antonio Balderas"
                                }
                            ],
                            "year": 2022,
                            "venue": "Universal Access in the Information Society",
                            "n_citations": 3
                        },
                        "score": 0.958984375
                    },
                    {
                        "id": "(Cooper et al., 2000)",
                        "snippets": [
                            "In learning to program, many students struggle with developing algorithms, figuring out how to apply problem solving techniques in their programs, and with how to use common programming constructs. In this paper, we present a new tool that provides a possible approach to actively engage students in increasing their knowledge and skills in these areas. The tool is Alice, a 3-D interactive animation environment."
                        ],
                        "paper": {
                            "corpus_id": 62491646,
                            "title": "Alice: a 3-D tool for introductory programming concepts",
                            "authors": [
                                {
                                    "authorId": "145819506",
                                    "name": "S. Cooper"
                                },
                                {
                                    "authorId": "3227142",
                                    "name": "W. Dann"
                                },
                                {
                                    "authorId": "1717974",
                                    "name": "R. Pausch"
                                }
                            ],
                            "year": 2000,
                            "venue": "Journal of Computing Sciences in Colleges (JCSC; Formerly: Journal of Computing in Small Colleges)",
                            "n_citations": 591
                        },
                        "score": 0
                    },
                    {
                        "id": "(Lutalo et al., 2020)",
                        "snippets": [
                            "When it comes to software construction using non-textual methods, two dominant approaches prevail: the use of visual programming interfaces (VPI) and then visual programming languages (VPL). VPL involves approaches to software construction in which the specification of a program relies on the manipulation of graphical artifacts [12]. VPI on the other hand does not eschew textual specification of a program entirely, but offers some graphical interface that allows the textual code to be generated automatically via manipulation of graphical artifacts.\n\nExamples of VPL include RAPTOR, a flow chart based VPL, Alice and Scratch [12]. Note that VPL approaches to software construction involve not just graphical interfaces or environments for producing the program, but that the program itself might be thought of as an executable graphical artifact -what traditionally have been called \"executable graphics\" [13].\n\nConsidering VPL approaches, the most outstanding in the industry today are block programming languages."
                        ],
                        "paper": {
                            "corpus_id": 238126162,
                            "title": "DNAP: Dynamic Nuchwezi Architecture Platform - A New Software Extension and Construction Technology",
                            "authors": [
                                {
                                    "authorId": "2007576185",
                                    "name": "Joseph Willrich Lutalo"
                                },
                                {
                                    "authorId": "2041303630",
                                    "name": "Odongo Steven Eyobu"
                                },
                                {
                                    "authorId": "1774407",
                                    "name": "Benjamin Kanagwa"
                                }
                            ],
                            "year": 2020,
                            "venue": "",
                            "n_citations": 0
                        },
                        "score": 0.931640625
                    },
                    {
                        "id": "(Repenning, 2017)",
                        "snippets": [
                            "The blocks programming community has been preoccupied with identifying syntactic obstacles that keep novices from learning to program. Unfortunately, this focus is now holding back research from systematically investigating various technological affordances that can make programming more accessible. Employing approaches from program analysis, program visualization, and real-time interfaces can push blocks programming beyond syntax towards the support of semantics and even pragmatics. Syntactic support could be compared to checking spelling and grammar in word processing. Spell checking is relatively simple to implement and immediately useful, but provides essentially no support to create meaningful text. Over the last 25 years, I have worked to empower students to create their own games, simulations, and robots. In this time I have explored, combined, and evaluated a number of programming paradigms. Every paradigm including data flow, programming by example, and programming through analogies brings its own set of affordances and obstacles. Twenty years ago, AgentSheets combined four key affordances of blocks programming, and since then has evolved into a highly accessible Computational Thinking Tool. This article describes the journey to overcome first syntactic, then semantic, and most recently pragmatic, obstacles in computer science education."
                        ],
                        "paper": {
                            "corpus_id": 41867280,
                            "title": "Moving Beyond Syntax: Lessons from 20 Years of Blocks Programing in AgentSheets",
                            "authors": [
                                {
                                    "authorId": "1782080",
                                    "name": "A. Repenning"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Visual Languages and Sentient Systems",
                            "n_citations": 50
                        },
                        "score": 0
                    },
                    {
                        "id": "(Pongthanisorn et al., 2022)",
                        "snippets": [
                            "This paradigm of programming, instead of text, uses a block or another notation to represent a logical flow. It is also called a block-based programming style. This enables more intuitive of a computer programming. Moreover, a graphical representation of visual programming evaluates information in the closest manner to human mental representation of real-world problems (Myers, 1990). There are multiple well-known visual programming styles in broad range, for example a model-based design of MATLAB [4] which represents an equation in a block and flow of logic using a flow-based design. LabView is used for an embedded application that implements a graphic of an electronic device and sign for the representation the system [5], Scratch, MIT Block and Google Blockly [6,7]8] which employ a concept of representing computer instruction into a block called block-based programming."
                        ],
                        "paper": {
                            "corpus_id": 246022597,
                            "title": "Visual Programming for Artificial Intelligent and Robotic Application (VPAR) Framework",
                            "authors": [
                                {
                                    "authorId": "2001006030",
                                    "name": "Goragod Pongthanisorn"
                                },
                                {
                                    "authorId": "19305117",
                                    "name": "W. Viriyavit"
                                },
                                {
                                    "authorId": "2844764",
                                    "name": "Thatsanee Charoenporn"
                                },
                                {
                                    "authorId": "1779078",
                                    "name": "Virach Sornlertlamvanich"
                                }
                            ],
                            "year": 2022,
                            "venue": "European-Japanese Conference on Information Modelling and Knowledge Bases",
                            "n_citations": 0
                        },
                        "score": 0.90771484375
                    },
                    {
                        "id": "(Lin et al., 2023)",
                        "snippets": [
                            "There are primarily two main paradigms for VPIs. The first, the dataflow paradigm, lets users specify how a program transforms data from step to step by connecting nodes in a directed graph. Pioneering work in this area includes Prograph [17] and LabVIEW [27]. The second paradigm utilizes block-based function representations and lets users create programs by connecting compatible components together. Notable works in this area include Scratch [35] and Blockly [19]."
                        ],
                        "paper": {
                            "corpus_id": 269747039,
                            "title": "Jigsaw: Supporting Designers to Prototype Multimodal Applications by Chaining AI Foundation Models",
                            "authors": [
                                {
                                    "authorId": "2106412318",
                                    "name": "David Chuan-En Lin"
                                },
                                {
                                    "authorId": "3111790",
                                    "name": "Nikolas Martelaro"
                                }
                            ],
                            "year": 2023,
                            "venue": "International Conference on Human Factors in Computing Systems",
                            "n_citations": 18
                        },
                        "score": 0.95263671875
                    },
                    {
                        "id": "(Ben-Ari et al., 2018)",
                        "snippets": [
                            "Programming is simplified if a block-based language is used, usually a language based upon Scratch or Blockly (Fig. 1.7). \n\nTo further simplify programming a robot by young students, a fully graphical programming notation can be used. Figure 1.8 shows VPL (Visual Programming Language), a graphical software environment for the Thymio robot. It uses eventaction pairs: when the event represented by the block on the left occurs, the actions in the following blocks are performed. \n\nFigure 1.9 shows the graphical software environment for the Dash robot. It also uses events and actions, where the actions are represented by nodes and events are represented by arrows between nodes."
                        ],
                        "paper": {
                            "corpus_id": 64771513,
                            "title": "Robots and Their Applications",
                            "authors": [
                                {
                                    "authorId": "1398913278",
                                    "name": "M. Ben-Ari"
                                },
                                {
                                    "authorId": "1727799",
                                    "name": "F. Mondada"
                                }
                            ],
                            "year": 2018,
                            "venue": "",
                            "n_citations": 96
                        },
                        "score": 0.9033203125
                    },
                    {
                        "id": "(Noone et al., 2017)",
                        "snippets": [
                            "It is well documented and has been the topic of much research as well that Computer Science courses tend to have higher than average drop-out rates at third level, particularly so, for students advancing from first year to second year. This is a problem that needs to be addressed not only with urgency but also with caution. The required number of Computer Science graduates is growing every year, but the number of graduates is not meeting this demand, and one way that this problem can be alleviated is to encourage students, at an early age, towards studying Computer Science courses. This paper presents a systematic literature review that examines the role of visual and textual programming languages when learning to program, particularly as a First Programming Language. The approach is systematic in that a structured search of electronic resources has been conducted, and the results are presented and quantitatively analysed. This study will provide insight into whether or not the current approaches to teaching young learners programming are viable, and examines what we can do to increase the interest and retention of these students as they progress through their education."
                        ],
                        "paper": {
                            "corpus_id": 4039308,
                            "title": "Visual and textual programming languages: a systematic review of the literature",
                            "authors": [
                                {
                                    "authorId": "2056455701",
                                    "name": "Mark Noone"
                                },
                                {
                                    "authorId": "12733217",
                                    "name": "Aidan Mooney"
                                }
                            ],
                            "year": 2017,
                            "venue": "Journal of Computers in Education",
                            "n_citations": 95
                        },
                        "score": 0
                    }
                ],
                "format": "list",
                "table": null,
                "model": "claude-3-7-sonnet-20250219"
            }
        ],
        "cost": 0.224223
    }
}